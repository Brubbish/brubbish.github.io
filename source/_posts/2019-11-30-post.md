---
title: 2019.11.25-2019.11.30
tags: 周报
abbrlink: 32145
date: 2019-11-30 14:59:09
---
## 1.PTA-寻找完美数

![题目如图](https://img-blog.csdnimg.cn/20191129134009445.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JydWlzaGk=,size_16,color_FFFFFF,t_70)
<!--more-->

```c
#include<stdio.h>
int judge(inti){
	intj=0;
	intn=1;
	for(intk=2;k<i;k++){
		if(i%k==0){
			j++;
			n=n+k;
		}
	}
	inta=0;
	if(n==i&&i!=1){
		printf("%d",i);
		a=1;
		returna;
	}
	return0;
}

int main(){
	inta,b;
	intj=0;
	scanf("%d%d",&a,&b);
	for(inti=a;i<=b;i++){
		j=judge(i);
		if(j==1){
			c=1;
		}
	}
	if(c!=1){
		printf("None");
	}
}
```

这是第一次提交的，结果只对了一个，其他都是格式错误，感觉应该是结尾不能有空格，就将 main 函数里的参数 c 传入 judge 函数，判断输出的是否是第一个完美数。

```c
#include<stdio.h>
int judge(inti,intc){
	intj=0;
	intn=1;
	for(intk=2;k<i;k++){
		if(i%k==0){
			j++;
			n=n+k+i/k;
		}
	}
	inta=0;
	if(n==i&&i!=1){
		if(c==0){
			printf("%d",i);
		}
		else{
			printf("%d",i);
		}
		a=1;
		returna;
	}
	return0;
}
```

第二次提交的时候有一个测试点没有通过，猜测是 i 太大的时候超时了，于是把 judge 函数里循环的循环条件改为

```c
k<sqrt(i)
```

就通过了。

##2.PTA-验证“哥德巴赫猜想”
![在这里插入图片描述](https://img-blog.csdnimg.cn/20191129234420522.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JydWlzaGk=,size_16,color_FFFFFF,t_70)

```c
#include<stdio.h>
#include<math.h>
intprime(intq){
	inti=2;
	for(;i<q;i++)
	{
		if(q%i==0){
			return0;
		}
	}
	if(q==i){
		return1;
	}
}
intmain(){
	intn;
	scanf("%d",&n);
	intm;
	m=sqrt(n)+1;
	inta;
	intta1;
	intta2;
	for(intp=2;p<n/2;p++){
		ta1=0;
		ta2=0;
		a=n-p;
		if(prime(p)==0)	continue;
		if(prime(a)==0)	continue;
		printf("%d=%d+%d",n,p,a);
		return0;
	}
}
```

第一次提交的时候长这样，依旧是最大 N 的时候运行超时，想了好久不知道怎么改，上网搜了一下：[7-6 验证“哥德巴赫猜想”（20 分）](https://blog.csdn.net/solitarily/article/details/78557649)得到：

```c
int prime(intn){
//判断n为偶数时
	if(n==2){
		return1;
	}
	if(n<2||n%2==0){
		return0;
	}
//判断n为奇数时
	for(inti=3;i*i<=n;i=i+2){
		if(n%i==0){
			return0;
		}
	}
	return1;
}
int main(){
	intn;
	scanf("%d",&n);
	if(n==4){
		printf("4=2+2");
		return0;
	}
	for(inti=2;i<n/2;i++){
		if(prime(i)&&prime(n-i)){
			printf("%d=%d+%d",n,i,n-i);
			break;
		}
	}
}
```

## 3.洛谷-P2089 烤鸡

![在这里插入图片描述](https://img-blog.csdnimg.cn/201911300913530.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JydWlzaGk=,size_16,color_FFFFFF,t_70)
只想到了这个方法：

```c
#include<stdio.h>
intmain(){
	intn;
	scanf("%d",&n);
	if(n>30||n<10){
		printf("0");
		return0;
	}
	intcnt=0;
	inta,b,c,d,e,f,g,h,i,j;
	for(a=1;a<=3;a++)
		for(b=1;b<=3;b++)
			for(c=1;c<=3;c++)
				for(d=1;d<=3;d++)
					for(e=1;e<=3;e++)
						for(f=1;f<=3;f++)
							for(g=1;g<=3;g++)
								for(h=1;h<=3;h++)
									for(i=1;i<=3;i++)
										for(j=1;j<=3;j++)
											if(a+b+c+d+e+f+g+h+i+j==n)
												cnt++;
	printf("%d\n",cnt);
	for(a=1;a<=3;a++)
		for(b=1;b<=3;b++)
			for(c=1;c<=3;c++)
				for(d=1;d<=3;d++)
					for(e=1;e<=3;e++)
						for(f=1;f<=3;f++)
							for(g=1;g<=3;g++)
								for(h=1;h<=3;h++)
									for(i=1;i<=3;i++)
										for(j=1;j<=3;j++)
											if(a+b+c+d+e+f+g+h+i+j==n)
												printf("%d%d%d%d%d%d%d%d%d%d\n",a,b,c,d,e,f,g,h,i,j);
}
```

虽然通过了但是觉得这样太傻了
不过别人交的题解也没看懂....
感觉这个方法挺特别的：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20191130094135480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JydWlzaGk=,size_16,color_FFFFFF,t_70)
##4.链表
周二在 b 站上看了个讲解单链表的教程：[C 语言入门教程第 13 讲动态内存分配和链表](https://www.bilibili.com/video/av418203?from=search&seid=9482584295121953132)，跟着打了两遍，看代码理解了一遍，感觉还不是很懂，就尝试自己打了一下。
然后顺便把教程里没说的删除弄出来了。

```c
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
structstud{
	charname[10];
	structstud*next;
};
voidprint(structstud*p);
structstud*remove(structstud*p);

structstud*build(){
	structstud*current,*nextp,*head;
	head=(structstud*)malloc(sizeof(structstud));
	charstr[10];
	printf("typeaname：");
	scanf("%s",str);
	getchar();
	strcpy(head->name,str);
	current=head;


	chara;
	printf("keepdoing?\n");
	scanf("%c",&a);
	while(a=='y'){

		printf("typeaname：");
		scanf("%s",str);
		getchar();


		nextp=(structstud*)malloc(sizeof(structstud));


		strcpy(nextp->name,str);
		current->next=nextp;
		current=nextp;

		printf("keepdoing?\n");
		scanf("%c",&a);

	}
	current->next=NULL;
	returnhead;
}



structstud*insert(structstud*p){
	structstud*insert,*current;
	intposition;
	charstr[10];
	printf("insertposition:\n");
	scanf("%d",&position);
	printf("typeaname:");
	scanf("%s",str);
	getchar();

	current=p;
	insert=(structstud*)malloc(sizeof(structstud));
	strcpy(insert->name,str);

	insert->next=NULL;
	if(position!=0){
		while(position>1)
		{
			current=current->next;
			position--;
		}//current=insert-1;
		insert->next=current->next;
		current->next=insert;


	}
	else{
		insert->next=current;
		p=insert;


	}
	printf("\npresentelement:\n");
	print(p);
	returnp;
}



intmain(){
	structstud*p;
	p=build();
	printf("presentelement:\n");
	print(p);

	charb='b';
	printf("insert?yorn");
	scanf("%c",&b);
	getchar();
	while(b!='n'){
		p=insert(p);
		printf("insert?yorn");
		scanf("%c",&b);
//		getchar();
	}

	charc;
	printf("deleteaname?yorn");
	scanf("%c",&c);
	getchar();
	while(c!='n'){
		p=remove(p);
		printf("deleteaname?yorn");
		scanf("%c",&c);
		getchar();
	}
	return0;

}



voidprint(structstud*p){
		while(1){
		if(p->next!=NULL){
			printf("%s\n",p->name);
			p=p->next;
		}
		else{
			printf("%s\n",p->name);
			break;
		}
	}
}

structstud*remove(structstud*p){
	structstud*position,*current=p;
	intpo;
	printf("place:");
	scanf("%d",&po);
	if(po!=0){
		while(po!=1){
			current=current->next;
			po--;
		}
		position=current;
		position=position->next;
		current->next=position->next;


	}
	else{
		p=current->next;
		free(current);
	}



	printf("currentlist:\n");
	print(p);
	returnp;
}
```
