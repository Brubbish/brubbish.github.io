---
title: 2020.04.13-2020.04.19
tags:
  - 周报
  - 加密与解密
abbrlink: 32820
date: 2020-04-19 15:10:30
---
# 加密算法  
## 单向散列算法
### SHA算法
安全散列算法，包括SHA-1,SHA-256,SHA-384,SHA-512,分别产生160位、256位、384位、512位散列值   
#### SHA-1算法
原始消息长度不能超过2^64  
sha-1算法与md4算法原理相同，消息分组和填充方式和md5算法相同(到md5的第二步)  
<!--more-->
sha-1初始散列值用5个32位双字进行初始化，如图：   
![ ](https://s1.ax1x.com/2020/04/14/GzwQKK.png)  
运算时使用到的常数：   
![ ](https://s1.ax1x.com/2020/04/14/GzwlDO.png)
用以上两组数识别sha-1算法   

## 对称加密算法
加密和解密的密钥完全相同  
安全性依赖于：
1. 加密算法足够强，无法根据密文直接获得原文  
2. 密钥的秘密性  

在使用时，把用户输入的注册码（或注册码的一部分等）作为算法的密钥。如果在检查注册码时把用户的输入作为算法的输出或输入，解密者都可以找到所用的密钥  
常用的对称分组加密算法有：DES、IDEA、AES等   

对称密码分为：
1. 流密码：对每一个比特都作为基本处理单元进行加密
2. 块密码（分组密码）：先分块，再对每一块进行加密
### RC4流密码
#### 原理
生成一种伪随机流（称为密钥流），与长度相同的明文通过异或（相同为假，不同为真）操作进行加密；解密时也与密文进行异或操作  
密钥流分为KSA和PRGA两部分   
1. KSA（the key-scheduling algorithm)   
    1. 先对一个256字节的数组S进行初始化，按顺序填入0~255    
    2. 如果输入的密钥长度小于256字节，则按密钥的填充输入的密钥（如输入1，2，3，4，5，填为1，2，3，4，5，1，2，3，...  放入数组T
    3. 对1中数组元素做如下交换
    ```c
        　j = 0;
    　  　for (i = 0 ; i < 256 ; i++){
      　　　　j = (j + S[i] + T[i]) mod 256;
      　　　　swap(S[i] , S[j]);
      　　}
    ```


2. PRGA（the pseudo-random gerneration algorithm)
```c
i=0,j=0;

while(datalength--){//明文长度datalength
　　　i = (i + 1) mod 256;
　　　　j = (j + S[i]) mod 256;
　　　　swap(S[i] , S[j]);
　　　　t = (S[i] + S[j]) mod 256;
　　　　k = S[t];//这里的K就是当前生成的一个秘钥流中的一位
　　　　//可以直接在这里进行加密，当然也可以将密钥流保存在数组中，最后进行异或
}
```


## 公开密钥加密算法
亦称非对称加密算法。在加密与解密时用不同的密钥，加密用的密钥叫做公钥，解密用的密钥叫做私钥   
公开密钥的设计基于[NP完全问题](https://blog.csdn.net/qq_21768483/article/details/80430590)   
### RSA算法

算法的安全性依赖于大整数因式分解（主要是分解n），密钥位数越长就越安全
#### 原理
1. 选取两个较大素数p，q（用算法随机产生两个数，使用概率算法来验证是否质数。假如通过了这个测试的话，那么要使用一个精确的测试来保证的确是质数。）且pq不能太接近  
2. n=pq，n称为模  
3. 计算欧拉函数φ(n)=(p-1)(q-1)  
4. 选取加密密钥e，e常用值为3、7和（2^16+1)  
5. 使用扩展欧几里得算法，求出d  
6. 公钥为e和n；私钥为d；p，q必须保密  
7. 把消息进行分组，每组长度比n小，将每组都根据公式进行加密的计算  
8. 解密时，取每一个分组按公式进行解密

## Base64算法
将二进制数据编码为字母和数字，用于非文本传输。使用ASCII（A~/)第65个字符为“=”），并用6个进制位表示一个可显示字符   
编码时：
1. 将第一个字节放置于24位缓冲区的高8位，第二个字节放在中间的8位，第三个字节放在低8位（少于3个字节，相应的缓冲区置0）
2. 对24位缓冲区以6位为一组作为索引，高位优先，从ASCII表取出对应数值的元素进行输出,置0的位置输出“=” 

如：对单词sky：   
![ ](https://s1.ax1x.com/2020/04/17/JZN1ER.png)   
![ ](https://s1.ax1x.com/2020/04/17/JZdBVJ.jpg)
再根据28->c;54->2;.....   
得到sky对应的base64编码   

在url和cookie里“=”会造成歧义，因此很多base64编码在最后会把"="去掉。   
因为**base64编码的长度永远是4的倍数**，所以可以确定少了几个“=”   


## 加密算法在软件保护的应用
不仅包括软件的注册激活系统、软件的防逆向，还包括软件涉及的数据的安全保护，包括存储数据的加密和数据交换的加密协议，如聊天软件的加密协议、游戏客户端与服务器通信的协议包、智能硬件和app通信的命令协议等  
高等难度级别的保护方案可以设计得简单也可以复杂：   
简单：例如对用户名处理时把哈希、对称、公钥算法全都用上，或者用难以分析的算法例如ecdsa。流程很简单但破解门槛很高   
复杂：可以使用不常见的算法（没有特征）、使用自己的算法，如果用公开的算法库，要去掉一些特征字符串，从而识别不出用了哪个算法库   



# Windows内核
操作系统一般分为应用层和内核层，应用层通过系统调用进入内核，由系统底层完成相应功能；内核处理某些硬件发来的中断请求，代替硬件完成某些功能
## 内核理论基础
### 权限级别
cpu的运行级别依次为R0（最高执行权限）、R1、R2、R3（最低执行权限），r0运行内核，r1、r2运行设备驱动，r3运行应用程序。为了让工作变得简单，现在cpu和操作系统只保留了r0和r3，驱动运行在r0级    
### 内存空间布局
32位寻址支持2^32B（4GB）的虚拟内存空间，其中系统的内存主要分为内核空间和应用层空间，每部分约占2GB，还有64kb的null空间和非法区域   
64位理论支持最大2^64kb的寻址空间，但因为太大用不完所以只支持到40多位（....顺便32位和64位cpu地址总线不一定是32/64，32位通过PAE扩展到36位；64位只有4x位）    

### Windows启动过程
1. 自检   
从bios载入指令，进行硬件的初始化检查  
2. 初始化启动   
根据cmos的设置，bios加载启动盘，将主引导记录（mbr）[1]中的引导代码载入内存。启动代码搜索mbr中的分区表,找出活动分区，将引导代码载入内存。引导代码查找并启动ntldr文件，bios将控制权转移给ntldr   
3. boot加载   
   1. 设置内存模式
   2. 启动文件系统，定位boot.ini等启动文件
   3. 读取boot.ini 
4. 检测和配置硬件   
检查和配置硬件设备如系统固件、适配器、输入设备等
5. 内核加载
    1. 加载系统内核的ntoskrnl.exe[2]和硬件抽象层（HAL,内核与硬件电路之间的接口层)。
    2. 从注册表读取安装的驱动程序，然后依次加载
6. Windows会话管理启动   
会话管理器程序：smss.exe，是系统第一个创建的用户模式进程  
7. 用户登录   
由winlogon.exe系统服务提供，完成：  
    1. 启动服务子系统，即服务控制管理器
    2. 启动本地安全授权过程
    3. 显示登录界面


用bios和mbr的启动方式具有局限性，新的系统引导方式用UEFI和GPT。   
UEFI（统一的可扩展固件接口）突破了读取分区容量最高仅为2tb的限制；并且UEFI本身相当于一个微型操作系统，可以直接读取FAT分区中的文件，程序员可以开发出直接在UEFI下运行的程序。因此可以将Windows安装程序做成efi类型的应用程序，从而不需要主引导记录、活动分区等，就可以启动Windows   
GPT（全局唯一标识分区表）可以对分区数量没有限制（Windows限制在128个以内），可管理磁盘大小为18eb，只有基于uefi平台的主板才支持gpt分区引导启动


[1]: Master Boot Record，包括启动代码、硬盘分区表、结束标志字，包含MBR引导代码的扇区称为主引导扇区   
[2]: Windows NT operating system kernel,为内核空间提供内核和执行层，并负责一些系统服务
