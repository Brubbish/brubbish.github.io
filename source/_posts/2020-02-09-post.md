---
title: 2020.02.03-2020.02.09
tags:
	- 周报
	- 汇编
abbrlink: 7089
date: 2020-02-09 15:35:26
---

这周学得比较少因为刚把输入法从全拼换成双拼在练习打字....
## 1.搞博客 
- 在博客里加入了点效果（小声 bb：以前觉得应该挺复杂的，其实有了轮子之后也就一行代码的事啊）
参考：[https://github.com/VincentGarreau/particles.js](https://github.com/VincentGarreau/particles.js) -了解了 GitHub 上博客的结构
[使用 GitHub,Jekyll 打造自己的免费独立博客](https://www.cnblogs.com/Eaglery/p/5126279.html)
<!--more-->
## 2.汇编语言学习
### div 指令
- div 是除法指令 -除数：有 8 位和 16 位两种，在一个寄存器或内存单元中 -被除数：默认放在 ax 或 dx 和 ax 中
如果除数为 8 位，则被除数为 16 位，默认放在 ax 中存放
如果除数为 16 位，则被除数位 32 位，在 dx 和 ax 中存放，dx 存放高 16 位，ax 存放低 16 位 -结果：
除数为 8 位（16^2-1=255)，al 储存商，ah 储存余数
除数为 16 位(16^4-1=65535)，ax 储存商，dx 储存余数

divbyteptrds:[0]含义：   
~(al)=(ax)/((ds)*16+0)的商   
(ah)=(ax)/((ds)*16+0)的余数

divwordptr[bx+si+8]含义：   
~(ax)=[(dx)*10000h+(ax)]/((ds)*16+(bx)+(si)+8)的商   
(dx)=[(dx)*10000h+(ax)]/((ds)\*16+(bx)+(si)+8)的余数

### dd 指令 
- 用 db 定义字节型数据  
- 用 dw 定义字型数据 
- 用 dd 定义 double（双字）型数据  

### dup
dup 是一个操作符，和 db、dw、dd 等数据定义伪指令配合使用，用来进行数据的重复  
db/dw/dd 重复次数 dup（重复的数据）

如：
~db200dup（0）  
：定义了 200 个字节的 0   
db3dup（‘abc’）  
：定义了 9 个字节:'abcabcabc'

### 转移指令
指可以修改 ip 或同时修改 cs 和 ip 的指令

段内转移：只修改 ip  
~短转移：-128~127  
近转移：-32768~32767

## 3.c 语言-学生成绩管理系统

```c
#include<stdio.h>
#include<stdlib.h>
structstu{
	intnum;
	charname[10];
	intsex;
	intage;
	intscore;
	structstu*next;
};
structstu*p;
voidmenu(){
	printf("choseafunction:\n"
	"1.录入信息\n"
	"2.打印信息\n"
	"3.保存信息\n"
	"4.读取信息\n"
	"5.统计所有人数\n"
	"6.按学号查找信息\n"
	"7.修改信息\n"
	"8.删除信息\n"
	"9.退出\n");
}
voidremove();
voidbuild();
voidprint(structstu*p);
voidsum(structstu*p);
voidsave(structstu*p);
voidfind(structstu*p);
voidmodify(structstu*p);
voidread();


intmain(){
	intn;
	while(1){
		menu();
		scanf("%d",&n);
		switch(n){
			case9:
				return0;
			case1://录入
				build();
				break;
			case2://打印
				print(p);
				break;
			case3://保存
				save(p);
				break;
			case4://读取
				read();
				break;
			case5://统计人数
				sum(p);
				break;
			case6://查找
				find(p);
				break;
			case7://修改
				modify(p);
				break;
			case8://删除
				remove();
				break;
			default:
				printf("Wrongnum\n");
				continue;
		}
	}

}
//
voidbuild(){
	structstu*head=NULL,*nextp;
	if(p!=NULL){
		head=p;
		while(head->next!=NULL){
			head=head->next;
		}
	}
	printf("顺序输入学号姓名性别（男1女0）年龄成绩输入-1结束\n");
	nextp=(structstu*)malloc(sizeof(structstu));
	nextp->next=NULL;
	scanf("%d",&nextp->num);
	while(nextp->num!=-1){
		scanf("%s%d%d%d",nextp->name,&nextp->sex,&nextp->age,&nextp->score);
		if(head==NULL){
			p=nextp;
			head=p;
		}else{
			head->next=nextp;
			head=head->next;
		}
		nextp=(structstu*)malloc(sizeof(structstu));
		nextp->next=NULL;
		scanf("%d",&nextp->num);
	}
}
//
voidprint(structstu*p){
	while(p){
		printf("%d%s%d%d%d\n",p->num,p->name,p->sex,p->age,p->score);
		p=p->next;
	}
}
//
voidsum(structstu*p){
	inti=0;
	while(p){
		p=p->next;
		i++;
	}
	printf("%d\n",i);

}
//
voidfind(structstu*p){
	printf("输入学号：");
	intnum;
	scanf("%d",&num);

	while(1){
		if(p->num==num){
			break;
		}
		p=p->next;
		if(p==NULL)
			break;
	}
	if(p!=NULL)
		printf("%d%s%d%d%d\n",p->num,p->name,p->sex,p->age,p->score);
	else
		printf("WrongNumber\n");
}

voidmodify(structstu*p){
	structstu*head;
	head=p;
	intnum;
	printf("输入修改学生的学号:\n");
	scanf("%d",&num);
	while(head){
		if(head->num!=num){
			head=head->next;
		}else
			break;
	}
	if(p==NULL)
		printf("学号错误");
	else{
		printf("输入修改学生的信息:\n");
		printf("顺序输入姓名性别（男1女0）年龄成绩输入:\n");
		scanf("%s%d%d%d",head->name,&head->sex,&head->age,&head->score);
		printf("成功修改\n");
		print(p);
	}
}

voidremove(){
	printf("输入删除的学生学号：");
	intn;
	scanf("%d",&n);
	structstu*head,*nextp,*d;
	head=p;
	nextp=p;
	d=(structstu*)malloc(sizeof(structstu));
	if(head->num==n){
		p=p->next;
		free(head);
		printf("success");
	}else{
		head=head->next;
		while(head){
			if(n!=head->num){
				head=head->next;
				nextp=nextp->next;

			}
			else
				break;
		}
		if(head==NULL)
			printf("学号错误");
		else{

			nextp->next=head->next;
			free(head);
			printf("success");
		}


	}
}

voidsave(structstu*p){
	FILE*fp;
	fp=fopen(".\\stuinfo.txt","w");
	while(p){
		fprintf(fp,"%d%s%d%d%d\n",p->num,p->name,p->sex,p->age,p->score);
		p=p->next;
	}
	fclose(fp);
	printf("数据保存成功。\n");
}


voidread(){
	if(p!=NULL){
		structstu*nextp=p->next;
		free(p);
		while(nextp){
			p=nextp;
			nextp=nextp->next;
			free(p);
		}
	}

	FILE*fp;
	fp=fopen(".\\stuinfo.txt","r");
	if(fp==NULL){
		printf("文件无法打开");
	}else{
		structstu*nextp,*head;
		head=NULL;
		nextp=(structstu*)malloc(sizeof(structstu));
		nextp->next=NULL;
		while(fscanf(fp,"%d",&nextp->num)==1){
			fscanf(fp,"%s",nextp->name);
			fscanf(fp,"%d",&nextp->sex);
			fscanf(fp,"%d",&nextp->age);
			fscanf(fp,"%d",&nextp->score);
			if(head==NULL){
				head=nextp;
				p=head;
			}
			else{
				head->next=nextp;
				head=head->next;
			}
			nextp=(structstu*)malloc(sizeof(structstu));
			nextp->next=NULL;
		}
		fclose(fp);
	}
}
```
