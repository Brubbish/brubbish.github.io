---
title: CVE-2010-2883 Adobe Reader TFF字体SING表栈溢出漏洞
tags:
  - Win漏洞分析
  - 漏洞战争
abbrlink: 57740
date: 2021-05-10
---

Adobe Reader和Acrobat中的CoolType.dll库在解析字体文件SING（Smart INdependent Glyphlets）中的uniqueName项时存在栈溢出漏洞。用户打开特制的PDF就可以执行任意恶意代码
<!--more-->

## 分析环境

|项目|版本|
|---|---|
|操作系统|WindowsXP PS3 32位|
|调试器|OD 1.10 吾爱汉化版|
|反编译器|IDA6.5|
|漏洞软件|Adobe Reader 9.3.4|

注：根据CVE的描述，漏洞影响的范围包括了Windows和macos上，9.4前的9.x和8.2.5前的8.x

## 漏洞分析

### 静态分析
IDA反汇编CoolType.dll，易定位漏洞
![20210414202752](https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210414202752.png)    

![20210414202821](https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210414202821.png)
注意到在pwn题里常见的危险函数strcat，且在调用strcat前并没有对长度进行判断    

### 漏洞样本
用二进制查看工具打开书中提供的TTF文件。   
```c
//TFF中SING表的入口结构
typedef struct_SING
{
    char tag[4];    //标记"SING"
    ULONG checksum; //校验和
    ULONG offset;   //相对偏移
    ULONG length;   //数据长度
} TableEntry;
```
![20210414210833](https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210414210833.png)   
再根据书中提供的SING表结构，找到uniqueName（BYTE[28]）
![20210414211429](https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210414211429.png)   
即strcat后，这个部分就将复制到指定的区域
### 动态调试
---
- 注：在调试时遇到了一个问题...Adobe Reader挂上od后打开任何pdf都会发生异常然后结束运行。百度后发现是od调试选项的问题，在选项里加上最后一个“忽略指定异常”应该就可以正常调试   
![20210415212329](https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210415212329.png)

再：几天后在看雪上也看到了类似的问题和泉哥给出的建议：https://bbs.pediy.com/thread-212556.htm

---

打开OD，加载Adobe Reader，F9，在0x0803DD74和0x0803DDAB处下断点，打开能触发漏洞的pdf   

F9运行至push “SING”后再单步运行至最近的call函数，
此时ECX指向SING表的入口地址，进入[0012E4B4]就可以找到SING表
![20210415214856](https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210415214856.png)
![20210415215446](https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210415215446.png)    
可以看出两个断点间代码的作用是判断SING表入口的有效性，并把uniqueName的地址传给EAX
```
注：上2图不是同一次运行的截图，所以地址不一样   
```

F9+F8到strcat的下一行，即发生溢出后，查看此时的栈帧情况（看起来GS至少在WinXP就有了）
![20210415221211](https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210415221211.png)    
此时返回地址已经被更改成了icucnv36.dll，通过工具可以知道这个库没有开启ASLR    

往下运行到0x0808B308，这里是一个进入icucnv36.dll的call指令，跟进去看一看   
只有简单的三条指令：
![20210415222508](https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210415222508.png)
调整了ebp   

运行至0xA82A714
![20210415223734](https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210415223734.png)
而0c0c0c0c处的内容为：
![20210415224754](https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210415224754.png)
可以看出是一个堆喷。   

后续的操作依次调用了CreateFileA、CreateFileMappingA、MapViewOfFile，开辟出一块可读写可执行的区域绕过DEP(NX)并写入shellcode，随后执行shellcode

## 流程总结
![20210415225645](https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210415225645.png)



# 后记
调试的第一个RW漏洞，感觉比想象中的漏洞复现复杂一些，并不是跟着别人/书里的步骤一步步执行就可以的，还可能遇到一些环境的问题（which整了好久，感谢021w师傅的指导orz）和要琢磨好久的点。   
がんばって

参考：
https://bbs.pediy.com/thread-251801.htm   
https://021w.github.io/2020/08/01/CVE-2010-2883%E6%A0%88%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/