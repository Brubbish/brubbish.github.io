---
title: CVE-2010-3333
tags:
  - Win漏洞分析
  - 漏洞战争
abbrlink: 47243
date: 2021-04-10
---
本来打算只看看书，跳过调试的环节，结果在下一章堆漏洞讲到了分析这个漏洞时用到的栈回溯，所以又回来了2333

<!--more-->

| 项目     | 版本           |
| -------- | -------------- |
| 操作系统 | Windows XP SP3 |
| 调试器   |  windbg 6.12  |
| 漏洞软件 | word 2003 (11.5604.5606)|
注：虽然漏洞好像在XP SP3上都有，但是metasploit生成的crash样本在高于11.5604的word上不一定能用（之前调试CVE-2011-0104用的那个office就8行，直接成功把样本打开了...）这个版本找了好久orzz
# 漏洞描述

Stack-based buffer overflow in Microsoft Office XP SP3, Office 2003 SP3, Office 2007 SP2, Office 2010, Office 2004 and 2008 for Mac, Office for Mac 2011, and Open XML File Format Converter for Mac allows remote attackers to execute arbitrary code via crafted RTF data, aka "RTF Stack Buffer Overflow Vulnerability."

# 复现过程
用metasploit生成poc。    
感觉metasploit在windows上不太好使，后来想起来kali自带了这个...

获得poc后打开word，windbg attach，加载poc触发异常一条龙    

![20210512215446](https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210512215446.png)
windbg查看寄存器信息
```
这一步需要符号文件，没有配置过的话可以参考下面两个链接
https://bbs.pediy.com/thread-251052.htm
https://www.cnblogs.com/csnd/p/11800535.html
```
发现edi指向了一个只读的区域
![20210512215515](https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210512215515.png)    
所以应该还是在循环复制的时候没有检查长度（似乎好多古老的栈溢出都是因为这个）    

在异常处下断点，bp 30e9eb88，重新加载   
![20210512220932](https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210512220932.png)     
命令k查看栈回溯    
![20210512222342](https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210512222342.png)      

```
windbg查看反汇编代码指令：
u .  // 反汇编当前eip寄存器地址的后8条指令

u $eip  // 反汇编当前eip寄存器地址的后8条指令

ub .  // 反汇编当前ip寄存器地址的前8条指令

ub $eip  // 反汇编当前eip寄存器地址的前8条指令

u main+0x29 L30 // 反汇编main+0x29地址的后30条指令

u  // 反编译下8条指令

uf CTest::add  // 反汇编CTest类的add函数

uf /c main  // 反汇编main函数，通过/c可以查看main函数中的函数调用(call)都有哪些

ub 000c135d L20  // 查看地址为000c135d指令前的20条指令内容
```

查看后续的指令和栈中的内容。连着两个pop然后ret，返回到调用漏洞代码的指令的下一指令，即0x30f4cc96
![20210513182456](https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210513182456.png)

在ida里查看，可以发现该指令位于函数sub_30F4CC5D
![20210513184917](https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210513184917.png)     
并且函数有三个参数。因为是32位程序，使用栈传递参数，涉及到的三个push指令分别与[ebp+arg_4]（在后续的子函数中赋给edi，如下图2）、ecx、esi有关
![20210513200611](https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210513200611.png)     
![20210513210636](https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210513210636.png)

先记录一下，这条call指令位于sub_20F4CC5D的30F4CC93，调用了sub_30E9EB62的30E9EB88（即溢出点）    
而我们要回溯它用到的三个参数。第一个很直白；2、3需要再分析    

先看esi，esi=[eax+64h]，注意到有一个
```
.text:30F4CC75                 call    sub_30D2810C
```
进入看到这里是最后修改eax的位置
![20210513211641](https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210513211641.png)      

再看ecx，在sub_30E9EB62中：   
![20210513212959](https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210513212959.png)

在30F4CDB0中可以看到，eax=[ebp+arg_0]   

综上得到：  
![20210513213522](https://raw.githubusercontent.com/Brubbish/pic_bed/master/blog/20210513213522.png)

在windbg中再次调试可以验证静态分析得到的传参过程，没截图，略    

```
整体思路：由崩溃点确定漏洞触发位置——>回溯调用栈——>分析参数如何计算及传递。
````

参考：    
https://www.yuque.com/hxfqg9/bin/hzyxvk   
https://bbs.pediy.com/thread-263998.htm