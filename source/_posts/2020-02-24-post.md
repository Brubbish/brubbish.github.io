---
title: 2020.02.24-2020.03.01
tags: 
    - 周报
    - 加密与解密
abbrlink: 9fec375a
date: 2020-02-24 15:40:38
---
# OllyDbg 学习
## 常用断点
### int(interrupt) 3断点
在OD中用'F2'来设置，机器码是0xCC   
执行一个int 3断点时，该地址处的指令首字节修改位CC（OD显示的还是原来的指令）  

优点是可以设置无数个指令，缺点是**改变了原程序机器码，容易被软件检测到**，例如有些软件会检测api的首地址是否为0xCC
### 硬件断点
和DRx调试寄存器有关  
DRx调试器共有8个（x从0 ~ 7）

![ ](https://s2.ax1x.com/2020/02/24/3G1qVf.png)  
<!--more-->

0 ~ 3：调试地址寄存器，用于保存需要监视的地址，例如设置硬件断点  
4、5：（先不做了解）  
6：调试寄存器组状态寄存器（'这个寄存器主要是在调试异常产生后，报告产生调试异常的相关信息')  
7：调试寄存器组控制寄存器，控制调试  
硬件断点的原理是使用DR0、DR1、DR2、DR3设定地址，并用DR7设定状态，因此最多设置4个断点  
设置方法为：1.在代码行单击右键，执行'断点'->'硬件执行&emsp;2.在数据窗口'右键'->'硬件访问断点'->（选择数据长度1/2/4字节），如4字节（Dword)当访问xxxxx0~xxxxx3的内存时会被断下  

快捷键'F4'执行到光标所在的行
### 内存断点
原理是对所设的地址赋予不可访问/不可写属性，当访问/写入的时候就会产生异常，OD比较异常地址是不是断点地址，如果是就中断  
设置内存断点在每次出现异常时都需要比较来判断是否应该中断，所以会降低OD的执行速度  
OD只能下一个内存断点，设置方法为：在数据/代码窗口选中要下断点的地址区域，右键执行'断点'->'内存写入'   
硬件访问/写入断点实在触发硬件断点的下一条指令处下断；内存断点是在触发断点的指令处下断。  
内存断点不修改原始代码，不会因为被程序校验而失败
### 内存访问一次性断点
windows 对内存使用段页式的管理方式
```
(quote):
段页式存储管理方式即先将用户程序分成若干个段，再把每个段分成若干个页，并为每一个段赋予一个段名。
（基本分段存储管理方式和基本分页存储管理方式原理的结合）
```
快捷键'Alt+M'显示内存，可以看到许多段，每个段都有不可访问、读、写、执行属性  
可用'F2'对整个段设置断点。当所在段被读取或执行时，中断发生，断点删除。
### 消息断点
当某个特定窗口函数接收到某个特定消息时，消息断点将使程序中断  
消息断点与INT 3断点的区别在于：INT 3 断点可以在程序启动之前设置，消息断点**只有在窗口被创建后才能设置**  

当用户点击按钮、移动光标、输入文字时，一条消息就会发送给当前窗体。发送的信息有4个参数：1个窗口句柄，1个消息编号，2个32位长的参数。  
设置方法：工具栏中的'w'按钮，在条目上单击右键....。 

ps：*当单击按钮并松开时会发送'WM_LBUTTONUP'这个消息。*

### 条件断点
在满足一定条件时才会中断。OD中可以按寄存器、储存器、消息等设断点。  
用带有条件表达式的INT 3 断点，当调试器遇到断点时，计算表达式的值，如果表达式有效则断点生效。   
1. 按寄存器条件中断  
快捷键'Shift+F2' 条件表达式例如：  eax==0400000
2. 按存储器条件中断  
*（CreateFileA函数用于打开文件，可对其设断）*  
在栈窗口右键，执行'Address'->'Relative to ESP'可看到各个参数相对于当前ESP的地址，如果要得到第一个参数的地址，可以用[ESP+4],如果要得到指向的字符串，使用[[ESP+4]],表达式可用：[STRING [ESP+4]]=="...."(STRING前缀是“以0结尾的ASCII字符串”,还有UNICODE前缀等)
### 条件记录断点
可以记录断点处函数表达式或参数的值，也可以设置断点次数，每次符合条件暂停后计数值-1  
快捷键'Shift+F4'打开条件记录窗口  
条件记录断点可以向插件传递多个命令  
## 插件
OD只能加载32个插件  
添加插件可通过将插件复制到'plugin'文件夹中  
## Run trace
把程序执行过的指令保存下来。  
将地址、寄存器等记录到Run tarce 缓冲区中。如果缓冲区太小可能造成缓冲区溢出，OD会自动丢弃旧记录。   
数据可以在'查看'->'RUN跟踪'里（或按'...'）查看。使用'+'和'-'浏览程序执行路线
## Hit trace
分辨哪一部分代码被执行了，哪一部分没有执行。在遇到一段跳转分支比较多的代码，需要了解程序执行路线时，可以用Hit trace。  
选中代码->右键->'Hit trace'->'Add selection'  
效果是执行过的指令前为红色，未执行的为蓝色：  
![](https://s2.ax1x.com/2020/02/28/3D6OqU.png)  

ps：**不要在监视的代码中设置断点**
## OD常见问题
### 乱码
1. 右键'分析'->'分析代码'或快捷键'Ctrl+A'
2. 右键'分析'->'从模块中删除分析'，或在udd文件夹中删除相应文件
### 在反汇编窗口输入'push E000'不能正确识别
改为'push 0E000'
### od'假死'
可能在调试加壳程序时产生
打开'ollydbg.ini'设置'Restore windows 0'

# 静态分析技术
用高级语言写的程序有两种形式。  
1. 程序被编译成机器语言在cpu上执行  
对于这种程序，可以将机器语言转化为汇编语言，这个过程称为**反汇编**
2. 边解释边执行（编写这种程序的语言称为解释性语言，如java）  
这种语言编译程序后可以被还原成高级语言的原始结构，这个过程被称为**反编译**  

静态分析：通过反编译、反汇编获得程序的汇编代码或源代码，然后分析流程，了解模块的功能  

## 文件类型分析
逆向分析程序的第一步
了解编写程序的语言、编译的编译器或是否被加密  
各种开发语言都有固定的启动代码，被加密程序处理过的程序中会留下加密软件的相关信息  
但有些外壳程序会将一些加壳信息去除，并伪造启动代码，从而欺骗了PEiD等检测分析软件。因此识别工具给出的结果只能作为参考  
## IDA
ida 是按区块装载pe文件的，例如.text代码块、.data数据块、.rsrc资源块、.idata输入表、.edata输出表。  
反编译过程分为两个阶段：
1. 将代码和数据分开，分析函数的参数调用、跳转等
2. 装载对应的编译器特征文件，给各个函数赋名