<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/unnamed.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/photo.gif">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="eaKNHevzJD712W6CICpiQ4_TgpzOgFr3dBKOwg7Hqs4">
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9943095847270020"
     crossorigin="anonymous"></script>

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"brubbish.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.11.0","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":true,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>



<link rel="canonical" href="https://brubbish.github.io/20986.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://brubbish.github.io/20986.html","path":"20986.html","title":"UCAS-2023-ML复习"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>UCAS-2023-ML复习 | Brubbish's Notebook</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-153514659-2"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"UA-153514659-2","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>




<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9943095847270020"
     crossorigin="anonymous"></script>
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9943095847270020"
     crossorigin="anonymous"></script>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Brubbish's Notebook</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-书单"><a href="/books/" rel="section"><i class="fa fa-bookmark fa-fw"></i>书单</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9943095847270020"
     crossorigin="anonymous"></script>
<!-- sidebar -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-9943095847270020"
     data-ad-slot="5504766755"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E9%A2%98%E5%BA%93%E5%AD%A6%E4%B9%A0%EF%BC%8C%E7%94%A8ChatGPT-3-5%EF%BC%8C%E9%94%99%E4%BA%86%E5%B0%B1%E5%AF%84%E6%9C%AC%E6%96%87%E6%97%A5%E6%9C%9F%E6%98%AF%E4%B9%B1%E6%A0%87%E6%B3%A8%E7%9A%84"><span class="nav-number">1.</span> <span class="nav-text">面向题库学习，用ChatGPT 3.5，错了就寄
本文日期是乱标注的</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number"></span> <span class="nav-text">选择</span></a></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Bruce</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">59</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9943095847270020"
     crossorigin="anonymous"></script>
<!-- sidebar -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-9943095847270020"
     data-ad-slot="5504766755"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9943095847270020"
     crossorigin="anonymous"></script>
<!-- sidebar -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-9943095847270020"
     data-ad-slot="5504766755"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
  </div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://brubbish.github.io/20986.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Bruce">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Brubbish's Notebook">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="UCAS-2023-ML复习 | Brubbish's Notebook">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          UCAS-2023-ML复习
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-07-02 00:00:00" itemprop="dateCreated datePublished" datetime="2024-07-02T00:00:00+00:00">2024-07-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2026-01-06 16:19:10" itemprop="dateModified" datetime="2026-01-06T16:19:10+00:00">2026-01-06</time>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="面向题库学习，用ChatGPT-3-5，错了就寄本文日期是乱标注的">面向题库学习，用ChatGPT 3.5，错了就寄<br>
本文日期是乱标注的</h2>
<p>事实证明想过只要背原题</p>
<span id="more"></span>      
<h1>选择</h1>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 属于监督学习的机器学习算法是( A )      </span><br><span class="line">A. 贝叶斯分类器      </span><br><span class="line">B. 主成分分析      </span><br><span class="line">C. K-Means      </span><br><span class="line">D. 高斯混合聚类      </span><br></pre></td></tr></table></figure>
<p>贝叶斯分类器：就是用贝叶斯定理搞的那玩意。在用的时候需要知道样本的类别，才能计算先验和条件概率<br>
主成分分析(PCA)：用来减少数据集的维度，通常用于无监督学习，也可以用于监督学习的预处理<br>
K-means：聚类算法，将数据集划分为k个簇，中心簇代表簇内的样本均值，然后不断中心簇使得样本点和所属的中心簇距离最小<br>
高斯混合聚类：通过最大化似然函数来估计模型参数，从而实现对数据的聚类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2. 属于无监督学习的机器学习算法是( C )      </span><br><span class="line">A．支持向量机      </span><br><span class="line">B．Logistic回归      </span><br><span class="line">C．层次聚类      </span><br><span class="line">D．决策树      </span><br></pre></td></tr></table></figure>
<p>支持向量机和逻辑回归都是监督学习算法<br>
层次聚类：把样本划分为层次结构的簇，通过合并和分裂来构建聚类树，不需要预先知道簇的数量<br>
决策树：更常用于监督学习的分类和回归</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3. 朴素贝叶斯分类器的特点是( C )      </span><br><span class="line">A. 假设样本服从正态分布      </span><br><span class="line">B. 假设样本服从多项式分布      </span><br><span class="line">C. 假设样本各维属性独立      </span><br><span class="line">D. 假设样本各维属性存在依赖      </span><br></pre></td></tr></table></figure>
<p>正态分布：高斯朴素贝叶斯<br>
多项式分布：多项式朴素贝叶斯，适用于离散特征的情况<br>
各维数型存在依赖：可以使用高斯混合模型、隐马尔可夫模型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4. 下列属于线性分类方法的是( B )      </span><br><span class="line">A. 决策树      </span><br><span class="line">B. 感知机      </span><br><span class="line">C. 最近邻      </span><br><span class="line">D. 集成学习      </span><br></pre></td></tr></table></figure>
<p>决策树不一定是线性分类方法，可以非常灵活地划分样本空间，并且可以包含非线性的决策边界。<br>
感知机通过找到一个超平面来划分两个类别的样本空间<br>
最近邻算法通常用于分类和回归任务，它根据样本的近邻进行预测，可用于线性和非线性的问题<br>
集成学习是一种通过组合多个基学习器来提高整体性能的方法，是一个组合的框架</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5. 下列方法不受数据归一化影响的是( D )      </span><br><span class="line">A. SVM      </span><br><span class="line">B. 神经网络      </span><br><span class="line">C. Logistic回归      </span><br><span class="line">D. 决策树      </span><br></pre></td></tr></table></figure>
<p>决策树基于特征的取值来进行划分，而不关心具体数值的大小<br>
归一化：<br>
标准化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">6. 关于线性鉴别分析的描述最准确的是，找到一个投影方向，使得( B )      </span><br><span class="line">A. 类内距离最大，类间距离最小      </span><br><span class="line">B. 类内距离最小，类间距离最大      </span><br><span class="line">C. 类内距离最大，类间距离最大      </span><br><span class="line">D. 类内距离最小，类间距离最小      </span><br></pre></td></tr></table></figure>
<p>线性判别分析（LDA）的目标是通过将数据投影到一个低维空间，在投影后，同一类别的样本尽可能接近，而不同类别的样本尽可能远离。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">7. SVM的原理可简单描述为( C )      </span><br><span class="line">A. 最小均方误差分类      </span><br><span class="line">B. 最小距离分类      </span><br><span class="line">C. 最大间隔分类      </span><br><span class="line">D. 最近邻分类      </span><br></pre></td></tr></table></figure>
<p>SVM：支持向量机<br>
最小均方误差：线性回归算法<br>
最小距离：最近邻算法就是最小距离分类的一种具体实现<br>
最近邻分类：k-Nearest Neighbors</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">8. SVM的算法性能取决于( D )      </span><br><span class="line">A. 核函数的选择      </span><br><span class="line">B. 核函数的参数      </span><br><span class="line">C. 软间隔参数C      </span><br><span class="line">D. 以上所有      </span><br></pre></td></tr></table></figure>
<p>记吧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">9. 支持向量机的对偶问题是( C )      </span><br><span class="line">A. 线性优化问题      </span><br><span class="line">B. 二次优化      </span><br><span class="line">C. 凸二次优化      </span><br><span class="line">D. 有约束的线性优化      </span><br></pre></td></tr></table></figure>
<p>线性优化问题目标是最小化或最大化一个线性目标函数，受到一组线性约束的限制</p>
<p>二次优化是一类目标函数和约束都是二次的数学规划问题</p>
<p>凸二次优化是指目标函数是凸函数，约束是凸集的优化问题。支持向量机的对偶问题其目标函数和约束都满足凸性质</p>
<p>有约束的线性优化是一类目标函数和约束都是线性的优化问题。但是支持向量机的对偶问题涉及到二次项</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">10. 以下对支持向量机中的支撑向量描述正确的是( C )      </span><br><span class="line">A. 最大特征向量      </span><br><span class="line">B. 最优投影向量      </span><br><span class="line">C. 最大间隔支撑面上的向量      </span><br><span class="line">D. 最速下降方向      </span><br></pre></td></tr></table></figure>
<p>记吧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">11. 假定你使用阶数为2的线性核SVM，将模型应用到实际数据集上后，其训练准      </span><br><span class="line">确率和测试准确率均为100%。现在增加模型复杂度（增加核函数的阶），会发      </span><br><span class="line">生以下哪种情况( A )      </span><br><span class="line">A. 过拟合      </span><br><span class="line">B. 欠拟合      </span><br><span class="line">C. 什么都不会发生，因为模型准确率已经到达极限      </span><br><span class="line">D. 以上都不对      </span><br></pre></td></tr></table></figure>
<p>增加模型复杂度（增加核函数的阶）可能会导致过拟合<br>
增加模型复杂度可以捕捉数据中的更多关系，避免欠拟合</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">12. 关于决策树节点划分指标描述正确的是( B )      </span><br><span class="line">A. 类别非纯度越大越好      </span><br><span class="line">B. 信息增益越大越好      </span><br><span class="line">C. 信息增益越小越好      </span><br><span class="line">D. 基尼指数越大越好      </span><br></pre></td></tr></table></figure>
<p>节点的类别纯度越高；信息增益越大；基尼指数越小（表示节点纯度越高）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">13. 以下描述中，属于决策树策略的是( D )      </span><br><span class="line">A. 最优投影方向      </span><br><span class="line">B. 梯度下降方法      </span><br><span class="line">C. 最大特征值      </span><br><span class="line">D. 最大信息增益      </span><br></pre></td></tr></table></figure>
<p>决策树中，常用的策略是选择能够最大化信息增益或最小化基尼指数的特征进行划分<br>
信息增益是衡量在给定划分条件下，划分前后样本的不确定性减少程度的指标</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">14. 集成学习中基分类器如何选择，学习效率通常越好( D )      </span><br><span class="line">A. 分类器相似      </span><br><span class="line">B. 都为线性分类器      </span><br><span class="line">C. 都为非线性分类器      </span><br><span class="line">D. 分类器多样，差异大      </span><br></pre></td></tr></table></figure>
<p>前面好像说过类似的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">15. 集成学习中，每个基分类器的正确率的最低要求( A )      </span><br><span class="line">A. 50%以上      </span><br><span class="line">B. 60%以上      </span><br><span class="line">C. 70%以上      </span><br><span class="line">D. 80%以上      </span><br></pre></td></tr></table></figure>
<p>记吧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">16. 下面属于Bagging方法的特点是( A )      </span><br><span class="line">A. 构造训练集时采用Bootstraping的方式      </span><br><span class="line">B. 每一轮训练时样本权重不同      </span><br><span class="line">C. 分类器必须按顺序训练      </span><br><span class="line">D. 预测结果时，分类器的比重不同      </span><br></pre></td></tr></table></figure>
<p>记吧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">17. 下面属于Boosting方法的特点是( D )      </span><br><span class="line">A. 构造训练集时采用Bootstraping的方式      </span><br><span class="line">B. 每一轮训练时样本权重相同      </span><br><span class="line">C. 分类器可以并行训练      </span><br><span class="line">D. 预测结果时，分类器的比重不同      </span><br></pre></td></tr></table></figure>
<p>18说了类似的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">18. 随机森林方法属于( B )      </span><br><span class="line">A. 梯度下降优化      </span><br><span class="line">B. Bagging方法      </span><br><span class="line">C. Boosting方法      </span><br><span class="line">D. 线性分类      </span><br></pre></td></tr></table></figure>
<p>随机森林通过构建多个决策树并将它们集成在一起来提高模型的性能和泛化能力。在构建每一个决策树的时候随机选择特征，增加模型整体的多样性。通过将所有决策树的输出进行集成，来做出最终的预测：对于分类问题，采用投票法，即选择得票最多的类别。对于回归问题，取所有树的平均预测值。随机森林通常用于解决非线性问题<br>
Bagging指的是通过构建多个基学习器，并将它们的结果进行集成</p>
<p>Boosting方法是另一种集成学习方法，通过训练一系列弱学习器，并根据前一个模型的性能对下一个模型进行加权</p>
<p>线性分类方法：例如线性支持向量机、逻辑回归等。<br>
梯度下降主要用于更新模型的损失函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">19. 软间隔SVM的阈值趋于无穷，下面哪种说法正确( A )      </span><br><span class="line">A. 只要最佳分类超平面存在，它就能将所有数据全部正确分类      </span><br><span class="line">B. 软间隔SVM分类器将正确分类数据      </span><br><span class="line">C. 会发生误分类现象      </span><br><span class="line">D. 以上都不对      </span><br></pre></td></tr></table></figure>
<p>Soft Margin SVM：用于处理线性不可分的数据<br>
阈值即松弛变量，软间隔SVM的优化目标：最大化训练样本点到决策边界（超平面）的间隔（与SVM的线性分类相同）、误差项（容忍一些训练样本不满足硬间隔的条件，允许它们位于错误的一侧。较小的C值允许更多的误分类）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">20. 回归问题和分类问题的区别( A )      </span><br><span class="line">A. 前者预测函数值为连续值，后者为离散值      </span><br><span class="line">B. 前者预测函数值为离散值，后者为连续值      </span><br><span class="line">C. 前者是无监督学习      </span><br><span class="line">D. 后者是无监督学习      </span><br></pre></td></tr></table></figure>
<p>记吧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">21. 正则化的回归分析，可以避免( B )      </span><br><span class="line">A. 线性化      </span><br><span class="line">B. 过拟合      </span><br><span class="line">C. 欠拟合      </span><br><span class="line">D. 连续值逼近      </span><br></pre></td></tr></table></figure>
<p>记吧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">22. “啤酒-纸尿布”问题讲述的是，超市购物中，通过分析购物单发现，买了      </span><br><span class="line">纸尿布的男士，往往又买了啤酒。这是一个什么问题( A )      </span><br><span class="line">A. 关联分析      </span><br><span class="line">B. 回归      </span><br><span class="line">C. 聚类      </span><br><span class="line">D. 分类      </span><br></pre></td></tr></table></figure>
<p>分类：监督学习；聚类：无监督学习<br>
关联分析：找到数据项之间的关系<br>
回归：用于预测连续型输出变量的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">23. 混合高斯聚类中，运用了以下哪种过程( A )      </span><br><span class="line">A. EM算法      </span><br><span class="line">B. 集合运算      </span><br><span class="line">C. 密度可达      </span><br><span class="line">D. 样本与集合运算      </span><br></pre></td></tr></table></figure>
<p>记吧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">24. 主成分分析方法是一种什么方法( C )      </span><br><span class="line">A. 分类方法      </span><br><span class="line">B. 回归方法      </span><br><span class="line">C. 降维方法      </span><br><span class="line">D. 参数估计方法      </span><br></pre></td></tr></table></figure>
<p>记吧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">25. PCA在做降维处理时，优先选取哪些特征( A )      </span><br><span class="line">A. 中心化样本的协方差矩阵的最大特征值对应特征向量      </span><br><span class="line">B. 最大间隔投影方向      </span><br><span class="line">C. 最小类内聚类      </span><br><span class="line">D. 最速梯度方向      </span><br></pre></td></tr></table></figure>
<p>renew一下：PCA==主成分分析</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">26. 过拟合现象中( A )      </span><br><span class="line">A. 训练样本的测试误差最小，测试样本的正确识别率却很低      </span><br><span class="line">B. 训练样本的测试误差最小，测试样本的正确识别率也很高      </span><br><span class="line">C. 模型的泛化能力很高      </span><br><span class="line">D. 通常为线性模型      </span><br></pre></td></tr></table></figure>
<p>没啥好说的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">27. 多层感知机方法中，可用作神经元的非线性激活函数( A )      </span><br><span class="line">A. logistic 函数      </span><br><span class="line">B. p-范数      </span><br><span class="line">C. 线性内积      </span><br><span class="line">D. 加权求和      </span><br></pre></td></tr></table></figure>
<p>记吧</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/3e7013703371ed09ec070cbad2311ce.png" alt="3e7013703371ed09ec070cbad2311ce"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">29. 梯度下降算法的正确步骤是什么( B )      </span><br><span class="line">(1)计算预测值和真实值之间的误差      </span><br><span class="line">(2)迭代更新，直到找到最佳权重      </span><br><span class="line">(3)把输入传入网络，得到输出值      </span><br><span class="line">(4)初始化随机权重和偏差      </span><br><span class="line">(5)对每一个产生误差的神经元，改变相应的（权重）值以减小误差      </span><br><span class="line"> A. 1, 2, 3, 4, 5      </span><br><span class="line"> B. 4, 3, 1, 5, 2      </span><br><span class="line"> C. 3, 2, 1, 5, 4      </span><br><span class="line"> D. 5, 4, 3, 2, 1      </span><br></pre></td></tr></table></figure>
<p>记吧：<br>
初始化-&gt;先进行一次预测-&gt;计算预测的误差-&gt;对每一个产生误差的神经元，改变相应的（权重）值以减小误差-&gt;迭代更新</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">30.假如使用一个较复杂的回归模型来拟合样本数据，使用岭回归，调试正则化      </span><br><span class="line">参数λ，来降低模型复杂度。若λ较大时，关于偏差（bias）和方差（variance），      </span><br><span class="line">下列说法正确的是（C）      </span><br><span class="line">A．若λ较大时，偏差减小，方差减小      </span><br><span class="line">B．若λ较大时，偏差减小，方差增大      </span><br><span class="line">C．若λ较大时，偏差增大，方差减小      </span><br><span class="line">D．若λ较大时，偏差增大，方差增大      </span><br></pre></td></tr></table></figure>
<p>岭回归是一种线性回归的扩展，目标是最小化损失函数和正则化项之和。正则化项的强度由正则化参数λ控制。<br>
偏差：模型的预测和真实值的差异。当λ较大时，正则化强度增大，模型更趋向于简单的参数设置，可能导致对训练数据的拟合程度不够<br>
方差：衡量模型在不同训练集上的预测的变异性。当λ较大时，正则化会限制模型参数的数量和范围，降低模型的复杂度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">31.以下哪种方法会增加模型的欠拟合风险（D）      </span><br><span class="line">A．添加新特征      </span><br><span class="line">B．增加模型复杂度      </span><br><span class="line">C．减小正则化系数      </span><br><span class="line">D．数据增强      </span><br></pre></td></tr></table></figure>
<p>没啥好说的，其他都可能过拟合</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">32. 增加以下哪些超参数可能导致随机森林模型过拟合数据（B）      </span><br><span class="line">(1). 决策树的数量；(2). 决策树的深度； (3). 学习率。      </span><br><span class="line">A. (1)      </span><br><span class="line">B. (2)      </span><br><span class="line">C. (3)      </span><br><span class="line">D. (2)(3)      </span><br></pre></td></tr></table></figure>
<p>(1)：减小单个决策树的过拟合倾向<br>
(2)：增加深度使得模型更复杂，容易过拟合<br>
(3)：通常是梯度提升机等模型中的超参数，而不是随机森林。较大的学习率可能导致模型对训练数据过于敏感，使其更容易过拟合</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">33. 以下关于深度网络训练的说法正确的是（D）      </span><br><span class="line">A. 训练过程需要用到梯度，梯度衡量了损失函数相对于模型参数的变化率      </span><br><span class="line">B. 损失函数衡量了模型预测结果与真实值之间的差异      </span><br><span class="line">C. 训练过程基于一种叫做反向传播的技术      </span><br><span class="line">D. 其他选项都正确      </span><br></pre></td></tr></table></figure>
<p>记吧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">34. 关于CNN，以下结论正确的是（C）      </span><br><span class="line">A. 在同样层数、每层神经元数量一样的情况下，CNN比全连接网络拥有更多的参      </span><br><span class="line">数      </span><br><span class="line">B. CNN可以用于非监督学习，但是普通神经网络不行      </span><br><span class="line">C. Pooling层用于减少图片的空间分辨率      </span><br><span class="line">D. 接近输出层的filter主要用于提取图像的边缘信息      </span><br></pre></td></tr></table></figure>
<p>CNN的参数通常较少，因为它们共享权重并具有局部连接性，而全连接网络的参数数量更多<br>
普通神经网络也可以用于非监督学习任务，例如自编码器等<br>
Pooling层通常用于减小特征图的空间尺寸，通过保留主要信息的同时减少计算量<br>
接近输出层的filter更倾向于提取高级抽象的特征，而靠近输入层的filter更多地捕捉图像的低级特征</p>
<p>输入层： 接收原始图像。<br>
卷积层： 提取图像的低级特征，例如边缘、纹理。<br>
激活函数层： 引入非线性，增加模型的表达能力。<br>
Pooling层： 减小特征图的空间尺寸，降低计算复杂度。<br>
全连接层： 将抽取的特征进行扁平化，并用于最终的分类或回归任务。<br>
输出层： 提供最终的预测结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">35. 关于k-means算法，正确的描述是（B）      </span><br><span class="line">A. 能找到任意形状的聚类      </span><br><span class="line">B. 初始值不同，最终结果可能不同      </span><br><span class="line">C. 每次迭代的时间复杂度是𝑂(𝑛), 其中𝑛是样本数量      </span><br><span class="line">D. 不能使用核函数      </span><br></pre></td></tr></table></figure>
<p>K-Means假设每个簇是凸的、等方向的，时间复杂度与迭代次数和簇数K有关；通常是较低的线性复杂度，不一定与样本量线性相关；可以使用核化的k-means算法来处理非线性数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">36. 下列关于过拟合现象的描述中，哪个是正确的（A）      </span><br><span class="line">A. 训练误差小，测试误差大      </span><br><span class="line">B. 训练误差小，测试误差小      </span><br><span class="line">C. 模型的泛化能力高      </span><br><span class="line">D. 其余选项都不对      </span><br></pre></td></tr></table></figure>
<p>我咋记得上面有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">37. 下列哪个函数不可以做激活函数（D）      </span><br><span class="line">A. y=tanh(x)      </span><br><span class="line">B. y=sin(x)      </span><br><span class="line">C. y=max(x,0)      </span><br><span class="line">D. y=2x      </span><br></pre></td></tr></table></figure>
<p>激活函数的主要目的是1.引入非线性特性，2.决定神经元是否应该被激活（输出非零值<br>
几个激活函数：<br>
Sigmoid函数： 用于输出层，将输出映射到（0, 1）范围，适用于二分类问题。<br>
Tanh函数： 类似于Sigmoid，但将输出映射到（-1, 1）范围，有助于缓解梯度消失问题。<br>
ReLU函数（Rectified Linear Unit）： y=max(x, 0)，在正区间为线性，在负区间截断为零，解决了梯度消失问题，常用于隐藏层。<br>
Leaky ReLU函数： 对于负区间不截断为零，而是保留一个小的斜率，解决了ReLU中负值为零的问题。<br>
Softmax函数： 用于多类别分类问题，将输出转化为概率分布。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">38. 在其他条件不变的前提下，以下哪种做法容易引起机器学习中的过拟合问题      </span><br><span class="line">（D）      </span><br><span class="line">A. 增加训练集量      </span><br><span class="line">B. 减少神经网络隐藏层节点数      </span><br><span class="line">C. 删除稀疏的特征      </span><br><span class="line">D. SVM算法中使用高斯核代替线性核      </span><br></pre></td></tr></table></figure>
<p>高斯核即RBF核，是一种非线性核函数，在特征空间中引入更复杂的决策边界。。使用复杂的核函数增加了模型对训练数据的拟合程度，但也可能导致在未见过的数据上的泛化性能下降，因此容易引起过拟合</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">39. 下面方法中属于无监督学习算法的是（D）      </span><br><span class="line">A. 线性回归      </span><br><span class="line">B. 支持向量机      </span><br><span class="line">C. 决策树      </span><br><span class="line">D. K-Means聚类      </span><br></pre></td></tr></table></figure>
<p>记吧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">40. Bootstrap数据是什么意思（C）      </span><br><span class="line">A. 有放回地从总共M个特征中抽样m个特征      </span><br><span class="line">B. 无放回地从总共M个特征中抽样m个特征      </span><br><span class="line">C. 有放回地从总共N个样本中抽样n个样本      </span><br><span class="line">D. 无放回地从总共N个样本中抽样n个样本      </span><br></pre></td></tr></table></figure>
<p>记吧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">41.下面关于Adaboost算法的描述中，错误的是（D）      </span><br><span class="line">A. 是弱分类器的线性组合      </span><br><span class="line">B. 提升树是以分类树或者回归树为基本分类器的提升办法      </span><br><span class="line">C. 该算法实际上是前向分步算法的一个实现，在这个方法里，模型是加法模型，      </span><br><span class="line">损失函数是指数损失，算法是前向分步算法。      </span><br><span class="line">D. 同时独立地学习多个弱分类器      </span><br></pre></td></tr></table></figure>
<p>Adaboost算法的核心思想是通过组合多个弱分类器（通常是决策树）来构建一个强分类器。每个弱分类器都对数据进行加权学习，然后根据其在训练集上的性能来分配一个权重。最终的强分类器是这些弱分类器的线性组合，权重大的弱分类器在最终的模型中起更大的作用。<br>
它是一个串行的算法，每个弱分类器都是在前一个分类器的误差上进行学习的。它通过增加之前弱分类器分错的样本的权重，使得后续的弱分类器更关注之前分类错误的样本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">42.在HMM中,如果已知观察序列和产生观察序列的状态序列,那么可用以下哪种方法直接进行参数估计（D）      </span><br><span class="line">A．EM算法      </span><br><span class="line">B．维特比算法      </span><br><span class="line">C. 前向后向算法      </span><br><span class="line">D. 极大似然估计      </span><br></pre></td></tr></table></figure>
<p>HMM:隐马尔可夫模型<br>
EM算法通常用于处理观察序列和状态序列都未知的情况<br>
维特比算法用于求解HMM中给定观察序列时最可能的隐藏状态序列。它是解码算法<br>
前向后向算法用于计算观察序列的概率，而不是直接用于参数估计</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">43.以下哪种距离会侧重考虑向量的方向（D）      </span><br><span class="line">A. 欧式距离      </span><br><span class="line">B. 海明距离      </span><br><span class="line">C. Jaccard距离      </span><br><span class="line">D. 余弦距离      </span><br></pre></td></tr></table></figure>
<p>欧式距离考虑向量的大小和方向，它是空间中两点之间的直线距离。<br>
海明距离用于衡量两个等长字符串之间的不同位数，它不直接关注向量的方向。Jaccard距离用于衡量集合之间的相似性，它关注共同项的比例，而不考虑向量的方向。<br>
余弦距离衡量两个向量之间的夹角，而不考虑它们的大小。它主要关注向量的方向，因此更侧重于向量的方向性。通常用于衡量文本相似性、向量空间模型等场景</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">44. 解决隐马模型中预测问题的算法是（D）      </span><br><span class="line">A. 前向算法      </span><br><span class="line">B. 后向算法      </span><br><span class="line">C. Baum-Welch算法      </span><br><span class="line">D. 维特比算法      </span><br></pre></td></tr></table></figure>
<p>记吧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">45. 梯度爆炸问题是指在训练深度神经网络的时候，梯度变得过大而损失函数变为无穷。在RNN中，下面哪种方法可以较好地处理梯度爆炸问题( A )      </span><br><span class="line">A. 梯度裁剪 B. 所有方法都不行      </span><br><span class="line">C. Dropout D. 加入正则项      </span><br></pre></td></tr></table></figure>
<p>梯度爆炸问题是指在训练过程中，梯度变得过大导致权重更新过大，损失函数变为无穷<br>
梯度裁剪通过设置一个梯度阈值，当梯度的L2范数超过这个阈值时，对梯度进行缩放，以防止梯度爆炸</p>
<p>Dropout是一种正则化技术；加入正则项是正则化的一种形式，通常用于控制模型的复杂度，减少过拟合。虽然它可以提高模型的泛化能力，但它的主要目的也不是直接处理梯度爆炸</p>
<p><img src="https://raw.githubusercontent.com/Brubbish/pic_bed/master/20240110214627.png" alt="20240110214627"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">47.当不知道数据所带标签时，可以使用哪种技术促使带同类标签的数据与带其      </span><br><span class="line">他标签的数据相分离？(B)      </span><br><span class="line">A. 分类 B. 聚类 C. 关联分析 D. 隐马尔可夫链      </span><br></pre></td></tr></table></figure>
<p>前面讲过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">48.现在需要计算三个稠密矩阵A,B,C的乘积ABC，假设三个矩阵的尺寸分别为m×n，n×p，p×q，且m &lt;n &lt;p &lt;q，不考虑矩阵乘法的优化时，以下计算顺序效率最高的是（A）      </span><br><span class="line">A. (AB)C      </span><br><span class="line">B. AC(B)      </span><br><span class="line">C. A(BC)      </span><br><span class="line">D. 效率都相同      </span><br></pre></td></tr></table></figure>
<p>中间结果的矩阵尺寸尽可能小</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">49.下列方法中没有考虑先验分布的是( D )      </span><br><span class="line">A. 最大后验估计      </span><br><span class="line">B. 贝叶斯分类器      </span><br><span class="line">C. 贝叶斯学习      </span><br><span class="line">D. 最大似然估计      </span><br></pre></td></tr></table></figure>
<p>最大似然估计（MLE）基于观察到的数据来找到最可能产生这些数据的参数值，仅依赖于数据本身，不考虑参数的先验分布<br>
最大后验估计（MAP）： 考虑了先验分布，通过最大化后验概率来估计模型参数<br>
贝叶斯： 涉及到先验分布和后验概率的计算</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">50.下列哪一项主要负责在神经网络中引入非线性？（B）      </span><br><span class="line">A. 随机梯度下降      </span><br><span class="line">B. 修正线性单元（ReLU）      </span><br><span class="line">C. 输入的加权求和      </span><br><span class="line">D. 以上都不正确      </span><br></pre></td></tr></table></figure>
<p>上面说过</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">51. 下列哪一种架构有反馈连接并常被用来处理序列数据？（A）      </span><br><span class="line">A. 循环神经网络      </span><br><span class="line">B. 卷积神经网络      </span><br><span class="line">C. 全连接网络      </span><br><span class="line">D. 都不是      </span><br></pre></td></tr></table></figure>
<p>循环神经网络的神经元之间的连接形成了循环，使得网络能够捕捉序列中的时间依赖关系，用来处理序列序列数据，如语言模型、时间序列分析<br>
卷积神经网络具有局部感知域和权重共享的特点，处理图像数据<br>
全连接网络即多层感知机，每一层中的神经元与前一层的所有神经元相连接，没有时间依赖关系</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">52. 在一个神经网络中，下面哪种方法可以用来处理过拟合？（D）      </span><br><span class="line">A. Dropout      </span><br><span class="line">B. 分批归一化(Batch Normalization)      </span><br><span class="line">C. 正则化(regularization)      </span><br><span class="line">D. 都可以      </span><br></pre></td></tr></table></figure>
<p>Dropout：正则化技术，在训练过程中随机地关闭一部分神经元，从而减少神经网络对特定神经元的依赖<br>
分批归一化：将每个输入特征在训练时归一化（将数据映射到一个标准范围或标准分布的过程），可以加速收敛、防止过拟合、允许较大学习率、对初始参数不敏感<br>
正则化：通过在损失函数中添加一个惩罚项，防止模型对训练数据过于敏感</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">53.某小区人脸识别准入系统用来识别待进入人员的身份，此系统一共包括识别3种不同的人员：业主，物业人员，未收录人员。下面哪种学习方法最适合此种应用需求：（B）。      </span><br><span class="line">A. 二分类      </span><br><span class="line">B. 多分类      </span><br><span class="line">C. 层次聚类      </span><br><span class="line">D. 线性回归      </span><br></pre></td></tr></table></figure>
<p>没啥好说的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">54.L1与L2范数在Logistic Regression 中,如果同时加入L1和L2范数,会产生什么效果( A )。      </span><br><span class="line">A. 可以做特征选择,并在一定程度上防止过拟合      </span><br><span class="line">B. 能解决维度灾难问题      </span><br><span class="line">C. 能加快计算速度      </span><br><span class="line">D. 能增加模型的拟合能力      </span><br></pre></td></tr></table></figure>
<p>L1和L2范数的加入主要是为了正则化和特征选择</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">55.下列模型中属于生成式模型的是（D）      </span><br><span class="line">A. 线性分类器      </span><br><span class="line">B. 卷积神经网络      </span><br><span class="line">C. 线性判别分析      </span><br><span class="line">D. 朴素贝叶斯模型      </span><br></pre></td></tr></table></figure>
<p>生成式模型是一类能够对数据的生成过程进行建模的模型。生成式模型通过学习类别的先验概率和类别条件概率来对样本进行建模<br>
线性分类器和卷积神经网络都是判别式模型<br>
线性判别分析要看具体使用方式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">56.下列模型中属于判别式模型的是（A）      </span><br><span class="line">A. 支持向量机      </span><br><span class="line">B. 隐马尔可夫模型      </span><br><span class="line">C. 朴素贝叶斯模型      </span><br><span class="line">D. 高斯混合模型      </span><br></pre></td></tr></table></figure>
<p>判别式模型是一类直接对类别进行建模的统计模型。这类模型通过学习输入数据与其对应的类别之间的关系，直接对类别进行判别。判别式模型的目标是找到一个决策边界或者决策函数，将不同类别的样本分开。<br>
隐马尔科夫模型用于建模数据的生成过程<br>
高斯混合模型假设数据是由多个高斯分布混合而成的，提供了对数据的生成过程的完整描述</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">57.下列属于无监督学习的是（A）      </span><br><span class="line">A. k-means      </span><br><span class="line">B. SVM      </span><br><span class="line">C. 最大熵      </span><br><span class="line">D. CRF      </span><br></pre></td></tr></table></figure>
<p>记吧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">58.关于“过拟合”现象的出现范围，下列说法哪个是正确的（C）      </span><br><span class="line">A. 只在监督学习中出现      </span><br><span class="line">B. 只在非监督学习中出现      </span><br><span class="line">C. 在监督学习和非监督学习中都可能出现      </span><br><span class="line">D. 在任何类型的学习中都不会出现      </span><br></pre></td></tr></table></figure>
<p>没啥好说的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">59.我们想在大数据集上训练决策树, 为了使用较少时间, 我们可以（C）      </span><br><span class="line">A. 增加树的深度      </span><br><span class="line">B. 增加学习率 (learning rate)      </span><br><span class="line">C. 减少树的深度      </span><br><span class="line">D. 减少树的数量      </span><br></pre></td></tr></table></figure>
<p>增加树的深度会导致更多的节点和分支，增加模型复杂度和训练时间、可能导致过拟合<br>
学习率通常用于控制梯度下降中步长的参数，决策树没有学习率参数可以调<br>
决策树只有一棵树, 不是随机森林</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">60.对于k折交叉验证, 以下对k的说法正确的是（D）      </span><br><span class="line">A. k越大, 不一定越好, 选择大的k会加大评估时间      </span><br><span class="line">B. 选择更大的k, 就会有更小的bias ，因为训练集更加接近总数据集      </span><br><span class="line">C. 在选择k时, 要最小化数据集之间的方差      </span><br><span class="line">D. 以上所有      </span><br></pre></td></tr></table></figure>
<p>在k折交叉验证中，将原始数据集分成k个子集，其中一个子集作为测试集，其余k-1个子集作为训练集。这个过程重复k次，每个子集都会轮流充当测试集。最终，将k次评估的结果取平均值，以得到对模型性能的综合评估。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">61.以下不属于贝叶斯分类器参数估计的准则的是（C）      </span><br><span class="line">A. 最大高斯后验      </span><br><span class="line">B. 最大beta后验      </span><br><span class="line">C. 最大间隔      </span><br><span class="line">D. 极大似然      </span><br></pre></td></tr></table></figure>
<p>记吧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">62.下列选项中属于机器学习可解决的问题的有（D）      </span><br><span class="line">A. 分类      </span><br><span class="line">B. 聚类      </span><br><span class="line">C. 回归      </span><br><span class="line">D. 以上均可      </span><br></pre></td></tr></table></figure>
<p>没啥好说的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">63.下列选项中，关于KNN算法说法不正确的是（D）      </span><br><span class="line">A. 能找出与待测样本相近的K个样本      </span><br><span class="line">B. 可以使用欧氏距离度量相似度      </span><br><span class="line">C. 实现过程相对简单      </span><br><span class="line">D. 效率很高      </span><br></pre></td></tr></table></figure>
<p>每次预测都需要计算待测样本与所有训练样本之间的距离，效率在某些情况下可能较低，特别是在具有大量训练样本的情况下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">64.关于特征预处理，下列说法中错误的是（B ）      </span><br><span class="line">A. 包含标准化和归一化      </span><br><span class="line">B. 标准化在任何场景下受异常值的影响都很小      </span><br><span class="line">C. 归一化利用了样本中的最大值和最小值      </span><br><span class="line">D. 标准化实际上是将数据在样本的标准差上做了等比例的缩放操作      </span><br></pre></td></tr></table></figure>
<p>标准化对异常值敏感</p>
<p>标准化和归一化：用于数据预处理，标准化能够将数据转换为具有相同尺度的分布，使得算法对不同特征的权重更加平衡；归一化使得数据的范围在[0, 1]之间，有助于避免由于特征尺度差异导致的算法收敛慢或不稳定的问题<br>
标准化是通过减去均值并除以标准差的过程，使得数据的均值为0，标准差为1<br>
归一化是通过线性缩放将数据限定在某个范围内，通常是[0, 1]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">65. 关于交叉验证，下列说法中错误的是（A ）      </span><br><span class="line">A. 交叉验证能够直接提升模型的准确率      </span><br><span class="line">B. 交叉验证能够提供对模型泛化性能的更可靠估计      </span><br><span class="line">C. 交叉验证搭配网格搜索能够提升我们查找最优超参数组合的效率      </span><br><span class="line">D. 使用网格搜索时我们一般会提供超参数的可能取值字典      </span><br></pre></td></tr></table></figure>
<p>交叉验证是评估技术</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">66. 请选择下面可以应用隐马尔可夫（HMM）模型的选项：（D）      </span><br><span class="line">A. 基因序列数据集      </span><br><span class="line">B. 电影浏览数据集      </span><br><span class="line">C. 股票市场数据集      </span><br><span class="line">D. 所有以上      </span><br></pre></td></tr></table></figure>
<p>没啥好说的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">67.EM算法（Expectation Maximization Algorithm）是机器学习领域的一个经典算法，下面关于EM算法的说法中不正确的有：（A）      </span><br><span class="line">A. EM算法属于一种分类算法      </span><br><span class="line">B. EM算法可用于隐马尔科夫模型的参数估计      </span><br><span class="line">C. EM算法可以分为E-step和M-step两步      </span><br><span class="line">D. EM算法可用于从不完整的数据中计算最大似然估计      </span><br></pre></td></tr></table></figure>
<p>EM算法（期望最大）是一种迭代优化算法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">68.关于SVM的损失函数，下列说法中错误的是：（D）      </span><br><span class="line">A. SVM适用于多种损失函数      </span><br><span class="line">B. 0/1损失函数的最终结果只有两个，0代表分类正确，1代表分类错误      </span><br><span class="line">C. 合页损失(Hinge loss)衡量了被误分类的样本离分割超平面的距离的大小程度      </span><br><span class="line">D. 分类SVM常用平方误差损失来衡量模型的好坏      </span><br></pre></td></tr></table></figure>
<p>SVM通常使用合页损失</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">69.关于SVM核函数，下列说法中错误的是：（C）      </span><br><span class="line">A. 核函数的引入提升了SVM在线性不可分场景下的模型的稳健性      </span><br><span class="line">B. 核函数就是一类具有将某一类输入映射为某一类输出的函数      </span><br><span class="line">C. 核函数把特征映射到的空间维度越高越好      </span><br><span class="line">D. 常见的核函数有线性核、高斯核、多项式核、sigmoid核      </span><br></pre></td></tr></table></figure>
<p>高维特征空间的引入可以使得数据在更复杂的空间中变得线性可分，但过高的维度也可能导致维度灾难和计算复杂度的增加</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">70.下列关于Kmeans聚类算法的说法错误的是（D）      </span><br><span class="line">A. 对大数据集有较高的效率并且具有可伸缩性      </span><br><span class="line">B. 是一种无监督学习方法      </span><br><span class="line">C. 初始聚类中心随机选择      </span><br><span class="line">D. 初始聚类中心的选择对聚类结果影响不大      </span><br></pre></td></tr></table></figure>
<p>初始聚类中心的选择直接影响了算法收敛到的最终聚类结果。不同的初始聚类中心可能导致不同的局部最优解。通常采用随机选择多组初始聚类中心，运行算法多次，最终选择效果最好的一组聚类结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">71.关于朴素贝叶斯，下列说法错误的是：（D）      </span><br><span class="line">A. 它是一个分类算法      </span><br><span class="line">B. 朴素的意义在于它基于假设：所有特征之间是相互独立的      </span><br><span class="line">C. 它实际上是将多条件下的条件概率转换成了单一条件下的条件概率，简化了      </span><br><span class="line">计算      </span><br><span class="line">D. 以贝叶斯估计的角度来看朴素贝叶斯时，其没有估计联合概率      </span><br></pre></td></tr></table></figure>
<p>朴素贝叶斯通过联合概率和条件概率的关系计算后验概率，条件概率的估计是通过对训练数据中的频率进行统计，并采用贝叶斯估计的方法来平滑估计值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">72.避免直接的复杂非线性变换，采用线性手段实现非线性学习的方法是( A )      </span><br><span class="line">A. 核函数方法      </span><br><span class="line">B. 集成学习      </span><br><span class="line">C. 线性鉴别分析      </span><br><span class="line">D. PCA      </span><br></pre></td></tr></table></figure>
<p>核函数方法：在线性空间中进行非线性映射来处理非线性问题，即低维空间中进行高维特征空间的计算，避免了直接进行复杂的非线性变换<br>
按照GPT的输出结果，下面三个在某些情况也能应用在非线性问题…<br>
集成学习：组合多个弱学习器来构建一个模型，例如随机森林<br>
线性鉴别分析：线性的监督学习方法，在保持类别间距离最大化和类别内方差最小化的同时进行降维，不直接用于实现非线性学习<br>
主成分分析：降维方法，同样不直接用于实现非线性学习</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">73.下列选项中，关于逻辑斯蒂回归的说法不正确是：（B）      </span><br><span class="line">A. 逻辑斯蒂回归是监督学习      </span><br><span class="line">B. 逻辑斯蒂回归是一个回归模型      </span><br><span class="line">C. 逻辑斯蒂回归是一个分类模型      </span><br><span class="line">D. 逻辑斯蒂回归使用sigmoid函数作为激活函数对回归的结果做了映射      </span><br></pre></td></tr></table></figure>
<p>逻辑斯蒂回归是用于解决二分类问题的分类模型。使用sigmoid函数（逻辑斯蒂函数）将线性组合的输入映射到[0,1]范围内，正负类别按0.5区分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">74.下列关于样本类别不均衡场景的描述正确的是（A）      </span><br><span class="line">A. 样本类别不均衡会影响分类模型的最终结果      </span><br><span class="line">B. 样本类别不均衡场景下我们没有可行的解决办法      </span><br><span class="line">C. 欠采样是复制类别数较少的样本来进行样本集的扩充      </span><br><span class="line">D. 过采样会造成数据集部分信息的流失      </span><br></pre></td></tr></table></figure>
<p>样本类别不均衡场景：可以过采样、欠采样、使用不同的评估指标以及使用专门设计用于处理不均衡数据的算法<br>
欠采样：减少类别较多的样本<br>
过采样：补充类别较少的样本（复制、生成新样本：随机插值、引入噪声等）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">75.下列关于无监督学习描述错误的是（C）      </span><br><span class="line">A. 无标签信息      </span><br><span class="line">B. 聚类是其中一个应用      </span><br><span class="line">C. 不能使用降维      </span><br><span class="line">D. 在现实生活中有广泛的应用      </span><br></pre></td></tr></table></figure>
<p>没啥好说的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">76.将一个k分类问题分解成一对一分类问题时总共需要（A）个分类器      </span><br><span class="line">A. k(k-1)/2      </span><br><span class="line">B. k(k-1)      </span><br><span class="line">C. k      </span><br><span class="line">D. k!      </span><br></pre></td></tr></table></figure>
<p>没啥好说的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">77.下列关于聚类说法错误的是（D）      </span><br><span class="line">A. 无需样本有标签      </span><br><span class="line">B. 可用于抽取一些特征      </span><br><span class="line">C. 可提取关于数据的结构信息      </span><br><span class="line">D. 同一个类内的样本之间差异较大      </span><br></pre></td></tr></table></figure>
<p>没啥好说的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">78.下列关于k-means说法不正确的是（ D ）      </span><br><span class="line">A. 算法有可能终止于局部最优解      </span><br><span class="line">B. 簇的数目需要事先给定      </span><br><span class="line">C. 对噪声和离群点敏感      </span><br><span class="line">D. 适合处理非凸型数据      </span><br></pre></td></tr></table></figure>
<p>k-means算法假定数据是凸形的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">79.在有限支撑集上，下面分布中熵最大的是( D )      </span><br><span class="line">A. 几何分布      </span><br><span class="line">B. 指数分布      </span><br><span class="line">C．高斯分布      </span><br><span class="line">D. 均匀分布      </span><br></pre></td></tr></table></figure>
<p>支撑集是指一个随机变量可能取值的集合。如果支撑集是有限的，意味着随机变量只能在一个有限的范围内取值<br>
随机变量约不确定熵越大，<br>
均匀分布的每个样本点都具有相同的概率，当每个可能的事件发生的概率相等时，熵取得最大值。在均匀分布的情况下，我们无法通过观察一些事件来更好地预测其他事件的发生，因此整个系统的不确定性最大，熵也就最大。<br>
几何分布的支撑集是整个正整数集合<br>
指数分布的支撑集是非负实数轴<br>
高斯分布，即正态分布，是连续概率分布，其支撑集是整个实数轴</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">80.给定均值和方差的情况下，下面分布中熵最大的是（C）      </span><br><span class="line">A. 几何分布      </span><br><span class="line">B. 指数分布      </span><br><span class="line">C．高斯分布      </span><br><span class="line">D. 均匀分布      </span><br></pre></td></tr></table></figure>
<p>几何分布：几何分布的熵由成功概率（或失败概率）决定<br>
高斯分布在所有具有相同均值和方差的分布中，熵是最大的，表示它是最不确定的分布；均匀分布在特定情况下可能具有最大熵，但一般情况下，高斯分布的熵更大。</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/9865.html" rel="prev" title="Ghidra-BSim测试">
                  <i class="fa fa-chevron-left"></i> Ghidra-BSim测试
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/33046.html" rel="next" title="软件供应链啥的">
                  软件供应链啥的 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9943095847270020"
     crossorigin="anonymous"></script>
<!-- sidebar -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-9943095847270020"
     data-ad-slot="5504766755"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2026</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Bruce</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="busuanzi_value_total_view">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9waXNjZXMv">NexT.Pisces</span> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>

  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdn.jsdelivr.net/npm/pdfobject@2.2.7/pdfobject.min.js","integrity":"sha256-ph3Dk89VmuTVXG6x/RDzk53SU9LPdAh1tpv0UvnDZ2I="},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="/js/third-party/tags/pdf.js"></script>




  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css" integrity="sha256-TThEtR+XalhWKkfF383YLOrI50NGNeIqrzS+q08afrY=" crossorigin="anonymous">



</body>
</html>
