---
title: 7-23
abbrlink: 64573
hidden: true
date: 2020-07-23 15:00:30
---
## pwn
### [when_did_you_born](https://adworld.xctf.org.cn/task/answer?type=pwn&number=2&grade=0&id=5051&page=1)

用ida打开后看到主要的伪代码：   
![UOvJsI.png](https://s1.ax1x.com/2020/07/23/UOvJsI.png)   
要求v5一开始不能等于1926，但最后要等于1926，然后发现输入完v5之后又输了一个v4，而且是用get()输入v4。   
![UOvGQA.png](https://s1.ax1x.com/2020/07/23/UOvGQA.png)   
看一下v4和v5的位置。输入v4的时候可以把v5覆盖掉。    
这样就可以把exp搞出来了：   
![UOvYLt.png](https://s1.ax1x.com/2020/07/23/UOvYLt.png)
p64(1962)*10中，因为懒得数所以写了”10“...

### [guess_num](https://adworld.xctf.org.cn/task/answer?type=pwn&number=2&grade=0&id=5057&page=1)
这题看了好久，以为可以用栈溢出的方式写，后来查到了个”checksec“（用来检测开启的安全机制），发现好像得换个思路。   
![UOvNeP.png](https://s1.ax1x.com/2020/07/23/UOvNeP.png)   
写这题的时候也发现对数据在内存中的储存方式（大小端）不太懂...   
明天看看《逆向工程核心原理》的第三章


## 数据结构-堆栈
### 堆栈的链式结构
链接堆栈就是采用一个线性链表实现一个堆栈结构。栈中每一个元素用一个链结点表示，设置一个指针变量存储当前栈顶元素所在链结点的存储位置。   
链表不必设置头结点，链表的第一个链结点就是在栈顶元素所在的链结点。在链接堆栈中设置一个新的元素，实际上就是在该链表的第一个结点之前插入一个新的链结点；删除链接堆栈的栈顶元素，实际上就是删除该链表的第一个结点。    
采用了链式存储结构，不必事先声明一片存储区作为堆栈的存储空间，因而不存在因为栈满而产生溢出的问题。若不知道将要进栈元素的数量时，采用链式存储结构比采用顺序存储结构更合适。    
### 基本算法
初始化：栈顶指针top=NULL
测试链接堆栈是否为空：判断top==NULL
取当前栈顶元素   
链接堆栈的插入（在头前插入一个新结点）   
删除   
正常情况下这些算法的时间复杂度均为O(1)

### 应用举例
问题只要满足“先进先出”的原则就可以使用堆栈
#### 符号匹配检查
首先创建一个空的堆栈，依次读入字符直到文件的末尾   
如果读得的字符为左花括号或者左圆括号，则将其压入堆栈。如果读得的字符是右括号或者右圆括号，而此时堆栈为空，则出现不匹配现象，否则退出当前栈顶元素。   
#### 数值转换（例：DEC->OCT）
把十进制整数转换为八进制可以看作反复执行：
1. 将num/8取余数
2. 判断商是否为0   
    - 为0,转换结束
    - 不为0，将商送到到第一步
依此求得的余数是要求的八进制数的各位数字，产生的顺序与实际的八进制数的各位数字的前后次序正好相反。

