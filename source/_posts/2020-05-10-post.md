---
title: 2020.05.04-2020.05.10
tags:
  - 周报
  - 数据结构
  - CTF
abbrlink: 12483
date: 2020-05-10 15:00:30
---
# 攻防世界新手题
## RE

### insanity
https://adworld.xctf.org.cn/task/answer?type=reverse&number=4&grade=0&id=5079&page=1

原来flag还能长"9447{This_is_a_flag}"这样....
<!--more-->
### logmein
https://adworld.xctf.org.cn/task/answer?type=reverse&number=4&grade=0&id=5078&page=1



```
.text:0000000000400707 loc_400707:                             ; CODE XREF: main+177↓j
.text:0000000000400707                 lea     rdi, [rbp+s]    ; s
.text:000000000040070B                 movsxd  rax, [rbp+var_54]
.text:000000000040070F                 mov     [rbp+var_88], rax
.text:0000000000400716                 call    _strlen
.text:000000000040071B                 mov     rdi, [rbp+var_88]
.text:0000000000400722                 cmp     rdi, rax
.text:0000000000400725                 jnb     loc_4007AC
.text:000000000040072B                 lea     rdi, [rbp+var_20] ; s
.text:000000000040072F                 movsxd  rax, [rbp+var_54]
.text:0000000000400733                 mov     [rbp+var_90], rax
.text:000000000040073A                 call    _strlen
.text:000000000040073F                 mov     rdi, [rbp+var_90]
.text:0000000000400746                 cmp     rdi, rax
.text:0000000000400749                 jb      loc_400754
.text:000000000040074F                 call    sub_4007C0
.text:0000000000400754 ; ---------------------------------------------------------------------------
.text:0000000000400754
.text:0000000000400754 loc_400754:                             ; CODE XREF: main+119↑j
.text:0000000000400754                 movsxd  rax, [rbp+var_54]
.text:0000000000400758                 mov     cl, [rbp+rax+var_20]
.text:000000000040075C                 mov     [rbp+var_55], cl
.text:000000000040075F                 mov     eax, [rbp+var_54]
.text:0000000000400762                 cdq
.text:0000000000400763                 idiv    [rbp+var_2C]
.text:0000000000400766                 movsxd  rsi, edx
.text:0000000000400769                 mov     cl, byte ptr [rbp+rsi+var_28]
.text:000000000040076D                 mov     [rbp+var_56], cl
.text:0000000000400770                 movsx   edx, [rbp+var_55]
.text:0000000000400774                 movsx   edi, [rbp+var_56]
.text:0000000000400778                 xor     edx, edi
.text:000000000040077A                 mov     cl, dl
.text:000000000040077C                 mov     [rbp+var_57], cl
.text:000000000040077F                 movsxd  rsi, [rbp+var_54]
.text:0000000000400783                 movsx   edx, [rbp+rsi+s]
.text:0000000000400788                 movsx   edi, [rbp+var_57]
.text:000000000040078C                 cmp     edx, edi
.text:000000000040078E                 jz      loc_400799
.text:0000000000400794                 call    sub_4007C0
.text:0000000000400799 ; ---------------------------------------------------------------------------
.text:0000000000400799
.text:0000000000400799 loc_400799:                             ; CODE XREF: main+15E↑j
.text:0000000000400799                 jmp     $+5
.text:000000000040079E ; ---------------------------------------------------------------------------
.text:000000000040079E
.text:000000000040079E loc_40079E:                             ; CODE XREF: main:loc_400799↑j
.text:000000000040079E                 mov     eax, [rbp+var_54]
.text:00000000004007A1                 add     eax, 1
.text:00000000004007A4                 mov     [rbp+var_54], eax
.text:00000000004007A7                 jmp     loc_400707
```

>ps:  
CQD:
把edx的所有位设成eax最高位的值


在最后的“jmp     loc_400707”实现循环   
跳转到sub_4007C0后，就显示输入的密码错误   

由于不会分析了 就 看了伪代码   
```c
  v9 = 0;
  strcpy(v8, ":\"AL_RT^L*.?+6/46");
  v7 = 28537194573619560LL;
  v6 = 7;
  printf("Welcome to the RC3 secure password guesser.\n", a2, a3);
  printf("To continue, you must enter the correct password.\n");
  printf("Enter your guess: ");
  __isoc99_scanf("%32s", s);
  v3 = strlen(s);
  if ( v3 < strlen(v8) )
    sub_4007C0(v8);
  for ( i = 0; i < strlen(s); ++i )
  {
    if ( i >= strlen(v8) )
      ((void (*)(void))sub_4007C0)();
    if ( s[i] != (char)(*((_BYTE *)&v7 + i % v6) ^ v8[i]) )
      ((void (*)(void))sub_4007C0)();
  }
  sub_4007F0();
}
```
其中v7可以转换为16进制再转换成字符串，所以v7在运算时变为"haramb"   
得到flag的代码：   
```c 
#include <stdio.h>
#include<string.h>
int main(){
	char k1[]=":\"AL_RT^L*.?+6/46";
	char k2[]="harambe";
	int a=7;
	char s[50];
	for(int i=0;i<strlen(k1);i++){
		s[i]=(char)(*(k2+i%a)^k1[i]);
	}
	puts(s);
}
```
### 彦林学长给的一题
题在这边：[easyYM](https://zhangsi.lanzous.com/icfzx7c)    
看了他的wp   
嗯...感觉自己知道 有flag的那块地方没有被调用，但一方面是不知道是哪些函数跟flag有关（通过查看字符串）(后来用ida打开发现，放在main函数里，刚开始就跳过了） ，另外就是没有想到od设置某处为新eip的功能

# 装Pwntools

```
apt-get update
apt-get install python2.7 python-pip python-dev git libssl-dev libffi-dev build-essential
pip install --upgrade pip
pip install pwntools -i https://pypi.tuna.tsinghua.edu.cn/simple/
```


# 数据结构
## 多重链表
* 广义表   
广义表中的元素可以是一个单元素，也可以是另一个表。
```c
struct Glist{
  int tag;
  union {
    Element Type Data;  //用这个标志控制结点为单元素或者广义表
    Glist anlist;
  }
  Glist Next
}
```
广义表即为一个多重链表   
多重链表中结点的指针域有多个（如anlist和Next）,包含两个指针域的链表不一定是多重链表(如双向链表)   

## 堆栈
数据对象集：有穷线性表   
操作集：堆栈的长度、堆栈元素   
1. 生成长度为MaxSize的空堆栈
2. 判断堆栈是否满了
3. 将一个元素压入堆栈
4. 判断堆栈是否为空
5. 删除并返回栈顶元素   
栈的顺序存储结构由一个**一位数组**和一个**记录栈顶位置**的变量top组成  

### 顺序存储
#### 入栈
```c
if(s->top==MaxSize-1){
  printf("堆栈满");
}
else{
  s->data[s->top]=item;
  (s->top)++;
}
```
#### 出栈
```c
if(s->top=-1){
  printf("堆栈空");
}
else{
  data=s->data[(s->top)--];
}
```
### 链式存储
用一个单链表，称作链栈   
top在链表的头结点，头结点里不存放其他元素   

#### 入栈
![Ynrdv6.png](https://s1.ax1x.com/2020/05/08/Ynrdv6.png)
#### 出栈
记得free()   
![Ynr0KK.png](https://s1.ax1x.com/2020/05/08/Ynr0KK.png)
## 队列
只能在一端插入（入队），在另一端删除（出队）  
先进先出   

### 顺序存储
一个一维数组+一个记录头元素的变量front+一个记录尾元素的变量rear     
front指向第一个元素的前一个位置
* 循环队列   
当front和rear相等时为空（或相等）（解决方案：加入一个额外标记；使用n-1个空间）     

![YnrBDO.png](https://s1.ax1x.com/2020/05/08/YnrBDO.png)

### 链式存储
存在单链表中，front和rear指针分别指向头和尾